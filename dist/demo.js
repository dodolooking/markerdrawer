/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.DG = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var css = ".leaflet-image-layer,.leaflet-layer,.leaflet-map-pane canvas,.leaflet-map-pane svg,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane,.leaflet-tile,.leaflet-tile-container,.leaflet-zoom-box{position:absolute;left:0;top:0}.leaflet-container{overflow:hidden}.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-tile{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-user-drag:none}.leaflet-safari .leaflet-tile{image-rendering:-webkit-optimize-contrast}.leaflet-safari .leaflet-tile-container{width:1600px;height:1600px;-webkit-transform-origin:0 0}.leaflet-marker-icon,.leaflet-marker-shadow{display:block}.leaflet-container .leaflet-marker-pane img,.leaflet-container .leaflet-overlay-pane svg,.leaflet-container .leaflet-tile-pane img,.leaflet-container img.leaflet-image-layer{max-width:none!important}.leaflet-container.leaflet-touch-zoom{-ms-touch-action:pan-x pan-y;touch-action:pan-x pan-y}.leaflet-container.leaflet-touch-drag{-ms-touch-action:pinch-zoom}.leaflet-container.leaflet-touch-drag.leaflet-touch-drag{-ms-touch-action:none;touch-action:none}.leaflet-tile{-webkit-filter:inherit;filter:inherit;visibility:hidden}.leaflet-tile-loaded{visibility:inherit}.leaflet-zoom-box{width:0;height:0;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:800}.leaflet-overlay-pane svg{-moz-user-select:none}.leaflet-pane{z-index:400}.leaflet-tile-pane{z-index:200}.leaflet-overlay-pane{z-index:400}.leaflet-shadow-pane{z-index:500}.leaflet-marker-pane{z-index:600}.leaflet-tooltip-pane{z-index:650}.leaflet-popup-pane{z-index:700}.leaflet-map-pane canvas{z-index:100}.leaflet-map-pane svg{z-index:200}.leaflet-vml-shape{width:1px;height:1px}.lvml{behavior:url(#default#VML);display:inline-block;position:absolute}.leaflet-control{position:relative;z-index:800;pointer-events:visiblePainted;pointer-events:auto}.leaflet-bottom,.leaflet-top{position:absolute;z-index:1000;pointer-events:none}.leaflet-top{top:0}.leaflet-right{right:0}.leaflet-bottom{bottom:0}.leaflet-left{left:0}.leaflet-control{float:left;clear:both}.leaflet-right .leaflet-control{float:right}.leaflet-top .leaflet-control{margin-top:10px}.leaflet-bottom .leaflet-control{margin-bottom:10px}.leaflet-left .leaflet-control{margin-left:10px}.leaflet-right .leaflet-control{margin-right:10px}.leaflet-fade-anim .leaflet-tile{will-change:opacity}.leaflet-fade-anim .leaflet-popup{opacity:0;-webkit-transition:opacity .2s linear;transition:opacity .2s linear}.leaflet-fade-anim .leaflet-map-pane .leaflet-popup{opacity:1}.leaflet-zoom-animated{-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0}.leaflet-zoom-anim .leaflet-zoom-animated{will-change:transform;-webkit-transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1),-webkit-transform .25s cubic-bezier(0,0,.25,1)}.leaflet-pan-anim .leaflet-tile,.leaflet-zoom-anim .leaflet-tile{-webkit-transition:none;transition:none}.leaflet-zoom-anim .leaflet-zoom-hide{visibility:hidden}.leaflet-interactive{cursor:pointer}.leaflet-grab{cursor:-webkit-grab;cursor:-moz-grab}.leaflet-crosshair,.leaflet-crosshair .leaflet-interactive{cursor:crosshair}.leaflet-control,.leaflet-popup-pane{cursor:auto}.leaflet-dragging .leaflet-grab,.leaflet-dragging .leaflet-grab .leaflet-interactive,.leaflet-dragging .leaflet-marker-draggable{cursor:move;cursor:-webkit-grabbing;cursor:-moz-grabbing}.leaflet-image-layer,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane>svg path,.leaflet-tile-container{pointer-events:none}.leaflet-image-layer.leaflet-interactive,.leaflet-marker-icon.leaflet-interactive,.leaflet-pane>svg path.leaflet-interactive{pointer-events:visiblePainted;pointer-events:auto}.leaflet-container{outline:0}.leaflet-container a{color:#0078A8}.leaflet-container a.leaflet-active{outline:orange solid 2px}.leaflet-zoom-box{border:2px dotted #38f;background:rgba(255,255,255,.5)}.leaflet-container{font:12px/1.5 \"Helvetica Neue\",Arial,Helvetica,sans-serif}.leaflet-bar{-webkit-box-shadow:0 1px 5px rgba(0,0,0,.65);box-shadow:0 1px 5px rgba(0,0,0,.65);border-radius:4px}.leaflet-bar a,.leaflet-bar a:hover{background-color:#fff;border-bottom:1px solid #ccc;width:26px;height:26px;line-height:26px;display:block;text-align:center;text-decoration:none;color:#000}.leaflet-bar a,.leaflet-control-layers-toggle{background-position:50% 50%;background-repeat:no-repeat;display:block}.leaflet-bar a:hover{background-color:#f4f4f4}.leaflet-bar a:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.leaflet-bar a:last-child{border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-bottom:none}.leaflet-bar a.leaflet-disabled{cursor:default;background-color:#f4f4f4;color:#bbb}.leaflet-touch .leaflet-bar a{width:30px;height:30px;line-height:30px}.leaflet-control-zoom-in,.leaflet-control-zoom-out{font:700 18px 'Lucida Console',Monaco,monospace;text-indent:1px}.leaflet-control-zoom-out{font-size:20px}.leaflet-touch .leaflet-control-zoom-in{font-size:22px}.leaflet-touch .leaflet-control-zoom-out{font-size:24px}.leaflet-control-layers{-webkit-box-shadow:0 1px 5px rgba(0,0,0,.4);box-shadow:0 1px 5px rgba(0,0,0,.4);background:#fff;border-radius:5px}.leaflet-control-layers-toggle{background-image:url(dist/css/images/layers.png);width:36px;height:36px}.leaflet-retina .leaflet-control-layers-toggle{background-image:url(dist/css/images/layers-2x.png);background-size:26px 26px}.leaflet-touch .leaflet-control-layers-toggle{width:44px;height:44px}.leaflet-control-layers .leaflet-control-layers-list,.leaflet-control-layers-expanded .leaflet-control-layers-toggle{display:none}.leaflet-control-layers-expanded .leaflet-control-layers-list{display:block;position:relative}.leaflet-control-layers-expanded{padding:6px 10px 6px 6px;color:#333;background:#fff}.leaflet-control-layers-scrollbar{overflow-y:scroll;padding-right:5px}.leaflet-control-layers-selector{margin-top:2px;position:relative;top:1px}.leaflet-control-layers label{display:block}.leaflet-control-layers-separator{height:0;border-top:1px solid #ddd;margin:5px -10px 5px -6px}.leaflet-default-icon-path{background-image:url(dist/css/images/marker-icon.png)}.leaflet-container .leaflet-control-attribution{background:#fff;background:rgba(255,255,255,.7);margin:0}.leaflet-control-attribution,.leaflet-control-scale-line{padding:0 5px;color:#333}.leaflet-control-attribution a{text-decoration:none}.leaflet-control-attribution a:hover{text-decoration:underline}.leaflet-container .leaflet-control-attribution,.leaflet-container .leaflet-control-scale{font-size:11px}.leaflet-left .leaflet-control-scale{margin-left:5px}.leaflet-bottom .leaflet-control-scale{margin-bottom:5px}.leaflet-control-scale-line{border:2px solid #777;border-top:none;line-height:1.1;padding:2px 5px 1px;font-size:11px;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;background:#fff;background:rgba(255,255,255,.5)}.leaflet-control-scale-line:not(:first-child){border-top:2px solid #777;border-bottom:none;margin-top:-2px}.leaflet-control-scale-line:not(:first-child):not(:last-child){border-bottom:2px solid #777}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-attribution,.leaflet-touch .leaflet-control-layers{-webkit-box-shadow:none;box-shadow:none}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-layers{border:2px solid rgba(0,0,0,.2);background-clip:padding-box}.leaflet-popup{position:absolute;text-align:center}.leaflet-popup-content-wrapper{text-align:left}.leaflet-popup-tip-container{width:40px;position:absolute;left:50%;margin-left:-20px;overflow:hidden;pointer-events:none}.leaflet-popup-tip{width:17px;height:17px;padding:1px;margin:-10px auto 0;-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}.leaflet-popup-content-wrapper,.leaflet-popup-tip{background:#fff;color:#333;-webkit-box-shadow:0 3px 14px rgba(0,0,0,.4);box-shadow:0 3px 14px rgba(0,0,0,.4)}.leaflet-container a.leaflet-popup-close-button{border:none;font:16px/14px Tahoma,Verdana,sans-serif;color:#c3c3c3;text-decoration:none;background:0 0}.leaflet-container a.leaflet-popup-close-button:hover{color:#999}.leaflet-oldie .leaflet-popup-content-wrapper{zoom:1}.leaflet-oldie .leaflet-popup-tip{width:24px;margin:0 auto;-ms-filter:\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\";filter:progid:DXImageTransform.Microsoft.Matrix(M11=.70710678, M12=.70710678, M21=-.70710678, M22=.70710678)}.leaflet-oldie .leaflet-popup-tip-container{margin-top:-1px}.leaflet-oldie .leaflet-control-layers,.leaflet-oldie .leaflet-control-zoom,.leaflet-oldie .leaflet-popup-content-wrapper,.leaflet-oldie .leaflet-popup-tip{border:1px solid #999}.leaflet-div-icon{background:#fff;border:1px solid #666}.leaflet-tooltip{position:absolute;padding:6px;background-color:#fff;border:1px solid #fff;border-radius:3px;color:#222;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.4);box-shadow:0 1px 3px rgba(0,0,0,.4)}.leaflet-tooltip.leaflet-clickable{cursor:pointer;pointer-events:auto}.leaflet-tooltip-bottom:before,.leaflet-tooltip-left:before,.leaflet-tooltip-right:before,.leaflet-tooltip-top:before{position:absolute;pointer-events:none;border:6px solid transparent;background:0 0;content:\"\"}.leaflet-tooltip-bottom{margin-top:6px}.leaflet-tooltip-top{margin-top:-6px}.leaflet-tooltip-bottom:before,.leaflet-tooltip-top:before{left:50%;margin-left:-6px}.leaflet-tooltip-top:before{bottom:0;margin-bottom:-12px;border-top-color:#fff}.leaflet-tooltip-bottom:before{top:0;margin-top:-12px;margin-left:-6px;border-bottom-color:#fff}.leaflet-tooltip-left{margin-left:-6px}.leaflet-tooltip-right{margin-left:6px}.leaflet-tooltip-left:before,.leaflet-tooltip-right:before{top:50%;margin-top:-6px}.leaflet-tooltip-left:before{right:0;margin-right:-12px;border-left-color:#fff}.leaflet-tooltip-right:before{left:0;margin-left:-12px;border-right-color:#fff}[class^=dg-],[class^=dg-]:after,[class^=dg-]:before{-webkit-box-sizing:content-box;box-sizing:content-box;margin:0;padding:0;vertical-align:baseline;font-weight:inherit;font-style:inherit;font-size:1em;font-family:inherit;line-height:1.2}[class^=dg-]>[class^=dg-]:last-child{margin-bottom:0}[class^=dg-] abbr,[class^=dg-] fieldset,[class^=dg-] img{border:0}[class^=dg-] blockquote,[class^=dg-] q{quotes:none}[class^=dg-] blockquote:after,[class^=dg-] blockquote:before,[class^=dg-] q:after,[class^=dg-] q:before{content:'';content:none}[class^=dg-] ol,[class^=dg-] ul{list-style:none}[class^=dg-] table{border-spacing:0;border-collapse:collapse}[class^=dg-] caption,[class^=dg-] th{text-align:left}[class^=dg-] td,[class^=dg-] th{vertical-align:middle}[class^=dg-] button::-moz-focus-inner,[class^=dg-] input::-moz-focus-inner{padding:0;border:0}.dg-label{position:absolute;top:0;left:0;max-width:none;max-height:none;width:300px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.dg-label__content{display:inline-block;overflow:hidden;padding:3px 7px;min-width:30px;max-width:300px;width:auto;border-width:1px;border-style:solid;border-radius:2px;vertical-align:top;font-size:12px}.leaflet-top .dg-label_name_location-error{top:5px}.leaflet-right .dg-label_name_location-error{right:40px;left:auto;text-align:right}.leaflet-bottom .dg-label_name_location-error{top:4px}.leaflet-left .dg-label_name_location-error{left:40px}.dg-label__content{border-color:#323232;border-color:rgba(50,50,50,.85);background:#323232;background:rgba(50,50,50,.85);color:#ffd26e}.leaflet-popup{margin-bottom:0}.leaflet-popup-tip-container{height:0}.leaflet-popup-content-wrapper{overflow:hidden;padding:0;min-width:60px;min-height:50px;border:0;border-radius:3px;background:0 0;-webkit-box-shadow:none;box-shadow:none;color:#e6e6e6;font-size:14px;-webkit-transition:opacity ease-out .2s,max-height ease-out .2s,height ease-out .2s;transition:opacity ease-out .2s,max-height ease-out .2s,height ease-out .2s;-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%}.leaflet-popup-content-wrapper:before{float:right;width:30px;height:17px;content:''}.leaflet-popup-content{position:relative;margin:16px;width:auto;line-height:1.4}.leaflet-popup a{outline:0}.leaflet-popup-content p{margin:0}.leaflet-popup-scrolled{overflow:visible;border:0}.leaflet-popup-inner{position:relative;z-index:0}.leaflet-popup_show_true{-webkit-transition:opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;transition:transform ease-in-out .2s,opacity ease-in-out .2s,height ease-out .2s;transition:transform ease-in-out .2s,opacity ease-in-out .2s,height ease-out .2s,-webkit-transform ease-in-out .2s;-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.leaflet-popup_show_false{opacity:0!important;-webkit-transition:all ease-in-out .1s;transition:all ease-in-out .1s;-webkit-transform:scale(0.2);-ms-transform:scale(0.2);transform:scale(0.2)}.leaflet-popup_preloader_true{width:384px;height:52px}.leaflet-map-pane .leaflet-popup-tip-container{position:absolute;top:auto;bottom:0;left:50%;margin-left:-29px;width:58px;height:47px;background-repeat:no-repeat;-webkit-transform:translateY(47px);-ms-transform:translateY(47px);transform:translateY(47px);pointer-events:none}.leaflet-popup-tip{display:none}.leaflet-popup-tip-container_svg{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGPopup__popupShadow.png);background-position:50% 95%;background-size:36px 12px}.leaflet-retina .leaflet-popup-tip-container_svg{background-image:url(https://maps.api.2gis.ru/2.0/img/DGPopup__popupShadow@2x.png)}.leaflet-container a.leaflet-popup-close-button{position:absolute;top:3px;right:3px;z-index:1;overflow:hidden;padding:0;width:30px;height:30px;text-align:center;font-weight:400;font-size:18px;line-height:30px;cursor:pointer}.no-touch .leaflet-container a.leaflet-popup-close-button:hover{border-radius:2px;-webkit-transition:all .2s;transition:all .2s}.leaflet-container a.leaflet-popup-close-button:active{color:#777}.leaflet-container a.leaflet-popup-close-button:after{position:absolute;z-index:2;content:''}.leaflet-popup-content-wrapper{background-color:rgba(50,50,50,.9)}.leaflet-popup-tip-container_image{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2258%22%20height%3D%2247%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M0%200c12.643%200%2028%207.115%2028%2044h2c0-36.885%2015.358-44%2028-44h-58z%22%20fill%3D%22rgba(50%2C50%2C50%2C.9)%22%3E%3C%2Fpath%3E%0A%3C%2Fsvg%3E%0A\")}.leaflet-map-pane .leaflet-popup-tip-container_svg{fill:rgba(50,50,50,.9)}.no-touch .leaflet-container a.leaflet-popup-close-button:hover{background-color:#222;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.5);box-shadow:0 1px 3px rgba(0,0,0,.5)}.leaflet-container a.leaflet-popup-close-button:after{top:-3px;right:-5px;width:40px;height:40px}.dg-wrapper{position:relative;overflow:hidden}.dg-scroller{height:100%;overflow-y:scroll;border:0}.dg-scroller__bar{z-index:1;right:0;background:#999}.dg-scroller__bar_h{bottom:2px;height:8px}.dg-header__title{width:100%;margin:0;-webkit-box-sizing:border-box;box-sizing:border-box;background:#999}.dg-header__title_state_fixed{position:absolute;z-index:1}.dg-scroller_hidden_true{overflow:auto}.dg-scroller::-webkit-scrollbar{width:0}.dg-scroller__wrapper{position:relative;overflow:hidden}.dg-scroller__bar-wrapper{position:absolute;top:18px;right:3px;bottom:4px;width:7px;border-radius:5px}.dg-scroller_hidden_true .dg-scroller__bar-wrapper{visibility:hidden}.dg-popup__header+.dg-popup__container-wrapper .dg-scroller__bar-wrapper{top:4px}.dg-scroller__bar{position:absolute;min-height:20px;width:7px;border-radius:3px;pointer-events:auto}.scroller__bar-wrapper .scroller__bar{background-color:#665b4f}.scroller__bar-wrapper:hover .scroller__bar{background-color:#897a6b}.dg-popup__container{margin:0}.leaflet-popup-scrolled .dg-popup__container{padding:8px 14px 8px 0}.dg-popup__header{position:relative;padding-bottom:12px}.leaflet-popup-scrolled .dg-popup__header:after{position:relative;top:12px;display:block;width:100%;height:1px;content:''}.dg-popup__footer{position:relative;bottom:0;overflow:hidden}.leaflet-popup-scrolled .dg-popup__footer:before{display:block;width:100%;height:1px;content:''}.dg-popup_hidden_true{display:none}.leaflet-popup-scrolled .dg-popup__footer:before,.leaflet-popup-scrolled .dg-popup__header:after{border-bottom:1px solid #636363;background-color:#494949}.dg-control-round{position:relative;padding:5px;width:30px;height:30px;border-radius:50%;cursor:default}.dg-control-round__icon{position:relative;display:block;width:30px;height:30px;border-radius:50%;background-color:#f0f0f0;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#fff),to(#e0e0e0));background-image:-webkit-linear-gradient(top,#fff 0,#e0e0e0 100%);background-image:linear-gradient(to bottom,#fff 0,#e0e0e0 100%);color:#2b2a29;text-align:center;text-decoration:none;text-shadow:0 1px 0 #fff;font-size:22px;line-height:30px;cursor:pointer}.no-touch .dg-control-round__icon:hover{background-color:#f5f5f5;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#ebebeb),to(#fff));background-image:-webkit-linear-gradient(top,#ebebeb 0,#fff 100%);background-image:linear-gradient(to bottom,#ebebeb 0,#fff 100%)}.dg-control-round__icon:active,.dg-control-round__icon_state_active,.no-touch .dg-control-round__icon:active{background-color:#ebebeb;background-image:-webkit-gradient(linear,left top,left bottom,color-stop(0,#d6d6d6),to(#fff));background-image:-webkit-linear-gradient(top,#d6d6d6 0,#fff 100%);background-image:linear-gradient(to bottom,#d6d6d6 0,#fff 100%)}.leaflet-disabled .dg-control-round__icon,.leaflet-disabled .dg-control-round__icon:active,.no-touch .leaflet-disabled .dg-control-round__icon:hover{background-image:none;cursor:default}.leaflet-touch .dg-control-round__icon:before{position:absolute;top:-10px;right:-15px;bottom:-10px;left:-15px;content:''}.dg-control-round_is-hidden_true{display:none}.dg-control-round{background-color:#3d3d3d;-webkit-box-shadow:0 3px 5px 0 rgba(0,0,0,.3);box-shadow:0 3px 5px 0 rgba(0,0,0,.3)}.dg-control-round__icon{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,.4);box-shadow:0 2px 2px 0 rgba(0,0,0,.4)}.no-touch .dg-control-round__icon:hover{-webkit-box-shadow:inset 0 1px #fff,0 0 0 1px rgba(0,0,0,.3),0 1px 0 1px rgba(0,0,0,.4);box-shadow:inset 0 1px #fff,0 0 0 1px rgba(0,0,0,.3),0 1px 0 1px rgba(0,0,0,.4)}.dg-control-round__icon:active,.dg-control-round__icon_state_active,.no-touch .dg-control-round__icon:active{-webkit-box-shadow:inset 0 1px 1px 1px rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.3),0 -1px 1px 0 #000;box-shadow:inset 0 1px 1px 1px rgba(0,0,0,.2),0 0 0 1px rgba(0,0,0,.3),0 -1px 1px 0 #000}.leaflet-disabled .dg-control-round__icon,.leaflet-disabled .dg-control-round__icon:active,.no-touch .leaflet-disabled .dg-control-round__icon:hover{background-color:#b8b8b8;-webkit-box-shadow:none;box-shadow:none}.leaflet-container{z-index:0;background:#f7f3df;cursor:default}.leaflet-container:-webkit-full-screen{width:100%!important;height:100%!important}.leaflet-container:-moz-full-screen{width:100%!important;height:100%!important}.leaflet-container:-ms-fullscreen{width:100%!important;height:100%!important}.leaflet-container:fullscreen{width:100%!important;height:100%!important}.leaflet-dragging,.leaflet-dragging .leaflet-clickable,.leaflet-dragging .leaflet-container{cursor:move}.leaflet-control a,.leaflet-control a:focus{outline:0!important}.leaflet-container .leaflet-control-attribution{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.dg-customization__marker{background-repeat:no-repeat}.dg-customization__marker:before{position:absolute;top:0;left:0;width:100%;height:100%;background-image:inherit;background-size:contain;background-repeat:no-repeat;-webkit-transition:opacity ease-in-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,-webkit-transform ease-in-out .2s;transition:opacity ease-in-out .2s,transform ease-in-out .2s;transition:opacity ease-in-out .2s,transform ease-in-out .2s,-webkit-transform ease-in-out .2s;-webkit-transform:scale(1,1);-ms-transform:scale(1,1);transform:scale(1,1);-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%}.dg-customization__marker_type_mushroom{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__marker.png);background-size:22px 34px;width:22px;height:34px;-webkit-transform-origin:50% 100%;-ms-transform-origin:50% 100%;transform-origin:50% 100%;-webkit-animation:dg-customization__show-marker .2s;animation:dg-customization__show-marker .2s}.leaflet-retina .dg-customization__marker_type_mushroom{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__marker@2x.png)}.dg-customization__marker_type_mushroom:focus{outline:0}.no-touch .dg-customization__marker_type_mushroom:hover{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerHover.png);background-size:22px 34px}.leaflet-retina .no-touch .dg-customization__marker_type_mushroom:hover{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerHover@2x.png)}.dg-customization__marker_type_mushroom:active,.no-touch .dg-customization__marker_type_mushroom:active{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerActive.png);background-size:22px 34px}.leaflet-retina .dg-customization__marker_type_mushroom:active,.leaflet-retina .no-touch .dg-customization__marker_type_mushroom:active{background-image:url(https://maps.api.2gis.ru/2.0/img/DGCustomization__markerActive@2x.png)}@-webkit-keyframes dg-customization__show-marker{from{opacity:0}to{opacity:1}}@keyframes dg-customization__show-marker{from{opacity:0}to{opacity:1}}.dg-customization__marker_appear{background-position:999px}.dg-customization__marker_appear:before{content:''}.dg-customization__marker_disappear{background-position:999px;pointer-events:none}.dg-customization__marker_disappear:before{visibility:hidden;content:'';opacity:0;-webkit-transform:scale(1.2,1.8);-ms-transform:scale(1.2,1.8);transform:scale(1.2,1.8);-webkit-animation:dg-customization__marker-to-callout .2s;animation:dg-customization__marker-to-callout .2s}@-webkit-keyframes dg-customization__marker-to-callout{0%{visibility:visible;opacity:1;-webkit-transform:scale(1,1);transform:scale(1,1)}100%{visibility:visible;opacity:0;-webkit-transform:scale(1.2,1.8);transform:scale(1.2,1.8)}}@keyframes dg-customization__marker-to-callout{0%{visibility:visible;opacity:1;-webkit-transform:scale(1,1);transform:scale(1,1)}100%{visibility:visible;opacity:0;-webkit-transform:scale(1.2,1.8);transform:scale(1.2,1.8)}}.dg-dragging-false{touch-action:auto;-ms-touch-action:auto}.leaflet-image-layer,.leaflet-tile-container{pointer-events:auto}.dg-zoom{width:40px;height:74px}.dg-zoom__in{position:absolute;top:0;left:0}.leaflet-touch .dg-zoom__in:before{position:absolute;top:-5px;right:-10px;bottom:0;left:-10px;content:''}.dg-zoom__in:after{position:absolute;right:0;bottom:-1px;left:0;z-index:-1;margin:auto;width:12px;height:2px;-webkit-box-shadow:0 0 3px 2px rgba(0,0,0,.3);box-shadow:0 0 3px 2px rgba(0,0,0,.3);content:''}.dg-zoom__button_type_in:after,.dg-zoom__button_type_in:before,.leaflet-touch .dg-zoom__button_type_in:before{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;width:14px;height:2px;background-color:#7a7a7a;-webkit-box-shadow:0 1px #fff;box-shadow:0 1px #fff;content:''}.dg-zoom__button_type_in:after{width:2px;height:14px}.no-touch .dg-zoom__button_type_in:hover:after,.no-touch .dg-zoom__button_type_in:hover:before{background-color:#616161}.dg-zoom__button_type_in:active:after,.dg-zoom__button_type_in:active:before,.no-touch .dg-zoom__button_type_in:active:after,.no-touch .dg-zoom__button_type_in:active:before{background-color:#575757}.leaflet-disabled .dg-zoom__button_type_in:active:after,.leaflet-disabled .dg-zoom__button_type_in:active:before,.leaflet-disabled .dg-zoom__button_type_in:after,.leaflet-disabled .dg-zoom__button_type_in:before,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:before{-webkit-box-shadow:none;box-shadow:none}.dg-zoom__out{position:absolute;top:40px;right:0;left:0;margin:auto;width:22px;height:22px}.dg-zoom__out:after{position:absolute;top:-1px;right:0;left:0;margin:auto;width:12px;height:2px;content:''}.dg-zoom__button_type_out{width:22px;height:22px}.leaflet-touch .dg-zoom__button_type_out:before{top:-5px;right:-19px;bottom:-19px;left:-19px}.dg-zoom__button_type_out:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;width:10px;height:2px;background:#7a7a7a;-webkit-box-shadow:0 1px #fff;box-shadow:0 1px #fff;content:''}.no-touch .dg-zoom__button_type_out:hover:after{background:#616161}.dg-zoom__button_type_out:active:after,.no-touch .dg-zoom__button_type_out:active:after{background:#575757}.leaflet-disabled .dg-zoom__button_type_out:active:after,.leaflet-disabled .dg-zoom__button_type_out:after,.no-touch .leaflet-disabled .dg-zoom__button_type_out:hover:after{-webkit-box-shadow:none;box-shadow:none}.dg-zoom__out{-webkit-box-shadow:0 2px 3px 0 rgba(0,0,0,.3);box-shadow:0 2px 3px 0 rgba(0,0,0,.3)}.dg-zoom__out:after{background-color:#3d3d3d}.leaflet-disabled .dg-zoom__button_type_in:active:after,.leaflet-disabled .dg-zoom__button_type_in:active:before,.leaflet-disabled .dg-zoom__button_type_in:after,.leaflet-disabled .dg-zoom__button_type_in:before,.leaflet-disabled .dg-zoom__button_type_out:active:after,.leaflet-disabled .dg-zoom__button_type_out:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:after,.no-touch .leaflet-disabled .dg-zoom__button_type_in:hover:before,.no-touch .leaflet-disabled .dg-zoom__button_type_out:hover:after{background-color:#707070}.dg-attribution{background-color:transparent!important}.dg-attribution__copyright{margin:0 55px 5px 0;text-align:right;white-space:nowrap;font-size:9px;font-family:Helvetica,Arial,sans-serif}.dg-attribution__links{display:inline-block;margin:0;padding:0 5px 0 0}.dg-attribution__link-item{padding:0;list-style-type:none}.leaflet-container .dg-attribution__link{background:-webkit-gradient(linear,left top,right top,from(rgba(8,8,8,.3)),to(rgba(8,8,8,.3))) 0 95%/10px 1px repeat-x;background:-webkit-linear-gradient(left,rgba(8,8,8,.3),rgba(8,8,8,.3) 100%) 0 95%/10px 1px repeat-x;background:linear-gradient(to right,rgba(8,8,8,.3),rgba(8,8,8,.3) 100%) 0 95%/10px 1px repeat-x;color:#333;text-decoration:none;font-size:9px;font-family:Helvetica,Arial,sans-serif;cursor:pointer}.leaflet-container .dg-attribution__link:hover{background-image:-webkit-gradient(linear,left top,right top,from(#080808),to(#080808));background-image:-webkit-linear-gradient(left,#080808,#080808 100%);background-image:linear-gradient(to right,#080808,#080808 100%);color:#333;text-decoration:none}.dg-attribution__logo-url{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2224%22%20width%3D%2255%22%3E%0A%20%3Cpath%20fill%3D%22%23a2c124%22%20d%3D%22m24.395%2012c0-1.4545-0.22177-2.6545-0.66532-4-0.14785%204.2545-4.879%207.8182-7.4664%2010h6.7641c0.70229-2%201.3676-3.9273%201.3676-6m-4.731-9.3455c-2.033-1.6-4.62-2.6545-7.466-2.6545-6.7276%200-12.198%205.4182-12.198%2012s5.4704%2012%2012.198%2012c3.1048%200%205.9509-1.4545%208.1317-3.3455h-8.797v-2.6545c5.3595-4.5455%208.797-7.3455%208.797-10%200-1.1273-0.81317-2.6545-2.6983-2.6545-1.4785%200-2.6983%201.3455-2.6983%204.6545h-3.4005c-0.73925-4.2182%201.8481-7.6727%206.2466-7.6727%200.66532%200%201.2567%200.21818%201.8851%200.32727%22%2F%3E%0A%20%3Cpath%20fill%3D%22%233c4347%22%20d%3D%22m36.593%209.3455h1.3676c0-2-0.66532-5.1273-4.7312-5.2727-4.732-0.2183-6.1%202.6181-6.1%205.9272v5.3455c0%204.4%203.4375%205.3455%206.0988%205.3455%201.5524%200%203.4005-0.87273%204.7312-2v-6.6909h-5.4335v2.6545h2.6983v2.6545c-1.3676%201.3455-5.4335%201.3455-5.4335-2.6545v-5.3091c0-4%205.9509-4.1455%205.6183%200h1.1828zm18.296%206.6545c0-5.8182-6.9859-4.0727-6.9859-7.6%200-1.2%200.81317-2%202.1808-2%201.4415%200%202.2547%201.0182%202.2547%202.9818h2.5874c0-2-0.66532-5.3455-4.7312-5.3455-2.7722%200-4.879%201.4182-4.879%204.3273%200%206.0727%207.1707%204.0727%207.0598%207.6727-0.07392%201.4545-1.1458%202.0727-2.3656%202.0727-1.4415%200-2.6983-0.72727-2.4395-3.3818h-2.6613c-0.25874%203.3455%201.4415%206%205.3595%206%202.699%200%204.732-2.145%204.732-5.345l-0.111%200.618zm-12.198%204h-2.6983v-16h2.6983v16z%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:55px;height:24px;background-size:55px 24px;position:absolute;margin:0 3px 0 0}.dg-location__pin{background-repeat:no-repeat;width:20px;height:20px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.basic.png);background-position:-22px -24px;background-size:87px 74px}.leaflet-retina .dg-location__pin{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.basic.png);background-position:-21px -24px;background-size:91px 71.5px}.dg-location__pin_state_following{background-repeat:no-repeat;width:20px;height:20px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.basic.png);background-position:-55px 0;background-size:87px 74px}.leaflet-retina .dg-location__pin_state_following{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.basic.png);background-position:-55px 0;background-size:91px 71.5px}.dg-control-round__icon_name_locate:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_state_active.dg-control-round__icon_name_locate:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_locate:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%2323a5d4%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%20fill%3D%22%232685aa%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%231c85ab%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}@-webkit-keyframes DGLocation__locateIconRequestingAnim{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes DGLocation__locateIconRequestingAnim{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dg-control-round__icon_name_locate:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23616161%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23444%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%23444%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:18px;height:18px;background-size:18px 18px}.dg-control-round__icon_name_locate:active:after,.no-touch .dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2218%22%20height%3D%2218%22%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23424242%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.553%200.447%2C10%201%2C10%20H%202.08%20C%202.52%2C13.063%204.936%2C15.48%208%2C15.92%20V%2017%20c%200%2C0.553%200.447%2C1%201%2C1%200.553%2C0%201%2C-0.447%201%2C-1%20V%2015.92%20C%2013.064%2C15.481%2015.48%2C13.064%2015.92%2C10%20H%2017%20C%2017.553%2C10%2018%2C9.553%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20z%20M%209%2C14%20C%206.24%2C14%204%2C11.762%204%2C9%204%2C6.238%206.24%2C4%209%2C4%20c%202.761%2C0%205%2C2.238%205%2C5%200%2C2.762%20-2.239%2C5%20-5%2C5%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Ccircle%20cx%3D%229%22%20cy%3D%229%22%20r%3D%223%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%232e2e2e%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2014%2C10.004%20C%2014%2C9.834%2013.991%2C9.667%2013.975%2C9.502%2013.723%2C12.027%2011.592%2C14%209%2C14%206.408%2C14%204.277%2C12.027%204.025%2C9.502%204.009%2C9.667%204%2C9.834%204%2C10.004%20c%200%2C2.762%202.24%2C5%205%2C5%202.761%2C0%205%2C-2.238%205%2C-5%20z%20M%2010%2C3.083%20c%203.064%2C0.439%205.48%2C2.856%205.92%2C5.921%20H%2017%20c%200.369%2C0%200.688%2C0.201%200.86%2C0.498%20C%2017.947%2C9.354%2018%2C9.184%2018%2C9%2018%2C8.448%2017.553%2C8%2017%2C8%20H%2015.92%20C%2015.48%2C4.937%2013.064%2C2.52%2010%2C2.08%20V%203.083%20z%20M%201%2C9.004%20H%202.08%20C%202.52%2C5.939%204.936%2C3.522%208%2C3.083%20V%202.08%20C%204.936%2C2.52%202.52%2C4.937%202.08%2C8%20H%201%20C%200.447%2C8%200%2C8.448%200%2C9%200%2C9.184%200.053%2C9.354%200.14%2C9.502%200.312%2C9.205%200.631%2C9.004%201%2C9.004%20z%20m%208%2C-8%20c%200.553%2C0%201%2C0.447%201%2C1%20V%201%20C%2010%2C0.448%209.553%2C0%209%2C0%208.447%2C0%208%2C0.448%208%2C1%20v%201.004%20c%200%2C-0.553%200.447%2C-1%201%2C-1%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%209%2C7%20c%201.486%2C0%202.717%2C1.082%202.955%2C2.5%20C%2011.982%2C9.337%2012%2C9.171%2012%2C9%2012%2C7.344%2010.656%2C6%209%2C6%207.344%2C6%206%2C7.344%206%2C9%206%2C9.171%206.018%2C9.337%206.045%2C9.5%206.283%2C8.082%207.514%2C7%209%2C7%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:active:after,.dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:after,.no-touch .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:hover:after{background-repeat:no-repeat;width:24px;height:24px;background-image:url(https://maps.api.2gis.ru/2.0/img/sprite.dark.png);background-position:0 0;background-size:78px 65px;-webkit-animation:DGLocation__locateIconRequestingAnim 1s linear infinite;animation:DGLocation__locateIconRequestingAnim 1s linear infinite;image-rendering:optimizeQuality}.leaflet-retina .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:active:after,.leaflet-retina .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:after,.leaflet-retina .no-touch .dg-control-round__icon_state_requesting.dg-control-round__icon_name_locate:hover:after{background-image:url(https://maps.api.2gis.ru/2.0/img/sprite@2x.dark.png);background-position:0 0;background-size:78px 65px}.dg-control-round__icon_name_fullscreen:after{position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_fullscreen:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%20m%204%2C14%20h%205%20v%20-5%20h%20-2%20v%203%20H%2010%20z%20M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20V%206%20z%20M%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%230da4d4%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C1%20H%206%20V%202%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%20m%203%2C9%20h%202%20v%201%20h%20-2%20z%20m%20-3%2C3%20h%203%20v%201%20h%20-3%20z%20m%20-7%2C0%20h%203%20v%201%20H%203%20z%20M%201%2C10%20h%202%20v%201%20H%201%20z%22%20fill%3D%22%230a84ab%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C6%20H%203%20V%207%20H%201%20z%20m%2012%2C0%20h%202%20V%207%20H%2013%20z%20M%201%2C15%20h%205%20v%201%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_name_fullscreen:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C3%20H%206%20V%204%20H%201%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%20m%204%2C14%20h%205%20v%20-5%20h%20-2%20v%203%20h%20-3%20z%22%20fill%3D%22%236c6c6c%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2010%2C3%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20V%206%20z%20M%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%236c6c6c%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C1%20H%206%20V%202%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%20m%203%2C9%20h%202%20v%201%20h%20-2%20z%20m%20-3%2C3%20h%203%20v%201%20h%20-3%20z%20m%20-7%2C0%20h%203%20v%201%20H%203%20z%20M%201%2C10%20h%202%20v%201%20H%201%20z%22%20fill%3D%22%234b4b4b%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%201%2C6%20H%203%20V%207%20H%201%20z%20m%2012%2C0%20h%202%20V%207%20H%2013%20z%20M%201%2C15%20h%205%20v%201%20H%201%20z%20m%209%2C0%20h%205%20v%201%20h%20-5%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:16px;height:16px;background-size:16px 16px}.dg-control-round__icon_name_fullscreen:active:after,.no-touch .dg-control-round__icon_name_fullscreen:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%2216%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012%2C9%20h%204%20v%207%20h%20-4%20z%20m%20-3%2C3%20h%205%20v%204%20H%209%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2010%2C15%20h%205%20v%20-5%20h%20-2%20v%203%20h%20-3%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%200%2C9%20h%204%20v%207%20H%200%20z%20m%202%2C3%20h%205%20v%204%20H%202%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%201%2C10%20v%205%20H%206%20V%2013%20H%203%20v%20-3%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%204%20V%207%20H%200%20z%20m%209%2C0%20h%205%20V%204%20H%209%20z%20m%203%2C0%20h%204%20v%207%20h%20-4%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2015%2C6%20V%201%20h%20-5%20v%202%20h%203%20v%203%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%202%2C0%20H%207%20V%204%20H%202%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C1%20H%201%20V%206%20H%203%20V%203%20h%203%20z%22%20fill%3D%22%23282828%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-building-callout__body{position:relative}.dg-building-callout__list{margin-bottom:8px;padding-left:24px;color:#ffe6aa;list-style:none}.dg-building-callout__list-item{position:relative;margin-bottom:4px;font-size:12px}.dg-building-callout__list-item:before{position:absolute;top:5px;left:-21px;content:'';background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%226%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%203%2C-0.002%20C%204.654%2C-0.002%205.994%2C1.342%205.994%2C3%205.994%2C4.658%204.655%2C6.002%203%2C6.002%201.345%2C6.002%200.005%2C4.658%200.005%2C3%200.005%2C1.342%201.346%2C-0.002%203%2C-0.002%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:6px;height:6px;background-size:6px 6px}.dg-map-geoclicker__address{margin-bottom:10px;font-size:16px}.dg-map-geoclicker__purpose+.dg-map-geoclicker__address{margin-top:-6px}.dg-map-geoclicker__address-header{position:relative;margin-bottom:4px;padding-left:24px}.dg-map-geoclicker__address-header:first-child:before{position:absolute;top:5px;left:1px;content:''}.dg-map-geoclicker__address-drilldown{position:relative;margin-bottom:4px;padding-left:24px;color:#aaa;font-size:12px}.dg-map-geoclicker__address-drilldown:first-child:before{position:absolute;top:2px;left:1px;content:''}.dg-map-geoclicker__purpose{position:relative;margin-bottom:10px;padding-left:24px;font-size:16px}.dg-map-geoclicker__address+.dg-map-geoclicker__purpose{margin-top:-6px}.dg-map-geoclicker__purpose:before{position:absolute;top:4px;left:2px;content:''}.dg-map-geoclicker__purpose_type_street:before{top:4px}.dg-map-geoclicker__sight-description{overflow:hidden;padding:.5em 0 0 24px;max-height:3.6em}a.dg-map-geoclicker__show-more-sights-link{position:relative;margin-left:24px;border-bottom:1px dotted;text-decoration:none}a.dg-map-geoclicker__show-more-sights-link:after{position:absolute;top:4px;margin-left:5px;width:6px;height:10px;content:'';font-weight:700}.dg-map-geoclicker__clamped-line{display:block;white-space:nowrap}.dg-map-geoclicker__clamped-line_last{overflow:hidden;width:100%;text-overflow:ellipsis}.dg-map-geoclicker__preloader-wrapper{display:table-cell;vertical-align:middle;text-align:center}.dg-map-geoclicker__drilldown{margin-bottom:10px}.dg-map-geoclicker__address-drilldown:first-child:before,.dg-map-geoclicker__address-header:first-child:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204.958%2C11%20C%204.958%2C9.036%206.756%2C6.751%208.719%2C6.751%208.885%2C6.223%209%2C5.656%209%2C5.063%209%2C2.267%206.985%2C0%204.5%2C0%202.015%2C0%200%2C2.267%200%2C5.063%200%2C5.656%200.114%2C6.222%200.28%2C6.751%202.243%2C6.751%204.018%2C9.012%204.018%2C11%20h%200.94%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:11px;background-size:9px 11px}.dg-map-geoclicker__purpose:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%228%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%203.582%2C8%20c%200.211%2C0%200.798%2C0.035%201%2C0%20v%204%20l%20-2%2C-1%20V%208%20c%200.372%2C0.066%200.861%2C0%201%2C0%20z%20M%200.44%2C5.384%20C%200.163%2C4.866%200%2C4.276%200%2C3.646%200%2C1.633%201.604%2C0.002%203.582%2C0.002%20c%201.978%2C0%203.582%2C1.631%203.582%2C3.644%200%2C0.647%20-0.169%2C1.254%20-0.461%2C1.781%20L%206.641%2C5.495%206.618%2C5.567%20C%205.954%2C6.549%204.844%2C7.192%203.584%2C7.192%202.25%2C7.192%201.084%2C6.467%200.44%2C5.384%20z%20M%202.613%2C1.276%20c%20-0.549%2C0%20-0.995%2C0.453%20-0.995%2C1.013%200%2C0.559%200.446%2C1.013%200.995%2C1.013%200.551%2C0%200.996%2C-0.454%200.996%2C-1.013%200%2C-0.56%20-0.445%2C-1.013%20-0.996%2C-1.013%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:8px;height:12px;background-size:8px 12px}.dg-map-geoclicker__purpose_type_street:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%208.8%2C0%20H%203.199%20L%200%2C12%20H%2012%20L%208.8%2C0%20z%20M%207%2C12%20H%205%20V%209%20h%202%20v%203%20z%20M%207%2C8%20H%205%20V%206%20H%207%20V%208%20z%20M%207%2C5%20H%205%20V%203%20H%207%20V%205%20z%20M%207%2C2%20H%205%20V%200%20h%202%20v%202%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px}.dg-map-geoclicker__purpose_type_sight:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%228%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%207%2C0%20H%202.547%20C%200.547%2C0%200%2C0.828%200%2C2.5%200%2C3.734%200.5%2C5%202%2C5%203.359%2C5%204%2C3.844%204%2C3%204%2C2.281%202.859%2C2%202%2C2%202%2C2.766%202.234%2C3%203%2C3%203%2C3.69%202.48%2C4%202%2C4%201.234%2C4%201%2C3.329%201%2C2.5%201%2C1.693%201.375%2C1%202.5%2C1%204.391%2C1%205%2C1.656%205%2C3%205%2C4.6%204.338%2C5.119%203%2C6%20v%204%20H%202%20v%202%20H%208%20V%201%20L%207%2C0%20z%20M%204%2C10%20V%206%20l%201%2C1%20v%203%20H%204%20z%20m%202%2C0%20V%206%20l%201%2C1%20v%203%20H%206%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:8px;height:12px;background-size:8px 12px}.dg-map-geoclicker__purpose_type_settlement:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209%2C9%20C%208.235%2C9%207.762%2C9.522%207.259%2C10.022%207.795%2C10.38%208.051%2C11.05%207.879%2C12%20H%2012%20C%2012%2C10.46%2010.535%2C9%209%2C9%20z%20m%20-2.868%2C1.248%20c%20-0.965%2C0%20-1.747%2C0.784%20-1.747%2C1.751%20h%203.494%20c%200%2C-0.967%20-0.782%2C-1.751%20-1.747%2C-1.751%20z%20M%2010%2C1%20V%200%20H%207%20V%201%20H%205%20V%206%20L%206%2C7%20V%202%20H%207%20V%207%20L%208%2C8%20V%202%20h%201%20v%206%20h%201%20V%202%20h%201%20v%207%20l%201%2C0.607%20V%201%20H%2010%20z%20M%206.66%2C9.539%206.721%2C9.479%20C%206.903%2C9.297%207.104%2C9.14%207.314%2C9.004%20V%208.414%20L%206.131%2C7.187%203%2C8%20v%204%20H%203.62%20C%203.62%2C10.612%204.747%2C9.483%206.132%2C9.483%206.312%2C9.482%206.49%2C9.502%206.66%2C9.539%20z%20M%202%2C12%20z%20M%201%2C2%200%2C5%20v%207%20H%202%20V%205%20L%201%2C2%20z%20M%201.111%2C6.955%20C%200.804%2C6.955%200.556%2C6.706%200.556%2C6.4%20c%200%2C-0.307%200.248%2C-0.555%200.555%2C-0.555%200.307%2C0%200.554%2C0.248%200.554%2C0.555%200%2C0.306%20-0.247%2C0.555%20-0.554%2C0.555%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px}a.dg-map-geoclicker__show-more-sights-link{color:#ffe6aa}.no-touch a.dg-map-geoclicker__show-more-sights-link:hover{color:#9cd}a.dg-map-geoclicker__show-more-sights-link:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%226%22%20height%3D%2210%22%20viewBox%3D%220%200%206%2010%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C5%20V%205.4%20L%201.4%2C10%20H%200%20L%200%2C8.6%203.6%2C5%200%2C1.4%200%2C0%201.4%2C0%206%2C4.6%20V%205%20l%200%2C0%200%2C0%200%2C0%200%2C0%200%2C0%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-map-geoclicker__drilldown{color:#aaa}.dg-preloader{position:relative;margin:0 auto;width:200px;height:44px;vertical-align:middle}.dg-preloader_animation_false{background-repeat:no-repeat;background-image:url(https://maps.api.2gis.ru/2.0/img/DGPreloader__preloader.gif);background-size:100px 26px;background-attachment:scroll;background-position:50% 50%}.dg-preloader_animation_true:before{position:absolute;top:50%;left:50%;margin:-22px 0 0 -22px;width:44px;height:44px;outline:transparent solid 1px;content:'';-webkit-animation:dg-preloader__outer 5s linear infinite;animation:dg-preloader__outer 5s linear infinite;image-rendering:optimizeQuality}.dg-preloader_animation_true.dg-preloader_size_small:before{margin:-12px 0 0 -12px;width:24px;height:24px}.dg-preloader_animation_true.dg-preloader_scheme_regular:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2244%22%20height%3D%2244%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2035.68%2C10.32%20C%2038.368%2C13.465%2040%2C17.539%2040%2C22%2040%2C31.941%2031.941%2C40%2022%2C40%2012.059%2C40%204%2C31.941%204%2C22%204%2C17.539%205.632%2C13.465%208.32%2C10.32%20L%205.48%2C7.48%20C%202.07%2C11.354%200%2C16.434%200%2C22%200%2C34.15%209.85%2C44%2022%2C44%2034.15%2C44%2044%2C34.15%2044%2C22%2044%2C16.434%2041.93%2C11.354%2038.52%2C7.48%20l%20-2.84%2C2.84%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209.271%2C9.272%20C%2012.529%2C6.015%2017.029%2C4%2022%2C4%2026.971%2C4%2031.471%2C6.015%2034.729%2C9.272%20L%2037.557%2C6.444%20C%2033.575%2C2.462%2028.075%2C0%2022%2C0%2015.925%2C0%2010.425%2C2.462%206.443%2C6.444%20l%202.828%2C2.828%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:44px 44px}.dg-preloader_animation_true.dg-preloader_scheme_regular.dg-preloader_size_small:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2224%22%20height%3D%2224%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018.564%2C7.435%20C%2019.467%2C8.73%2020%2C10.302%2020%2C12%2020%2C16.418%2016.418%2C20%2012%2C20%207.582%2C20%204%2C16.418%204%2C12%204%2C10.302%204.533%2C8.73%205.436%2C7.435%20L%202.581%2C4.581%20C%200.969%2C6.623%200%2C9.195%200%2C12%200%2C18.627%205.373%2C24%2012%2C24%2018.627%2C24%2024%2C18.627%2024%2C12%2024%2C9.195%2023.031%2C6.623%2021.419%2C4.581%20l%20-2.855%2C2.854%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2012%2C0%20C%208.686%2C0%205.686%2C1.343%203.516%2C3.515%20L%206.343%2C6.343%20C%207.791%2C4.895%209.791%2C4%2012%2C4%20c%202.209%2C0%204.209%2C0.895%205.657%2C2.343%20L%2020.484%2C3.515%20C%2018.314%2C1.343%2015.314%2C0%2012%2C0%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:24px 24px}.dg-preloader_animation_true:after{position:absolute;top:50%;left:50%;margin:-16px 0 0 -16px;width:32px;height:32px;outline:transparent solid 1px;content:'';-webkit-animation:dg-preloader__inner 4s linear infinite;animation:dg-preloader__inner 4s linear infinite;image-rendering:optimizeQuality}.dg-preloader_animation_true.dg-preloader_size_small:after{margin:-6px 0 0 -6px;width:12px;height:12px}.dg-preloader_animation_true.dg-preloader_scheme_regular:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2232%22%20height%3D%2232%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206.581%2C23.419%20C%204.969%2C21.377%204%2C18.804%204%2C16%204%2C9.373%209.373%2C4%2016%2C4%20c%206.627%2C0%2012%2C5.373%2012%2C12%200%2C2.804%20-0.969%2C5.377%20-2.581%2C7.419%20l%202.847%2C2.847%20C%2030.594%2C23.487%2032%2C19.909%2032%2C16%2032%2C7.163%2024.837%2C0%2016%2C0%207.163%2C0%200%2C7.163%200%2C16%20c%200%2C3.909%201.406%2C7.487%203.734%2C10.266%20l%202.847%2C-2.847%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2027.314%2C27.314%2024.486%2C24.486%20C%2022.314%2C26.657%2019.314%2C28%2016%2C28%2012.686%2C28%209.686%2C26.657%207.516%2C24.485%20L%204.688%2C27.313%20C%207.582%2C30.209%2011.582%2C32%2016%2C32%20c%204.418%2C0%208.418%2C-1.791%2011.314%2C-4.686%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:32px 32px}.dg-preloader_animation_true.dg-preloader_scheme_regular.dg-preloader_size_small:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%203.141%2C6.86%20C%203.059%2C6.586%203%2C6.301%203%2C6%203%2C4.343%204.343%2C3%206%2C3%207.657%2C3%209%2C4.343%209%2C6%209%2C6.301%208.941%2C6.586%208.859%2C6.86%20l%202.26%2C2.259%20C%2011.674%2C8.209%2012%2C7.144%2012%2C6%2012%2C2.686%209.314%2C0%206%2C0%202.686%2C0%200%2C2.686%200%2C6%200%2C7.144%200.326%2C8.209%200.881%2C9.119%20L%203.141%2C6.86%20z%22%20fill%3D%22%23a6cd2a%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%206%2C12%20c%201.657%2C0%203.157%2C-0.672%204.243%2C-1.757%20L%208.122%2C8.122%20C%207.578%2C8.664%206.828%2C9%206%2C9%205.172%2C9%204.422%2C8.664%203.879%2C8.121%20L%201.758%2C10.242%20C%202.843%2C11.328%204.343%2C12%206%2C12%20z%22%20fill%3D%22%230da5d5%22%2F%3E%0A%3C%2Fsvg%3E%0A\");background-size:12px 12px}@-webkit-keyframes dg-preloader__outer{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes dg-preloader__outer{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes dg-preloader__inner{to{-webkit-transform:rotate(-360deg);transform:rotate(-360deg)}}@keyframes dg-preloader__inner{to{-webkit-transform:rotate(-360deg);transform:rotate(-360deg)}}.dg-popup__footer-buttons{display:table;margin-top:10px;width:100%}.dg-popup__footer-button-wrapper{display:table-cell}.dg-popup__footer-button{position:relative;display:inline-block;-webkit-box-sizing:border-box;box-sizing:border-box;margin-left:5%;width:95%;border-radius:2px;text-align:center;text-decoration:none;font:12px/24px Arial,sans-serif;cursor:pointer;-webkit-transition:all .1s;transition:all .1s}.dg-popup__footer-button-wrapper:first-child .dg-popup__footer-button{margin:0;width:100%}.no-touch .dg-popup__footer-button:hover{-webkit-transition:all .2s;transition:all .2s}.dg-popup__footer-icon-button:before{display:inline-block;margin:-2px 5px 0 0;width:12px;height:12px;background-size:contain;background-repeat:no-repeat;content:'';vertical-align:middle}.dg-popup__button_name_back:before,.dg-popup__button_name_firm-card-back:before,.dg-popup__button_name_firm-list-back:before{width:9px;height:6px}.dg-popup__show-less-house-link{position:relative;top:6px;margin:0 15px 10px;color:#0070c0;text-decoration:none;font-size:12px;line-height:24px}.dg-popup__header-links{margin:8px 18px 0 0}.dg-popup__header-title_for_firmcard{position:relative;overflow:hidden;max-height:3.4em}.dg-popup__header-teaser{display:-webkit-box;height:3.3em;-webkit-line-clamp:3;-webkit-box-orient:vertical}.dg-popup__header-title{display:block;white-space:normal;font:22px/24px 'Arial narrow',Arial,sans-serif}.dg-popup__header-link{display:inline-block;margin-left:2.6em;vertical-align:middle;white-space:nowrap}.dg-popup__header-link:first-child{margin-left:1.2em}.dg-popup__rating{display:inline-block;margin:0 .4em 3px 0;width:70px;height:14px;vertical-align:middle}.dg-popup__rating-stars{background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2214%22%20height%3D%2214%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206.999%2C0%208.748%2C4.989%2013.997%2C4.991%209.83%2C8.708%2011.324%2C14.002%206.999%2C10.871%202.674%2C14.002%204.168%2C8.708%200%2C4.991%205.249%2C4.989%206.999%2C0%20z%22%20fill%3D%22%23ffc84b%22%2F%3E%0A%3C%2Fsvg%3E%0A\");float:left;height:100%}.dg-popup__link{position:relative;background-position:center bottom;background-size:10px 1px;background-repeat:repeat-x;text-decoration:none;-webkit-tap-highlight-color:transparent}.dg-popup__link_type_flamp_reviews{margin-left:.1em}.dg-popup__link_type_photos:before{position:absolute;top:2px;left:-18px;display:inherit;content:''}.dg-popup__link_type_booklet:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%200%2C8%203%2C2%20V%202%20L%200%2C0%20V%208%20z%20M%204%2C10%208%2C8%20V%200%20L%204%2C2%20v%208%20z%20M%209%2C0%20v%208%20l%203%2C2%20V%202%20L%209%2C0%20z%22%20fill%3D%22%237dc814%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:10px;background-size:12px 10px;position:absolute;top:2px;left:-18px;display:inherit;content:''}a.dg-popup__link{background-image:-webkit-gradient(linear,left top,right top,from(rgba(255,230,170,.3)),to(rgba(255,230,170,.3)));background-image:-webkit-linear-gradient(left,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);background-image:linear-gradient(to right,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);color:#ffe6aa}.no-touch a.dg-popup__link:hover{background-image:-webkit-gradient(linear,left top,right top,from(rgba(153,204,221,.3)),to(rgba(153,204,221,.3)));background-image:-webkit-linear-gradient(left,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);background-image:linear-gradient(to right,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);color:#9cd}.dg-popup__header-title{color:#ffc84b}.dg-popup__footer-button-wrapper .dg-popup__footer-button,.dg-popup__footer-button-wrapper .dg-popup__footer-button:hover{color:#e6e6e6}.dg-popup__footer-button{background:rgba(0,0,0,.2);-webkit-box-shadow:0 1px rgba(0,0,0,.1);box-shadow:0 1px rgba(0,0,0,.1)}.no-touch .dg-popup__footer-button:hover{background:#222;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.5);box-shadow:0 1px 3px rgba(0,0,0,.5)}.dg-popup__rating{background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2214%22%20height%3D%2214%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%207.002%2C0%208.751%2C4.989%2014%2C4.991%209.833%2C8.708%2011.327%2C14.002%207.002%2C10.871%202.677%2C14.002%204.171%2C8.708%200.003%2C4.991%205.252%2C4.989%207.002%2C0%20z%22%20fill%3D%22%23aaa%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-popup__link_type_photos:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2011%2C1%20H%2010%20L%209%2C0%20H%206%20L%205%2C1%20H%201%20L%200%2C2%20v%207%20l%201%2C1%20H%2011%20L%2012%2C9%20V%202%20L%2011%2C1%20z%20M%203%2C4%20H%202%20V%203%20h%201%20v%201%20z%20m%204.518%2C3.992%20c%20-1.381%2C0%20-2.5%2C-1.119%20-2.5%2C-2.5%200%2C-1.38%201.119%2C-2.5%202.5%2C-2.5%201.38%2C0%202.5%2C1.12%202.5%2C2.5%200%2C1.381%20-1.121%2C2.5%20-2.5%2C2.5%20z%22%20fill%3D%22%2379b0bc%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:10px;background-size:12px 10px}.dg-popup__button_name_firm-card-back:before,.dg-popup__button_name_firm-list-back:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C3%204%2C6%20V%204%20H%209%20V%202%20H%204%20V%200%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-popup__button_name_back:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C3%204%2C6%20V%204%20H%209%20V%202%20H%204%20V%200%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:6px;background-size:9px 6px}.dg-popup__button_name_goto:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%227%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2016.5%2C0%20C%2014.738%2C0%2013.295%2C1.306%2013.051%2C3%20H%204.949%20C%204.718%2C1.858%203.71%2C1%202.5%2C1%201.119%2C1%200%2C2.119%200%2C3.5%200%2C4.881%201.119%2C6%202.5%2C6%203.71%2C6%204.718%2C5.142%204.949%2C4%20h%208.102%20C%2013.295%2C5.693%2014.739%2C7%2016.5%2C7%2018.433%2C7%2020%2C5.433%2020%2C3.5%2020%2C1.566%2018.433%2C0%2016.5%2C0%20z%22%20fill%3D%22%239f9f9f%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:20px;height:7px;background-size:20px 7px}.dg-popup__button_name_show-entrance:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C9%209%2C6%205%2C3%20V%205%20H%200%20V%207%20H%205%20V%209%20z%20M%209.6%2C0%20H%202.4%20C%201.074%2C0%200%2C1.074%200%2C2.4%20V%204%20H%202%20V%203.6%20C%202%2C2.716%202.716%2C2%203.6%2C2%20H%208.4%20C%209.283%2C2%2010%2C2.716%2010%2C3.6%20V%208.4%20C%2010%2C9.284%209.283%2C10%208.4%2C10%20H%203.6%20C%202.716%2C10%202%2C9.284%202%2C8.4%20V%208%20H%200%20V%209.6%20C%200%2C10.925%201.074%2C12%202.4%2C12%20H%209.6%20C%2010.926%2C12%2012%2C10.925%2012%2C9.6%20V%202.4%20C%2012%2C1.074%2010.926%2C0%209.6%2C0%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-firm-card__icon{position:relative;padding-left:24px}.dg-firm-card__icon:before{position:absolute;top:0;left:0;margin:auto;background-position:0 50%;background-repeat:no-repeat;content:''}.dg-firm-card__link{overflow:hidden;margin-bottom:4px;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;line-height:16px}.dg-firm-card__link a{background-position:center bottom;background-size:10px 1px;background-repeat:repeat-x;text-decoration:none}.dg-firm-card__address{margin-bottom:10px;font-size:16px}.dg-firm-card__address:before{position:absolute;top:5px;left:1px;content:''}.dg-firm-card__comment{position:relative;margin-left:5px;font-size:12px}.dg-firm-card__phone{overflow:hidden;margin-bottom:4px;text-overflow:ellipsis;line-height:16px}.dg-firm-card__phone:before{top:3px;left:1px}.dg-firm-card__site:before{top:3px}.dg-firm-card__email:before{top:5px}.dg-firm-card__rubrics{overflow:hidden;margin-bottom:4px;font-size:12px;line-height:16px}.dg-firm-card__rubrics-list{margin:0;padding:0;list-style:none}.dg-firm-card__rubrics-list-item{display:inline;cursor:default}.dg-firm-card__rubrics-list-item:before{display:inline-block;margin:0 4px;content:'•'}.dg-firm-card__rubrics-list-item:first-child:before{margin:0;content:''}.dg-firm-card__aa{margin:0 0 4px;padding:0 0 0 24px;font-size:12px}.dg-firm-card__aa-list{display:inline;margin:0;padding:0;list-style:none;line-height:16px}.dg-firm-card__aa-list-item{display:inline;-webkit-box-sizing:border-box;box-sizing:border-box;max-width:100%;cursor:default}.dg-firm-card__aa-list-item:before{display:inline-block;margin:0 4px;content:'•'}.dg-firm-card__aa-list-item:first-child:before{margin:0;content:''}.dg-firm-card__aa-list-additional{display:inline;margin:0;padding:0;list-style:none;line-height:16px}.dg-firm-card__schedule{margin-bottom:10px}.dg-firm-card__link a{background-image:-webkit-gradient(linear,left top,right top,from(rgba(255,230,170,.3)),to(rgba(255,230,170,.3)));background-image:-webkit-linear-gradient(left,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);background-image:linear-gradient(to right,rgba(255,230,170,.3),rgba(255,230,170,.3) 100%);color:#ffe6aa}.no-touch .dg-firm-card__link a:hover{background-image:-webkit-gradient(linear,left top,right top,from(rgba(153,204,221,.3)),to(rgba(153,204,221,.3)));background-image:-webkit-linear-gradient(left,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);background-image:linear-gradient(to right,rgba(153,204,221,.3),rgba(153,204,221,.3) 100%);color:#9cd}.dg-firm-card__comment,.dg-firm-card__rubrics{color:#aaa}.dg-firm-card__rubrics-list-item:after{color:#6e6964}.dg-firm-card__aa-list-item:after{color:#e6e6e6}.dg-firm-card__address:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%229%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204.958%2C11%20C%204.958%2C9.036%206.756%2C6.751%208.719%2C6.751%208.885%2C6.223%209%2C5.656%209%2C5.063%209%2C2.267%206.985%2C0%204.5%2C0%202.015%2C0%200%2C2.267%200%2C5.063%200%2C5.656%200.114%2C6.222%200.28%2C6.751%202.243%2C6.751%204.018%2C9.012%204.018%2C11%20h%200.94%20z%22%20fill%3D%22%23a0a0a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:9px;height:11px;background-size:9px 11px}.dg-firm-card__phone:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%209.181%2C9.05%20C%208.673%2C9.556%208.047%2C9.873%207.391%2C10%206.156%2C9.841%205.008%2C9.417%203.998%2C8.788%20L%201.293%2C6.092%20C%200.639%2C5.053%200.203%2C3.865%200.052%2C2.589%200.19%2C1.964%200.494%2C1.368%200.983%2C0.882%20L%201.803%2C0.065%203.987%2C2.241%20V%202.79%20L%203.441%2C3.332%20c%20-0.452%2C0.451%20-0.453%2C1.183%200%2C1.634%20L%205.082%2C6.6%20c%200.452%2C0.451%201.187%2C0.451%201.639%2C0%20L%207.244%2C6.079%20H%207.838%20L%2010%2C8.233%209.181%2C9.05%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:10px;background-size:10px 10px}.dg-firm-card__site:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.538%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.538%208.537%2C11%205.5%2C11%20z%20m%200%2C-9%20C%203.566%2C2%202%2C3.567%202%2C5.5%202%2C7.433%203.566%2C9%205.5%2C9%205.655%2C9%205.804%2C8.974%205.954%2C8.954%20L%203%2C6%20V%205%20L%205.571%2C3.286%205.984%2C2.049%20C%205.824%2C2.026%205.666%2C2%205.5%2C2%20z%20M%208.949%2C5%20H%207.375%20C%207.021%2C5.505%206.545%2C6.082%206%2C6.497%20V%208.95%20C%207.693%2C8.705%209%2C7.262%209%2C5.5%209%2C5.329%208.974%2C5.165%208.949%2C5%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-firm-card__email:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%227%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2011%2C1.555%20v%203.89%20C%2011%2C6.303%2010.242%2C7%209.309%2C7%20H%201.692%20C%200.758%2C7%200%2C6.303%200%2C5.444%20V%201.554%20L%205.5%2C4.826%2011%2C1.555%20z%20M%200.191%2C0%20H%2010.808%20L%205.5%2C3.111%200.191%2C0%20z%22%20fill%3D%22%23aaa%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:7px;background-size:11px 7px}.dg-schedule__today{position:relative;display:inline-block;margin-left:24px;max-width:84%;background-position:center bottom;background-size:2px 1px;background-repeat:repeat-x;font-size:14px;line-height:16px;cursor:pointer}.dg-schedule__today:before{position:absolute;top:3px;left:-24px;content:''}.dg-schedule__today:after{position:absolute;right:-15px;bottom:4px;content:''}.dg-schedule__today-inner{overflow:hidden;width:100%;text-overflow:ellipsis;white-space:nowrap}.dg-schedule_works-everyday_true .dg-schedule__today{background-image:none;cursor:default}.dg-schedule_works-everyday_true .dg-schedule__today:after{background-image:none}.dg-schedule_open_true .dg-schedule__today:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%2370bf00%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__now{margin:2px 7px 0 36px;font-size:12px}.dg-schedule__string{padding:3px 16px 3px 24px;text-align:left;font-size:14px}.dg-schedule__string-time{white-space:nowrap}.dg-schedule__table{display:none;text-align:center;font-size:0}.dg-schedule__table-cell-group{white-space:nowrap}.dg-schedule__tc{display:inline-block;padding:2px 0 15px;width:44px;vertical-align:top;white-space:normal;font-size:14px}.dg-schedule__tc_pre{width:19px}.dg-schedule__day-name{margin:0;color:#8c8782;text-transform:capitalize}.dg-schedule__td{margin:10px 0 0}.dg-schedule_state_expanded .dg-schedule__popup{display:block;visibility:visible;max-height:1000px;opacity:1}.dg-schedule__table-clock{margin:13px 0 0}.dg-schedule__table-lunch{margin:31px 0 0}.dg-schedule__today{background-image:-webkit-gradient(linear,left top,right top,from(rgba(230,230,230,.55)),color-stop(50%,rgba(230,230,230,.55)),color-stop(51%,rgba(0,0,0,0)),to(rgba(0,0,0,0)));background-image:-webkit-linear-gradient(left,rgba(230,230,230,.55),rgba(230,230,230,.55) 50%,rgba(0,0,0,0) 51%,rgba(0,0,0,0) 100%);background-image:linear-gradient(to right,rgba(230,230,230,.55),rgba(230,230,230,.55) 50%,rgba(0,0,0,0) 51%,rgba(0,0,0,0) 100%)}.dg-schedule__now{color:#aaa}.dg-schedule__td{color:#e6e6e6}.dg-schedule__tc_active_true{background:rgba(255,255,255,.1)}.dg-schedule__string-time{color:#e6e6e6}.dg-schedule__table-clock{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__table-lunch{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%204%2C7%20H%208%20C%208.58%2C7%209.461%2C6.084%209.826%2C4.977%20V%205%20C%2011.047%2C5%2012%2C3.453%2012%2C2.031%2012%2C1.453%2011.531%2C1%2011.016%2C1%20H%2010%20C%2010%2C0.188%209.781%2C0%209%2C0%20H%203%20C%202.297%2C0%202%2C0.188%202%2C1%20v%203%20c%200%2C1.49%201.137%2C3%202%2C3%20z%20m%206%2C-5%20h%200.5%20C%2010.875%2C2%2011%2C2.219%2011%2C2.5%2011%2C3.625%2010.562%2C4%2010%2C4%20V%202%20z%20M%200%2C9%20c%200%2C0.448%201.791%2C1%203%2C1%200%2C0.405%200.646%2C1%201%2C1%20h%204%20c%200.354%2C0%201%2C-0.595%201%2C-1%201.208%2C0%203%2C-0.552%203%2C-1%20V%208%20H%200%20v%201%20z%22%20fill%3D%22%23aaa5a0%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:11px;background-size:12px 11px}.dg-schedule_open_false .dg-schedule__today:before{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2211%22%20height%3D%2211%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205.5%2C11%20C%202.463%2C11%200%2C8.537%200%2C5.5%200%2C2.462%202.463%2C0%205.5%2C0%208.537%2C0%2011%2C2.462%2011%2C5.5%2011%2C8.537%208.537%2C11%205.5%2C11%20z%20M%206%2C5.293%20V%202%20H%205%20V%205.707%20L%207.646%2C8.353%208.353%2C7.646%206%2C5.293%20z%22%20fill%3D%22%23a0a0a0%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:11px;height:11px;background-size:11px 11px}.dg-schedule__today:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C6%20H%204.586%20L%200%2C1.414%20V%200%20H%201.414%20L%205%2C3.586%208.586%2C0%20H%2010%20V%201.414%20L%205.414%2C6%20H%205%20z%22%20fill%3D%22%23a5a09c%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:6px;background-size:10px 6px}.dg-schedule__today_shown_true:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%226%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%205%2C0%20H%205.414%20L%2010%2C4.586%20V%206%20H%208.586%20L%205%2C2.414%201.414%2C6%20H%200%20V%204.586%20L%204.586%2C0%20H%205%20z%22%20fill%3D%22%23a5a09c%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:10px;height:6px;background-size:10px 6px}.dg-link,.dg-link:hover{background-position:0 95%;background-size:10px 1px;background-repeat:repeat-x}.dg-link_type_local{background:-webkit-gradient(linear,left top,right top,from(#9cd),color-stop(50%,#9cd),color-stop(50%,transparent));background:-webkit-linear-gradient(left,#9cd,#9cd 50%,transparent 50%);background:linear-gradient(to right,#9cd,#9cd 50%,transparent 50%)}.no-touch .dg-link_type_local:hover{background:-webkit-gradient(linear,left top,right top,from(#9bc),color-stop(50%,#9bc),color-stop(50%,transparent));background:-webkit-linear-gradient(left,#9bc,#9bc 50%,transparent 50%);background:linear-gradient(to right,#9bc,#9bc 50%,transparent 50%)}.dg-link.dg-link_type_local,.dg-link.dg-link_type_local:hover{background-size:6px 1px}.dg-control-round__icon_name_traffic:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2214%22%20viewBox%3D%220%200%2020%2014%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018%2C5%20C%2018%2C4%2017%2C1%2015%2C1%20H%2012%2010%20C%208%2C1%207%2C4%207%2C5%20H%205%20v%202%20h%201%20v%204%20c%200%2C0.6%200%2C1%201%2C1%20v%202%20h%202%20v%20-2%20h%207%20v%202%20h%202%20v%20-2%20c%201%2C0%201%2C-0.4%201%2C-1%20V%207%20h%201%20V%205%20H%2018%20z%20M%2010%2C3%20h%202%203%20c%202%2C0%202%2C1%202%2C3%20H%208%20C%208%2C4%208%2C3%2010%2C3%20z%20M%209%2C10%20H%208%20C%207.4%2C10%207%2C9.6%207%2C9%207%2C8.4%207.4%2C8%208%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20m%208%2C0%20H%2016%20C%2015.4%2C10%2015%2C9.6%2015%2C9%2015%2C8.4%2015.4%2C8%2016%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20M%204%2C4%20H%206%20V%203%20H%204%20C%201%2C3%201%2C6%201%2C7%20H%200%20v%201%20h%201%20v%204%20H%203%20V%2011%20H%205%20V%207%20H%202%20C%202%2C6%202%2C4%204%2C4%20z%20M%203%2C9%204%2C10%20H%202%20V%209%20h%201%20z%22%20fill%3D%22%23616161%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23fff%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2016%2C8%20h%201%20c%200.4%2C0%200.7%2C0.2%200.8%2C0.5%20C%2017.9%2C8.4%2018%2C8.2%2018%2C8%2018%2C7.4%2017.6%2C7%2017%2C7%20h%20-1%20c%20-0.6%2C0%20-1%2C0.4%20-1%2C1%200%2C0.2%200.1%2C0.4%200.2%2C0.5%20C%2015.3%2C8.2%2015.6%2C8%2016%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C8%20H%209%20C%209.4%2C8%209.7%2C8.2%209.8%2C8.5%209.9%2C8.4%2010%2C8.2%2010%2C8%2010%2C7.4%209.6%2C7%209%2C7%20H%208%20C%207.4%2C7%207%2C7.4%207%2C8%207%2C8.2%207.1%2C8.4%207.2%2C8.5%207.3%2C8.2%207.6%2C8%208%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%206%2C3%20H%204%20C%204%2C3%204%2C3%204%2C3%202%2C3%202%2C5%202%2C6%20H%202%20C%202.1%2C5%202.5%2C4%204%2C4%20H%205%206%20V%203%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M0%207H1V8H0z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2015%2C2%20H%2012%2010%20C%208%2C2%208%2C3%208%2C5%20H%208%20C%208%2C3.7%208.3%2C3%2010%2C3%20h%202%203%20c%201.7%2C0%201.9%2C0.7%202%2C2%20h%200%20C%2017%2C3%2017%2C2%2015%2C2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%209L4%209%203%208%202%208%202%209%202%209%202%209%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%207%2C11%20C%206%2C11%206%2C10.6%206%2C10%20v%201%20c%200%2C0.6%200%2C1%201%2C1%20v%20-1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2018%2C11%20v%201%20c%201%2C0%201%2C-0.4%201%2C-1%20v%20-1%20c%200%2C0.6%200%2C1%20-1%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M19%206H20V7H19z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%2011L1%2011%201%2012%203%2012%203%2011%205%2011%205%207%205%207%205%2010%203%2010z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M16%2013H18V14H16z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M5%206H6V7H5z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M9%2013L7%2013%207%2014%209%2014%209%2012%2016%2012%2016%2011%209%2011z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23444%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%202%2C6%20C%202%2C6.4%202%2C6.7%202%2C7%20H%205%20V%206%20H%202%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M2%209L2%2010%204%2010%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%204%2C3%20H%206%20V%202%20H%204%20C%201%2C2%201%2C5%201%2C6%20H%200%20V%207%20H%201%20C%201%2C6%201%2C3%204%2C3%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2018%2C4%20C%2018%2C3%2017%2C0%2015%2C0%20H%2012%2010%20C%208%2C0%207%2C3%207%2C4%20H%206%205%20V%205%20H%207%20C%207%2C4%208%2C1%2010%2C1%20h%202%203%20c%202%2C0%203%2C3%203%2C4%20h%202%20V%204%20h%20-2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C10%20H%209%20C%209.6%2C10%2010%2C9.6%2010%2C9%2010%2C8.8%209.9%2C8.6%209.8%2C8.5%209.7%2C8.8%209.4%2C9%209%2C9%20H%208%20C%207.6%2C9%207.3%2C8.8%207.2%2C8.5%207.1%2C8.6%207%2C8.8%207%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C6%20C%2017%2C5.6%2017%2C5.3%2017%2C5%20H%208%20c%200%2C0.3%200%2C0.6%200%2C1%20h%209%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017.8%2C8.5%20C%2017.7%2C8.8%2017.4%2C9%2017%2C9%20H%2016%20C%2015.6%2C9%2015.3%2C8.8%2015.2%2C8.5%2015.1%2C8.6%2015%2C8.8%2015%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20h%201%20c%200.6%2C0%201%2C-0.4%201%2C-1%200%2C-0.2%20-0.1%2C-0.4%20-0.2%2C-0.5%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A\");width:20px;height:14px;background-size:20px 14px;position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_name_traffic:active:after,.no-touch .dg-control-round__icon_name_traffic:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2214%22%20viewBox%3D%220%200%2020%2014%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%2018%2C5%20C%2018%2C4%2017%2C1%2015%2C1%20H%2012%2010%20C%208%2C1%207%2C4%207%2C5%20H%205%20v%202%20h%201%20v%204%20c%200%2C0.6%200%2C1%201%2C1%20v%202%20h%202%20v%20-2%20h%207%20v%202%20h%202%20v%20-2%20c%201%2C0%201%2C-0.4%201%2C-1%20V%207%20h%201%20V%205%20H%2018%20z%20M%2010%2C3%20h%202%203%20c%202%2C0%202%2C1%202%2C3%20H%208%20C%208%2C4%208%2C3%2010%2C3%20z%20M%209%2C10%20H%208%20C%207.4%2C10%207%2C9.6%207%2C9%207%2C8.4%207.4%2C8%208%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20m%208%2C0%20H%2016%20C%2015.4%2C10%2015%2C9.6%2015%2C9%2015%2C8.4%2015.4%2C8%2016%2C8%20h%201%20c%200.6%2C0%201%2C0.4%201%2C1%200%2C0.6%20-0.4%2C1%20-1%2C1%20z%20M%204%2C4%20H%206%20V%203%20H%204%20C%201%2C3%201%2C6%201%2C7%20H%200%20v%201%20h%201%20v%204%20H%203%20V%2011%20H%205%20V%207%20H%202%20C%202%2C6%202%2C4%204%2C4%20z%20M%203%2C9%204%2C10%20H%202%20V%209%20h%201%20z%22%20fill%3D%22%23424242%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%20%20%20%20%3Cg%20fill%3D%22%23fff%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2016%2C8%20h%201%20c%200.4%2C0%200.7%2C0.2%200.8%2C0.5%20C%2017.9%2C8.4%2018%2C8.2%2018%2C8%2018%2C7.4%2017.6%2C7%2017%2C7%20h%20-1%20c%20-0.6%2C0%20-1%2C0.4%20-1%2C1%200%2C0.2%200.1%2C0.4%200.2%2C0.5%20C%2015.3%2C8.2%2015.6%2C8%2016%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C8%20H%209%20C%209.4%2C8%209.7%2C8.2%209.8%2C8.5%209.9%2C8.4%2010%2C8.2%2010%2C8%2010%2C7.4%209.6%2C7%209%2C7%20H%208%20C%207.4%2C7%207%2C7.4%207%2C8%207%2C8.2%207.1%2C8.4%207.2%2C8.5%207.3%2C8.2%207.6%2C8%208%2C8%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%206%2C3%20H%204%20C%204%2C3%204%2C3%204%2C3%202%2C3%202%2C5%202%2C6%20H%202%20C%202.1%2C5%202.5%2C4%204%2C4%20H%205%206%20V%203%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M0%207H1V8H0z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2015%2C2%20H%2012%2010%20C%208%2C2%208%2C3%208%2C5%20H%208%20C%208%2C3.7%208.3%2C3%2010%2C3%20h%202%203%20c%201.7%2C0%201.9%2C0.7%202%2C2%20h%200%20C%2017%2C3%2017%2C2%2015%2C2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%209L4%209%203%208%202%208%202%209%202%209%202%209%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%207%2C11%20C%206%2C11%206%2C10.6%206%2C10%20v%201%20c%200%2C0.6%200%2C1%201%2C1%20v%20-1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22m%2018%2C11%20v%201%20c%201%2C0%201%2C-0.4%201%2C-1%20v%20-1%20c%200%2C0.6%200%2C1%20-1%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M19%206H20V7H19z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M3%2011L1%2011%201%2012%203%2012%203%2011%205%2011%205%207%205%207%205%2010%203%2010z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M16%2013H18V14H16z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M5%206H6V7H5z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M9%2013L7%2013%207%2014%209%2014%209%2012%2016%2012%2016%2011%209%2011z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%20%20%20%20%3Cg%20fill%3D%22%232e2e2e%22%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%202%2C6%20C%202%2C6.4%202%2C6.7%202%2C7%20H%205%20V%206%20H%202%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M2%209L2%2010%204%2010%203%209z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%204%2C3%20H%206%20V%202%20H%204%20C%201%2C2%201%2C5%201%2C6%20H%200%20V%207%20H%201%20C%201%2C6%201%2C3%204%2C3%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2018%2C4%20C%2018%2C3%2017%2C0%2015%2C0%20H%2012%2010%20C%208%2C0%207%2C3%207%2C4%20H%206%205%20V%205%20H%207%20C%207%2C4%208%2C1%2010%2C1%20h%202%203%20c%202%2C0%203%2C3%203%2C4%20h%202%20V%204%20h%20-2%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%208%2C10%20H%209%20C%209.6%2C10%2010%2C9.6%2010%2C9%2010%2C8.8%209.9%2C8.6%209.8%2C8.5%209.7%2C8.8%209.4%2C9%209%2C9%20H%208%20C%207.6%2C9%207.3%2C8.8%207.2%2C8.5%207.1%2C8.6%207%2C8.8%207%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017%2C6%20C%2017%2C5.6%2017%2C5.3%2017%2C5%20H%208%20c%200%2C0.3%200%2C0.6%200%2C1%20h%209%20z%22%2F%3E%0A%20%20%20%20%20%20%20%20%3Cpath%20d%3D%22M%2017.8%2C8.5%20C%2017.7%2C8.8%2017.4%2C9%2017%2C9%20H%2016%20C%2015.6%2C9%2015.3%2C8.8%2015.2%2C8.5%2015.1%2C8.6%2015%2C8.8%2015%2C9%20c%200%2C0.6%200.4%2C1%201%2C1%20h%201%20c%200.6%2C0%201%2C-0.4%201%2C-1%200%2C-0.2%20-0.1%2C-0.4%20-0.2%2C-0.5%20z%22%2F%3E%0A%20%20%20%20%3C%2Fg%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_traffic:hover:after{background-image:none}a.dg-traffic-control{z-index:0;color:#f2f2f2;text-decoration:none;text-shadow:0 1px 2px rgba(0,0,0,.3);font:400 15px/32px 'Arial narrow',Arial,sans-serif}a.dg-traffic-control_color_green:after,a.dg-traffic-control_color_red:after,a.dg-traffic-control_color_yellow:after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:auto;width:22px;height:22px;border-radius:50%;-webkit-box-shadow:inset 0 1px 0 0 rgba(0,0,0,.2),0 1px 0 0 #fff;box-shadow:inset 0 1px 0 0 rgba(0,0,0,.2),0 1px 0 0 #fff}.no-touch a.dg-traffic-control:hover{color:#f2f2f2}.no-touch a.dg-traffic-control_color_green:hover:after,.no-touch a.dg-traffic-control_color_red:hover:after,.no-touch a.dg-traffic-control_color_yellow:hover:after{width:22px;height:22px}a.dg-traffic-control_color_green:after{background:#3fc03b}.no-touch a.dg-traffic-control_color_green:hover:after,a.dg-traffic-control_color_green:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#2aa731),to(#53e13a)) #3ec435;background:-webkit-linear-gradient(bottom,#2aa731,#53e13a) #3ec435;background:linear-gradient(to top,#2aa731,#53e13a) #3ec435}a.dg-traffic-control_color_yellow:after{background:#f3b223}.no-touch a.dg-traffic-control_color_yellow:hover:after,a.dg-traffic-control_color_yellow:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#ef931b),to(#f7be26)) #f4a820;background:-webkit-linear-gradient(bottom,#ef931b,#f7be26) #f4a820;background:linear-gradient(to top,#ef931b,#f7be26) #f4a820}a.dg-traffic-control_color_red:after{background:#eb240c}.no-touch a.dg-traffic-control_color_red:hover:after,a.dg-traffic-control_color_red:active:after{background:-webkit-gradient(linear,left bottom,left top,from(#c01c0a),to(#f73416)) #db2811;background:-webkit-linear-gradient(bottom,#c01c0a,#f73416) #db2811;background:linear-gradient(to top,#c01c0a,#f73416) #db2811}.leaflet-rulerMarker-pane{z-index:600}.dg-ruler__label{position:absolute;top:0;left:0;z-index:200;-webkit-tap-highlight-color:transparent}.dg-ruler__label-spacer{display:block}.dg-ruler__label-container{display:none;padding:2px 4px;border:4px solid #fff;border-radius:13px;background:#0da5d5;background-clip:padding-box;color:#fff;white-space:nowrap;font-size:12px}.dg-ruler__point{display:inline-block;margin:2px 4px 0 0;width:10px;height:10px;border-radius:5px;background:#fff}.dg-ruler__label-remove-link{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2212%22%20height%3D%2212%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%206%2C0%20C%202.687%2C0%200%2C2.687%200%2C6%200%2C9.313%202.687%2C12%206%2C12%209.313%2C12%2012%2C9.313%2012%2C6%2012%2C2.687%209.313%2C0%206%2C0%20z%20M%209.401%2C9.398%208.8%2C9.6%206%2C6.8%203.199%2C9.6%202.59%2C9.415%202.375%2C8.774%205.199%2C6%202.399%2C3.175%202.62%2C2.591%203.175%2C2.375%205.949%2C5.225%208.774%2C2.375%209.415%2C2.605%209.566%2C3.196%206.824%2C6%209.6%2C8.8%209.401%2C9.398%20z%22%20fill%3D%22%23fff%22%20fill-rule%3D%22evenodd%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:12px;height:12px;background-size:12px 12px;display:none;margin:1px 0 0 4px;vertical-align:top;-webkit-transition:all .2s ease;transition:all .2s ease}.no-touch .dg-ruler__label-remove-link:hover{-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.dg-ruler__remove-link-overlay{position:absolute;top:-7px;right:-7px;bottom:-7px;width:40px}.no-touch .dg-ruler__remove-link-overlay{display:none}.dg-control-round__icon_name_ruler:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.998%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%23616161%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%23444%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%23444%22%2F%3E%0A%3C%2Fsvg%3E%0A\");width:16px;height:9px;background-size:16px 9px;position:absolute;top:0;right:0;bottom:0;left:0;margin:auto;content:''}.dg-control-round__icon_name_ruler:active:after,.no-touch .dg-control-round__icon_name_ruler:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.998%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%23424242%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%232e2e2e%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}.dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:active:after,.dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:after,.no-touch .dg-control-round__icon_state_active.dg-control-round__icon_name_ruler:hover:after{background-repeat:no-repeat;background-image:url(\"data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2216%22%20height%3D%229%22%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%2012.999%2C0%20v%204.001%20h%20-1%20V%200%20h%20-2%20v%202%20h%20-1%20V%200%20h%20-2%20V%202%20H%206%20V%200%20H%203.999%20v%204.001%20h%20-1%20V%200%20h%20-3%20V%208%20H%2016%20V%200%20z%22%20fill%3D%22%2321a7d6%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22m%202.999%2C4%20h%201%20v%201%20h%20-1%20z%20m%203%2C-2%20h%201%20v%201%20h%20-1%20z%20m%203%2C0%20h%201%20v%201%20h%20-1%20z%20m%203%2C2%20h%201%20v%201%20h%20-1%20z%22%20fill%3D%22%23147596%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C8%20H%2016%20V%209%20H%200%20z%22%20fill%3D%22%23fff%22%2F%3E%0A%20%20%20%20%3Cpath%20d%3D%22M%200%2C0%20H%203%20V%201%20H%200%20z%20m%2013%2C0%20h%203%20v%201%20h%20-3%20z%20m%20-3%2C0%20h%202%20V%201%20H%2010%20z%20M%207%2C0%20H%209%20V%201%20H%207%20z%20M%204%2C0%20H%206%20V%201%20H%204%20z%22%20fill%3D%22%23147596%22%2F%3E%0A%3C%2Fsvg%3E%0A\")}"; (_dereq_("browserify-css").createStyle(css, { "href": "dist/css/styles.full.dark.css" }, { "insertAt": "bottom" })); module.exports = css;
},{"browserify-css":3}],2:[function(_dereq_,module,exports){
(function (process){
if (!Array.prototype.map)
{
  Array.prototype.map = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function")
      throw new TypeError();

    var res = new Array(len);
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      // NOTE: Absolute correctness would demand Object.defineProperty
      //       be used.  But this method is fairly new, and failure is
      //       possible only if Object.prototype or Array.prototype
      //       has a property |i| (very unlikely), so use a less-correct
      //       but more portable alternative.
      if (i in t)
        res[i] = fun.call(thisArg, t[i], i, t);
    }

    return res;
  };
}

/* reduce implemintation by Mozila https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FReduce*/
if ('function' !== typeof Array.prototype.reduce) {
  Array.prototype.reduce = function(callback, opt_initialValue){
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      // At the moment all modern browsers, that support strict mode, have
      // native implementation of Array.prototype.reduce. For instance, IE8
      // does not support strict mode, so this check is actually useless.
      throw new TypeError(
          'Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var index, value,
        length = this.length >>> 0,
        isValueSet = false;
    if (1 < arguments.length) {
      value = opt_initialValue;
      isValueSet = true;
    }
    for (index = 0; length > index; ++index) {
      if (this.hasOwnProperty(index)) {
        if (isValueSet) {
          value = callback(value, this[index], index, this);
        }
        else {
          value = this[index];
          isValueSet = true;
        }
      }
    }
    if (!isValueSet) {
      throw new TypeError('Reduce of empty array with no initial value');
    }
    return value;
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.com/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function forEach(callback, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError("this is null or not defined");
    }

    var kValue,
        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        O = Object(this),

        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        len = O.length >>> 0; // Hack to convert O.length to a UInt32

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if ({}.toString.call(callback) !== "[object Function]") {
      throw new TypeError(callback + " is not a function");
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length >= 2) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as the this value and
        // argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = (function () {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
      }

      var result = [], prop, i;

      for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          result.push(prop);
        }
      }

      if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
          if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
          }
        }
      }
      return result;
    };
  }());
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
if (!Array.prototype.some)
{
  Array.prototype.some = function(fun /*, thisArg */)
  {
    'use strict';

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function')
      throw new TypeError();

    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t && fun.call(thisArg, t[i], i, t))
        return true;
    }

    return false;
  };
}

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
if (!Array.prototype.map)
{
  Array.prototype.map = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function")
      throw new TypeError();

    var res = new Array(len);
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      // NOTE: Absolute correctness would demand Object.defineProperty
      //       be used.  But this method is fairly new, and failure is
      //       possible only if Object.prototype or Array.prototype
      //       has a property |i| (very unlikely), so use a less-correct
      //       but more portable alternative.
      if (i in t)
        res[i] = fun.call(thisArg, t[i], i, t);
    }

    return res;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
if (!Array.prototype.filter)
{
  Array.prototype.filter = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun != "function")
      throw new TypeError();

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++)
    {
      if (i in t)
      {
        var val = t[i];

        // NOTE: Technically this should Object.defineProperty at
        //       the next index, as push can be affected by
        //       properties on Object.prototype and Array.prototype.
        //       But that method's new, and collisions should be
        //       rare, so use the more-compatible alternative.
        if (fun.call(thisArg, val, i, t))
          res.push(val);
      }
    }

    return res;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function () {},
        fBound = function () {
          return fToBind.apply(this instanceof fNOP && oThis
                                 ? this
                                 : oThis,
                               aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}

//From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (searchElement, fromIndex) {
    if ( this === undefined || this === null ) {
      throw new TypeError( '"this" is null or not defined' );
    }

    var length = this.length >>> 0; // Hack to convert object.length to a UInt32

    fromIndex = +fromIndex || 0;

    if (Math.abs(fromIndex) === Infinity) {
      fromIndex = 0;
    }

    if (fromIndex < 0) {
      fromIndex += length;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
    }

    for (;fromIndex < length; fromIndex++) {
      if (this[fromIndex] === searchElement) {
        return fromIndex;
      }
    }

    return -1;
  };
}

if (typeof Promise !== 'function') {
  (function() {
  var define, requireModule, _dereq_, requirejs;

  (function() {
    var registry = {}, seen = {};

    define = function(name, deps, callback) {
      registry[name] = { deps: deps, callback: callback };
    };

    requirejs = _dereq_ = requireModule = function(name) {
    requirejs._eak_seen = registry;

      if (seen[name]) { return seen[name]; }
      seen[name] = {};

      if (!registry[name]) {
        throw new Error("Could not find module " + name);
      }

      var mod = registry[name],
          deps = mod.deps,
          callback = mod.callback,
          reified = [],
          exports;

      for (var i=0, l=deps.length; i<l; i++) {
        if (deps[i] === 'exports') {
          reified.push(exports = {});
        } else {
          reified.push(requireModule(resolve(deps[i])));
        }
      }

      var value = callback.apply(this, reified);
      return seen[name] = exports || value;

      function resolve(child) {
        if (child.charAt(0) !== '.') { return child; }
        var parts = child.split("/");
        var parentBase = name.split("/").slice(0, -1);

        for (var i=0, l=parts.length; i<l; i++) {
          var part = parts[i];

          if (part === '..') { parentBase.pop(); }
          else if (part === '.') { continue; }
          else { parentBase.push(part); }
        }

        return parentBase.join("/");
      }
    };
  })();

  define("promise/all",
    ["./utils","exports"],
    function(__dependency1__, __exports__) {
      "use strict";
      /* global toString */

      var isArray = __dependency1__.isArray;
      var isFunction = __dependency1__.isFunction;

      /**
        Returns a promise that is fulfilled when all the given promises have been
        fulfilled, or rejected if any of them become rejected. The return promise
        is fulfilled with an array that gives all the values in the order they were
        passed in the `promises` array argument.

        Example:

        ```javascript
        var promise1 = RSVP.resolve(1);
        var promise2 = RSVP.resolve(2);
        var promise3 = RSVP.resolve(3);
        var promises = [ promise1, promise2, promise3 ];

        RSVP.all(promises).then(function(array){
          // The array here would be [ 1, 2, 3 ];
        });
        ```

        If any of the `promises` given to `RSVP.all` are rejected, the first promise
        that is rejected will be given as an argument to the returned promises's
        rejection handler. For example:

        Example:

        ```javascript
        var promise1 = RSVP.resolve(1);
        var promise2 = RSVP.reject(new Error("2"));
        var promise3 = RSVP.reject(new Error("3"));
        var promises = [ promise1, promise2, promise3 ];

        RSVP.all(promises).then(function(array){
          // Code here never runs because there are rejected promises!
        }, function(error) {
          // error.message === "2"
        });
        ```

        @method all
        @for RSVP
        @param {Array} promises
        @param {String} label
        @return {Promise} promise that is fulfilled when all `promises` have been
        fulfilled, or rejected if any of them become rejected.
      */
      function all(promises) {
        /*jshint validthis:true */
        var Promise = this;

        if (!isArray(promises)) {
          throw new TypeError('You must pass an array to all.');
        }

        return new Promise(function(resolve, reject) {
          var results = [], remaining = promises.length,
          promise;

          if (remaining === 0) {
            resolve([]);
          }

          function resolver(index) {
            return function(value) {
              resolveAll(index, value);
            };
          }

          function resolveAll(index, value) {
            results[index] = value;
            if (--remaining === 0) {
              resolve(results);
            }
          }

          for (var i = 0; i < promises.length; i++) {
            promise = promises[i];

            if (promise && isFunction(promise.then)) {
              promise.then(resolver(i), reject);
            } else {
              resolveAll(i, promise);
            }
          }
        });
      }

      __exports__.all = all;
    });
  define("promise/asap",
    ["exports"],
    function(__exports__) {
      "use strict";
      var browserGlobal = (typeof window !== 'undefined') ? window : {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var local = window;

      // node
      function useNextTick() {
        return function() {
          process.nextTick(flush);
        };
      }

      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node = document.createTextNode('');
        observer.observe(node, { characterData: true });

        return function() {
          node.data = (iterations = ++iterations % 2);
        };
      }

      function useSetTimeout() {
        return function() {
          local.setTimeout(flush, 1);
        };
      }

      var queue = [];
      function flush() {
        for (var i = 0; i < queue.length; i++) {
          var tuple = queue[i];
          var callback = tuple[0], arg = tuple[1];
          callback(arg);
        }
        queue = [];
      }

      var scheduleFlush;

      // Decide what async method to use to triggering processing of queued callbacks:
      if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else {
        scheduleFlush = useSetTimeout();
      }

      function asap(callback, arg) {
        var length = queue.push([callback, arg]);
        if (length === 1) {
          // If length is 1, that means that we need to schedule an async flush.
          // If additional callbacks are queued before the queue is flushed, they
          // will be processed by this flush that we are scheduling.
          scheduleFlush();
        }
      }

      __exports__.asap = asap;
    });
  define("promise/config",
    ["exports"],
    function(__exports__) {
      "use strict";
      var config = {
        instrument: false
      };

      function configure(name, value) {
        if (arguments.length === 2) {
          config[name] = value;
        } else {
          return config[name];
        }
      }

      __exports__.config = config;
      __exports__.configure = configure;
    });
  define("promise/polyfill",
    ["./promise","./utils","exports"],
    function(__dependency1__, __dependency2__, __exports__) {
      "use strict";
      /*global self*/
      var RSVPPromise = __dependency1__.Promise;
      var isFunction = __dependency2__.isFunction;

      function polyfill() {
        var local;

        if (typeof window !== 'undefined' && window.document) {
          local = window;
        } else {
          local = self;
        }

        var es6PromiseSupport =
          "Promise" in local &&
          // Some of these methods are missing from
          // Firefox/Chrome experimental implementations
          "resolve" in local.Promise &&
          "reject" in local.Promise &&
          "all" in local.Promise &&
          "race" in local.Promise &&
          // Older version of the spec had a resolver object
          // as the arg rather than a function
          (function() {
            var resolve;
            new local.Promise(function(r) { resolve = r; });
            return isFunction(resolve);
          }());

        if (!es6PromiseSupport) {
          local.Promise = RSVPPromise;
        }
      }

      __exports__.polyfill = polyfill;
    });
  define("promise/promise",
    ["./config","./utils","./all","./race","./resolve","./reject","./asap","exports"],
    function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
      "use strict";
      var config = __dependency1__.config;
      var configure = __dependency1__.configure;
      var objectOrFunction = __dependency2__.objectOrFunction;
      var isFunction = __dependency2__.isFunction;
      var now = __dependency2__.now;
      var all = __dependency3__.all;
      var race = __dependency4__.race;
      var staticResolve = __dependency5__.resolve;
      var staticReject = __dependency6__.reject;
      var asap = __dependency7__.asap;

      var counter = 0;

      config.async = asap; // default async is asap;

      function Promise(resolver) {
        if (!isFunction(resolver)) {
          throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
        }

        if (!(this instanceof Promise)) {
          throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
        }

        this._subscribers = [];

        invokeResolver(resolver, this);
      }

      function invokeResolver(resolver, promise) {
        function resolvePromise(value) {
          resolve(promise, value);
        }

        function rejectPromise(reason) {
          reject(promise, reason);
        }

        try {
          resolver(resolvePromise, rejectPromise);
        } catch(e) {
          rejectPromise(e);
        }
      }

      function invokeCallback(settled, promise, callback, detail) {
        var hasCallback = isFunction(callback),
            value, error, succeeded, failed;

        if (hasCallback) {
          try {
            value = callback(detail);
            succeeded = true;
          } catch(e) {
            failed = true;
            error = e;
          }
        } else {
          value = detail;
          succeeded = true;
        }

        if (handleThenable(promise, value)) {
          return;
        } else if (hasCallback && succeeded) {
          resolve(promise, value);
        } else if (failed) {
          reject(promise, error);
        } else if (settled === FULFILLED) {
          resolve(promise, value);
        } else if (settled === REJECTED) {
          reject(promise, value);
        }
      }

      var PENDING   = void 0;
      var SEALED    = 0;
      var FULFILLED = 1;
      var REJECTED  = 2;

      function subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;

        subscribers[length] = child;
        subscribers[length + FULFILLED] = onFulfillment;
        subscribers[length + REJECTED]  = onRejection;
      }

      function publish(promise, settled) {
        var child, callback, subscribers = promise._subscribers, detail = promise._detail;

        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];

          invokeCallback(settled, child, callback, detail);
        }

        promise._subscribers = null;
      }

      Promise.prototype = {
        constructor: Promise,

        _state: undefined,
        _detail: undefined,
        _subscribers: undefined,

        then: function(onFulfillment, onRejection) {
          var promise = this;

          var thenPromise = new this.constructor(function() {});

          if (this._state) {
            var callbacks = arguments;
            config.async(function invokePromiseCallback() {
              invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
            });
          } else {
            subscribe(this, thenPromise, onFulfillment, onRejection);
          }

          return thenPromise;
        },

        'catch': function(onRejection) {
          return this.then(null, onRejection);
        }
      };

      Promise.all = all;
      Promise.race = race;
      Promise.resolve = staticResolve;
      Promise.reject = staticReject;

      function handleThenable(promise, value) {
        var then = null,
        resolved;

        try {
          if (promise === value) {
            throw new TypeError("A promises callback cannot return that same promise.");
          }

          if (objectOrFunction(value)) {
            then = value.then;

            if (isFunction(then)) {
              then.call(value, function(val) {
                if (resolved) { return true; }
                resolved = true;

                if (value !== val) {
                  resolve(promise, val);
                } else {
                  fulfill(promise, val);
                }
              }, function(val) {
                if (resolved) { return true; }
                resolved = true;

                reject(promise, val);
              });

              return true;
            }
          }
        } catch (error) {
          if (resolved) { return true; }
          reject(promise, error);
          return true;
        }

        return false;
      }

      function resolve(promise, value) {
        if (promise === value) {
          fulfill(promise, value);
        } else if (!handleThenable(promise, value)) {
          fulfill(promise, value);
        }
      }

      function fulfill(promise, value) {
        if (promise._state !== PENDING) { return; }
        promise._state = SEALED;
        promise._detail = value;

        config.async(publishFulfillment, promise);
      }

      function reject(promise, reason) {
        if (promise._state !== PENDING) { return; }
        promise._state = SEALED;
        promise._detail = reason;

        config.async(publishRejection, promise);
      }

      function publishFulfillment(promise) {
        publish(promise, promise._state = FULFILLED);
      }

      function publishRejection(promise) {
        publish(promise, promise._state = REJECTED);
      }

      __exports__.Promise = Promise;
    });
  define("promise/race",
    ["./utils","exports"],
    function(__dependency1__, __exports__) {
      "use strict";
      /* global toString */
      var isArray = __dependency1__.isArray;

      /**
        `RSVP.race` allows you to watch a series of promises and act as soon as the
        first promise given to the `promises` argument fulfills or rejects.

        Example:

        ```javascript
        var promise1 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 1");
          }, 200);
        });

        var promise2 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 2");
          }, 100);
        });

        RSVP.race([promise1, promise2]).then(function(result){
          // result === "promise 2" because it was resolved before promise1
          // was resolved.
        });
        ```

        `RSVP.race` is deterministic in that only the state of the first completed
        promise matters. For example, even if other promises given to the `promises`
        array argument are resolved, but the first completed promise has become
        rejected before the other promises became fulfilled, the returned promise
        will become rejected:

        ```javascript
        var promise1 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            resolve("promise 1");
          }, 200);
        });

        var promise2 = new RSVP.Promise(function(resolve, reject){
          setTimeout(function(){
            reject(new Error("promise 2"));
          }, 100);
        });

        RSVP.race([promise1, promise2]).then(function(result){
          // Code here never runs because there are rejected promises!
        }, function(reason){
          // reason.message === "promise2" because promise 2 became rejected before
          // promise 1 became fulfilled
        });
        ```

        @method race
        @for RSVP
        @param {Array} promises array of promises to observe
        @param {String} label optional string for describing the promise returned.
        Useful for tooling.
        @return {Promise} a promise that becomes fulfilled with the value the first
        completed promises is resolved with if the first completed promise was
        fulfilled, or rejected with the reason that the first completed promise
        was rejected with.
      */
      function race(promises) {
        /*jshint validthis:true */
        var Promise = this;

        if (!isArray(promises)) {
          throw new TypeError('You must pass an array to race.');
        }
        return new Promise(function(resolve, reject) {
          var results = [], promise;

          for (var i = 0; i < promises.length; i++) {
            promise = promises[i];

            if (promise && typeof promise.then === 'function') {
              promise.then(resolve, reject);
            } else {
              resolve(promise);
            }
          }
        });
      }

      __exports__.race = race;
    });
  define("promise/reject",
    ["exports"],
    function(__exports__) {
      "use strict";
      /**
        `RSVP.reject` returns a promise that will become rejected with the passed
        `reason`. `RSVP.reject` is essentially shorthand for the following:

        ```javascript
        var promise = new RSVP.Promise(function(resolve, reject){
          reject(new Error('WHOOPS'));
        });

        promise.then(function(value){
          // Code here doesn't run because the promise is rejected!
        }, function(reason){
          // reason.message === 'WHOOPS'
        });
        ```

        Instead of writing the above, your code now simply becomes the following:

        ```javascript
        var promise = RSVP.reject(new Error('WHOOPS'));

        promise.then(function(value){
          // Code here doesn't run because the promise is rejected!
        }, function(reason){
          // reason.message === 'WHOOPS'
        });
        ```

        @method reject
        @for RSVP
        @param {Any} reason value that the returned promise will be rejected with.
        @param {String} label optional string for identifying the returned promise.
        Useful for tooling.
        @return {Promise} a promise that will become rejected with the given
        `reason`.
      */
      function reject(reason) {
        /*jshint validthis:true */
        var Promise = this;

        return new Promise(function (resolve, reject) {
          reject(reason);
        });
      }

      __exports__.reject = reject;
    });
  define("promise/resolve",
    ["exports"],
    function(__exports__) {
      "use strict";
      function resolve(value) {
        /*jshint validthis:true */
        if (value && typeof value === 'object' && value.constructor === this) {
          return value;
        }

        var Promise = this;

        return new Promise(function(resolve) {
          resolve(value);
        });
      }

      __exports__.resolve = resolve;
    });
  define("promise/utils",
    ["exports"],
    function(__exports__) {
      "use strict";
      function objectOrFunction(x) {
        return isFunction(x) || (typeof x === "object" && x !== null);
      }

      function isFunction(x) {
        return typeof x === "function";
      }

      function isArray(x) {
        return Object.prototype.toString.call(x) === "[object Array]";
      }

      // Date.now is not available in browsers < IE9
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
      var now = Date.now || function() { return new Date().getTime(); };


      __exports__.objectOrFunction = objectOrFunction;
      __exports__.isFunction = isFunction;
      __exports__.isArray = isArray;
      __exports__.now = now;
    });
  requireModule('promise/polyfill').polyfill();
  }());
}

_dereq_('leaflet');
_dereq_('html5shiv');

// DG inheritance
var oldDG = window.DG;
DG = new (
    (function () {
        var DgApi = function () {},
            DgApiCore = function () {};

        DgApiCore.prototype = L;
        DgApi.prototype = new DgApiCore();

        return DgApi;
    })()
)();

for (var prop in oldDG) {
    if (oldDG.hasOwnProperty(prop) && typeof DG[prop] === 'undefined') {
        DG[prop] = oldDG[prop];
    }
}

window.__dgApi__ = window.__dgApi__ || {};
DG.version = window.__dgApi__.version;
DG.Icon.Default.imagePath  = '../img/vendors/leaflet';

DG.Map.addInitHook((function () {
    var inited = false;

    // Analytics inited once
    return function () {
        if (!inited) {
            /*eslint-disable */
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script',DG.config.protocol+DG.config.googleAnalytics,'ga');
            /*eslint-enable */

            inited = true;
        }

        /*eslint-disable */
        ga('create', DG.config.gaCode, 'none', {name: 'mapsapi2gis'});
        ga('mapsapi2gis.send', 'pageview');
        /*eslint-enable */

        var newImg = new Image();
        newImg.src = DG.config.protocol + DG.config.analytics + '?' +
            'sr=' + window.screen.width + 'x' + window.screen.height + '&' +
            'v=' + DG.version;
    };
})());

// Improve IHandler
DG.Map.include({
    addHandler: function (name, HandlerClass) {
        if (!HandlerClass) { return this; }

        var options = this.options[name],
            param = (options === Object(options)) ? options : null,
            handler = this[name] = new HandlerClass(this, param);

        this._handlers.push(handler);

        if (options) {
            handler.enable();
        }

        return this;
    }
});

// Apply class to map container for detect when we dont need hover effects
DG.Map.addInitHook(function () {
    if (!DG.Browser.touch) {
        DG.DomUtil.addClass(this._container, 'no-touch');
    }
});

module.exports = DG;

var handlers = window.__dgApi__.callbacks || [],
    chain = Promise.resolve();

handlers.forEach(function (handlers) {
    chain = chain.then(handlers[0], handlers[1]);
});

DG.then = function (resolve, reject) {
    return chain.then(resolve, reject);
};

// IE8 throw error if `chain.catch`
/* eslint-disable dot-notation, no-console */
chain['catch'](function (err) {
    console.error(err);
});
/* eslint-enable dot-notation, no-console */

DG.plugin = function (plugins) {
    var count,
        jsReg = new RegExp(/.js$/i),
        cssReg = new RegExp(/.css$/i);

    return new Promise(function (resolve) {
        function checkLoading () {
            count--;

            if (count === 0) {
                resolve();
            }
        }

        function appendJS (link) {
            var js = document.createElement('script');
            js.setAttribute('type', 'text/javascript');
            js.setAttribute('src', link);
            js.onload = function () {
                checkLoading();
            };
            js.onerror = function () {
                checkLoading();
            };
            // load/error for IE
            js.onreadystatechange = function () {
                if (js.readyState === 'complete' || js.readyState === 'loaded') {
                    checkLoading();
                }
            };

            document.getElementsByTagName('head')[0].appendChild(js);
        }

        function appendCSS (link) {
            var css = document.createElement('link');
            css.setAttribute('rel', 'stylesheet');
            css.setAttribute('type', 'text/css');
            css.setAttribute('href', link);
            document.getElementsByTagName('head')[0].appendChild(css);

            checkLoading();
        }

        function isJs (url) {
            return jsReg.test(url);
        }

        function isCss (url) {
            return cssReg.test(url);
        }

        function appendAsset (asset) {
            if (isJs(asset)) {
                appendJS(asset);
            } else if (isCss(asset)) {
                appendCSS(asset);
            } else {
                count--;
            }
        }

        if (DG.Util.isArray(plugins)) {
            count = plugins.length;
            plugins.forEach(function (plugin) {
                appendAsset(plugin);
            });
        }

        if (typeof plugins === 'string') {
            count = 1;
            appendAsset(plugins);
        }
    });
};

DG.ajax = (function () {

    var win = window,
        doc = document,

        rurl = /^([\w.+-]+:)?(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
        twoHundo = /^20\d$/,

        // Document location
        ajaxLocParts,
        ajaxLocation,

        byTag = 'getElementsByTagName',
        readyState = 'readyState',
        contentType = 'Content-Type',
        requestedWith = 'X-Requested-With',
        head = doc[byTag]('head')[0],
        uniqid = 0,
        callbackPrefix = 'l_dg_ajax_callback_' + (+new Date()),
        lastValue, // data stored by the most recent JSONP callback
        xmlHttpRequest = 'XMLHttpRequest',
        xDomainRequest = 'XDomainRequest',
        noop = function () {},
        defaultHeaders = {
            contentType: 'application/x-www-form-urlencoded',
            requestedWith: xmlHttpRequest,
            accept: {
                '*':  'text/javascript, text/html, application/xml, text/xml, */*',
                xml:  'application/xml, text/xml',
                html: 'text/html',
                text: 'text/plain',
                json: 'application/json, text/javascript',
                js:   'application/javascript, text/javascript'
            }
        },
        /*global XDomainRequest:false, ActiveXObject:false */
        xhr = function (o) {
            // is it x-domain
            if (o.crossDomain === true) {
                var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;
                if (xhr && 'withCredentials' in xhr) {
                    return xhr;
                } else if (win[xDomainRequest]) {
                    return new XDomainRequest();
                } else {
                    throw new Error('Browser does not support cross-origin requests');
                }
            } else if (win[xmlHttpRequest]) {
                return new XMLHttpRequest();
            } else {
                return new ActiveXObject('Microsoft.XMLHTTP');
            }
        },

        globalSetupOptions = {
            dataFilter: function (data) {
                return data;
            }
        };

    // IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement('a');
        ajaxLocation.href = '';
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    function handleReadyState (r, success, error) {
        return function () {
            // use _aborted to mitigate against IE err c00c023f
            // (can't read props on aborted request objects)
            if (r._aborted) {
                return error(r.request);
            }
            if (r.request && r.request[readyState] === 4) {
                r.request.onreadystatechange = noop;
                if (twoHundo.test(r.request.status)) {
                    success(r.request);
                } else {
                    error(r.request);
                }
            }
        };
    }

    function setHeaders (http, o) {
        var headers = o.headers || {},
            h;

        headers.Accept = headers.Accept || defaultHeaders.accept[o.dataType] || defaultHeaders.accept['*'];

        // breaks cross-origin requests with legacy browsers
        if (!o.crossDomain && !headers[requestedWith]) {
            headers[requestedWith] = defaultHeaders.requestedWith;
        }
        if (!headers[contentType]) {
            headers[contentType] = o.contentType || defaultHeaders.contentType;
        }
        for (h in headers) {
            if (headers.hasOwnProperty(h) && 'setRequestHeader' in http) {
                http.setRequestHeader(h, headers[h]);
            }
        }
    }

    function setCredentials (http, o) {
        if (typeof o.withCredentials !== 'undefined' && typeof http.withCredentials !== 'undefined') {
            http.withCredentials = !!o.withCredentials;
        }
    }

    function generalCallback (data) {
        lastValue = data;
    }

    function urlappend (url, s) {
        return url + (/\?/.test(url) ? '&' : '?') + s;
    }

    function handleJsonp (o, fn, err, url) {
        var reqId = uniqid++,
            cbkey = o.jsonpCallback || 'callback', // the 'callback' key
            cbval = o.jsonpCallbackName || callbackPrefix,
            cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)'),
            match = url.match(cbreg),
            script = doc.createElement('script'),
            loaded = 0,
            isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1;

        if (match) {
            if (match[3] === '?') {
                url = url.replace(cbreg, '$1=' + cbval); // wildcard callback func name
            } else {
                cbval = match[3]; // provided callback func name
            }
        } else {
            url = urlappend(url, cbkey + '=' + cbval); // no callback details, add 'em
        }

        win[cbval] = generalCallback;

        script.type = 'text/javascript';
        script.src = url;
        script.async = true;
        if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
            // need this for IE due to out-of-order onreadystatechange(), binding script
            // execution to an event listener gives us control over when the script
            // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
            //
            // if this hack is used in IE10 jsonp callback are never called
            script.event = 'onclick';
            script.htmlFor = script.id = '_request_' + reqId;
        }

        script.onerror = function () {
            script.onerror = script.onload = script.onreadystatechange = null;
            err({}, 'Request unknown error', {});
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
        };
        script.onload = script.onreadystatechange = function () {
            if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
                return false;
            }
            script.onerror = script.onload = script.onreadystatechange = null;
            if (script.onclick) {
                script.onclick();
            }
            // Call the user callback with the last value stored and clean up values and scripts.
            fn(lastValue);
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
        };

        // Add the script to the DOM head
        head.appendChild(script);

        // Enable JSONP timeout
        return {
            abort: function () {
                script.onerror = script.onload = script.onreadystatechange = null;
                err({}, 'Request is aborted: timeout', {});
                lastValue = undefined;
                head.removeChild(script);
                loaded = 1;
            }
        };
    }

    function getRequest (fn, err) {
        var o = this.options,
            method = (o.type || 'GET').toUpperCase(),
            url = typeof o === 'string' ? o : o.url,
            // convert non-string objects to query-string form unless o.processData is false
            data = (o.processData !== false && o.data && typeof o.data !== 'string') ? Ajax.toQueryString(o.data) : (o.data || null),
            http,
            sendWait = false;

        // if we're working on a GET request and we have data then we should append
        // query string to end of URL and not post data
        if ((o.type === 'jsonp' || method === 'GET') && data) {
            url = urlappend(url, data);
            data = null;
        }

        if (o.type === 'jsonp') {
            return handleJsonp(o, fn, err, url);
        }

        http = xhr(o);
        http.open(method, url, o.async === false ? false : true);

        setHeaders(http, o);
        setCredentials(http, o);

        if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
            http.onload = fn;
            http.onprogress = function () {};
            http.ontimeout = function () {};
            http.onerror = err;
            sendWait = true;
        } else {
            http.onreadystatechange = handleReadyState(this, fn, err);
        }
        if (sendWait) {
            setTimeout(function () {
                http.send(data);
            }, 200);
        } else {
            http.send(data);
        }
        return http;
    }

    function buildParams (prefix, obj, traditional, add) {
        var name, i, v,
            rbracket = /\[\]$/;

        if (DG.Util.isArray(obj)) {
        // Serialize array item.
            for (i = 0; obj && i < obj.length; i++) {
                v = obj[i];
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            }
        } else if (obj && obj.toString() === '[object Object]') {
            // Serialize object item.
            for (name in obj) {
                if (obj.hasOwnProperty(name)) {
                    buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
                }
            }
        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    function setType (url) {
        var m = url.match(/\.(json|jsonp|html|xml)(\?|$)/);
        return m ? m[1] : 'js';
    }

    function isCrossDomain (url) {
        var parts = rurl.exec(url.toLowerCase());
        return !!(parts &&
                (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
                    (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !==
                        (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443')))
            );
    }

    function doRequest (o) {

        if (!('crossDomain' in o)) {
            o.crossDomain = isCrossDomain(o.url);
        }

        var self = {};
        self.promise = new Promise(function (resolve, reject) {
            self.abort = function () {
                self._aborted = true;
                reject('aborted');
            };

            self.url = o.url;
            self.timeout = null;
            self.options = o;

            self._aborted = false;
            self._erred = false;
            self._responseArgs = {};

            var type = o.type === 'jsonp' ? o.type : (o.dataType || setType(self.url));

            if (o.timeout) {
                self.timeout = setTimeout(function () {
                    self.abort();
                }, o.timeout);
            }

            function complete (resp) {
                if (o.timeout) {
                    clearTimeout(self.timeout);
                }
                self.timeout = null;
                if (self._erred) {
                    reject(resp);
                } else {
                    resolve(resp);
                }
            }

            function success (resp) {
                resp = (type !== 'jsonp') ? self.request : resp;
                // use global data filter on response text
                var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type),
                    r = filteredResponse;

                try {
                    resp.responseText = r;
                } catch (e) {
                    // can't assign this in IE<=8, just ignore
                }
                /* eslint-disable no-eval */
                if (r) {
                    switch (type) {
                        case 'json':
                            try {
                                resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')');
                            } catch (err) {
                                return error(resp, 'Could not parse JSON in response', err);
                            }
                            break;
                        case 'js':
                            resp = eval('(' + r + ')');
                            break;
                        case 'html':
                            resp = r;
                            break;
                        case 'xml':
                            resp = resp.responseXML && resp.responseXML.parseError && resp.responseXML.parseError.errorCode && resp.responseXML.parseError.reason ? null : resp.responseXML;
                            break;
                    }
                }
                /* eslint-enable no-eval */
                self._responseArgs.resp = resp;
                complete(resp);
            }

            function error (resp, msg, t) {
                resp = self.request;
                self._responseArgs.resp = resp;
                self._responseArgs.msg = msg;
                self._responseArgs.t = t;
                self._erred = true;
                complete(resp);
            }

            self.request = getRequest.call(self, success, error);
        });

        return self;
    }

    function Ajax (url, options) {

        if (Object.prototype.toString.call(url) === '[object Object]') {
            options = url;
            url = undefined;
        }
        options = options || {};
        options.url = url || options.url;

        var requestPromise = doRequest(options),
            resultPromise = requestPromise.promise;

        if (options.success || options.error || options.complete) {
            resultPromise.then(options.success, options.error);
        }

        resultPromise.abort = requestPromise.abort;

        return resultPromise;
    }

    Ajax.setup = function (options) {
        options = options || {};
        for (var k in options) {
            if (options.hasOwnProperty(k)) {
                globalSetupOptions[k] = options[k];
            }
        }
    };

    Ajax.toQueryString = function (o, trad) {
        var prefix, i,
            traditional = trad || false,
            s = [],
            enc = encodeURIComponent,
            add = function (key, value) {
                // If value is a function, invoke it and return its value
                if (typeof value == 'function') {
                    value = value();
                } else {
                    value = value || '';
                }

                s[s.length] = enc(key) + '=' + enc(value);
            };

        // If an array was passed in, assume that it is an array of form elements.
        if (DG.Util.isArray(o)) {
            for (i = 0; o && i < o.length; i++) {
                add(o[i].name, o[i].value);
            }
        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in o) {
                if (o.hasOwnProperty(prefix)) {
                    buildParams(prefix, o[prefix], traditional, add);
                }
            }
        }

        // spaces should be + according to spec
        return s.join('&').replace(/%20/g, '+');
    };

    var testxhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;

    Ajax.corsSupport = !(!(testxhr && 'withCredentials' in testxhr) && !win[xDomainRequest]) &&
        // cors not available in IE and with cyrillic domain
        !(DG.Browser.ie && document.location.host.toLowerCase().search(/[а-я]/) != -1);

    return Ajax;
})();

DG.Wkt = {};

DG.Wkt.toGeoJSON = function (data) {
    if (DG.Util.isArray(data)) {
        data = data[0];
    }
    var parts = data.split(';');
    data = parts.pop();

    var i = 0,
        srid = (parts.shift() || '').split('=').pop();

    function $(re) {
        var match = data.substring(i).match(re);
        if (!match) {
            return null;
        }
        else {
            i += match[0].length;
            return match[0];
        }
    }

    function crs(obj) {
        if (obj && srid.match(/\d+/)) {
            obj.crs = {
                type: 'name',
                'properties': {
                    name: 'urn:ogc:def:crs:EPSG::' + srid
                }
            };
        }

        return obj;
    }

    function white() { $(/^\s*/); }

    function multicoords() {
        white();
        var depth = 0, rings = [], stack = [rings],
            pointer = rings, elem;
        while (elem =
            $(/^(\()/) ||
            $(/^(\))/) ||
            $(/^(\,)/) ||
            $(/^[-+]?([0-9]*\.[0-9]+|[0-9]+)/)) {
            if (elem === '(') {
                stack.push(pointer);
                pointer = [];
                stack[stack.length - 1].push(pointer);
                depth++;
            } else if (elem === ')') {
                pointer = stack.pop();
                depth--;
                if (depth === 0) {
                    break;
                }
            } else if (elem === ',') {
                pointer = [];
                stack[stack.length - 1].push(pointer);
            } else {
                pointer.push(parseFloat(elem));
            }
            white();
        }
        stack.length = 0;
        if (depth !== 0) {
            return null;
        }
        return rings;
    }

    function coords() {
        var list = [], item, pt;
        while (pt =
            $(/^[-+]?([0-9]*\.[0-9]+|[0-9]+)/) ||
            $(/^(\,)/)) {
            if (pt === ',') {
                list.push(item);
                item = [];
            } else {
                if (!item) {
                    item = [];
                }
                item.push(parseFloat(pt));
            }
            white();
        }
        if (item) {
            list.push(item);
        }
        return list.length ? list : null;
    }

    function point() {
        if (!$(/^(point)/i)) { return null; }
        white();
        if (!$(/^(\()/)) { return null; }
        var c = coords();
        white();
        if (!$(/^(\))/)) { return null; }
        return {
            type: 'Point',
            coordinates: c[0]
        };
    }

    function multipoint() {
        if (!$(/^(multipoint)/i)) { return null; }
        white();
        var c = multicoords();
        white();
        return {
            type: 'MultiPoint',
            coordinates: c
        };
    }

    function multilinestring() {
        if (!$(/^(multilinestring)/i)) { return null; }
        white();
        var c = multicoords();
        white();
        return {
            type: 'MultiLineString',
            coordinates: c
        };
    }

    function linestring() {
        if (!$(/^(linestring)/i)) { return null; }
        white();
        if (!$(/^(\()/)) { return null; }
        var c = coords();
        if (!$(/^(\))/)) { return null; }
        return {
            type: 'LineString',
            coordinates: c
        };
    }

    function polygon() {
        if (!$(/^(polygon)/i)) { return null; }
        white();
        return {
            type: 'Polygon',
            coordinates: multicoords()
        };
    }

    function multipolygon() {
        if (!$(/^(multipolygon)/i)) { return null; }
        white();
        return {
            type: 'MultiPolygon',
            coordinates: multicoords()
        };
    }

    function geometrycollection() {
        var geometries = [], geometry;

        if (!$(/^(geometrycollection)/i)) { return null; }
        white();

        if (!$(/^(\()/)) { return null; }
        while (geometry = root()) {
            geometries.push(geometry);
            white();
            $(/^(\,)/);
            white();
        }
        if (!$(/^(\))/)) { return null; }

        return {
            type: 'GeometryCollection',
            geometries: geometries
        };
    }

    function root() {
        return point() ||
            linestring() ||
            polygon() ||
            multipoint() ||
            multilinestring() ||
            multipolygon() ||
            geometrycollection();
    }

    return crs(root());
};

DG.Wkt.geoJsonLayer = function (data, opts) {
    return DG.geoJson(DG.Wkt.toGeoJSON(data), opts);
};

DG.Wkt._coordsToLatLngs = function (coords) {
    if (DG.Util.isArray(coords) && !DG.Util.isArray(coords[0])) {
        return [DG.GeoJSON.coordsToLatLng(coords)];
    }

    return coords.map(function (el) {
            return DG.Wkt._coordsToLatLngs(el);
        })
        .reduce(function (arr, coord) {
            return arr.concat(coord);
        });
};

DG.Wkt.toLatLngs = function (data) {
    if (!DG.Util.isArray(data)) {
        data = [data];
    }

    return data.map(function (el) {
        var coords = DG.Wkt.toGeoJSON(el).coordinates;

        return DG.Wkt._coordsToLatLngs(coords);
    }).reduce(function (arr, coord) {
        return arr.concat(coord);
    });
};

DG.Wkt.toPoints = function (data) {
    return DG.Wkt.toGeoJSON(data).coordinates;
};

DG.Wkt.pointsToLatLngOnMap = function (wkt, map) {
    return (function parsePoints(points) {
        return (Array.isArray(points) && Array.isArray(points[0])) ?
            points.map(parsePoints) :
            map.containerPointToLatLng(points);
    })(DG.Wkt.toPoints(wkt));
};

DG.ProjectDetector = DG.Handler.extend({
    initialize: function (map) { // (Object)
        this._map = map;
        this._osmViewport = false;
        this._project = undefined;
        this._loadProjectList();
    },

    addHooks: function () {
        this._map.on('move', this._projectWatch, this);
    },

    removeHooks: function () {
        this._map.off('move', this._projectWatch, this);
    },

    getProject: function () {
        if (!this._project) { return false; }

        return DG.Util.extend({}, this._project);
    },

    getProjectsList: function () {
        return this._projectList.slice(0);
    },

    isProjectHere: function (coords, project, checkMethod) {
        if (!coords) { return null; }

        if (!(coords instanceof DG.LatLng) && !(coords instanceof DG.LatLngBounds)) {
            coords = DG.latLng(coords);
        }

        coords = (coords instanceof DG.LatLngBounds) ?
            DG.latLngBounds(coords.getSouthWest().wrap(), coords.getNorthEast().wrap()) : coords.wrap();

        checkMethod = checkMethod || ((coords instanceof DG.LatLngBounds) ?  'intersects' : 'contains');

        var method = checkMethod == 'intersects' ? this._testProjectIntersects : this._testProjectContains;
        method = method.bind(this, coords);

        if (project) {
            return method(project);
        } else {
            return this._projectList.filter(method)[0];
        }
    },

    _projectWatch: function () {
        if (this._osmViewport === (this._project && this._centerInProject(this._project, 'contains'))) {
            this._osmViewport = !this._osmViewport;
            this._map.attributionControl._update(null, this._osmViewport);
        }

        if (this._project && this._zoomInProject(this._project) && this._centerInProject(this._project)) {
            return;
        }

        this._searchProject();

        if (this._project) {
            if (this._osmViewport === (this._project && this._centerInProject(this._project, 'contains'))) {
                this._osmViewport = !this._osmViewport;
            }
            this._map.attributionControl._update(null, this._osmViewport, this._project.country_code);
        }
    },

    _checkProjectData: function (project) {
        function check (value) {
            return value !== undefined && value !== null;
        }

        return project &&
                project.bounds &&
                check(project.code) &&
                check(project.domain) &&
                check(project.country_code) &&
                project.zoom_level &&
                    check(project.zoom_level.min) &&
                    check(project.zoom_level.max) &&
                project.time_zone &&
                    check(project.time_zone.offset);
    },

    _loadProjectList: function () {
        DG.fallbackProjectsList = DG.fallbackProjectsList || [];

        if (!DG.projectsList) {
            DG.projectsList = DG.fallbackProjectsList;
        }
        delete DG.fallbackProjectsList;

        this._projectList = DG.projectsList
            .filter(this._checkProjectData)
            .map(function (project) {
                var bound = DG.Wkt.toGeoJSON(project.bounds);
                var latLngBounds = DG.geoJSON(bound).getBounds();
                var defaultPos = project.default_pos ? DG.latLng(project.default_pos.lat, project.default_pos.lon) : null;


                /* eslint-disable camelcase */
                return {
                    id: project.id,
                    code: project.code,
                    minZoom: project.zoom_level.min,
                    maxZoom: project.zoom_level.max,
                    timeOffset: project.time_zone.offset,
                    bound: bound,
                    latLngBounds: latLngBounds,
                    traffic: !!project.flags.traffic,
                    transport: !!project.flags.public_transport,
                    roads: !!project.flags.road_network,
                    country_code: project.country_code,
                    domain: project.domain,
                    defaultPos: defaultPos
                };
                /* eslint-enable camelcase */
            });
    },

    _searchProject: function () {
        // Вначале отсеиваем регионы по зуму
        var filteredByZoom = this._projectList.filter(this._zoomInProject, this);

        // Находим проект в границы которого попадает центр карты
        var foundProjects = filteredByZoom.filter(this._centerInProject, this);

        // Если такой проект не найден, то ищем проекты баунд боксы которых пересекаются с экраном
        if (foundProjects.length === 0) {
            var mapBounds = this._map.getBounds();
            foundProjects = filteredByZoom.filter(DG.bind(this._testProjectIntersects, this, mapBounds));

            if (foundProjects.length > 1) {
                var mapCenter = this._map.getCenter();
                var neareastProject = foundProjects[0];
                for (var i = 1; i < foundProjects.length; i++) {
                    var currentProject = foundProjects[i];
                    if (currentProject.defaultPos &&
                        mapCenter.distanceTo(neareastProject.defaultPos) >
                        mapCenter.distanceTo(currentProject.defaultPos)
                    ) {
                        neareastProject = currentProject;
                    }
                }
                foundProjects = [neareastProject];
            }
        }

        var newProject = foundProjects[0] || null;

        if (this._project === newProject) {
            return;
        }

        var self = this;

        if (this._project !== null) {
            this._project = null;
            setTimeout(function () {
                self._map.fire('projectleave');
            }, 1);
        }

        if (newProject) {
            this._project = newProject;
            setTimeout(function () {
                self._map.fire('projectchange', {getProject: self.getProject.bind(self)});
            }, 1);
        }
    },

    _testProjectIntersects: function (bounds, project) {
        return project.latLngBounds.intersects(bounds);
    },

    _testProjectContains: function (latlng, project) {
        return DG.PolyUtil.inside([latlng.lng, latlng.lat], project.bound);
    },

    _centerInProject: function (project, checkMethod) {
        return this.isProjectHere(this._map.getCenter(), project, checkMethod);
    },

    _zoomInProject: function (project) {
        return (this._map.getZoom() >= project.minZoom);
    }
});

DG.Map.mergeOptions({
    projectDetector: true
});

DG.Map.addInitHook('addHandler', 'projectDetector', DG.ProjectDetector);

/*
 * Utility functions
 */

DG.Metric = function () {};

/*
 * DG.Metric.Segments class can calculate total pushed segments length and used to shortcut
 * 'get Something by provided Length' calculations (segment's Index, segment's Length, etc...)
 */
DG.Metric.Segments = function () {
    this.length = 0;
};

DG.Metric.Segments.prototype = {
    push: function (len) {
        this[this.length] = this.length > 0 ? this[this.length - 1] + len : len;
        this.length += 1;

        return this;
    },

    getLength: function () {
        return this[this.length - 1];
    },

    getReverse: function () {
        var segments = new DG.Metric.Segments();
        var i = this.length - 1;

        if (i < 0) { return segments; }

        while (i--) {
            segments.push(this[i + 1] - this[i]);
        }

        return segments.push(this[0]);
    },

    getIndex: function (len) {
        var i = this.length - 1;

        if (i < 0) { return i; }

        while (i--) {
            if (this[i] <= len) { break; }
        }

        return i + 1;
    },

    getSegRatio: function (len) {
        var i = this.getIndex(len);
        var sub = i > 0 ? this[i - 1] : 0;

        return (len - sub) / (this[i] - sub);
    },

    getSegLength: function (len) {
        var i = this.getIndex(len);
        var sub = i > 0 ? this[i - 1] : 0;

        return len - sub;
    }
};

/*
 * DG.VertexTransform is a classic 2D matrix transformation class
 *
 * Prototype methods can scale/rotate/translate vertices
 *
 * Static methods do the same but return simple array instances with attached
 * .clone() method which can reconstruct full DG.VertexTransform object
 */

DG.VertexTransform = DG.Class.extend({
    initialize: function (vertices) {
        this._vertices = vertices;

        this._scale = null;
        this._angle = null;
        this._trans = null;
        this._matrix = null;

        this.load();
    },

    load: function () {
        this.vertices = this._vertices.map(function (vertex) { return vertex.clone(); });
        this.vertices.clone = DG.VertexTransform.clone;

        return this;
    },

    save: function () {
        this._vertices = this.vertices.map(function (vertex) { return vertex.clone(); });

        return this;
    },

    setScale: function (scale) {
        this._scale = scale;
        return this;
    },

    getScale: function () {
        return this._scale;
    },

    setAngle: function (angle) {
        this._angle = angle;
        return this;
    },

    getAngle: function () {
        return this._angle;
    },

    setTranslation: function (trans) {
        this._trans = trans;
        return this;
    },

    getTranslation: function () {
        return this._trans;
    },

    setMatrix: function (matrix) {
        this._matrix = matrix;
        return this;
    },

    getMatrix: function () {
        return this._matrix;
    },

    scale: function (scale) {
        var v = this.vertices;
        var i = v.length;

        scale = scale || this._scale || 1;
        while (i--) {
            v[i].x *= scale;
            v[i].y *= scale;
        }

        return this;
    },

    unScale: function (scale) {
        scale = scale || this._scale || 1;      //  Also safeguard against zero scale
        return this.scale(1 / scale);
    },

    rotate: function (angle) {
        var cos = angle ? angle.cos : (this._angle ? this._angle.cos : 1);
        var sin = angle ? angle.sin : (this._angle ? this._angle.sin : 0);
        var v = this.vertices;
        var i = v.length;
        var x, y;

        while (i--) {
            x = v[i].x;
            y = v[i].y;
            v[i].x = x * cos - y * sin;
            v[i].y = x * sin + y * cos;
        }

        return this;
    },

    unRotate: function (angle) {
        var cos = angle ? angle.cos : (this._angle ? this._angle.cos : 1);
        var sin = angle ? angle.sin : (this._angle ? this._angle.sin : 0);

        return this.rotate({cos: cos, sin: -sin});
    },

    translate: function (trans) {
        var dx = trans ? trans.x : (this._trans ? this._trans.x : 0);
        var dy = trans ? trans.y : (this._trans ? this._trans.y : 0);
        var v = this.vertices;
        var i = v.length;

        while (i--) {
            v[i].x += dx;
            v[i].y += dy;
        }

        return this;
    },

    unTranslate: function (trans) {
        var dx = trans ? trans.x : (this._trans ? this._trans.x : 0);
        var dy = trans ? trans.y : (this._trans ? this._trans.y : 0);

        return this.translate({x: -dx, y: -dy});
    },

    transform: function (matrix) {
        var a, b, c, d, dx, dy;
        var v = this.vertices;
        var i = v.length;
        var x, y;

        if (matrix) {
            a = matrix[0]; b = matrix[1]; dx = matrix[2];
            c = matrix[3]; d = matrix[4]; dy = matrix[5];
        } else if (this._matrix) {
            a = this._matrix[0]; b = this._matrix[1]; dx = this._matrix[2];
            c = this._matrix[3]; d = this._matrix[4]; dy = this._matrix[5];
        } else {
            a = 1; b = 0; dx = 0;
            c = 0; d = 1; dy = 0;
        }

        while (i--) {
            x = v[i].x;
            y = v[i].y;
            v[i].x = x * a + y * b + dx;
            v[i].y = x * c + y * d + dy;
        }

        return this;
    },

    statics: {
        scale: function (vt, scale) {
            var v = vt.vertices;
            var result = [];
            var x, y;

            scale = scale || 1;
            for (var i = 0; i < v.length; i++) {
                x = v[i].x * scale;
                y = v[i].y * scale;
                result.push(new DG.Point(x, y));
            }
            result.clone = DG.VertexTransform.clone;

            return result;
        },

        unScale: function (vt, scale) {
            scale = scale || 1;         //  Also safeguard against zero scale
            return DG.VertexTransform.scale(vt, 1 / scale);
        },

        rotate: function (vt, angle) {
            var cos = angle ? angle.cos : 1;
            var sin = angle ? angle.sin : 0;
            var v = vt.vertices;
            var x, y, rx, ry;
            var result = [];

            for (var i = 0; i < v.length; i++) {
                rx = v[i].x;
                ry = v[i].y;
                x = rx * cos - ry * sin;
                y = rx * sin + ry * cos;
                result.push(new DG.Point(x, y));
            }
            result.clone = DG.VertexTransform.clone;

            return result;
        },

        unRotate: function (vt, angle) {
            var cos = angle ? angle.cos : 1;
            var sin = angle ? angle.sin : 0;

            return DG.VertexTransform.rotate(vt, {cos: cos, sin: -sin});
        },

        translate: function (vt, trans) {
            var dx = trans ? trans.x : 0;
            var dy = trans ? trans.y : 0;
            var v = vt.vertices;
            var result = [];
            var x, y;

            for (var i = 0; i < v.length; i++) {
                x = v[i].x + dx;
                y = v[i].y + dy;
                result.push(new DG.Point(x, y));
            }
            result.clone = DG.VertexTransform.clone;

            return result;
        },

        unTranslate: function (vt, trans) {
            var dx = trans ? trans.x : 0;
            var dy = trans ? trans.y : 0;

            return DG.VertexTransform.translate(vt, {x: -dx, y: -dy});
        },

        clone: function () {
            //  'this' is an array
            return new DG.VertexTransform(this).save();
        },

        getLength: function (vec1, vec2) {
            var dx, dy;

            if (typeof vec1 === 'number') {
                //  'vec1' and 'vec2' are absolute coordinates of vector
                return Math.sqrt(vec1 * vec1 + vec2 * vec2);
            } else {
                //  'vec1' and 'vec2' are vector objects
                dx = vec2.x - vec1.x;
                dy = vec2.y - vec1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        },

        getScaled: function (vec1, vec2, scale) {
            var dx, dy;

            if (typeof vec1 === 'number') {
                //  'vec1' and 'vec2' are absolute coordinates of vector
                return new DG.Point(vec1 * scale, vec2 * scale);
            } else {
                //  'vec1' and 'vec2' are vector objects
                dx = (vec2.x - vec1.x) * scale;
                dy = (vec2.y - vec1.y) * scale;
                return new DG.Point(vec1.x + dx, vec1.y + dy);
            }
        },

        getAngle: function (vec1, vec2, origin) {
            var l, sp, x1, y1, x2, y2;

            if (typeof vec1 === 'number') {
                //  'vec1' and 'vec2' are absolute coordinates of vector
                l = Math.sqrt(vec1 * vec1 + vec2 * vec2);
                if (l > 0) {
                    return {cos: vec1 / l, sin: vec2 / l};
                } else {
                    return {cos: 1, sin: 0};
                }
            } else {
                //  'vec1' and 'vec2' are vector objects
                x1 = vec1.x; y1 = vec1.y;
                x2 = vec2.x; y2 = vec2.y;
                if (origin) {
                    x1 -= origin.x; y1 -= origin.y;
                    x2 -= origin.x; y2 -= origin.y;
                }
                sp = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2);
                return {
                    cos: (x1 * x2 + y1 * y2) / sp,
                    sin: (x1 * y2 - x2 * y1) / sp
                };
            }
        },

        getAnglesSum: function (angle1, angle2) {
            return {
                cos: angle1.cos * angle2.cos - angle1.sin * angle2.sin,
                sin: angle1.sin * angle2.cos + angle1.cos * angle2.sin
            };
        },

        getAnglesDif: function (angle1, angle2) {
            return {
                cos: angle1.cos * angle2.cos + angle1.sin * angle2.sin,
                sin: angle1.sin * angle2.cos - angle1.cos * angle2.sin
            };
        }
    }
});

/*
 * DG.ArrowPathTransform class is a core of arrow's body calculations
 *
 * General ideas are:
 *      We construct arrow body with stroke points making arcs on outer path turns
 *      Processing is done segment by segment around {0, 0} virtual point
 *          and resulting 'path' finally rotated to it's original map's angle (.fullAngle)
 *      Subset of this vertices lately used in .subPath() calculations which can be used
 *          in animations for ex.
 *
 *  Final translation (see DG.Entrance.Arrow) moves arrow objects to their original positions
 */

DG.ArrowPathTransform = DG.VertexTransform.extend({
    initialize: function (path) {
        //  'path.offset' is initial points offset (-x / +x) to compensate arrow tip length

        //  Skip super initialization as we need only subset of DG.VertexTransform power
        this._lengths = new DG.Metric.Segments();
        this._vertices = [[], []];
        this._drawings = [[], []];
        //  this._arcs = [];    //  initialized in _setPath()

        this._setPath(path);
        this.subPath(1);
    },

    load: function () {
        return this.subPath(1);
    },

    save: function () {
        return this;    //  NoOp
    },

    //  Method constructs new path points with some displacement from original 'path'
    //  Outer corners will be smoothed by arcs (cubic Bézier curves)
    _setPath: function (path) {
        var transform = DG.ArrowPathTransform.transform;
        var vertices = this._vertices;
        var drawings = this._drawings;
        var Point = DG.Point;
        var width = path.width;
        var arcs = [[], [], []];
        var lengths = [];

        var i, x,
            ax, bx, cx,
            angles, angle;

        vertices.push(path.vertices);   //  expect .pop() in final transform
        vertices[0].push(new DG.Point(path.offset, +width));
        vertices[1].push(new DG.Point(path.offset, -width));
        angles = DG.ArrowPathTransform.getAngles(path);

        cx = -path.offset;
        for (i = 0; i < angles.length; i++) {
            x = path.vertices[i + 1].x;
            ax = width * angles[i].cot;

            //  http://pomax.github.io/bezierinfo/#circles_cubic
            //  actual equation is (4/3 * tan(α/4) * radius)
            bx = angles[i].tan * width * 8 / 3;

            //  Next code can be combined by -/+ inversion but for simplicity it is left as is
            if (ax > 0) {
                vertices[0].push(new Point(x + ax,      +width));
                drawings[0].push('L');

                arcs[2].push(1);
                arcs[1].push(vertices[1].length);
                vertices[1].push(new Point(x + ax,      -width));
                vertices[1].push(new Point(x + ax - bx, -width));

                transform(vertices, angles[i], {x: x, y: 0});

                vertices[1].push(new Point(0 - ax + bx, -width));
                vertices[1].push(new Point(0 - ax,      -width));
                drawings[1].push('L', 'C');

                lengths.push(Math.abs(x + ax) - cx); cx = +ax;
            } else {
                vertices[1].push(new Point(x - ax,      -width));
                drawings[1].push('L');

                arcs[2].push(0);
                arcs[0].push(vertices[0].length);
                vertices[0].push(new Point(x - ax,      +width));
                vertices[0].push(new Point(x - ax + bx, +width));

                transform(vertices, angles[i], {x: x, y: 0});

                vertices[0].push(new Point(0 + ax - bx, +width));
                vertices[0].push(new Point(0 + ax,      +width));
                drawings[0].push('L', 'C');

                lengths.push(Math.abs(x - ax) - cx); cx = -ax;
            }
        }

        //  Final segments and tail arc
        ax = path.vertices[i + 1].x;
        bx = width * 4 / 3; // tan(PI/4) = 1

        vertices[0].push(new Point(ax, +width));
        vertices[1].push(new Point(ax, -width));

        vertices[0].push(new Point(ax - bx, +width));
        vertices[1].push(new Point(ax - bx, -width));

        drawings[0].push('L');
        drawings[1].push('L');

        lengths.push(Math.abs(ax) - cx);

        //  Reverse right path
        vertices[1].reverse();
        drawings[1].reverse();

        //  Move vertices into original position (before last translation)
        angle = DG.VertexTransform.getAnglesSum(angles.fullAngle, path.getAngle());
        transform(vertices, angle, vertices.pop()[0]);  //  path.vertices[0]

        //  We need to reconstruct arc's indexes but too many variables already touched, reuse some of them
        ax = vertices[0].length;
        bx = vertices[1].length;
        this._arcs = arcs[2].map(function (i) {
            cx = arcs[i].shift();
            if (i > 0) {
                return new DG.ArcBezier(vertices[1].slice(bx - cx - 4, bx - cx));
            } else {
                return new DG.ArcBezier(vertices[0].slice(cx, cx + 4).reverse());
            }
        }).reverse();

        this._lengths.push(lengths.pop());
        lengths.reverse().forEach(function (l, i) {
            this._lengths.push(this._arcs[i].getLength()).push(l);
        }, this);

        //  Shortcut border cases (0%-length sub-path and full-path)
        this[0] = {
            vertices: [vertices[0][ax - 2], vertices[0][ax - 1], vertices[1][0], vertices[1][1]],
            drawings: ['M', 'C']
        };
        this[1] = {
            vertices: vertices[0].concat(vertices[1]),
            drawings: ['M'].concat(drawings[0], 'C', drawings[1])
        };
    },

    _setAngleAndDisplacement: function (vL, vR) { // Used in DG.ArrowTipTransform.subShape()
        this.angle = DG.VertexTransform.getAngle({x: vL.x - vR.x, y: vL.y - vR.y}, {x: 0, y: 1});
        this.displ = vR.clone();
    },

    subPath: function (pathRatio) {
        pathRatio = pathRatio > 1 ? 1 : pathRatio;

        //  Shortcut border cases (0%-length sub-path and full-path)
        if (pathRatio === 0 || pathRatio === 1) {
            this.vertices = this[pathRatio].vertices.map(function (vertex) { return vertex.clone(); });
            this.drawings = this[pathRatio].drawings;
            this._setAngleAndDisplacement(this.vertices[0], this.vertices[this.vertices.length - 1]);
            return this;
        }

        var getScaled = DG.VertexTransform.getScaled;
        var vertices = this._vertices;
        var drawings = this._drawings;
        var lengths = this._lengths;
        var len = lengths.getLength() * pathRatio;
        var segIndex = lengths.getIndex(len);
        var segRatio = lengths.getSegRatio(len);
        var vertexIndexLeft = vertices[0].length - 2;
        var vertexIndexRight = 1;
        var drawingIndexLeft = drawings[0].length - 1;
        var drawingIndexRight = 0;
        var vertexLeft, vertexRight;
        var arc = 0, aed = 0;

        while (aed++ < segIndex) {
            if (aed % 2 == 1) {
                vertexIndexLeft--;
                drawingIndexLeft--;
                vertexIndexRight++;
                drawingIndexRight++;
            } else {
                if (drawings[0][drawingIndexLeft] === 'C') {
                    vertexIndexLeft -= 3;
                    drawingIndexLeft -= 1;
                } else {
                    vertexIndexRight += 3;
                    drawingIndexRight += 1;
                }
                arc++;
            }
        }

        if (segIndex % 2 == 1) {
            //  One path ends with an arc
            arc = this._arcs[arc];
            if (drawings[0][drawingIndexLeft] === 'C') {
                arc = arc.getCurveBefore(arc.getTbyL(lengths.getSegLength(len)));
                vertexLeft = arc.points[3];
                vertexRight = vertices[1][vertexIndexRight];
                this.vertices = arc.points.slice(1).reverse()
                    .concat(vertices[0].slice(vertexIndexLeft), vertices[1].slice(0, vertexIndexRight + 1))
                    .map(function (vertex) { return vertex.clone(); });
                this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft), 'C', drawings[1].slice(0, drawingIndexRight));
            } else {
                arc = arc.getCurveBefore(arc.getTbyL(lengths.getSegLength(len)));
                vertexLeft = vertices[0][vertexIndexLeft];
                vertexRight = arc.points[3];
                this.vertices = vertices[0].slice(vertexIndexLeft)
                    .concat(vertices[1].slice(0, vertexIndexRight + 1), arc.points.slice(1))
                    .map(function (vertex) { return vertex.clone(); });
                this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft + 1), 'C', drawings[1].slice(0, drawingIndexRight + 1));
            }
        } else {
            //  Both paths end with lines
            vertexLeft = getScaled(vertices[0][vertexIndexLeft], vertices[0][vertexIndexLeft - 1], segRatio);
            vertexRight = getScaled(vertices[1][vertexIndexRight], vertices[1][vertexIndexRight + 1], segRatio);
            this.vertices = [vertexLeft]
                .concat(vertices[0].slice(vertexIndexLeft), vertices[1].slice(0, vertexIndexRight + 1), vertexRight)
                .map(function (vertex) { return vertex.clone(); });
            this.drawings = ['M'].concat(drawings[0].slice(drawingIndexLeft), 'C', drawings[1].slice(0, drawingIndexRight + 1));
        }

        this._setAngleAndDisplacement(vertexLeft, vertexRight);
        return this;
    },

    statics: {
        getAngles: function (path) {
            var getAngle = DG.VertexTransform.getAngle;
            var fullAngle = {cos: 1, sin: 0};
            var vertices = path.vertices;
            var angles = [];

            var absSin, angle,
                cos, sin, cot, temp, sign;

            for (var i = 1, len = vertices.length - 1; i < len; i++) {
                angle = getAngle(vertices[i - 1], vertices[i + 1], vertices[i]);

                absSin = Math.abs(angle.sin);
                if (absSin < 0.000001) {
                    //  Exclude 180° angle from vertices array
                    vertices.splice(vertices.length - i - 1, 1);
                    len--;
                    i--;
                } else {
                    //  This is half ∢α cotangent, sign describes angle direction and used to shortcut stroke calculations
                    //  '-1' - right angle is inner angle, '1' - left angle is inner angle (if seen from [0, 0] to [-1, 0])
                    angle.cot = (1 + angle.cos) / angle.sin;

                    //  We need to rotate next segment to [-1, 0] axis, so we need complementary angle actually
                    angle.cos = -angle.cos;

                    //  Complimentary angle also used to calculate it's quaternary ∢β tangent
                    //  ∢β tangent used in approximation of outer arc segment by Bézier curve
                    cot = (1 + angle.cos) / angle.sin;
                    sign = cot < 0 ? -1 : 1;
                    temp = sign * Math.sqrt(4 * cot * cot + 4);
                    angle.tan = -0.5 * (cot + cot - temp);

                    angles.push(angle);

                    cos = fullAngle.cos * angle.cos - fullAngle.sin * angle.sin;
                    sin = fullAngle.sin * angle.cos + fullAngle.cos * angle.sin;

                    fullAngle = {cos: cos, sin: sin};
                }
            }

            //  Used in final stroke points translation
            angles.fullAngle =  {cos: fullAngle.cos, sin: -fullAngle.sin};
            return angles;
        },

        //  TODO - if length of 'latlngs' array is less than 2 or it is undefined next function produces exception
        //  check this condition in outer routines?!
        getTranslatedPath: function (map, latlngs) {
            var path = new DG.VertexTransform([]);
            var i = latlngs.length - 1;
            var v = map.project(latlngs[i]);
            var dx = v.x, dy = v.y;

            path.vertices.push(new DG.Point(0, 0));
            while (i--) {
                v = map.project(latlngs[i]);
                path.vertices.push(new DG.Point(v.x - dx, v.y - dy));
            }
            return path
                .setAngle(DG.VertexTransform.getAngle(-path.vertices[1].x, -path.vertices[1].y))
                .unRotate();
        },

        transform: function (rings, angle, vector) {
            var i = rings.length;
            var cos = angle.cos;
            var sin = angle.sin;
            var dx = vector.x;
            var dy = vector.y;
            var ring, x, y, j;

            while (i--) {
                ring = rings[i];
                j = ring.length;
                while (j--) {
                    x = ring[j].x - dx;
                    y = ring[j].y - dy;
                    ring[j].x = x * cos - y * sin;
                    ring[j].y = x * sin + y * cos;
                }
            }
        }
    }
});

/*
 * DG.ArrowTipTransform class is a core of arrow's tip calculations
 *
 * .subShape() routine 'bound' arrow's tip to the ending points of .subPath()
 * calculated separately in DG.ArrowPathTransform
 *
 *  Final translation (see DG.Entrance.Arrow) moves arrow objects to their original positions
 */

DG.ArrowTipTransform = DG.VertexTransform.extend({
    initialize: function (path, shape) {
        this.drawings = shape.drawings; //  static mapping
        this._vertices = shape.vertices;

        this._setShape(path, shape);
    },

    _setShape: function (path, shape) {
        var sp = shape.vertices[0];
        var width = Math.abs(sp.y);
        var pl = path.vertices[1].x;    //  negative value
        var length = sp.x;              //  negative value
        var offset = pl - length + width + width;

        path.width = width;
        path.offset = length + (offset > 0 ? offset : 0);
        if (path.vertices.length < 3 && length > -10) {
            path.offset += 2.5;
        }

        this._vertices = this.load().unTranslate(sp).vertices;
    },

    subShape: function (transform) {
        this.load().unRotate(transform.angle).translate(transform.displ);
        return this;
    }
});

/*
 * DG.ComplexPath is a simple vector layer class with empty .getEvents() object(!)
 * It's drawing logic is maintained in DG.Entrance.Arrow class
 *
 * _pxBounds is a pixel bounds of this drawings and they are used in L.Canvas
 */

DG.ComplexPath = DG.Path.extend({
    options: {
        fill: true,
        fillOpacity: 1,
        interactive: false
    },

    initialize: function (options) {
        DG.setOptions(this, options);

        this._empty = [];

        this._pxEmpty = DG.bounds(
            DG.point(0, 0), DG.point(0, 0)
        );
        this._pxBounds = this._pxEmpty;

        this._vertices = [this._empty];
        this._drawings = [this._empty];
    },

    getEvents: function () {
        return {};
    },

    _project: function () {
        var opts = this.options,
            zoom, weight;

        if (this._map) {
            zoom = this._map.getZoom();
        } else {
            return;
        }

        if (opts.visibility.isShown && opts.transform[zoom]) {
            //  Next numbers was empirically selected in order to provide visual compliance
            //  to the original arrow's implementation
            weight = 2.2 - ((19 - zoom) * 0.2);
            if (opts.weight !== weight) {
                this.setStyle({weight: +weight.toFixed(2)});
            }

            this._vertices[0] = opts.transform[zoom].vertices;
            this._drawings[0] = opts.transform[zoom].drawings;

            this._pxBounds = opts.transform[zoom]._pxBounds;
        } else {
            this._vertices[0] = this._empty;
            this._drawings[0] = this._empty;

            this._pxBounds = this._pxEmpty;
        }
    },

    _update: function () {
        if (this._map) {
            this._updatePath();
        }
    },

    _updatePath: function () {  //  used in Canvas renderer
        this._renderer._updateComplexPath(this);
    }
});

/*
 * Actual painting methods that can draw complex objects with curves
 *
 * Point coordinates must be provided in layer._vertices object
 * And types of line must be provided in layer._drawings object
 */

DG.extend(L.Canvas.prototype, {
    _updateComplexPath: function (layer, closed) {
        var i, j, k, d, x, y, _x, _y, $x, $y, points;
        var drawings = layer._drawings;
        var vertices = layer._vertices;
        var ctx = this._ctx;

        this._drawnLayers[layer._leaflet_id] = layer;

        //  TODO: Do we need to do a 'beginPath()' and possible 'closePath()' per ring?!
        ctx.beginPath();

        for (i = 0; i < vertices.length; i++) {
            points = vertices[i];
            x = y = 0;
            j = k = 0;
            while (j < points.length) {
                d = drawings[i][k++];
                switch (d) {
                    case 'M':
                        x = points[j].x;
                        y = points[j].y;
                        j += 1;
                        ctx.moveTo(x, y);
                        break;

                    case 'm':
                        x += points[j].x;
                        y += points[j].y;
                        j += 1;
                        ctx.moveTo(x, y);
                        break;

                    case 'L':
                        x = points[j].x;
                        y = points[j].y;
                        j += 1;
                        ctx.lineTo(x, y);
                        break;

                    case 'l':
                        x += points[j].x;
                        y += points[j].y;
                        j += 1;
                        ctx.lineTo(x, y);
                        break;

                    case 'C':
                        _x = points[j].x;
                        _y = points[j].y;
                        j += 1;
                        $x = points[j].x;
                        $y = points[j].y;
                        j += 1;
                        x = points[j].x;
                        y = points[j].y;
                        j += 1;
                        ctx.bezierCurveTo(_x, _y, $x, $y, x, y);
                        break;

                    case 'c':
                        _x = x + points[j].x;
                        _y = y + points[j].y;
                        j += 1;
                        $x = x + points[j].x;
                        $y = y + points[j].y;
                        j += 1;
                        x = x + points[j].x;
                        y = y + points[j].y;
                        j += 1;
                        ctx.bezierCurveTo(_x, _y, $x, $y, x, y);
                        break;

                    case 'Q':
                        _x = points[j].x;
                        _y = points[j].y;
                        j += 1;
                        x = points[j].x;
                        y = points[j].y;
                        j += 1;
                        ctx.quadraticCurveTo(_x, _y, x, y);
                        break;

                    case 'q':
                        _x = x + points[j].x;
                        _y = y + points[j].y;
                        j += 1;
                        x = x + points[j].x;
                        y = y + points[j].y;
                        j += 1;
                        ctx.quadraticCurveTo(_x, _y, x, y);
                        break;
                }
            }
            if (closed) {
                ctx.closePath();
            }
        }

        this._fillStroke(ctx, layer);
    }
});


DG.extend(L.SVG.prototype, {
    _updateComplexPath: function (layer, closed) {
        this._setPath(layer, L.SVG.complexPointsToPath(layer._vertices, layer._drawings, closed));
    }
});


DG.extend(L.SVG, {
    complexPointsToPath: function (vertices, drawings, closed) {
        var str = '';
        var svg = DG.Browser.svg;
        var i, j, k, n, d, points;

        for (i = 0; i < vertices.length; i++) {
            points = vertices[i];

            //  Speedup hot path by removing if/ternary condition checks but duplicating loops
            if (svg) {
                j = k = 0;
                while (j < points.length) {
                    d = drawings[i][k++];
                    switch (d) {
                        case 'C':
                        case 'c':   n = 3; break;
                        case 'Q':
                        case 'q':   n = 2; break;

                        default:    n = 1;  //  'M', 'm', 'L', 'l', ...
                    }
                    str += d;
                    while (n--) {
                        str += points[j].x.toFixed(4) + ',' + points[j].y.toFixed(4) + ' ';
                        j += 1;
                    }
                }
            } else {
                //  vml in IE8 can support only integer values in 'path', sorry about loss of precision
                j = k = 0;
                while (j < points.length) {
                    d = drawings[i][k++];
                    switch (d) {
                        case 'M':   d = 'm'; n = 1; break;
                        case 'm':   d = 't'; n = 1; break;
                        case 'L':   d = 'l'; n = 1; break;
                        case 'l':   d = 'r'; n = 1; break;
                        case 'C':   d = 'c'; n = 3; break;
                        case 'c':   d = 'v'; n = 3; break;
                        case 'Q':
                            //  VML spec has 'qb' command in 'v' attribute string but no 'relativeTo' compliment
                            //  So we'll emulate Cubic Bézier curve by applying Quadratic variant in both cases
                            //  TODO: Both control points will use the same value but this is not true solution
                            str += 'C' +
                                points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' +
                                points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' +
                                points[j + 1].x.toFixed(0) + ',' + points[j + 1].y.toFixed(0) + ' ';
                            j += 2;
                            d = '';
                            n = 0;
                            break;
                        case 'q':
                            str += 'c' +
                                points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' +
                                points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ' +
                                points[j + 1].x.toFixed(0) + ',' + points[j + 1].y.toFixed(0) + ' ';
                            j += 2;
                            d = '';
                            n = 0;
                            break;

                        default:    n = 1;
                    }
                    str += d;
                    while (n--) {
                        str += points[j].x.toFixed(0) + ',' + points[j].y.toFixed(0) + ' ';
                        j += 1;
                    }
                }
            }

            str += closed ? (svg ? 'z' : 'x') : '';
        }

        // SVG complains about empty path strings
        return str || 'm0,0';
    }
});

/*
 * DGBezierCurves is a collection of three classes:
 * Original DG.Bezier class provides basic math for Cubic and Quadratic Bézier curves
 * DG.TimeBezier used in animation effects it can return 'Distance' (Y) by Time (X) value
 * DG.ArcBezier can return 't' value by curve's segment length
 * Actual calculations can be very hard (in math terms) so we use LUT's to optimize them
 *
 * Original ideas come from this source:   https://pomax.github.io/bezierinfo/
 */

DG.Bezier = DG.Class.extend({
    /**
     * Initialize curve object by provided control points
     * @param {Array<DG.Point>} coords Curve's control points in DG.Point format (up to four control points supported)
     * @param {boolean} [clone] Clone original points or not (Default)
     */
    initialize: function (coords, clone) {
        if (clone) {
            this.points = coords.map(function (coord) { return coord.clone(); });
        } else {
            this.points = coords;
        }
        this.dpoints = this._getDerivatives();
        this.order = this.points.length - 1;
        this._lut = [];
    },

    getPoint: function (t) {
        var p = this.points;
        var mt, mt2, t2;
        var a, b, c, d;

        if (t === 0) { return p[0]; }
        if (t === 1) { return p[this.order]; }

        mt = 1 - t;
        mt2 = mt * mt;
        t2 = t * t;

        if (this.order > 2) {
            a = mt2 * mt;
            b = mt2 * t * 3;
            c = mt * t2 * 3;
            d = t * t2;
        } else {
            p = [p[0], p[1], p[2], {x: 0, y: 0}];
            a = mt2;
            b = mt * t * 2;
            c = t2;
            d = 0;
        }

        return new DG.Point(
            a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
            a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
        );
    },

    derivative: function (t) {
        var p = this.dpoints[0];
        var mt = 1 - t;
        var a, b, c;

        if (this.order > 2) {
            a = mt * mt;
            b = mt * t * 2;
            c = t * t;
        } else {
            p = [p[0], p[1], {x: 0, y: 0}];
            a = mt; b = t; c = 0;
        }

        return new DG.Point(
            a * p[0].x + b * p[1].x + c * p[2].x,
            a * p[0].y + b * p[1].y + c * p[2].y
        );
    },

    getLength: function () {
        /* eslint-disable camelcase */
        var w_i = DG.Bezier.WEIGHT;
        var x_i = DG.Bezier.ABSCISSA;
        var z = 0.5;
        var sum = 0;
        var d, l, t;

        for (var i = 0; i < x_i.length; i++) {
            t = z * x_i[i] + z;
            d = this.derivative(t);
            l = d.x * d.x + d.y * d.y;
            sum += w_i[i] * Math.sqrt(l);
        }
        /* eslint-enable camelcase */

        return z * sum;
    },

    getCurveBefore: function (z) {
        var p = this.points;
        var z2, z3, mz, mz2, mz3;
        var b$3, b$4, c$4;
        var curve;

        if (z === 1) { return this.clone(); }

        curve = [];
        z2 = z * z;
        mz = z - 1;
        mz2 = mz * mz;

        curve[0] = new DG.Point(
            p[0].x,
            p[0].y
        );

        curve[1] = new DG.Point(
            z * p[1].x - mz * p[0].x,
            z * p[1].y - mz * p[0].y
        );

        b$3 = z * mz * 2;
        curve[2] = new DG.Point(
            z2 * p[2].x - b$3 * p[1].x + mz2 * p[0].x,
            z2 * p[2].y - b$3 * p[1].y + mz2 * p[0].y
        );

        if (this.order > 2) {
            z3 = z2 * z;
            mz3 = mz2 * mz;
            b$4 = z2 * mz * 3;
            c$4 = z * mz2 * 3;
            curve[3] = new DG.Point(
                z3 * p[3].x - b$4 * p[2].x + c$4 * p[1].x - mz3 * p[0].x,
                z3 * p[3].y - b$4 * p[2].y + c$4 * p[1].y - mz3 * p[0].y
            );
        }

        return new DG.Bezier(curve);
    },

    getCurveAfter: function (z) {
        var p = this.points;
        var n = this.order;
        var z2, z3, mz, mz2, mz3;
        var b$3, b$4, c$4;
        var curve;

        if (z === 1) { return this.clone(); }

        curve = [];
        z2 = z * z;
        mz = z - 1;
        mz2 = mz * mz;

        curve[n] = new DG.Point(
            p[n].x,
            p[n].y
        );

        curve[--n] = new DG.Point(
            z * p[n + 1].x - mz * p[n].x,
            z * p[n + 1].y - mz * p[n].y
        );

        b$3 = z * mz * 2;
        curve[--n] = new DG.Point(
            z2 * p[n + 2].x - b$3 * p[n + 1].x + mz2 * p[n].x,
            z2 * p[n + 2].y - b$3 * p[n + 1].y + mz2 * p[n].y
        );

        if (this.order > 2) {
            z3 = z2 * z;
            mz3 = mz2 * mz;
            b$4 = z2 * mz * 3;
            c$4 = z * mz2 * 3;
            curve[--n] = new DG.Point(
                z3 * p[n + 3].x - b$4 * p[n + 2].x + c$4 * p[n + 1].x - mz3 * p[n].x,
                z3 * p[n + 3].y - b$4 * p[n + 2].y + c$4 * p[n + 1].y - mz3 * p[n].y
            );
        }

        return new DG.Bezier(curve);
    },

    _getDerivatives: function () {
        var p = this.points;
        var d, c, j, list;
        var result = [];

        for (d = p.length, c = d - 1; d > 1; d--, c--) {
            list = [];
            for (j = 0; j < c; j++) {
                list.push(new DG.Point(
                    c * (p[j + 1].x - p[j].x),
                    c * (p[j + 1].y - p[j].y)
                ));
            }
            result.push(list);
            p = list;
        }

        return result;
    },

    getLUT: function (steps) {
        steps = steps || 125;

        if (this._lut.length !== steps + 1) {
            if (this.order > 2) {
                this._setLUT3(steps);
            } else {
                this._setLUT2(steps);
            }
        }

        return this._lut;
    },

    _setLUT2: function (steps) {
        var lut = this._lut = [];
        var p = this.points;
        var t, mt;
        var a, b, c;

        lut.push({x: p[0].x, y: p[0].y, l: 0});
        for (var s = 1; s < steps; s++) {
            t = s / steps;
            mt = 1 - t;
            a = mt * mt;
            b = mt * t * 2;
            c = t * t;
            lut.push({
                x: a * p[0].x + b * p[1].x + c * p[2].x,
                y: a * p[0].y + b * p[1].y + c * p[2].y
            });
        }
        lut.push({x: p[2].x, y: p[2].y, l: 0});
    },

    _setLUT3: function (steps) {
        var lut = this._lut = [];
        var p = this.points;
        var t, t2, mt, mt2;
        var a, b, c, d;

        lut.push({x: p[0].x, y: p[0].y, l: 0});
        for (var s = 1; s < steps; s++) {
            t = s / steps;
            mt = 1 - t;
            mt2 = mt * mt;
            t2 = t * t;
            a = mt2 * mt;
            b = mt2 * t * 3;
            c = mt * t2 * 3;
            d = t * t2;
            lut.push({
                x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
                y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
            });
        }
        lut.push({x: p[3].x, y: p[3].y, l: 0});
    },

    clone: function () {
        return new DG.Bezier(this.points, true);
    }
});

DG.bezier = function (coords) {
    if (typeof coords === 'number' || coords instanceof DG.Point) {
        coords = Array.prototype.slice.call(arguments);
    }

    if (typeof coords[0] === 'number') {
        if (coords.length < 7) {
            coords = [
                new DG.Point(coords[0], coords[1]),
                new DG.Point(coords[2], coords[3]),
                new DG.Point(coords[4], coords[5])
            ];
        } else {
            coords = [
                new DG.Point(coords[0], coords[1]),
                new DG.Point(coords[2], coords[3]),
                new DG.Point(coords[4], coords[5]),
                new DG.Point(coords[6], coords[7])
            ];
        }
        return new DG.Bezier(coords);
    } else {
        return new DG.Bezier(coords, true);
    }
};

/* eslint-disable indent */
DG.Bezier.WEIGHT = [
    0.3626837833783620,
    0.3626837833783620,
    0.3137066458778873,
    0.3137066458778873,
    0.2223810344533745,
    0.2223810344533745,
    0.1012285362903763,
    0.1012285362903763
];
DG.Bezier.ABSCISSA = [
   -0.1834346424956498,
    0.1834346424956498,
   -0.5255324099163290,
    0.5255324099163290,
   -0.7966664774136267,
    0.7966664774136267,
   -0.9602898564975363,
    0.9602898564975363
];
/* eslint-enable indent */


//  This curve is monotonically ordered by 'X' coordinate and has P[0] = {0, 0} and P[3] = {1, 1}
//  We can utilize this facts to shortcut calculations
DG.TimeBezier = DG.Bezier.extend({
    initialize: function (controlPoint1, controlPoint2, clone) {
        DG.Bezier.prototype.initialize.call(
            this,
            [DG.TimeBezier.START, controlPoint1, controlPoint2, DG.TimeBezier.END],
            clone
        );
    },

    getYbyX: function (x) {
        var lut = this.getLUT();
        var max = lut.length - 1;
        var min = 0;
        var mid;

        if (x <= 0) { return 0; }
        if (x >= 1) { return 1; }

        //  'X' is monotonically increasing so we can do a simple binary search (LUT)
        //  and then fine-tune the result by linear interpolation assuming 'Y' is not changed so radically
        while (true) {
            mid = min + (max - min >> 1);
            if (x < lut[mid].x) {
                max = mid;
            } else {
                min = mid;
            }
            if (max - min < 2) { break; }
        }
        x = (x - lut[min].x) / (lut[max].x - lut[min].x);

        return (lut[min].y + (lut[max].y - lut[min].y) * x);
    },

    getLUT: function (steps) {
        var p = this.points;
        var t, t2, mt;
        var b, c, d;
        var lut;

        steps = steps || 240;
        if (this._lut.length === steps + 1) {
            return this._lut;
        } else {
            this._lut = lut = [];
        }

        lut.push({x: 0, y: 0});
        for (var s = 1; s < steps; s++) {
            t = s / steps;
            mt = 1 - t;
            t2 = t * t;
            //  We don't need 'a' coefficient because p[0] is {0, 0}
            b = mt * mt * t * 3;
            c = mt * t2 * 3;
            d = t * t2;
            lut.push({
                x: b * p[1].x + c * p[2].x + d,
                y: b * p[1].y + c * p[2].y + d
            });
        }
        lut.push({x: 1, y: 1});

        return lut;
    },

    clone: function () {
        return new DG.TimeBezier(this.points, true);
    }
});

DG.TimeBezier.START = DG.point(0, 0);
DG.TimeBezier.END = DG.point(1, 1);


//  This is cubic Bezier describing circular arc
DG.ArcBezier = DG.Bezier.extend({
    initialize: function (coords, clone) {
        DG.Bezier.prototype.initialize.call(this, coords, clone);
        this.getLUT();
        this._setLutLengths();
    },

    getTbyL: function (l) {
        var lut = this.getLUT();
        var max = lut.length - 1;
        var min = 0;
        var mid;
        var x, y;

        if (l <= 0) { return 0; }
        if (l >= lut[max].l) { return 1; }

        //  'L' is monotonically increasing so we can do a binary search (LUT)
        //  and then fine-tune the result by linear interpolation
        while (true) {
            mid = min + (max - min >> 1);
            if (l < lut[mid].l) {
                max = mid;
            } else {
                min = mid;
            }
            if (max - min < 2) { break; }
        }
        l = (l - lut[min].l) / (lut[max].l - lut[min].l);

        x = (lut[min].x + (lut[max].x - lut[min].x) * l);
        y = (lut[min].y + (lut[max].y - lut[min].y) * l);

        //  BUT this is a part of story, we need a projection of this point to the actual curve and it's reverse 't' val
        var p, dx, dy, t;
        var et = max / lut.length;
        var dt = min / lut.length;
        var s = 1 / lut.length / 10;    //  TODO
        var d = Math.pow(2, 53) - 1;

        for (t = dt; dt < et; dt += s) {
            p = this.getPoint(dt);
            dx = p.x - x; dy = p.y - y;
            l = Math.sqrt(dx * dx + dy * dy);
            if (l < d) {
                d = l;
                t = dt;
            }
        }

        return t;
    },

    _setLutLengths: function () {
        var lut = this._lut;
        var dx, dy;

        lut[0].l = 0;
        for (var i = 1; i < lut.length; i++) {
            dx = lut[i].x - lut[i - 1].x;
            dy = lut[i].y - lut[i - 1].y;
            lut[i].l = lut[i - 1].l + Math.sqrt(dx * dx + dy * dy);
        }
    },

    getLength: function () {
        return this._lut[this._lut.length - 1].l;
    },

    clone: function () {
        return new DG.ArcBezier(this.points, true);
    }
});

/*
 * DG.Animation provides tick (step) logic returning progression values
 * calculated over provided or custom Bézier curves
 * Original input can be array object btw...
 */

DG.Animation = DG.Evented.extend({
    options: {
        // animation: {    //  Or array of objects
        //     function: DG.Animation.EASE,
        //     duration: 2000,
        //     frames: null
        // }

        //offset: 0
        //repeat: 0
    },

    initialize: function (options) {
        DG.setOptions(this, options);

        this._animID = -1;
        this._startTime = 0;
        this._running = false;
        this._animation = null;
        this._durations = null;
    },

    start: function () {
        this.stop();
        this._prepare();

        this._running = true;

        this.fire('start');

        //  Date.now(), but... IE9+
        this._startTime = new Date().getTime();

        this._animate();
    },

    stop: function () {
        if (this._running) {
            this._run(this._durations.getLength());
        }
    },

    _prepare: function () {
        this._animation = DG.Util.isArray(this.options.animation) ? this.options.animation : [this.options.animation];

        this._durations = new DG.Metric.Segments();
        this._animation.forEach(function (animation) {
            this.push(animation.duration);
        }, this._durations);
    },

    _animate: function () {
        this._animID = DG.Util.requestAnimFrame(this._animate, this);
        this._run();
    },

    _run: function (elapsed) {
        var el, index, progress;
        //  Possible skip zero delta time but who cares?!
        elapsed = elapsed ? elapsed : new Date().getTime() - this._startTime;

        if (elapsed < this._durations.getLength()) {
            index = this._durations.getIndex(elapsed);
            el = this._durations.getSegRatio(elapsed);
            progress = this._animation[index]['function'].getYbyX(el);
            this._step(this._getFrameValues(index, progress));
        } else {
            index = this._durations.length - 1;
            this._step(this._getFrameValues(index, 1));
            this._complete();
        }
    },

    _step: function (obj) {
        this.fire('step', obj);
    },

    _complete: function () {
        DG.Util.cancelAnimFrame(this._animID);

        this._durations = null;
        this._animation = null;
        this._running = false;
        this.fire('end');
    },

    _getFrameValues: function (index, progress) {
        var frames = this._animation[index].frames;
        var obj = {progress: progress};
        var fr, to;

        if (frames) {
            for (var key in frames) {
                if (frames[key].progress) {
                    obj[key] = frames[key].progress(progress);
                } else {
                    fr = frames[key].from;
                    to = frames[key].to;
                    obj[key] = fr + (to - fr) * progress;
                }
            }
        }
        return obj;
    }
});

DG.animation = function (options) {
    return new DG.Animation(options);
};

DG.Animation.LINEAR         = new DG.TimeBezier(DG.point(0.00, 0.0), DG.point(1.00, 1.0));
DG.Animation.EASE           = new DG.TimeBezier(DG.point(0.25, 0.1), DG.point(0.25, 1.0));
DG.Animation.EASE_IN        = new DG.TimeBezier(DG.point(0.42, 0.0), DG.point(1.00, 1.0));
DG.Animation.EASE_IN_OUT    = new DG.TimeBezier(DG.point(0.42, 0.0), DG.point(0.58, 1.0));
DG.Animation.EASE_OUT       = new DG.TimeBezier(DG.point(0.00, 0.0), DG.point(0.58, 1.0));

/*
 * DG.Entrance is a main class that hosts actual arrow layers
 * It orchestrates animation and provides user space methods like .show() and .hide()
 */

DG.Entrance = DG.FeatureGroup.extend({

    options: {
        vectors: [],

        fillColor: '#0085a0',
        strokeColor: '#fff',

        enableAnimation: true,
        interactive: false,

        autoClose: true
    },

    initialize: function (options) {
        DG.LayerGroup.prototype.initialize.call(this);

        DG.setOptions(this, options);

        this._bounds =
            new DG.LatLngBounds();
        this._animations = {
            bounce: DG.animation(DG.Entrance.BOUNCE_ANIMATION),
            path: DG.animation(DG.Entrance.PATH_ANIMATION)
        };

        this._initArrows();

        this._isShown = false;
    },

    onAdd: function (map) {
        DG.LayerGroup.prototype.onAdd.call(this, map);
        this.show();
    },

    onRemove: function (map) {
        this.hide();
        DG.LayerGroup.prototype.onRemove.call(this, map);
    },

    getEvents: function () {
        var events = {};

        if (this.options.autoClose) {
            events['layeradd'] = this._removeEntrance;  //  eslint-disable-line dot-notation
        }
        if (this.options.enableAnimation) {
            events['zoomend'] = this._animate;          //  eslint-disable-line dot-notation
        }

        return events;
    },

    show: function (fitBounds) {
        if (this._layers) {
            if (fitBounds) {
                this.fitBounds();
            }
            if (!this._isShown) {
                this._isShown = true;
                this.eachLayer(function (arrow) {
                    arrow.setVisibility(true);
                });
                if (this.options.enableAnimation) {
                    this._animate();
                }
                this._map.fire('entranceshow');
            }
        }

        return this;
    },

    hide: function () {
        if (this._layers && this._isShown) {
            this._isShown = false;
            this.eachLayer(function (arrow) {
                arrow.setVisibility(false);
            });
            this._map.fire('entrancehide');
        }

        return this;
    },

    isShown: function () {
        return this._isShown;
    },

    getBounds: function () {
        return this._bounds;
    },

    setFillColor: function (color) {
        this.eachLayer(function (arrow) {
            arrow.setStyle({fillColor: color});
        });
    },

    setStrokeColor: function (color) {
        this.eachLayer(function (arrow) {
            arrow.setStyle({color: color});
        });
    },

    _initArrows: function () {
        var base = {
            color: this.options.strokeColor,
            fillColor: this.options.fillColor,
            interactive: this.options.interactive
        };

        this.options.vectors
            .map(function (vector) {
                return DG.Wkt.toLatLngs(vector);
            })
            .forEach(function (latlngs) {
                var options = DG.Util.create(base),
                    bounds = DG.latLngBounds(latlngs);

                this._bounds.extend(bounds);

                options.latlngs = latlngs;
                options.bounds = bounds;
                if (this.options.enableAnimation) {
                    if (latlngs.length > 2) {
                        options.animation = this._animations.path;
                    } else {
                        options.animation = this._animations.bounce;
                        options.distance = true;
                    }
                }

                this.addLayer(DG.entrance.arrow(options));
            }, this);
    },


    _animate: function () {
        if (this._isShown) {
            this._animations.bounce.start();
            this._animations.path.start();
        }
    },

    //  Current logic of next four methods extracted from original arrow's implementation
    fitBounds: function () {
        var map = this._map, fitZoom,
            bounds = this.getBounds();

        if (!map.getBounds().contains(bounds) || !this._isAllowedZoom()) {
            fitZoom = this._getFitZoom();
            if (!map.projectDetector.getProject()) {
                map.once('moveend', function () {
                    map.setZoom(this._getFitZoom());
                }, this);
            }
            map.setView(bounds.getCenter(), fitZoom, {animate: true});
        }

        return this;
    },

    _getFitZoom: function () {
        return this._map.projectDetector.getProject().maxZoom || DG.Entrance.SHOW_FROM_ZOOM;
    },

    _isAllowedZoom: function () {
        return this._map.getZoom() >= DG.Entrance.SHOW_FROM_ZOOM;
    },

    _removeEntrance: function (e) {
        if (e.layer instanceof DG.Popup ||
            (e.layer instanceof DG.Entrance && e.layer !== this)) {

            this.remove();
        }
    }
});

DG.entrance = function (options) {
    return new DG.Entrance(options);
};

DG.Entrance.SHOW_FROM_ZOOM = 16;
DG.Entrance.PATH_ANIMATION = {
    animation: {
        'function': DG.Animation.EASE_IN_OUT,
        'duration': 750
    }
};
DG.Entrance.BOUNCE_ANIMATION = {
    animation: [
        {'function': DG.Animation.EASE_IN_OUT, 'duration': 250, 'frames': {'distance': {'from': 0, 'to': 0.6}}},
        {'function': DG.Animation.EASE_IN, 'duration': 135, 'frames': {'distance': {'from': 0.6, 'to': 0}}},
        {'function': DG.Animation.EASE_OUT, 'duration': 135, 'frames': {'distance': {'from': 0, 'to': 0.16}}},
        {'function': DG.Animation.EASE_IN, 'duration': 90, 'frames': {'distance': {'from': 0.16, 'to': 0}}},
        {'function': DG.Animation.EASE_OUT, 'duration': 90, 'frames': {'distance': {'from': 0, 'to': 0.06}}},
        {'function': DG.Animation.EASE_IN, 'duration': 50, 'frames': {'distance': {'from': 0.06, 'to': 0}}}
    ]
};

/*
 * DG.Entrance.Arrow class hosts two layers, one for arrow body (path) and one for arrow tip
 * It overrides projection events from hosted layers to minimize total overhead
 * Actual calculations produced in DG.ArrowPathTransform and DG.ArrowTipTransform classes
 */

DG.Entrance.Arrow = DG.FeatureGroup.extend({
    initialize: function (options) {
        DG.LayerGroup.prototype.initialize.call(this);

        DG.setOptions(this, options);

        this._progress = 1;
        this._distance = 0;
        this._visibility = {
            isShown: false
        };
        this._position =
            options.latlngs[options.latlngs.length - 1];
        this._shape =
            this.options.shape ||
            DG.Entrance.Arrow.SHAPE;

        this._apt = {}; // DG.ArrowPathTransform objects by zoom levels
        this._att = {}; // DG.ArrowTipTransform objects by zoom levels
    },

    beforeAdd: function (map) {
        //  this._map is not initialized yet, so we can freely addLayer(s)
        var opts = this.options;

        //  TODO: Check Canvas processing order
        //  Additional logic to DISABLE animation on Canvas for now!
        if (opts.animation && !map.options.preferCanvas && !DG.Browser.ielt9) {
            opts.animation.on('step', this._animation, this);
        } else {
            opts.animation = null;
        }

        this.projection();

        this.addLayer(new DG.ComplexPath({
            lineCap: 'butt',
            color: opts.color,
            fillColor: opts.fillColor,
            interactive: opts.interactive,
            visibility: this._visibility,
            transform: this._apt
        }));

        this.addLayer(new DG.ComplexPath({
            lineJoin: 'miter',
            color: opts.color,
            fillColor: opts.fillColor,
            interactive: opts.interactive,
            visibility: this._visibility,
            transform: this._att
        }));
    },

    getEvents: function () {
        return {
            zoomend: this._project,
            moveend: this._update,
            viewreset: this._reset
        };
    },

    setVisibility: function (isShown) {
        if (this._visibility.isShown !== isShown) {
            this._visibility.isShown = isShown;
            if (isShown) {
                if (!this.options.animation) {
                    this._reset();
                }
            } else {
                this._reset();
            }
        }
    },

    getBounds: function () {
        return this.options.bounds;
    },

    projection: function () {
        var map = this._map || this._mapToAdd;
        var zoom = map ? map.getZoom() : 0;
        var vertices = this._shape.vertices[zoom];
        var drawings = this._shape.drawings[zoom];
        var latlngs = this.options.latlngs;
        var shape, path, lastPoint, prevPoint;

        if (zoom && vertices && drawings) {
            if (!this._att[zoom]) {
                path = DG.ArrowPathTransform.getTranslatedPath(map, latlngs);
                shape = {vertices: vertices, drawings: drawings};
                this._att[zoom] = new DG.ArrowTipTransform(path, shape);
                this._apt[zoom] = new DG.ArrowPathTransform(path);
            }

            lastPoint = map.latLngToLayerPoint(this._position);
            prevPoint = map.latLngToLayerPoint(latlngs[latlngs.length - 2]);
            if (!this._apt[zoom]._pxBounds) {
                //  One-time action per 'viewreset' event
                //  Caching _pxBounds for using with Canvas renderer
                this._setBounds(lastPoint, prevPoint, this._apt[zoom], this._att[zoom]);
            }
            if (this.options.distance) {
                //  Arrow position recalculated for Bounce animation effect
                lastPoint = DG.VertexTransform.getScaled(lastPoint, prevPoint, this._distance);
            }

            //  Main calculations
            //  Get part of the arrow path and move (bound) arrow tip to it
            this._apt[zoom].subPath(this._progress).translate(lastPoint);
            this._att[zoom].subShape(this._apt[zoom]).translate(lastPoint);
        }

        return this;
    },

    _animation: function (e) {
        if (e.distance != undefined) {
            this._distance = e.distance;    //  bounce animation effect
        } else {
            this._progress = e.progress;    //  path animation effect
        }
        if (this._visibility.isShown) {
            //  TODO: Additional logic for animation on Canvas
            // this.projection().invoke('redraw');

            this._project();
            this._update();
        }
    },

    _project: function () {
        this.projection().invoke('_project');
    },

    _update: function () {
        this.invoke('_update');
    },

    _reset: function () {
        this._resetBounds();

        this._project();
        this._update();
    },

    _resetBounds: function () {
        //  Canvas renderer specific
        var z;

        for (z in this._apt) {
            this._apt[z]._pxBounds = null;
        }

        for (z in this._att) {
            this._att[z]._pxBounds = null;
        }
    },

    _setBounds: function (pl, pp, apt, att) {
        var _apt = apt.subPath(1).translate(pl).vertices,
            _att = att.subShape(apt).translate(pl).vertices;

/*
        //  TODO: Additional logic for animation on Canvas
        if (this.options.distance) {
            pl = DG.VertexTransform.getScaled(pl, pp, 1);
            _apt = _apt.concat(apt.subPath(1).translate(pl).vertices);
            _att = _att.concat(att.subShape(apt).translate(pl).vertices);
        }
*/
        apt._pxBounds = new DG.Bounds(_apt);
        att._pxBounds = new DG.Bounds(_att);
    }
});

DG.entrance.arrow = function (options) {
    return new DG.Entrance.Arrow(options);
};

/*
 * Predefined arrow tips
 */

/* eslint-disable array-bracket-spacing */
DG.Entrance.Arrow.SHAPE = {
    vertices: {
        16: [
            [ -6.5000,  -1.8000],
            [ -6.0522,  -1.8000],
            [ -7.0975,  -5.2537],
            [ -6.6619,  -6.2565], [ -6.5980,  -6.3550], [ -6.1757,  -6.1470],
            [  0.8371,  -0.3552],
            [  0.9275,  -0.1764], [  0.9275,   0.1764], [  0.8371,   0.3552],
            [ -6.1757,   6.1470],
            [ -6.5980,   6.3550], [ -6.6619,   6.2565], [ -7.0975,   5.2537],
            [ -6.0522,   1.8000],
            [ -6.5000,   1.8000]
        ],
        17: [
            [ -9.0000,  -2.4000],
            [ -7.8890,  -2.4000],
            [ -9.9245,  -7.2548],
            [ -9.3363,  -8.6404], [ -9.3448,  -8.6448], [ -8.8717,  -8.3508],
            [  1.0285,  -0.3552],
            [  1.1190,  -0.1764], [  1.1190,   0.1764], [  1.0285,   0.3552],
            [ -8.8717,   8.3508],
            [ -9.3448,   8.6448], [ -9.3363,   8.6404], [ -9.9245,   7.2548],
            [ -7.8890,   2.4000],
            [ -9.0000,   2.4000]
        ],
        18: [
            [-11.5000,  -3.0000],
            [-10.0795,  -3.0000],
            [-12.4909,  -9.3173],
            [-11.8402, -10.7654], [-11.5986, -10.7073], [-10.9380, -10.2258],
            [  1.1497,  -0.3552],
            [  1.2402,  -0.1764], [  1.2402,   0.1764], [  1.1497,   0.3552],
            [-10.9380,  10.2258],
            [-11.5986,  10.7073], [-11.8402,  10.7654], [-12.4909,   9.3173],
            [-10.0795,   3.0000],
            [-11.5000,   3.0000]
        ],
        19: [
            [-13.0000,  -3.6000],
            [-11.6600,  -3.6000],
            [-14.1696, -10.8351],
            [-13.5189, -12.2832], [-13.2773, -12.2251], [-12.6167, -11.7436],
            [  1.3061,  -0.3552],
            [  1.3966,  -0.1764], [  1.3966,   0.1764], [  1.3061,   0.3552],
            [-12.6167,  11.7436],
            [-13.2773,  12.2251], [-13.5189,  12.2832], [-14.1696,  10.8351],
            [-11.6600,   3.6000],
            [-13.0000,   3.6000]
        ]
    },
    drawings: {
        16: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
        17: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
        18: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L'],
        19: ['M', 'L', 'L', 'C', 'L', 'C', 'L', 'C', 'L', 'L']
    }
};
/* eslint-enable array-bracket-spacing */


(function (vertices) {
    for (var i in vertices) {
        vertices[i] = vertices[i].map(function (vertex) { return DG.point(vertex); });
    }
})(DG.Entrance.Arrow.SHAPE.vertices);

DG.Label = DG.Layer.extend({

    options: {
        offset: new DG.Point(12, 15),
        className: 'dg-label',
        zIndexOffset: 0
    },

    _typeOfString : Object.prototype.toString.call('s'),
    _defaultZIndex: 100,

    initialize: function (content, options) {
        DG.Util.setOptions(this, options);

        this._animated = DG.Browser.any3d;
        this._content = content;
    },

    onAdd: function (map) {
        this._map = map;

        if (!this._el) {
            this._initDOM();
        }

        this._visible = true;

        this
            .setContent(this._content)
            ._onViewReset();

        map
            .on('viewreset', this._onViewReset, this)
            .on('zoomanim', this._onZoomAnimation, this);
    },

    onRemove: function (map) {
        map
            .off('viewreset', this._onViewReset, this)
            .off('zoomanim', this._onZoomAnimation, this);

        this._visible = false;

        this._el.removeChild(this._container);
        DG.Util.falseFn(this._container.offsetWidth); // we need reflow here
        this._container = null;

        map.getPanes().markerPane.removeChild(this._el);
        this._el = null;
    },

    _initDOM: function () {
        this._el = DG.DomUtil.create(
                        'div',
                        this.options.className + ' leaflet-zoom-' + (this._animated ? 'animated' : 'hide'),
                        this._map.getPanes().markerPane);
        this._el.style.zIndex = this._defaultZIndex + this.options.zIndexOffset;

        this._container = DG.DomUtil.create('div', this.options.className + '__content', this._el);
        DG.DomEvent
            .disableClickPropagation(this._el)
            .on(this._container, 'mousewheel', DG.DomEvent.stopPropagation)
            .on(this._container, 'contextmenu', DG.DomEvent.stopPropagation);
    },

    _onViewReset: function () {
        if (this._visible && this._latlng) {
            DG.DomUtil.setPosition(this._el, this._map.latLngToLayerPoint(this._latlng).add(this.options.offset), DG.Browser.ie);
        }
    },

    _onZoomAnimation: function (opt) {
        if (this._latlng) {
            DG.DomUtil.setPosition(this._el, this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).add(this.options.offset));
        }
    },

    setOffset: function (point) {
        if (point instanceof DG.Point) {
            this.options.offset = point;
            this._onViewReset();
        }
        return this;
    },

    setZIndexOffset: function (zIndex) {
        if (!isNaN(+zIndex)) {
            this.options.zIndexOffset = +zIndex;
            if (this._visible) {
                this._el.style.zIndex = this._defaultZIndex + this.options.zIndexOffset;
            }
        }
        return this;
    },

    setContent: function (content) {
        if (Object.prototype.toString.call(content) !== this._typeOfString) {
            return this;
        }
        this._content = content;
        if (this._visible) {
            this._container.innerHTML = content;
        }
        return this;
    },

    setPosition: function (latlng) {
        if (!(latlng instanceof DG.LatLng)) {
            return this;
        }

        this._latlng = latlng;
        this._onViewReset();
        return this;
    }
});

DG.label = function (content, options) {
    return new DG.Label(content, options);
};

DG.Marker.include({

    bindLabel: function (content, options) {
        if (this._label) {
            this._label.setContent(content);
            if (options) {
                if (this.options.offset !== options.offset) {
                    this._label.setOffset(this.options.offset = options.offset);
                }
                if (this.options.static !== options.static) {
                    this.unbindLabel().bindLabel(content, options);
                }
            }
        } else {
            options = DG.extend({
                offset: new DG.Point(5, 5)
            }, options);

            this._label = DG.label(content, options);

            this.once('remove', this._onMarkerRemove);

            if (options.static) {
                this.showLabel();
            } else {
                this
                    .on('mouseover', this._mouseOverLabel)
                    .on('mouseout', this._mouseOutLabel)
                    .on('dragstart', this._dragStartLabel)
                    .on('dragend', this._dragEndLabel);
            }

            if (typeof this._map !== 'undefined') {
                this._updateLabelZIndex();
            } else {
                this.once('add', this._updateLabelZIndex);
            }
        }
        return this;
    },

    unbindLabel: function () {
        if (this._label) {
            this
                .hideLabel()
                .off('remove', this.unbindLabel)
                .off('mouseover', this._mouseOverLabel)
                .off('mouseout', this._mouseOutLabel)
                .off('dragstart', this._dragStartLabel)
                .off('dragend', this._dragEndLabel)
                .off('move', this._updatePosition)
                .off('add', this._updateLabelZIndex);

            this._label = null;
        }
        return this;
    },

    _onMarkerRemove: function () {
        if (this._label) {
            var content = this._label._content;
            this.once('add', function () {
                if (this._label) { return; } // new label added after removing marker
                this.bindLabel(content);
            });
            this.unbindLabel();
        }
    },

    getLabel: function () {
        return this._label ? this._label : null;
    },

    _originalUpdateZIndex: DG.Marker.prototype._updateZIndex,
    _updateZIndex: function (offset) {
        if (!this._zIndex) {
            this._zIndex = 0;
        }
        this._originalUpdateZIndex(offset);
        this._updateLabelZIndex();
        return this;
    },

    _updateLabelZIndex: function () {
        if (this._label && this._icon) {
            this._label.setZIndexOffset(this._icon.style.zIndex);
        }
        return this;
    },

    showLabel : function () {
        if (this._label) {
            this
                .on('move', this._updatePosition)
                ._map.addLayer(this._label.setPosition(this.getLatLng()));
        }

        return this;
    },

    hideLabel : function () {
        if (this._label) {
            this
                .off('move', this._updatePosition)
                ._map.removeLayer(this._label);
        }
        return this;
    },

    _updatePosition : function () {
        this._label.setPosition(this.getLatLng());
    },

    _dragStartLabel: function () {
        this._label.isMarkerDragging = true;

        this.hideLabel();
    },

    _dragEndLabel: function () {
        this._label.isMarkerDragging = false;

        if (this._label.isMouseOverMarker) {
            this.showLabel();
        }
    },

    _mouseOverLabel: function () {
        this._label.isMouseOverMarker = true;

        if (!this._label.isMarkerDragging) {
            this.showLabel();
        }
    },

    _mouseOutLabel: function () {
        this._label.isMouseOverMarker = false;

        this.hideLabel();
    }
});

DG.Marker.addInitHook(function () {
    if (typeof this.options.label !== 'undefined') {
        this.bindLabel(this.options.label);
    }
});

DG.Path.include({
    bindLabel: function (content, options) {

        if (!this._label) {
            this._label = DG.label(content, options);
            this.on(this._labelEvents, this);
        } else {
            this._label.setContent(content);

            if (this._label.options.offset !== options.offset) {
                this._label.setOffset(options.offset);
            }
        }
        return this;
    },

    unbindLabel: function () {
        if (this._label) {
            this.off(this._labelEvents, this);
            this._map.removeLayer(this._label);
            this._label = null;
        }
        return this;
    },

    getLabel: function () {
        return this._label ? this._label : null;
    },

    _labelEvents : {
        mouseover: function (event) {
            this._map.addLayer(this._label.setPosition(event.latlng));
        },
        mousemove: function (event) {
            this._label.setPosition(event.latlng);
        },
        mouseout: function () {
            this._map.removeLayer(this._label);
        },
        remove: function () {
            this._map.removeLayer(this._label);
        }
    }
});

DG.Path.addInitHook(function () {
    if (typeof this.options.label !== 'undefined') {
        this.bindLabel(this.options.label);
    }
});

DG.Entrance.include({
    bindLabel: function (content, options) {

        if (!this._label) {
            this._label = DG.label(content, options);
            this.on(this._labelEvents, this);
        } else {
            this._label.setContent(content);

            if (this._label.options.offset !== options.offset) {
                this._label.setOffset(options.offset);
            }
        }
        return this;
    },

    unbindLabel: function () {
        if (this._label) {
            this.off(this._labelEvents, this);
            this._map.removeLayer(this._label);
            this._label = null;
        }
        return this;
    },

    getLabel: function () {
        return this._label ? this._label : null;
    },

    _labelEvents : {
        mouseover: function (event) {
            this._map.addLayer(this._label.setPosition(event.latlng));
        },
        mousemove: function (event) {
            this._label.setPosition(event.latlng);
        },
        mouseout: function () {
            this._label.remove();
        },
        remove: function () {
            this._label.remove();
        }
    }
});

DG.Entrance.addInitHook(function () {
    if (typeof this.options.label !== 'undefined') {
        this.bindLabel(this.options.label);
    }
});

DG.configTheme = DG.configTheme || {};

DG.configTheme.balloonOptions = {
    offset: {
        x: 1,
        y: -43
    }
};

_dereq_('../../../vendors/baron');

// 2GIS-related popup content wrapper and offset
(function () {
    var offsetX = DG.configTheme.balloonOptions.offset.x,
        offsetY = DG.configTheme.balloonOptions.offset.y,
        originalInitialize = DG.Popup.prototype.initialize,
        originalInitLayout = DG.Popup.prototype._initLayout,
        originalOnAdd = DG.Popup.prototype.onAdd,
        originalAdjustPan = DG.Popup.prototype._adjustPan,
        graf = baron.noConflict();

    var BaronDomHelper = function (element) {
        this[0] = element;
        this.length = 1;
    };
    BaronDomHelper.prototype = {
        setAttribute: function (name, value) {
            this[0].setAttribute(name, value);
            return this;
        },
        getAttribute: function (name) {
            return this[0].getAttribute(name);
        },
        removeAttribute: function (name) {
            this[0].removeAttribute(name);
            return this;
        },
        css: function (style, value) {
            if (value) {
                this[0].style[style] = value;
                return this;
            } else {
                return DG.DomUtil.getStyle(this[0], style);
            }
        }
    };

    DG.Popup.prototype.options.offset = DG.point(offsetX, offsetY);

    DG.Popup.mergeOptions({
        border: 16,
        mapControlsWidth: 60
    });

    DG.Popup.include({
        _headerContent: null,
        _footerContent: null,

        //baron elements references
        _scroller: null,
        _scrollerBar: null,
        _barWrapper: null,
        _baron: null,
        _isBaronExist: false,

        _popupShowClass: 'leaflet-popup_show_true',
        _popupHideClass: 'leaflet-popup_show_false',

        _popupTipClass: 'leaflet-popup-tip-container',
        _tipSVGPath: 'M0 0c12.643 0 28 7.115 28 44h2c0-36.885 15.358-44 28-44h-58z',

        _isAutoPanPaddingUserDefined: false,

        initialize: function (options, source) { // (Object, Object)
            this._popupStructure = {};
            this._isAutoPanPaddingUserDefined = options && options.hasOwnProperty('autoPanPadding');
            originalInitialize.call(this, options, source);
        },

        onAdd: function (map) { // (Map)
            map.on({
                entranceshow: this._closePopup,
                resize: this.resize
            }, this);
            originalOnAdd.call(this, map);
            this._animateOpening();
        },

        onRemove: function (map) { // (Map)
            this._animateClosing();
            map.off({
                entranceshow: this._closePopup,
                resize: this.resize
            }, this);

            if (DG.DomUtil.TRANSITION) {
                this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
            } else {
                L.DomUtil.remove(this._container);
            }

            map.fire('popupclose', {popup: this});

            if (this._source) {
                this._source.fire('popupclose', {popup: this}, true);
            }
        },

        setContent: function (content) { // (DOMElement | Object | HTML) -> Popup
            if (!this._isNode(content) && typeof content === 'object') {
                Object.keys(content).forEach(function (item) {
                    this['_' + item + 'Content'] = content[item];
                }, this);
            } else {
                this._bodyContent = content;
            }

            this.update();

            return this;
        },

        setHeaderContent: function (content) { // (HTML) -> Popup
            this._headerContent = content;
            this.update();

            return this;
        },

        setFooterContent: function (content) { // (HTML) -> Popup
            this._footerContent = content;
            this.update();

            return this;
        },

        getContent: function () { // () -> HTML
            return this._bodyContent;
        },

        getHeaderContent: function () { // () -> HTML
            return this._headerContent;
        },

        getFooterContent: function () { // () -> HTML
            return this._footerContent;
        },

        clear: function () { // () -> Popup
            Object.keys(this._popupStructure).forEach(this._clearElement, this);

            // think about move this set to another public method
            this._isBaronExist = false;
            return this;
        },

        clearHeader: function () { // () -> Popup
            return this._clearElement('header');
        },

        clearFooter: function () { // () -> Popup
            return this._clearElement('footer');
        },

        findElement: function (element) { // (String) -> DOMElement
            return this._contentNode.querySelector(element);
        },

        _animateOpening: function () {
            DG.DomUtil.addClass(this._innerContainer, this._popupShowClass);
            DG.DomUtil.removeClass(this._innerContainer, this._popupHideClass);
        },

        _animateClosing: function () {
            DG.DomUtil.addClass(this._innerContainer, this._popupHideClass);
            DG.DomUtil.removeClass(this._innerContainer, this._popupShowClass);
        },

        _closePopup: function () {
            this._map.closePopup(this);
        },

        _isNode: function (o) { // (Object) -> Boolean
            return (o.nodeName ? true : false);
        },

        _close: function () {
            if (this._map) {
                if (DG.Browser.mobile && this._map.geoclicker &&
                    (this.options.closeOnClick || this._map.options.closePopupOnClick)) {
                    //  We need to signal geoclicker that popup was open before 'click' event
                    //  But by time it will get it's event the popup will be already closed
                    //  See 'DGGeoclicker' for '_mapEventsListeners' and '_singleClick' method
                    this._map.geoclicker.popupWasOpen = true;
                }

                this._map.closePopup(this);
            }
        },

        _initLayout: function () {
            originalInitLayout.call(this);
            this._innerContainer = DG.DomUtil.create('div', 'leaflet-popup-inner ' + this._popupHideClass, this._container);

            // Prevents mouse events from leaking through close button
            // See https://github.com/2gis/mapsapi/pull/153/
            DG.DomEvent.disableClickPropagation(this._innerContainer);

            if (this.options.closeButton) {
                this._innerContainer.appendChild(this._detachEl(this._closeButton));
            }

            this._innerContainer.appendChild(this._detachEl(this._wrapper));

            var tip = this._detachEl(this._tipContainer);

            if (DG.Browser.svg) {
                var path = DG.SVG.create('path');
                var svgClass = this._popupTipClass + ' ' + this._popupTipClass + '_svg';

                path.setAttribute('d', this._tipSVGPath);

                tip = DG.SVG.create('svg');
                tip.setAttribute('class', svgClass);

                tip.appendChild(path);
                DG.DomEvent.disableClickPropagation(path);
            } else {
                DG.DomUtil.addClass(tip, this._popupTipClass + '_image');
                DG.DomEvent.disableClickPropagation(tip);
            }

            this._innerContainer.appendChild(tip);
        },

        _clearElement: function (elem) { // (DOMElement) -> Popup
            this['_' + elem + 'Content'] = null;
            this._detachEl(this._popupStructure[elem]);
            delete this._popupStructure[elem];
            return this;
        },

        _updateScrollPosition: function () {
            if (this._baron) {
                this._baron.update();
            }
        },

        resize: function () {
            var scrolled = this._updateLayout();
            this._updatePosition();

            if (!scrolled) {
                if (this._isBaronExist) {
                    this._scrollerWrapper.style.height = '';
                    DG.DomUtil.removeClass(this._scroller, 'dg-scroller');

                    DG.DomUtil.addClass(this._scroller, 'dg-scroller_hidden_true');
                    DG.DomUtil.removeClass(this._scroller, 'dg-scroller');
                    DG.DomEvent.off(this._scroller, 'scroll', this._onScroll);
                }
            } else if (this._isBaronExist) {
                DG.DomUtil.removeClass(this._scroller, 'dg-scroller_hidden_true');
                DG.DomUtil.addClass(this._scroller, 'dg-scroller');

                var scrollTop = this._isBaronExist ? this._scroller.scrollTop : false;

                if (scrollTop) {
                    this._scroller.scrollTop = scrollTop;
                }

                var innerHeight = this.options.maxHeight - this.options.border * 2 - this._getDelta();
                this._scrollerWrapper.style.height = innerHeight + 'px';

                this._updateScrollPosition();
            } else if (!this._isContentHeightEnough()) {
                this._initBaronScroller();
                this._initBaron();
            }

            this._adjustPan();
            this._bindAdjustPanOnTransitionEnd();
        },

        _adjustPan: function (e) {
            if (!this._map) { return; }

            if (e) {
                if (e.propertyName === 'max-height') {
                    setTimeout(originalAdjustPan.bind(this), 1); //JSAPI-3409 fix safari glich
                    DG.DomEvent.off(this._wrapper, DG.DomUtil.TRANSITION_END, this._adjustPan);
                }

                return;
            }

            var options = this.options;

            if (!options.autoPan) { return; }

            var map = this._map,
                containerHeight = this._container.offsetHeight,
                containerWidth = this._containerWidth,
                layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

            if (this._zoomAnimated) {
                layerPos._add(L.DomUtil.getPosition(this._container));
            }

            var autoPanPadding = [options.autoPanPadding[0], options.autoPanPadding[1]];

            // if width of map is more then width of popup and controls
            // set default autoPanPadding to width controls
            if (
                !this._isAutoPanPaddingUserDefined &&
                    this._map._container.offsetWidth >= options.maxWidth + options.mapControlsWidth * 2
            ) {
                autoPanPadding[0] = options.mapControlsWidth;
            }

            var containerPos = map.layerPointToContainerPoint(layerPos),
                padding = L.point(autoPanPadding),
                paddingTL = L.point(options.autoPanPaddingTopLeft || padding),
                paddingBR = L.point(options.autoPanPaddingBottomRight || padding),
                size = map.getSize(),
                dx = 0,
                dy = 0;

            if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
                dx = containerPos.x + containerWidth - size.x + paddingBR.x;
            }
            if (containerPos.x - dx - paddingTL.x < 0) { // left
                dx = containerPos.x - paddingTL.x;
            }
            if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
                dy = containerPos.y + containerHeight - size.y + paddingBR.y;
            }
            if (containerPos.y - dy - paddingTL.y < 0) { // top
                dy = containerPos.y - paddingTL.y;
            }

            if (dx || dy) {
                map
                    .fire('autopanstart')
                    .panBy([dx, dy]);
            }
        },

        _bindAdjustPanOnTransitionEnd: function () {
            if (DG.DomUtil.TRANSITION) {
                DG.DomEvent.on(this._wrapper, DG.DomUtil.TRANSITION_END, this._adjustPan, this);
            } else {
                this._adjustPan();
            }
        },

        _isContentHeightEnough: function () { // () -> Boolean
            var options = this.options;

            if (!options.maxHeight) {
                return true;
            }

            var popupHeight = this._popupStructure.body ?
                this._popupStructure.body.offsetHeight + this._getDelta() :
                this._contentNode.offsetHeight;

            popupHeight += options.border * 2;

            return popupHeight <= options.maxHeight;
        },

        _initBaronScroller: function () {
            var contentNode = this._popupStructure.body.parentNode,
                scrollerWrapper = this._scrollerWrapper = DG.DomUtil.create('div', 'dg-scroller__wrapper', contentNode),
                scroller = this._scroller = DG.DomUtil.create('div', 'dg-scroller', scrollerWrapper),
                barWrapper = this._barWrapper = DG.DomUtil.create('div', 'dg-scroller__bar-wrapper', scroller),
                innerHeight = this.options.maxHeight - this.options.border * 2;

            this._scrollerBar = DG.DomUtil.create('div', 'dg-scroller__bar', barWrapper);
            scroller.appendChild(this._detachEl(this._popupStructure.body));

            innerHeight -= this._getDelta();
            scrollerWrapper.style.height = Math.max(18, innerHeight) + 'px';
            scrollerWrapper.style.width = contentNode.offsetWidth + 5 + 'px'; //TODO

            this._isBaronExist = true;

            this._switchEvents();
        },

        _onScroll: function (e) {
            this.fire('scroll', {originalEvent: e});
        },

        _onClick: function (e) {
            e.target = e.target || e.srcElement;

            if (!this._moving) {
                this.fire('click', {originalEvent: e});
            }
        },

        _onStart: function (e) {
            this._moved = false;

            if (this._moving) { return; }

            var first = e.touches ? e.touches[0] : e;

            this._startPoint = new DG.Point(first.clientX, first.clientY);

            this._toggleTouchEvents();
        },

        _onEnd: function (e) {
            this._toggleTouchEvents(true);

            this._onClick(e);

            this._moving = false;
        },

        _onMove: function (e) {

            if (e.touches && e.touches.length > 1) {
                this._moved = true;
                return;
            }

            var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
                newPoint = DG.point(first.clientX, first.clientY),
                offset = Math.abs(newPoint.subtract(this._startPoint).y);

            if (!offset || offset < 10) { return; }

            this._moving = this._moved = true;

        },

        _initBaron: function () {
            var context = this._scrollerWrapper;
            this._baron = graf({
                scroller: '.dg-scroller',
                bar: '.dg-scroller__bar',
                track: '.dg-scroller__bar-wrapper',
                $: function (selector) {
                    var node = {}.toString.call(selector) === '[object String]' ?
                        context.querySelector(selector) : selector;

                    return new BaronDomHelper(node);
                },
                event: function (elem, event, func, mode) {
                    event.split(' ').forEach(function (type) {
                        DG.DomEvent[mode || 'on'](elem, type, func);
                    });
                }
            });
        },

        _initHeader: function () {
            this._popupStructure.header = DG.DomUtil.create('header', 'dg-popup__header', this._contentNode);
        },

        _initFooter: function () {
            this._popupStructure.footer = DG.DomUtil.create('footer', 'dg-popup__footer', this._contentNode);
        },

        _initBodyContainer: function () {
            this._popupStructure.wrapper = DG.DomUtil.create('div', 'dg-popup__container-wrapper', this._contentNode);
            this._popupStructure.body = DG.DomUtil.create('div', 'dg-popup__container', this._popupStructure.wrapper);
        },

        update: function () {
            if (!this._map) { return; }

            if (!DG.Browser.ielt9) {
                this._container.style.visibility = 'hidden';
            }
            this._switchEvents(true);

            this._clearNode(this._contentNode);
            this._isBaronExist = false;

            // init popup content dom structure
            if (this._headerContent) { this._initHeader(); }
            if (this._bodyContent) { this._initBodyContainer(); }
            if (this._footerContent) { this._initFooter(); }

            this._updatePopupStructure();
            this.resize();

            DG.DomEvent.on(this._wrapper, 'click', DG.DomEvent.stopPropagation);
            this._switchEvents();

            if (DG.Browser.ielt9) {
                var elem = this._popupStructure.footer;
                if (elem) {
                    elem.className += ' ie8';
                }
            }

            if (!DG.Browser.ielt9) {
                this._container.style.visibility = '';
            }
        },

        _getDelta: function () { // () -> Number
            var delta = 0,
                popup = this._popupStructure;

            if (popup.header) {
                delta += popup.header.offsetHeight;
            }
            if (popup.footer) {
                delta += popup.footer.offsetHeight;
            }

            return delta;
        },

        _updateLayout: function () {
            var opts = this.options,
                content = this._contentNode, // leaflet-popup-content
                wrapper = this._wrapper, // leaflet-popup-content-wrapper
                style = content.style,
                wrapperStyle = wrapper.style,
                width,
                scrolledClass = 'leaflet-popup-scrolled',
                result = false;

            style.margin = opts.border + 'px';

            DG.DomUtil.removeClass(content, scrolledClass);

            if (this._isContentHeightEnough()) {
                wrapperStyle.maxHeight = content.offsetHeight + opts.border * 2 + 'px';
            } else {
                wrapperStyle.maxHeight = opts.maxHeight + 'px';
                DG.DomUtil.addClass(content, scrolledClass);
                result = true;
            }

            var availableWidth = opts.autoPanPadding[0] * 2;

            if (opts.sprawling) {
                width = opts.maxWidth;

                width = Math.min(width, this._map._container.offsetWidth - availableWidth);
                width = Math.max(width, opts.minWidth);
            } else {
                wrapperStyle.width = '';

                style.whiteSpace = 'nowrap';
                width = wrapper.offsetWidth;
                style.whiteSpace = '';

                width = Math.min(width, this._map._container.offsetWidth - availableWidth);
                width = Math.min(Math.max(width, opts.minWidth), opts.maxWidth);
            }

            wrapperStyle.width = width + 'px';

            this._containerWidth = this._container.offsetWidth;

            return result;
        },

        _updatePopupStructure: function () {
            Object.keys(this._popupStructure).forEach(function (item) {
                this._insertContent(this['_' + item + 'Content'], this._popupStructure[item]);
            }, this);

            this.fire('contentupdate');
        },

        _insertContent: function (content, node) { // (String | DOMElement, DOMElement)
            if (!content || !node) { return; }

            content = (typeof content === 'function') ? content(this._source || this) : content;

            if (typeof content === 'string') {
                node.innerHTML = content;
            } else {
                this._clearNode(node);
                node.appendChild(content);
            }
        },

        _clearNode: function (node) { // (DOMElement)
            while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
            }
        },

        _detachEl: function (elem) { // (DOMElement) -> DOMElement
            if (elem.parentNode) {
                elem.parentNode.removeChild(elem);
            }
            return elem;
        },

        _switchEvents: function (on) { // (Boolean)
            var switcher = on ? 'off' : 'on';

            if (!DG.Browser.touch) {
                DG.DomEvent[switcher](this._contentNode, 'click', this._onClick, this);
            } else {
                DG.DomEvent[switcher](this._contentNode, 'touchstart mousedown mousemove', this._onStart, this);
            }

            if (this._isBaronExist) {
                DG.DomEvent[switcher](this._scroller, 'scroll', this._onScroll, this);
            }
        },

        _toggleTouchEvents: function (on) {
            var switcher = on ? 'off' : 'on';

            DG.DomEvent
                [switcher](this._contentNode, 'touchmove', this._onMove, this)
                [switcher](this._contentNode, 'touchend', this._onEnd, this);
        }

    });
}());


DG.Map.include({
    _markerClass: 'dg-customization__marker_type_mushroom',
    _markerShowClass: 'dg-customization__marker_appear',
    _markerHideClass: 'dg-customization__marker_disappear',
    _dgHideClass: 'dg-popup_hidden_true',
    openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
        if (!(popup instanceof L.Popup)) {
            var content = popup;

            popup = new L.Popup(options).setContent(content);
        }

        if (latlng) {
            popup.setLatLng(latlng);
        }

        if (this.hasLayer(popup)) {
            return this;
        }

        if (this._popup && this._popup.options.autoClose) {
            this.closePopup();
        }

        this._popup = popup;

        if (popup._source && popup._source._icon) {
            if (popup._source._icon.className.indexOf(this._markerClass) !== -1) {
                DG.DomUtil.removeClass(popup._source._icon, this._markerShowClass);
                DG.DomUtil.addClass(popup._source._icon, this._markerHideClass);
            } else {
                DG.DomUtil.addClass(popup._source._icon, this._dgHideClass);
                if (popup._source._shadow) {
                    DG.DomUtil.addClass(popup._source._shadow, this._dgHideClass);
                }
            }
        }

        return this.addLayer(popup);
    },

    closePopup: function (popup) {  // (Popup) -> Popup
        if (!popup || popup === this._popup) {
            popup = this._popup;
            this._popup = null;
        }
        if (popup) {
            if (popup._source && popup._source._icon) {
                if (popup._source._icon.className.indexOf(this._markerClass) !== -1) {
                    DG.DomUtil.removeClass(popup._source._icon, this._markerHideClass);
                    DG.DomUtil.addClass(popup._source._icon, this._markerShowClass);
                } else {
                    DG.DomUtil.removeClass(popup._source._icon, this._dgHideClass);
                    if (popup._source._shadow) {
                        DG.DomUtil.removeClass(popup._source._shadow, this._dgHideClass);
                    }
                }
            }
            this.removeLayer(popup);
        }

        return this;
    }
});

DG.Dictionary = {};

DG.Dictionary.ru = {
    pluralRules: function (n) { // (Number)
        if (n % 10 === 1 && n % 100 !== 11) { // 1, 21
            return 0;
        }
        if ((n % 10 >= 2 && n % 10 <= 4 && (n % 10) % 1 === 0) && (n % 100 < 12 || n % 100 > 14)) { // 2, 3
            return 1;
        }

        if ((n % 10 === 0) || (n % 10 >= 5 && n % 10 <= 9 && (n % 10) % 1 === 0) || (n % 100 >= 11 && (n % 100) <= 14 && (n % 100) % 1 === 0)) { // 13, 17
            return 2;
        }
    }
};

DG.Dictionary.en = {
    pluralRules: function (n) { // (Number)
        if (n === 1) { // 1
            return 0;
        } else {
            return 1; //0, 2, 3, 4 ..
        }
    }
};

DG.Dictionary.it = {
    pluralRules: function (n) { // (Number)
        if (n === 1) { // 1
            return 0;
        } else {
            return 1; //0, 2, 3, 4 ..
        }
    }
};

DG.Dictionary.cs = {
    pluralRules: function (n) { // (Number)
        return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
    }
};

DG.Dictionary.es = {
    pluralRules: function (n) { // (Number)
        return (n >= 2) ? 1 : 0;
    }
};

DG.Locale = {
    t: function (msg, argument) { // (String, Number) -> String
        var result,
            lang = this._map.getLang(),
            msgIsset = false,
            dictionaryMsg,
            exp;

        if (typeof this.constructor.Dictionary[lang] === 'undefined') {
            lang = DG.config.defaultLang;
            this._map.setLang(lang);
        }
        dictionaryMsg = this.constructor.Dictionary[lang][msg];
        msgIsset = typeof dictionaryMsg !== 'undefined';
        if (!msgIsset) {
            return msg;
        }
        result = msgIsset ? dictionaryMsg : msg;

        if (argument !== undefined) {
            argument = parseInt(argument, 10);
            argument = isNaN(argument) ? 0 : argument;
            exp = this.constructor.Dictionary[lang].pluralRules(argument);
            result = dictionaryMsg[exp];
        }

        result = DG.Util.template(result, {n: argument});
        return result ? result : msg;
    }
};

DG.Map.include({
    setLang: function (lang) { // (String)
        if (lang && Object.prototype.toString.call(lang) === '[object String]') {
            this.options.currentLang = lang;
            this.fire('langchange', {'lang': lang});
        }
    },

    getLang: function () { // () -> String
        // If the language hasn't been set before, set it to page language or
        // default language from config
        if (!this.options.currentLang) {
            var root = document.documentElement;
            var lang = root.lang || (root.getAttributeNS && root.getAttributeNS('http://www.w3.org/XML/1998/namespace', 'lang')) || DG.config.defaultLang;

            this.options.currentLang = lang;
        }

        return this.options.currentLang;
    }
});

DG.RoundControl = DG.Control.extend({
    includes: DG.Mixin.Events,

    options: {
        position: 'topright',
        iconClass: 'default'
    },

    onAdd: function (map) {
        var controlClass = this._controlCLass = 'dg-control-round',
            controlIconClass = this._controlIconCLass = this._controlCLass + '__icon',
            container = DG.DomUtil.create('div', '');

        if (this._disable) {
            return container;
        }
        DG.DomUtil.addClass(container, controlClass);

        var link = this._link = DG.DomUtil.create(
            'a',
            controlIconClass + ' ' + controlIconClass + '_name_' + this.options.iconClass,
            container
        );

        link.href = '#';

        this._renderTranslation();

        this._map = map;

        DG.DomEvent
            .on(container, 'click', this._toggleControl, this)
            .on(container, 'dblclick', DG.DomEvent.stopPropagation)
            .on(link, 'mousedown', DG.DomEvent.stopPropagation);

        this.fireEvent('add');

        return container;
    },

    onRemove: function () {
        this.fireEvent('remove');
        DG.DomEvent.off(this._link, 'click', this._toggleControl);
    },

    setState: function (state) {
        if (!this._link || !this._container) {
            return this;
        }

        if (this._state) {
            DG.DomUtil.removeClass(this._container, this._controlCLass + '_state_' + this._state);
            DG.DomUtil.removeClass(this._link, this._controlIconCLass + '_state_' + this._state);

            this._state = null;
        }

        if (state) {
            this._state = state;

            DG.DomUtil.addClass(this._container, this._controlCLass + '_state_' + this._state);
            DG.DomUtil.addClass(this._link, this._controlIconCLass + '_state_' + this._state);
        }

        return this;
    },

    _toggleControl: function (e) {
        DG.DomEvent.stop(e);
        this.fireEvent('click');
    }
});

DG.RoundControl.include(DG.Locale);

DG.roundControl = function (options) {
    return new DG.RoundControl(options);
};

DG.configTheme = DG.configTheme || {};

DG.configTheme.markersData = {
    iconSize: [22, 34],
    className: 'dg-customization__marker dg-customization__marker_type_mushroom',
    iconAnchor: [10, 32]
};

// Fix a lot of bugs with pinch-zooming
// See https://github.com/2gis/mapsapi/issues/327
DG.Map.mergeOptions({
    bounceAtZoomLimits: false
});

//Inject observing localization change
var controlAddTo = DG.Control.prototype.addTo;

DG.Control.include({
    addTo: function (map) {
        map.on('langchange', this._renderTranslation, this);

        return controlAddTo.call(this, map);
    },
    _renderTranslation: function () {}
});

// Add some browser detection
DG.Browser.safari51 = DG.Browser.safari && navigator.userAgent.indexOf('Version/5.1') !== -1;

// Applies 2GIS divIcon to marker
DG.Marker.prototype.options.icon = DG.divIcon(DG.configTheme.markersData);

// support old option clickable
var utilSetOptions = DG.Util.setOptions;

DG.setOptions = L.setOptions = DG.Util.setOptions = function (obj, options) {
    if (options && typeof options.clickable !== 'undefined') {
        options.interactive = options.clickable;
    }

    return utilSetOptions.call(this, obj, options);
};

DG.Layer.mergeOptions({
    nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
});

var initMap = DG.Map.prototype.initialize,
    panBy = DG.Map.prototype.panBy,
    getBoundsZoom = DG.Map.prototype.getBoundsZoom,
    setMaxZoom = DG.Map.prototype.setMaxZoom;

// Restrict zoom level according to 2gis projects, in case if dgTileLayer is only one
DG.Map.include({

    // number of tileLayers without 2gis layers
    _tileLayersNumber: 0,

    _mapMaxZoomCache: null,

    //TODO try refactor it after up on new leaflet (> 0.7)
    initialize: function (id, options) { // (HTMLElement or String, Object)
        // Override default wheelPxPerZoomLevel value to avoid zooming too fast
        // on mouse wheel rotation
        // See https://github.com/2gis/mapsapi/issues/343
        options = DG.extend({wheelPxPerZoomLevel: 10000}, options);

        initMap.call(this, id, options);

        //  Project must be checked after BaseLayer init which occurs in InitHook (see orig method definition)
        if (this.options.center && this.options.zoom !== undefined) {
            this.setView(DG.latLng(this.options.center), this.options.zoom, {reset: true});
        }
    },

    setView: function (center, zoom, options) {
        this._restrictZoom(center, zoom);

        zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
        center = this._limitCenter(DG.latLng(center), zoom, this.options.maxBounds);
        options = options || {};

        if (options.animate) {
            options.animate = this._testAnimation(center);
        }

        this._stop();

        if (this._loaded && !options.reset && options !== true) {

            if (options.animate !== undefined) {
                options.zoom = DG.extend({
                    animate: options.animate,
                    duration: options.duration
                }, options.zoom);
                options.pan = DG.extend({
                    animate: options.animate,
                    duration: options.duration
                }, options.pan);
            }

            // try animating pan or zoom
            var animated = (this._zoom !== zoom) ?
            this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
                this._tryAnimatedPan(center, options.pan);

            if (animated) {
                // prevent resize handler call, the view will refresh after animation anyway
                clearTimeout(this._sizeTimer);
                return this;
            }
        }

        // animation didn't start, just reset the map view
        this._resetView(center, zoom);

        return this;
    },

    panBy: function (offset, options) {
        var map = panBy.call(this, offset, options);

        var zoom = this._restrictZoom(this.getCenter());
        if (this.getZoom() > zoom) {
            this.setZoom(zoom);
        }

        return map;
    },

    getBoundsZoom: function (bounds, inside, padding) {
        bounds = DG.latLngBounds(bounds);
        this._restrictZoom(bounds);
        return getBoundsZoom.call(this, bounds, inside, padding);
    },

    getTileLayersNumber: function () {
        return this._tileLayersNumber;
    },

    setMaxZoom: function (zoom) {
        this._mapMaxZoomCache = null;
        return setMaxZoom.call(this, zoom);
    },

    _testAnimation: function (coords) {//if we jump to other project - disable animation
        if (this.projectDetector.enabled()) {
            var projectFrom = this.projectDetector.getProject(),
                projectTo = this.projectDetector.isProjectHere(coords);

            if (projectFrom && projectTo) {
                return projectFrom.code === projectTo.code;
            }
        }

        return true;
    },

    _updateTileLayers: function (e) {
        if (!(e.layer instanceof DG.TileLayer) || e.layer._isDg) { return; }

        if (e.type === 'layeradd') {
            this._tileLayersNumber++;
        } else {
            this._tileLayersNumber--;
        }
    },

    _getNewBounds: function (coords, zoom) {
        if (coords instanceof DG.LatLngBounds) {
            return coords;
        }

        var point = this.project(coords, zoom);
        var screenSize = this.getSize().divideBy(2);

        var sw = this.unproject(point.subtract(screenSize), zoom);
        var ne = this.unproject(point.add(screenSize), zoom);

        return DG.latLngBounds(sw, ne);
    },

    _restrictZoom: function (coords, zoom) {
        if (this._layers &&
            this.projectDetector.enabled() &&
            (this._tileLayersNumber === 0)) {

            var mapOptions = this.options,
                isMapMaxZoom = !!mapOptions.maxZoom,
                dgTileLayer = this.baseLayer,
                bounds = this._getNewBounds(coords, zoom),
                project = this.projectDetector.isProjectHere(bounds);

            if (isMapMaxZoom) {
                if (!this._mapMaxZoomCache) {
                    if (this.baseLayer.options.detectRetina && DG.Browser.retina && mapOptions.maxZoom > 0) {
                        mapOptions.maxZoom--;
                    }

                    this._mapMaxZoomCache = mapOptions.maxZoom;
                }
                mapOptions.maxZoom = (this._mapMaxZoomCache && project) ? this._mapMaxZoomCache :  DG.config.projectLeaveMaxZoom;
                if (project) {
                    this._mapMaxZoomCache = mapOptions.maxZoom;
                }

                return mapOptions.maxZoom;
            } else {
                if (project) {
                    if (dgTileLayer.options.detectRetina && DG.Browser.retina && project.maxZoom > 0) {
                        dgTileLayer.options.maxZoom = project.maxZoom - 1;
                    } else {
                        dgTileLayer.options.maxZoom = project.maxZoom;
                    }
                } else {
                    dgTileLayer.options.maxZoom = DG.config.projectLeaveMaxZoom;
                }

                dgTileLayer.options.maxNativeZoom = dgTileLayer.options.maxZoom;
                this._updateZoomLevels();

                return dgTileLayer.options.maxZoom;
            }
        }
    }
});

DG.Map.addInitHook(function () {
    this.on('layeradd layerremove', this._updateTileLayers);
});

// Set css property touch-action to auto if dragging is false.
// Need for scrolling page in mobile using our map dom element.
// todo: I made issue in leaflet https://github.com/Leaflet/Leaflet/issues/4415
DG.Map.addInitHook(function () {
    if (this.options.dragging == false && this.options.tap == false) {
        DG.DomUtil.addClass(this._container, 'dg-dragging-false');
    }
});

DG.Map.addInitHook(function () {
    var errorUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX28t5R0k5UAAAAH0lEQVR4Xu3AAQkAAADCMPunNsdhWxwAAAAAAAAAwAEhAAABg2UP5AAAAABJRU5ErkJggg==';
    var errorRuUrl = DG.config.protocol + DG.config.baseUrl + '/img/nomap_ru.png';

    var BaseLayer = DG.TileLayer.extend({
        initialize: function (url, options) {
            this._isDg = true;
            DG.TileLayer.prototype.initialize.call(this, url, options);
        },

        getTiles: function () {
            return this._tiles;
        }
    });

    var tileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTileServer : DG.config.tileServer);

    this.baseLayer = new BaseLayer(tileUrl, {
        subdomains: '0123',
        errorTileUrl: this.getLang() === 'ru' ? errorRuUrl : errorUrl,
        detectRetina: DG.config.detectRetina,
        maxZoom: 19,
        maxNativeZoom: 19,
        zIndex: 0
    }).addTo(this);

    function updateErrorTileUrl () {
        var lang = this.getLang();
        var project = this.projectDetector && this.projectDetector.getProject();

        if (lang === 'ru' && !project) {
            this.baseLayer.options.errorTileUrl = errorRuUrl;
        } else {
            this.baseLayer.options.errorTileUrl = errorUrl;
        }
    }

    this.on({
        langchange: updateErrorTileUrl,
        projectchange: updateErrorTileUrl,
        projectleave: updateErrorTileUrl
    }, this);
});

DG.Map.mergeOptions({
    tilesCheck: true
});

DG.Map.TilesCheck = DG.Handler.extend({
    initialize: function (map) {
        this._map = map;
        this._layer = map.baseLayer;

        this._moveStartEventCounter = 0;
        this._moveEndEventCounter = 0;

        this._loadingEventCounter = 0;
        this._loadEventCounter = 0;
    },

    addHooks: function () {
        this._map.on(this._mapEvents, this);
        this._layer.on(this._layerEvents, this);
    },

    removeHooks: function () {
        this._map.off(this._mapEvents, this);
        this._layer.off(this._layerEvents, this);
    },

    _mapEvents: {
        layeradd: function (e) {
            if (e.layer == this._layer) {
                this.enable();
            }
        },

        layerremove: function (e) {
            if (e.layer == this._layer) {
                this.disable();
            }
        },

        movestart: function () {
            this._stopWaiting();

            this._moveStartEventCounter++;
            this._isWaiting = true;
        },

        moveend: function () {
            this._moveEndEventCounter++;

            if (!this._isWaiting && this._moveStartEventCounter !== this._moveEndEventCounter) { return; }

            this._isMoveEnd = true;

            this._checkWaiting();
        }
    },

    _layerEvents: {
        loading: function () {
            this._loadingEventCounter++;
        },

        load: function () {
            this._loadEventCounter++;

            if (!this._isWaiting && this._loadingEventCounter !== this._loadEventCounter) { return; }

            this._isLoad = true;

            this._checkWaiting();
        }
    },

    _stopWaiting: function () {
        this._isWaiting = false;
        this._isMoveEnd = false;
        this._isLoad = false;
    },

    _checkWaiting: function () {
        if (this._isWaiting && this._isLoad && this._isMoveEnd) {
            this._stopWaiting();
            this._resetCounters();
            this._checkTiles();
        }
    },

    _checkTiles: function () {
        if (this._map.getTileLayersNumber() !== 0 || !this._map._loaded) { return; }

        var zoom = this._map.getZoom();
        var errorUrl = this._layer.options.errorTileUrl;
        var tiles = this._layer.getTiles();

        for (var i in tiles) {
            if (tiles[i].coords.z === zoom && tiles[i].el.src !== errorUrl) {
                return;
            }
        }

        this._map.zoomOut();
    },

    _resetCounters: function () {
        this._moveStartEventCounter = 0;
        this._moveEndEventCounter = 0;

        this._loadingEventCounter = 0;
        this._loadEventCounter = 0;
    }
});

DG.Map.addInitHook('addHandler', 'tilesCheck', DG.Map.TilesCheck);

/**
 * This customization fixes unwanted inertia movement after sudden drag stops
 * See https://github.com/Leaflet/Leaflet/pull/4048.
 * If this PR ever gets merged, this file can be removed.
 */
var onDragEnd = DG.Map.Drag.prototype._onDragEnd;

DG.Map.Drag.include({
    _rememberTimeAndPosition: function () {
        var time = this._lastTime = +new Date(),
            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

        this._positions.push(pos);
        this._times.push(time);

        // Remove all data points older than 50 ms
        while (time - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
        }
    },

    _onDrag: function (e) {
        if (this._map.options.inertia) {
            this._rememberTimeAndPosition();
        }

        this._map
            .fire('move', e)
            .fire('drag', e);
    },

    _onDragEnd: function () {
        if (this._map.options.inertia && !DG.Browser.touch) {
            this._rememberTimeAndPosition();
        }

        onDragEnd.call(this);
    }
});

// from https://github.com/Turfjs/turf-inside/blob/master/index.js
DG.PolyUtil.inside = function (point, polygon, pointReduce) {
    pointReduce = pointReduce || DG.PolyUtil._defaultPointReduce;
    var polys = polygon.coordinates;
    var pt = pointReduce(point);

    // normalize to multipolygon
    if (polygon.type === 'Polygon') {
        polys = [polys];
    }

    var insidePoly = false;
    var i = 0;
    while (i < polys.length && !insidePoly) {
        // check if it is in the outer ring first
        if (this._inRing(pt, polys[i][0], pointReduce)) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while (k < polys[i].length && !inHole) {
                if (this._inRing(pt, polys[i][k], pointReduce)) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole)  {
                insidePoly = true;
            }
        }
        i++;
    }
    return insidePoly;
};

// pt is [x,y] and ring is [[x,y], [x,y],..]
DG.PolyUtil._inRing = function (pt, ring, pointReduce) {
    var isInside = false;
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var pi = pointReduce(ring[i]);
        var pj = pointReduce(ring[j]);
        var xi = pi[0], yi = pi[1];
        var xj = pj[0], yj = pj[1];
        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);

        if (intersect) {
            isInside = !isInside;
        }
    }
    return isInside;
};

DG.PolyUtil._defaultPointReduce = function (point) {
    return point;
};

DG.Control.Zoom.include(DG.Locale);
DG.Control.Zoom.Dictionary = {};

DG.Control.Zoom.include({
    onAdd: function (map) {
        var zoomName = 'dg-zoom',
            buttonTemplate = '<div class="dg-control-round__icon ' + zoomName + '__control ' + zoomName + '__button ' + zoomName + '__button_type_{type}"></div>',
            container = DG.DomUtil.create('div', zoomName);

        this._map = map;

        this._zoomInButton = this._createButton(DG.Util.template(buttonTemplate, {type : 'in'}), this.t('zoom_in'), 'dg-control-round ' + zoomName + '__in', container, this._zoomIn, this);
        this._zoomOutButton = this._createButton(DG.Util.template(buttonTemplate, {type : 'out'}), this.t('zoom_out'), 'dg-control-round ' + zoomName + '__out', container, this._zoomOut, this);

        this._updateDisabled();
        map.on('zoomend zoomlevelschange', this._updateDisabled, this);

        return container;
    },

    _originalCreateButton: DG.Control.Zoom.prototype._createButton,

    // set active state control on mobile devices
    _createButton: function () {
        var args = Array.prototype.slice.call(arguments);
        var link = this._originalCreateButton.apply(this, args);

        var icon = link.children[0];
        var linkActiveClass = 'dg-control-round_state_active';
        var iconActiveClass = 'dg-control-round__icon_state_active';

        DG.DomEvent
            .on(link, 'touchstart', function () {
                DG.DomUtil.addClass(link, linkActiveClass);
                DG.DomUtil.addClass(icon, iconActiveClass);
            })
            .on(link, 'touchend touchcancel', function () {
                DG.DomUtil.removeClass(link, linkActiveClass);
                DG.DomUtil.removeClass(icon, iconActiveClass);
            });

        return link;
    },

    _renderTranslation: function () {
        if (!this._zoomInButton || !this._zoomOutButton) {
            return;
        }

        this._zoomInButton.title = this.t('zoom_in');
        this._zoomOutButton.title = this.t('zoom_out');
    }
});

DG.Control.Zoom.Dictionary.ru = {
    zoom_in : 'Приблизить',
    zoom_out : 'Отдалить'
};
DG.Control.Zoom.Dictionary.it = {
    zoom_in : 'Zoom avanti',
    zoom_out : 'Zoom indietro'
};
DG.Control.Zoom.Dictionary.cs = {
    zoom_in : 'Přiblížit',
    zoom_out : 'Oddálit'
};
DG.Control.Zoom.Dictionary.en = {
    zoom_in : 'Zoom in',
    zoom_out : 'Zoom out'
};
DG.Control.Zoom.Dictionary.es = {
    zoom_in : 'Acercar',
    zoom_out : 'Alejar'
};

var dust = _dereq_('dustjs-linkedin');
_dereq_('dustjs-helpers');

DG.dust = function (name, data) {
    var result;

    // The callback is called synchronously, so this works
    dust.render(name, data, function (err, html) {
        result = html;
    });

    return result;
};

DG.Control.Attribution.include(DG.Locale);
DG.Control.Attribution.Dictionary = {};
DG.Control.Attribution.include({
    options: {
        position: 'bottomright'
    },

    _getLink: function (linkType) {
        /* eslint-disable camelcase */
        var dictionary = {
            ru: {
                copyright_logo: 'http://info.2gis.ru/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://api.2gis.ru/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://help.2gis.ru/licensing-agreement/'
            },

            it: {
                copyright_logo: 'http://2gis.it/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://2gis.it/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://2gis.it/'
            },

            cz: {
                copyright_logo: 'http://praha.2gis.cz/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://praha.2gis.cz/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.cz/licensing-agreement/'
            },

            cl: {
                copyright_logo: 'http://santiago.2gis.cl/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://santiago.2gis.cl/?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.cl/licensing-agreement/'
            },

            cy: {
                copyright_logo: 'http://info.2gis.com.cy/lemesos?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://info.2gis.com.cy/lemesos?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.com.cy/licensing-agreement/'
            },

            ae: {
                copyright_logo: 'http://info.2gis.ae/dubai?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_apilink: 'http://info.2gis.ae/dubai?utm_source=copyright&utm_medium=map&utm_campaign=partners',
                copyright_license: 'http://law.2gis.ae/licensing-agreement/'
            }
        };
        /* eslint-enable camelcase */

        var countryCode = (this._countryCode in dictionary) ? this._countryCode : 'ru';

        return dictionary[countryCode][linkType];
    },

    onAdd: function (map) {
        if (!map._copyright) {
            map._copyright = true;
            this._first = true;
        }

        map.attributionControl = this;
        this._container = DG.DomUtil.create('div', 'dg-attribution');
        DG.DomEvent.disableClickPropagation(this._container);

        for (var i in map._layers) {
            if (map._layers[i].getAttribution) {
                this.addAttribution(map._layers[i].getAttribution());
            }
        }

        this._update();

        return this._container;
    },

    _update: function (lang, osm, countryCode) {
        if (!this._map) { return; }

        if (typeof osm !== 'undefined') {
            this._osm = osm;
        }

        if (typeof countryCode !== 'undefined') {
            this._countryCode = countryCode;
        }

        var attribs = [];

        for (var i in this._attributions) {
            if (this._attributions[i]) {
                attribs.push(i);
            }
        }

        var prefixAndAttribs = [],
            copyright = '';

        if (this._first) {
            copyright = this._getAttributionHTML(lang);
        }

        if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
        }
        if (attribs.length) {
            prefixAndAttribs.push(attribs.join(', '));
        }

        this._container.innerHTML = copyright + prefixAndAttribs.join(' | ');
    },
    _getData: function (lang) {
        return {
            'osm': this._osm,
            'work_on': this.t('work_on'),
            'lang': lang || this._map.getLang(),
            'copyright_apilink': this._getLink('copyright_apilink'),
            'copyright_license': this._getLink('copyright_license'),
            'copyright_logo': this._getLink('copyright_logo'),
            'license_agreement': this.t('license_agreement'),
            'API_2GIS': this.t('API_2GIS')
        };
    },
    _getAttributionHTML: function (lang) {
        return DG.dust('DGAttribution/copyright', this._getData(lang));
    },
    _renderTranslation: function (e) {
        this._update(e.lang);
    }
});

DG.Map.addInitHook(function () {
    if (!this._copyright) {
        DG.control.attribution().addTo(this);
    }
});

DG.Control.Attribution.Dictionary.ru = {
    license_agreement: 'Лицензионное соглашение',
    work_on: 'Работает на',
    API_2GIS: 'API 2ГИС'
};

DG.Control.Attribution.Dictionary.it = {
	license_agreement : 'Accordo di licenza',
    work_on: ' ',
	API_2GIS: '2GIS API'
};

DG.Control.Attribution.Dictionary.cs = {
	license_agreement: 'Licenční smlouva',
	work_on: 'Pracuje na',
    API_2GIS: 'API 2GIS'
};

DG.Control.Attribution.Dictionary.en = {
    license_agreement: 'License agreement',
    work_on: 'Uses',
    API_2GIS: '2GIS API'
};

DG.Control.Attribution.Dictionary.es = {
	license_agreement : 'Acuerdo de licencia',
    work_on: ' ',
	API_2GIS: '2GIS API'
};

DG.Control.Location = DG.RoundControl.extend({

    statics: {
        Dictionary: {}
    },

    options: {
        iconClass: 'locate',
        position: DG.Browser.mobile ? 'bottomright' : 'topleft',
        drawCircle: true,
        follow: true,  // follow with zoom and pan the user's location
        stopFollowingOnDrag: false, // if follow is true, stop following when map is dragged
        metric: true,
        onLocationError: function (/*err*/) {
            // this event is called in case of any location error
            // that is not a time out error.
            // console.log(err.message);
        },
        onLocationOutsideMapBounds: function (/*context*/) {
            // this event is repeatedly called when the location changes
            // console.log(context.t('outsideMapBoundsMsg'));
        },
        locateOptions: {}
    },

    initialize: function (options) {
        DG.Util.setOptions(this, options);

        if (!navigator.geolocation) {
            this._disable = true;
            return;
        }

        this._event = undefined;

        this._locateOptions = {
            watch: true,  // if you overwrite this, visualization cannot be updated
            setView: true,
            maximumAge: Infinity,
            maxZoom: Infinity
        };
        DG.extend(this._locateOptions, this.options.locateOptions);

        this._resetVariables();

        this.on({
            'click': this._handleLocate,
            'add': this._initLocate
        });
    },

    _initLocate: function () {
        this._layer = new DG.LayerGroup();
        this._layer.addTo(this._map);

        // event hooks
        this._map.on({
            'locationfound': this._onLocationFound,
            'locationerror': this._onLocationError
        }, this);
    },

    _handleLocate: function () {
        if (this._active && (!this._event ||
            (this._map.getBounds().contains(this._event.latlng) ||
            this._isOutsideMapBounds()))) {
            this._stopLocate();
        } else {
            this._locateOnNextLocationFound = true;

            if (!this._active) {
                this._map.locate(this._locateOptions);
            }

            this._active = true;

            if (this.options.follow) {
                this._startFollowing();
            }

            this._clearError();

            if (this._event) {
                this._visualizeLocation();
            } else {
                this.setState('requesting');
            }
        }
    },

    _onLocationFound: function (e) {
        // no need to do anything if the location has not changed
        if (this._event &&
            (this._event.latlng.lat === e.latlng.lat &&
             this._event.latlng.lng === e.latlng.lng &&
             this._event.accuracy === e.accuracy)) {
            return;
        }

        if (!this._active) {
            return;
        }

        this._event = e;

        if (this.options.follow && this._following) {
            this._locateOnNextLocationFound = true;
        }

        this._visualizeLocation();
    },

    _startFollowing: function () {
        this._following = true;
        if (this.options.stopFollowingOnDrag) {
            this._map.on('dragstart', this._stopFollowing);
        }
    },

    _stopFollowing: function () {
        this._following = false;
        if (this.options.stopFollowingOnDrag) {
            this._map.off('dragstart', this._stopFollowing);
        }
        this._visualizeLocation();
    },

    _isOutsideMapBounds: function () {
        if (this._event === undefined) {
            return false;
        }
        return this._map.options.maxBounds &&
            !this._map.options.maxBounds.contains(this._event.latlng);
    },

    _visualizeLocation: function () {
        if (this._event.accuracy === undefined) {
            this._event.accuracy = 0;
        }

        var radius = this._event.accuracy;

        if (this._locateOnNextLocationFound) {
            if (this._isOutsideMapBounds()) {
                this.options.onLocationOutsideMapBounds(this);
            } else if (this._locateOptions.setView) {
                var zoom = this._map.projectDetector.getProject().maxZoom || DG.config.projectLeaveMaxZoom;
                zoom = Math.min(this._locateOptions.maxZoom, zoom);
                this._map.setView(this._event.latlng, zoom);
            }
            this._locateOnNextLocationFound = false;
        }

        // circle with the radius of the location's accuracy
        var style = {
            clickable: false,
            color: '#FFF',
            fillColor: '#FFF',
            fillOpacity: 0.4,
            weight: 0,
            opacity: 0.3
        };
        if (this.options.drawCircle) {
            if (!this._circle) {
                this._circle = DG.circle(this._event.latlng, radius, style)
                    .addTo(this._layer);
            } else {
                this._circle.setLatLng(this._event.latlng).setRadius(radius);
            }
        }

        var markerClass = 'dg-location__pin';

        markerClass += this._following ? (' ' + markerClass + 'state_following') : '';
        // small inner marker
        var m = {
            icon: DG.divIcon({
                className: markerClass,
                iconSize: [20, 20]
            })
        };

        if (!this._marker) {
            this._marker = DG.marker(this._event.latlng, m)
                .bindLabel(this.t('you_are_here'))
                .addTo(this._layer);
        } else {
            this._marker.setLatLng(this._event.latlng);
        }

        DG.DomEvent.on(this._marker, 'click', function () {
            this._map.fireEvent('dgLocateClick');
        }, this);

        if (!this._container) {
            return;
        }

        this.setState('active');
    },

    _resetVariables: function () {
        this._active = false;
        this._following = false;
    },


    _stopLocate: function () {
        this._map.stopLocate();
        this._map.off('dragstart', this._stopFollowing);

        this.setState();
        this._resetVariables();

        this._layer.clearLayers();
        this._marker = undefined;
        this._circle = undefined;
        this._event = undefined;
    },

    _onLocationError: function (err) {
        // ignore time out error if the location is watched
        if (err.code === 3 && this._locateOptions.watch) {
            return;
        }

        this._stopLocate();
        this._error = DG.DomUtil.create('div', 'dg-label dg-label_name_location-error', this._container);
        this._errorText = DG.DomUtil.create('div', 'dg-label__content', this._error);
        this._errorText.innerHTML = this.t('cant_find');

        var self = this;
        setTimeout(function () {
            self._clearError();
        }, 3000);

        //show location error
        this.options.onLocationError(err);
    },

    _clearError: function () {
        if (this._error) {
            this._container.removeChild(this._error);
            this._error = undefined;
            this._errorText = undefined;
        }
    },

    _renderTranslation: function () {
        if (this._link) {
            this._link.title = this.t('button_title');
        }
        if (this._marker) {
            this._marker.bindLabel(this.t('you_are_here'));
        }
    }
});

DG.control.location = function (options) {
    return new DG.Control.Location(options);
};

DG.Map.addInitHook(function () {
    if (this.options.locationControl) {
        this.locationControl = DG.control.location(this.options.locationControl);
        this.addControl(this.locationControl);
    }
});

DG.Control.Location.Dictionary.ru = {
	 cant_find : 'Мы не смогли Вас найти',
	 you_are_here : 'Вы здесь',
	 button_title : 'Найти Вас на карте'
};
DG.Control.Location.Dictionary.it = {
	 cant_find : 'Non siamo riusciti a localizzarti',
	 you_are_here : 'Voi siete qui',
	 button_title : 'Trova la tua posizione sulla mappa'
};
DG.Control.Location.Dictionary.cs = {
	 cant_find : 'Nepodařilo se nám určit Vaši polohu',
	 you_are_here : 'Jste tady',
	 button_title : 'Určit Vaši polohu na mapě'
};
DG.Control.Location.Dictionary.en = {
	 cant_find : 'We can\'t find you',
	 you_are_here : 'You are here',
	 button_title : 'Show your location'
};
DG.Control.Location.Dictionary.es = {
	 cant_find : 'No pudimos encontrarte',
	 you_are_here : 'Tú estás aquí',
	 button_title : 'Encontrarte en el mapa'
};
// Inspired by Sindre Sorhus screenfull
/*global Element */
DG.Screenfull = DG.Class.extend({
    _apiMap: [
        [
            'requestFullscreen',
            'exitFullscreen',
            'fullscreenElement',
            'fullscreenEnabled',
            'fullscreenchange',
            'fullscreenerror'
        ],
        [
            'webkitRequestFullscreen',
            'webkitExitFullscreen',
            'webkitFullscreenElement',
            'webkitFullscreenEnabled',
            'webkitfullscreenchange',
            'webkitfullscreenerror'

        ],
        [
            'mozRequestFullScreen',
            'mozCancelFullScreen',
            'mozFullScreenElement',
            'mozFullScreenEnabled',
            'mozfullscreenchange',
            'mozfullscreenerror'
        ],
        [
            'msRequestFullscreen',
            'msExitFullscreen',
            'msFullscreenElement',
            'msFullscreenEnabled',
            'MSFullscreenChange',
            'MSFullscreenError'
        ]
    ],

    initialize: function () {
        this.api = this._api();
    },

    request: function (elem) {
        var request = this.api.requestFullscreen;

        elem = elem || document.documentElement;
        elem[request](Element.ALLOW_KEYBOARD_INPUT);
    },

    exit: function () {
        document[this.api.exitFullscreen]();
    },

    isFullscreen: function () {
        return !!document[this.api.fullscreenElement];
    },

    isAvailable: function () {
        return Boolean(this.api);
    },

    _api: function () {
        var api = {},
            apiMap = this._apiMap;

        apiMap.forEach(function (val) {
            if (val && val[1] in document) {
                val.forEach(function (method, i) {
                    api[apiMap[0][i]] = method;
                });
            }
        });

        return api.requestFullscreen ? api : false;
    }
});

DG.screenfull = new DG.Screenfull();

DG.Control.Fullscreen = DG.RoundControl.extend({

    statics: {
        Dictionary: {}
    },

    options: {
        position: 'topright',
        iconClass: 'fullscreen'
    },

    initialize: function (options) {
        DG.Util.setOptions(this, options);
        this._isFullscreen = false;
        this.on('click', this._toggleFullscreen);
    },

    _toggleFullscreen: function () {
        if (!this._isFullscreen) {
            this._toggle(true, 'request', 'on', 'requestfullscreen');
        } else {
            this._toggle(false, 'exit', 'on', 'cancelfullscreen');
        }

        this._renderTranslation();
        this._map.invalidateSize();
    },

    _renderTranslation: function () {
        this._link.title = this.t(this._isFullscreen ? 'title_min' : 'title_max');
    },

    _toggle: function (isEnabled, method, list, event) {
        var container = this._map._container;

        this._isFullscreen = isEnabled;
        this.setState(isEnabled ? 'active' : '');

        DG.screenfull[method](container);
        DG.DomEvent[list](document, DG.screenfull.api.fullscreenchange, this._onFullScreenStateChange, this);
        this._map.fire(event);
    },

    _onFullScreenStateChange: function () {
        if (!DG.screenfull.isFullscreen()) {
            this._toggle(false, 'exit', 'on', 'cancelfullscreen');
        }
    }
});

DG.control.fullscreen = function (options) {
    return new DG.Control.Fullscreen(options);
};

DG.Map.mergeOptions({
    fullscreenControl: true
});

DG.Map.addInitHook(function () {
    if (this.options.fullscreenControl) {
        this.fullscreenControl = DG.control.fullscreen(this.options.fullscreenControl);

        if (DG.screenfull.isAvailable()) {
            this.addControl(this.fullscreenControl);
        }
    }
});

DG.Control.Fullscreen.Dictionary.ru = {
    title_max : 'Развернуть',
    title_min : 'Восстановить'
};

DG.Control.Fullscreen.Dictionary.it = {
    title_max : 'Espandi',
    title_min : 'Ripristina'
};

DG.Control.Fullscreen.Dictionary.cs = {
     title_max : 'Rozbalit',
     title_min : 'Obnovit'
};

DG.Control.Fullscreen.Dictionary.en = {
    title_max : 'Expand',
    title_min : 'Restore'
};

DG.Control.Fullscreen.Dictionary.es = {
    title_max : 'Maximizar',
    title_min : 'Restaurar'
};

DG.Meta = {};

DG.Meta.Layer = DG.Layer.extend({

    options: {
        tileSize: 256,

        minZoom: 0,
        maxZoom: 19,
        zoomOffset: 0,
        eventBubbling: 'transparent'
        // maxNativeZoom: <Number>,
        // detectRetina: <Number>,
        // zoomReverse: <Number>
        // attribution: <String>,
        // zIndex: <Number>,
        // bounds: <LatLngBounds>
    },

    initialize: function (source, options) { // (String, Object)
        DG.TileLayer.prototype.initialize.call(this, null, options);
        delete this._url;

        this._currentTile = false;
        this._currentTileData = false;

        this._origin = DG.Meta.origin(source, {
            dataFilter: this.options.dataFilter
        });
    },

    getOrigin: function () { // () -> Object
        return this._origin;
    },

    onAdd: function (map) {
        this._resetView();
        this._addDomEvents();

        map.on('rulerstart', this._removeDomEvents, this);
        map.on('rulerend', this._addDomEvents, this);
    },

    onRemove: function (map) {
        this._removeDomEvents();
        this._tileZoom = null;

        map.off('rulerstart', this._removeDomEvents, this);
        map.off('rulerend', this._addDomEvents, this);
    },

    getEvents: function () {
        return {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
        };
    },

    _addDomEvents: function () {
        DG.DomEvent.on(this._map.getPane('tilePane'), this._domEvents, this);
    },

    _removeDomEvents: function () {
        DG.DomEvent.off(this._map.getPane('tilePane'), this._domEvents, this);
    },

    _removeAllTiles: DG.GridLayer.prototype._removeAllTiles,
    _getZoomForUrl: DG.TileLayer.prototype._getZoomForUrl,
    getTileSize: DG.TileLayer.prototype.getTileSize,
    _isValidTile: DG.GridLayer.prototype._isValidTile,
    _wrapCoords: DG.GridLayer.prototype._wrapCoords,
    _resetView: DG.GridLayer.prototype._resetView,
    _resetGrid: DG.GridLayer.prototype._resetGrid,
    _invalidateAll: DG.GridLayer.prototype._invalidateAll,
    _pxBoundsToTileRange: DG.GridLayer.prototype._pxBoundsToTileRange,

    // Fix for https://github.com/Leaflet/Leaflet/compare/0726f12bbf33fcb18fe8bb541d5e3212bb1f5ab2...c263f2d8b1bd962b60474376cc4816a688052513#diff-f1e6be67599c594731fff6191c710420L579
    _onMoveEnd: function () {
        if (!this._map || this._map._animatingZoom) { return; }

        this._resetView();
    },

    _domEvents: {
        mousemove: function (event) { // (MouseEvent)
            var tileSize = this.getTileSize(),
                layerPoint = this._map.mouseEventToLayerPoint(event),
                tileOriginPoint = this._map.getPixelOrigin().add(layerPoint),
                tileCoord = tileOriginPoint.unscaleBy(tileSize).floor(),
                mouseTileOffset,
                tileKey,
                hoveredObject,
                zoom = this._map.getZoom();

            if (zoom > (this.options.maxZoom + this.options.zoomOffset) ||
                zoom < (this.options.minZoom - this.options.zoomOffset) ||
                !this._isValidTile(tileCoord)) {
                return;
            }

            this._wrapCoords(tileCoord);

            tileCoord.z = this._getZoomForUrl();
            tileCoord.key = tileSize.x + 'x' + tileSize.y;
            tileKey = this._origin.getTileKey(tileCoord);

            if (tileKey !== this._currentTile) {
                this._currentTile = tileKey;
                this._currentTileData = false;
            }

            if (this._currentTileData === false) {
                this._currentTileData = this._origin.getTileData(tileCoord);
            } else {
                mouseTileOffset = DG.point(tileOriginPoint.x % tileSize.x, tileOriginPoint.y % tileSize.y);
                hoveredObject = this._getHoveredObject(tileCoord, mouseTileOffset);

                if (this._hoveredEntity !== hoveredObject) {
                    this._fireMouseEvent('mouseout', event);

                    this._hoveredEntity = hoveredObject;
                    this._fireMouseEvent('mouseover', event);
                }

                this._fireMouseEvent('mousemove', event);
            }
        },
        mouseout: function (event) {
            this._fireMouseEvent('mouseout', event);
            this._hoveredEntity = null;
            this._currentTile = false;
        },

        click: function (event) {
            this._fireMouseEvent('click', event);
        },

        dblclick: function (event) {
            this._fireMouseEvent('dblclick', event);
        },

        mousedown: function (event) {
            this._fireMouseEvent('mousedown', event);
        },

        contextmenu: function (event) {
            this._fireMouseEvent('contextmenu', event);
        }
    },

    _fireMouseEvent: function (type, mouseEvent) {
        if (this._hoveredEntity) {
            this.fire(type, {
                meta: this._hoveredEntity,
                latlng: this._map.mouseEventToLatLng(mouseEvent)
            });
            if (this.options.eventBubbling === 'layer') {
                DG.DomEvent.stop(mouseEvent);
            }
        }
    },

    _getHoveredObject: function (coords, mouseTileOffset) {
        for (var i = 0; i < this._currentTileData.length; i++) {
            if (DG.PolyUtil.inside(mouseTileOffset, this._currentTileData[i].geometry, this._pointReduceHelper)) {
                return this._currentTileData[i];
            }
        }

        return null;
    },

    _pointReduceHelper: function (point) {
        return [point.x, point.y];
    },

    _setView: function (center, zoom, noPrune, noUpdate) {
        var tileZoom = Math.round(zoom),
            tileZoomChanged = this._tileZoom !== tileZoom;

        if (!noUpdate && tileZoomChanged) {
            this._tileZoom = tileZoom;
            this._resetGrid();
        }
    }
});

DG.Meta.layer = function (source, options) {
    return new DG.Meta.Layer(source, options);
};

DG.Meta.Origin = DG.Class.extend({

    options: {
        subdomains: '0123',
        dataFilter: null
    },

    _url: false,

    initialize: function (url, options) { // (String, Object)
        this._url = url;
        this._requests = {};

        this._tileStorage = {};

        options = DG.setOptions(this, options);

        if (typeof options.subdomains === 'string') {
            options.subdomains = options.subdomains.split('');
        }
    },

    getTileData: function (coord) { // (Object) -> Object
        var tileKey = this.getTileKey(coord),
            self = this;

        if (typeof this._tileStorage[tileKey] === 'undefined' && typeof this._requests[tileKey] === 'undefined') {
            this._tileStorage[tileKey] = false;
            this._requests[tileKey] = this._requestData(coord).then(function (data) {
                self.setTileData(tileKey, self.options.dataFilter ? self.options.dataFilter(data, coord) : data);
                delete self._requests[tileKey];
            });
            return false;
        }

        return this._tileStorage[tileKey];
    },

    setTileData: function (key, data) { // (Object/String, Object) -> Object
        if (typeof key !== 'string') {
            key = this.getTileKey(key);
        }

        data.forEach(function (entity) {
            if (entity.geometry.constructor !== Object) {
                entity.geometry = DG.Wkt.toGeoJSON(entity.geometry);
            }
            if (!this._tileStorage[key]) {
                this._tileStorage[key] = [];
            }
            this._tileStorage[key].push(entity);
        }, this);

        return this;
    },

    flush: function () { // () -> Object
        this._tileStorage = {};
        Object.keys(this._requests).forEach(function (tileKey) {
            if (this[tileKey].abort) {
                this[tileKey].abort();
            }
        }, this._requests);

        return this;
    },

    setURL: function (url, flush) { // (String, Boolean) -> Object
        this._url = url;
        if (flush) {
            this.flush();
        }

        return this;
    },

    getTileKey: function (coord) { // (Object)-> String
        return [coord.x, coord.y, coord.z, coord.key].join(':');
    },

    _requestData: function (key) { // (String)
        if (this._url) {
            return this._performRequest(key);
        } else {
            return Promise.resolve([]);
        }
    },

    _performRequest: function (coords) { // (Object) -> Promise
        return DG.ajax(this._prepareURL(coords), {
            type: 'get',
            dataType: 'json'
        });
    },

    _prepareURL: function (coords) { // (Object) -> String
        return DG.Util.template(this._url, {
            x: coords.x,
            y: coords.y,
            z: coords.z,
            s: this._getSubdomain(coords)
        });
    },

    _getSubdomain: DG.TileLayer.prototype._getSubdomain

});

DG.Meta.origin = function (source, options) {
    return new DG.Meta.Origin(source, options);
};

DG.Map.mergeOptions({
    poi: !DG.Browser.mobile
});

DG.Poi = DG.Handler.extend({

    options: {
        disableLabel: false
    },

    initialize: function (map, options) { // (Object)
        this._map = map;
        DG.Util.setOptions(this, options);

        var url = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaPoiMetaServer : DG.config.poiMetaServer);

        this._metaLayer = DG.Meta.layer(url, {
            minZoom: DG.config.poiLayerMinZoom,
            maxNativeZoom: 19,
            detectRetina: DG.config.detectRetina,
            eventBubbling: 'layer',
            dataFilter: DG.bind(this._processData, this)
        });
    },

    addHooks: function () {
        this._map.addLayer(this._metaLayer);
        if (!this.options.disableLabel) {
            this._labelHelper = DG.label();
            this._metaLayer.on(this._layerEventsListeners, this);
        }
    },

    removeHooks: function () {
        this._map.removeLayer(this._metaLayer);
        if (!this.options.disableLabel) {
            this._metaLayer.off(this._layerEventsListeners, this);
            this._map.removeLayer(this._labelHelper);
            this._labelHelper = null;
        }
    },

    getMetaLayer : function () {
        return this._metaLayer;
    },

    _processData : function (data, coord) {
        var tileOriginPoint = coord.scaleBy(this._metaLayer.getTileSize());
        var polygonLngLatToPoints = DG.bind(this._polygonLngLatToPoints, this, tileOriginPoint);

        if (data.responseText === '') {
            return [];
        }

        return data.result.poi
            .map(function (item) {
                return {
                    id: item.id,
                    hint: item.links[0].name,
                    linked: item.links[0],
                    geometry: DG.Wkt.toGeoJSON(item.hover)
                };
            })
            .filter(function (item) {
                return item.geometry.type == 'Polygon' ||
                    item.geometry.type == 'MultiPolygon';
            })
            .map(function (item) {
                var geoJson = item.geometry;

                if (geoJson.type == 'Polygon') {
                    geoJson.coordinates = polygonLngLatToPoints(geoJson.coordinates);
                } else if (geoJson.type == 'MultiPolygon') {
                    geoJson.coordinates = geoJson.coordinates.map(polygonLngLatToPoints);
                }

                return item;
            });
    },

    _polygonLngLatToPoints: function (originPoint, polygon) {
        var map = this._map;

        return polygon.map(function (contour) {
            return contour.map(function (lngLat) {
                return map
                    .project([lngLat[1], lngLat[0]]).round()
                    .subtract(originPoint);
            });
        });
    },

    _layerEventsListeners : {
        mouseover: function (e) { // (Object)
            this._setCursor('pointer');
            if (e.meta.hint && e.meta.hint.length) {
                this._labelHelper
                    .setPosition(e.latlng)
                    .setContent(e.meta.hint)
                    .setZIndexOffset(300);
                this._map.addLayer(this._labelHelper);
            }
            this._map.fire('poihover', {
                latlng: e.latlng,
                meta: e.meta
            });
        },

        mouseout: function (e) {
            this._setCursor('');
            this._map.removeLayer(this._labelHelper);
            this._map.fire('poileave', {
                latlng: e.latlng,
                meta: e.meta
            });
        },

        mousemove: function (e) { // (Object)
            this._labelHelper.setPosition(e.latlng);
        }
    },

    _setCursor: function (cursor) { // (String)
        this._map.getContainer().style.cursor = cursor;
    }

});

DG.Map.addInitHook('addHandler', 'poi', DG.Poi);

DG.Map.mergeOptions({
    geoclicker: false
});

DG.Geoclicker = DG.Handler.extend({
    clickCount: 0,
    pendingClick: 0,
    timeout: 250, // should be equal to 'delay' value in DoubleTap event

    initialize: function (map, options) { // (Object)
        this._map = map;
        this._controller = new DG.Geoclicker.Controller(map, options);
    },

    addHooks: function () {
        this._toggleEvents(true);

        this._map
            .on('rulerstart', this._pause, this)
            .on('rulerend', this._unpause, this);
    },

    removeHooks: function () {
        this._toggleEvents();

        this._map
            .off('rulerstart', this._pause, this)
            .off('rulerend', this._unpause, this);
    },

    _checkOpenPopup: function () {
        if (DG.Browser.mobile && this._map._popup &&
            (this._map._popup.options.closeOnClick ||
            this._map.options.closePopupOnClick)) {
            this.popupWasOpen = true;
        }
    },

    _pause: function () {
        this._toggleEvents();
    },

    _unpause: function () {
        // Reenable event handling only in case geoclicker is enabled
        if (this.enabled()) {
            this._toggleEvents(true);
        }
    },

    _toggleEvents: function (flag) {
        this._map[flag ? 'on' : 'off'](this._mapEventsListeners, this);
        if (this._map.poi) {
            this._map.poi.getMetaLayer()[flag ? 'on' : 'off']('click', this._onMetaClick, this);
        }
    },

    getController: function () {
        return this._controller;
    },

    _onMetaClick: function (e) {
        this.clickCount = 0;
        clearTimeout(this.pendingClick);
        this.popupWasOpen = false;

        this._mapEventsListeners.click.call(this, e);
    },

    _mapEventsListeners: {
        langchange: function () {
            this._controller.reinvokeHandler();
        },

        popupclose: function (e) { // (Object)
            this._controller.handlePopupClose(e.popup);
        },

        click: function (e) { // (Object)
            if (this.clickCount === 0) {
                this.clickCount = 1;
                this._singleClick(e);
            } else {
                this.clickCount = 0;
                clearTimeout(this.pendingClick);
                this.popupWasOpen = false;
            }
        },

        dblclick: function () {
            if (DG.Browser.ielt9) {
                this.clickCount = 0;
                this.popupWasOpen = false;
                clearTimeout(this.pendingClick);
            }
        }
    },

    _singleClick: function (e) { // (Object)
        var self = this;

        clearTimeout(this.pendingClick);

        this.pendingClick = setTimeout(function () {
            if (e.meta) {
                self._checkOpenPopup();
                self._map.closePopup();
            }

            //  DGPopup's '_close' method is the only place where .popupWasOpen is modified
            //  It signals geoclicker that popup was open before user do a 'click' on map
            //  Multistage behavior is needed as this processing occurs after popup was already closed
            if (!self.popupWasOpen) {
                var zoom = self._map.getZoom();
                self._controller.handleClick(e.latlng, zoom, e.meta);
            }

            self.clickCount = 0;
            self.popupWasOpen = false;
        }, this.timeout);
    }
});

DG.Map.addInitHook('addHandler', 'geoclicker', DG.Geoclicker);

DG.Geoclicker.clampHelper = function (el, lineClamp) {
    var measure, text, lineWidth,
        lineStart, lineCount, wordStart,
        line, lineText, wasNewLine,
        ce = document.createElement.bind(document),
        ctn = document.createTextNode.bind(document);

    // measurement element is made a child of the clamped element to get it's style
    measure = ce('span');

    (function (s) {
        s.position = 'absolute'; // prevent page reflow
        s.whiteSpace = 'pre'; // cross-browser width results
        s.visibility = 'hidden'; // prevent drawing
        s.margin = '0 18px 8px 0';
    })(measure.style);

    // make sure the element belongs to the document
    if (!el.ownerDocument || el.ownerDocument !== document) {
        return;
    }
    // reset to safe starting values
    lineStart = wordStart = 0;
    lineCount = 1;
    wasNewLine = false;
    lineWidth = el.clientWidth;
    // get all the text, remove any line changes
    text = (el.textContent || el.innerText).replace(/\n/g, ' ');
    // remove all content
    while (el.firstChild !== null) {
        el.removeChild(el.firstChild);
    }
    // add measurement element within so it inherits styles
    el.appendChild(measure);
    // http://ejohn.org/blog/search-and-dont-replace/
    text.replace(/ |-/g, function (m, pos) {
        // ignore any further processing if we have total lines
        if (lineCount === lineClamp) {
            return;
        }
        // create a text node and place it in the measurement element
        measure.appendChild(ctn(text.substr(lineStart, pos - lineStart)));
        // have we exceeded allowed line width?
        if (lineWidth < measure.clientWidth) {
            if (wasNewLine) {
                // we have a long word so it gets a line of it's own
                lineText = text.substr(lineStart, pos + 1 - lineStart);
                // next line start position
                lineStart = pos + 1;
            } else {
                // grab the text until this word
                lineText = text.substr(lineStart, wordStart - lineStart);
                // next line start position
                lineStart = wordStart;
            }
            // create a line element
            line = ce('span');
            // add text to the line element
            line.appendChild(ctn(lineText));
            // add the line element to the container
            el.appendChild(line);
            line.className = 'dg-map-geoclicker__clamped-line';
            // yes, we created a new line
            wasNewLine = true;
            lineCount++;
        } else {
            // did not create a new line
            wasNewLine = false;
        }
        // remember last word start position
        wordStart = pos + 1;
        // clear measurement element
        measure.removeChild(measure.firstChild);
    });
    // remove the measurement element from the container
    el.removeChild(measure);
    // create the last line element
    line = ce('span');
    // give styles required for text-overflow to kick in
    line.className = 'dg-map-geoclicker__clamped-line dg-map-geoclicker__clamped-line_last';
    // add all remaining text to the line element
    line.appendChild(ctn(text.substr(lineStart)));
    // add the line element to the container
    el.appendChild(line);
};

DG.Geoclicker.Provider = {};

DG.Geoclicker.Provider.CatalogApi = DG.Class.extend({
    initialize: function (map) { // (Object)
        this._map = map;

        var apiUrl = DG.config.protocol +
            DG.config.webApiServer + '/' +
            DG.config.webApiVersion + '/';

        this._urlGeoSearch = apiUrl + 'geo/search';
        this._urlGeoGet = apiUrl + 'geo/get';
        this._urlDetails = apiUrl + 'catalog/branch/get';
        this._urlFirmsInHouse = apiUrl + 'catalog/branch/list';

        this._key = DG.config.geoclickerCatalogApiKey;
        this._geoFields = DG.config.geoAdditionalFields;
        this._firmInfoFields = DG.config.firmInfoFields;
    },

    getLocations: function (options) { // (Object)
        // Callback will receive array of found results or void if errors occurred or nothing was found.
        var zoom = options.zoom,
            latlng = options.latlng,
            beforeRequest = options.beforeRequest || function () {},
            types = this.getTypesByZoom(zoom),
            q = latlng.lng + ',' + latlng.lat;

        if (!types) {
            return Promise.reject('no type');
        }

        beforeRequest();

        return this.geoSearch(q, types, zoom).then(DG.bind(function (result) {
            return this._filterResponse(result, types);
        }, this));
    },

    firmsInHouse: function (houseId, parameters) { // (String, Function, Number)
        parameters = parameters || {};

        /* eslint-disable camelcase */
        var params = {
            building_id: houseId,
            page: parameters.page || 1
        };
        /* eslint-enable camelcase */

        return this._performRequest(params, this._urlFirmsInHouse);
    },

    getFirmInfo: function (firmId) {
        return this._performRequest({
            type: 'filial',
            id: firmId,
            fields: this._firmInfoFields
        }, this._urlDetails);
    },

    geoSearch: function (q, types, zoomlevel) { // (String, String, Number)
        /* eslint-disable camelcase */
        var params = {
            point: q,
            type: types,
            zoom_level: zoomlevel,
            fields: this._geoFields
        };
        /* eslint-enable camelcase */

        return this._performRequest(params, this._urlGeoSearch);
    },

    geoGet: function (id) {
        var params = {
            id: id,
            fields: this._geoFields
        };

        return this._performRequest(params, this._urlGeoGet);
    },

    cancelLastRequest: function () {
        if (this._lastRequest) {
            this._lastRequest.abort();
        }
    },

    getTypesByZoom: function (zoom) { // (Number) -> String|Null
        var types = {
                'adm_div.settlement':   8,
                'adm_div.city':         8,
                'adm_div.division':     11,
                'adm_div.district':     12,
                'street':               14,
                'building':             14,
                'adm_div.place':        15,
                'poi':                  15,
                'attraction':           17
            },
            selectedTypes = [];

        Object.keys(types).forEach(function (type) {
            if (zoom >= types[type]) {
                selectedTypes.push(type);
            }
        });

        if (selectedTypes.length) {
            return selectedTypes.join(',');
        } else {
            return null;
        }
    },

    _performRequest: function (params, url) { // (Object, String, Function, Function)
        var data = DG.extend({key: this._key}, params);
        var type = 'get';

        this.cancelLastRequest();

        if (!DG.ajax.corsSupport) {
            type = data.format = 'jsonp';
        }

        this._lastRequest = DG.ajax(url, {
            type: type,
            data: data,
            timeout: this._timeoutMs
        });

        return this._lastRequest;
    },

    _filterResponse: function (response, allowedTypes) { // (Object, Array) -> Boolean|Object
        var result = {}, i, item, found, data, type;

        if (this._isNotFound(response)) {
            return false;
        }

        data = response.result.items;

        for (i = data.length - 1; i >= 0; i--) {
            item = data[i];

            type = item.type;
            if (item.subtype) {
                type += '.' + item.subtype;
            }

            if (allowedTypes && allowedTypes.indexOf(type) === -1) {
                continue;
            }

            result[type] = item;
            found = true;
        }

        if (found) {
            return result;
        } else {
            return false;
        }
    },

    _isNotFound: function (response) { // (Object) -> Boolean
        return !response ||
               !!response.meta && !!response.meta.error ||
               !response.result ||
               !response.result.items ||
               !response.result.items.length;
    }

});

DG.Geoclicker.Handler = {};

DG.Geoclicker.Handler.Default = DG.Class.extend({

    includes: DG.Locale,

    statics: {
        Dictionary: {}
    },

    _eventHandlers: {},

    initialize: function (controller, view, map) { // (Object, Object, Object)
        this._controller = controller;
        this._view = view;
        this._map = map;
    },

    handle: function () { // () -> Promise
        return Promise.resolve({
            tmpl: 'popupHeader',
            data: {'title': this.t('we_have_not')}
        });
    },

    addClickEvent: function () {
        this._view._popup.on('click', this._runEventHandlers, this);
        this._map.once('popupclose', this._removeClickEvent, this);
    },

    _removeClickEvent: function () {
        this._view._popup.off('click', this._runEventHandlers, this);
    },

    _addEventHandler: function (el, handler) { // (String, Function)
        this._eventHandlers[el] = handler;
    },

    _runEventHandlers: function (e) {
        var target = e.originalEvent.target;

        for (var eventClass in this._eventHandlers) {
            if (this._eventHandlers.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                DG.DomEvent.preventDefault(e.originalEvent);
                this._eventHandlers[eventClass].call(this, target);
                return;
            }
        }
    },

    _clearEventHandlers: function () {
        this._eventHandlers = {};
    },

    _getDirectionsUrl: function (name) {
        return DG.Util.template(DG.config.ppnotLink, {
            'domain': this._map.projectDetector.getProject().domain,
            'projectCode': this._map.projectDetector.getProject().code,
            'center': this._map.getCenter().lng + ',' + this._map.getCenter().lat,
            'zoom': this._map.getZoom(),
            'name': encodeURIComponent(name),
            'rsType': this._map.projectDetector.getProject().transport ? 'bus' : 'car',
            'point': this._popup._latlng.lng + ',' + this._popup._latlng.lat
        });
    },

    _getDrilldown: function (object) {
        var admDivs = [],
            result;

        if (object.adm_div) {
            admDivs = object.adm_div
                .reduce(function (admDivs, admDiv) {
                    if (admDiv.name) {
                        admDivs.push(admDiv.name);
                    }

                    return admDivs;
                }, [])
                .reverse();
        }

        if (admDivs.length && object.address && object.address.postcode) {
            admDivs.push(object.address.postcode);
        }

        result = admDivs.join(', ');

        return result;
    }

});


DG.Geoclicker.Handler.HandlerExample = DG.Geoclicker.Handler.Default.extend({

    handle: function (results, type) { // (Object, String) -> Promise
        return Promise.resolve({
            tmpl: type + ':<br/>' + results[type].id
        });
    }
});

DG.Geoclicker.Handler.ApiError = DG.Geoclicker.Handler.Default.extend({
    handle: function () { // () -> Promise
        var header = this._view.render({
            tmpl: 'popupHeader',
            data: {
                title: this.t('apiErrorTitle')
            }
        });

        return Promise.resolve({
            header: header,
            tmpl: this.t('apiErrorBody')
        });
    }
});

DG.Geoclicker.Handler.CityArea = DG.Geoclicker.Handler.Default.extend({

    _polylineStyleDefault : {
        fillColor: '#ff9387',
        color: '#ff9387',
        noClip: true,
        opacity: 1
    },

    _polylineStyles : {
        11 : {
            fillOpacity: 0.18,
            weight: 1
        },
        12 : {
            fillOpacity: 0.12,
            weight: 1
        },
        13 : {
            fillOpacity: 0.08,
            weight: 2
        },
        18 : {
            fillOpacity: 0,
            weight: 3
        }
    },

    handle: function (results, type) { // (Object, String) -> Promise
        if (!results[type]) {
            return false;
        }

        if (!this._stylesInited) {
            this._initStyles();
        }

        // remove previous geometry see https://github.com/2gis/mapsapi/issues/213
        if (this._geometry) {
            this._map.removeLayer(this._geometry);
        }

        this._popup = this._view.getPopup();

        this._geometryZoomStyle = this._getPolyStyleNum();
        this._geometry = DG.Wkt.geoJsonLayer(results[type].geometry.selection, {
            style: this._polylineStyles[this._geometryZoomStyle],
            interactive: false
        }).addTo(this._map);

        this._map
            .on('zoomend', this._updateGeometry, this)
            .once('popupclose', this._clearPopup, this);

        return Promise.resolve(this._fillCityAreaObject(results, type));
    },

    _fillCityAreaObject: function (results, type) {
        var data = {
            name: this.t('noname'),
            drilldown: '',
            purpose: this.t(type),
            type: type.split('.').join('_')
        };

        data.drilldown = this._getDrilldown(results[type]);

        if (results[type].name) {
            data.name = results[type].name;
        }

        return {
            tmpl: 'cityarea',
            data: data,
            header: this._view.render({
                tmpl: 'popupHeader',
                data: {'title': data.name}
            })
        };
    },

    _initStyles : function () {
        this._stylesInited = true;

        Object.keys(this._polylineStyles).forEach(function (zoom) {
            DG.extend(this._polylineStyles[zoom], this._polylineStyleDefault);
        }, this);
    },

    _getPolyStyleNum: function () {
        var mapZoom = this._map.getZoom();

        return Object.keys(this._polylineStyles).filter(function (zoom) {
            return mapZoom <= zoom;
        })[0] || false;
    },

    _updateGeometry: function () {
        var newStyle = this._getPolyStyleNum();

        if (newStyle && newStyle !== this._geometryZoomStyle) {
            this._geometryZoomStyle = newStyle;
            this._geometry.setStyle(this._polylineStyles[newStyle]);
        }
    },

    _clearPopup: function () {
        this._map
                .removeLayer(this._geometry)
                .off('zoomend', this._updateGeometry, this);
    }

});

/*global FirmCard */
DG.Geoclicker.Handler.House = DG.Geoclicker.Handler.Default.extend({

    _firmsOnPage: 20,
    _scrollThrottleInterval: 400,
    _scrollHeightReserve: 60,

    options: {
        'showBooklet': true,
        'showPhotos': true,
        'showRouteSearch': true
    },

    handle: function (results) { // (Object) -> Promise
        if (!results.building) {
            return false;
        }

        // initialization setup
        this.firmCard = null;
        this._page = 1;
        this._houseObject = null;
        this._firmList = null;
        this._firmListObject = null;
        this._firmCardObject = null;
        this._onScroll = false;
        this._isFirmlistOpen = false;

        this._id = results.building.id;
        this._totalPages = 1;
        this._api = this._controller.getCatalogApi();
        this._popup = this._view.getPopup();
        this._initedPopupClose = false;
        this._directionsUrl = this._getDirectionsUrl(results.building.name);
        this._firmListLoader = this._view.initLoader(true);

        this._houseObject = this._fillHouseObject(results.building);

        return Promise.resolve(this._houseObject);
    },

    _isRouteSearchAllowed: function () { //() -> Boolean
        var project = this._controller.getMap().projectDetector.getProject();
        return project.transport || project.roads;
    },

    _firmCardSetup: function () { //() -> Object
        return {
            render: this._view.renderTemplate,
            lang: this._map.getLang(),
            domain: this._controller.getMap().projectDetector.getProject().domain,
            ajax: DG.bind(this._api.getFirmInfo, this._api),
            timezoneOffset: this._controller.getMap().projectDetector.getProject().timeOffset,
            map: this._map,
            popup: this._popup,
            isMobile: DG.Browser.mobile,
            showEntrance: DG.Entrance,
            gotoUrl: this._directionsUrl,
            onFirmReady: DG.bind(this._onFirmReady, this),
            onToggle: DG.bind(this._popup.resize, this._popup),
            showBooklet: this.options.showBooklet,
            showPhotos: this.options.showPhotos,
            showRouteSearch: this.options.showRouteSearch && this._isRouteSearchAllowed(),
            t: DG.bind(this.t, this)
        };
    },

    // init single firm card in case of poi
    _fillFirmCardObject: function (firmId) {
        var options = this._firmCardSetup();

        this.firmCard = new FirmCard(firmId, options);
        this._initPopupClose();
        return this.firmCard.getContainer();
    },

    _firmListSetup: function () {
        var options = this._firmCardSetup();

        DG.extend(options, {
            backBtn: DG.bind(this._showHousePopup, this),
            onFirmClick: DG.bind(this._onFirmListClick, this),
            onShowLess: DG.bind(this._showHousePopup, this),
            pasteLoader: DG.bind(this._pasteLoader, this)
        });

        return {
            firmCard: options,
            firmlistItemTmpl: 'firmlistItem',
            onListReady: DG.bind(this._renderFirmList, this)
        };
    },

    _initShortFirmList: function (firms) { //(Object) -> DOMElement
        var options = this._firmListSetup();

        this._shortFirmList = new FirmCard.List(firms, options);

        return this._shortFirmList.renderList();
    },

    _initFirmList: function (res) { //(Object) -> Promise
        if (!res) { return false; }

        var results = res.result.items,
            options = this._firmListSetup();

        options.firmCard.backBtn = DG.bind(this._showListPopup, this);

        this._shortFirmList._toggleEventHandlers(true);

        this._firmList = new FirmCard.List(results, options);

        this._firmListObject = this._fillFirmListObject(this._firmList.renderList());
        this._clearAndRenderPopup(this._firmListObject);
    },

    _fillFirmListObject: function (firmList) { //(DOMElement) -> Object
        var self = this;

        return {
            tmpl: firmList,
            header: this._header,
            footer: this._view.render({
                tmpl: 'popupFooterBtns',
                data: {
                    btns: [
                        {
                            name: 'back',
                            label: this.t('back_button'),
                            icon: true
                        }
                    ]
                }
            }),
            afterRender: function () {
                self._initPopupClose();

                if (self._totalPages > 1 && self._firmListLoader) {
                    // "this" here is self._firmListObject
                    this.tmpl.parentNode.appendChild(self._firmListLoader);
                }
            }
        };
    },

    _onFirmReady: function (firmContentObject) {
        var self = this;
        firmContentObject.afterRender = function () {
            var headerTitle = self._popup._popupStructure.header.firstChild;
            if (!DG.Browser.ielt9) {
                if (headerTitle.offsetHeight > 72) { //TODO: magic number
                    DG.DomUtil.addClass(headerTitle, 'dg-popup__header-teaser');
                    if (!DG.Browser.webkit) {
                        DG.Geoclicker.clampHelper(headerTitle, 3);
                    }
                }
            }
        };
        this._clearAndRenderPopup(firmContentObject);
    },

    _showHousePopup: function () {
        this._popup.off('scroll', this._onScroll);
        this._clearAndRenderPopup(this._houseObject);
        this._shortFirmList._toggleEventHandlers();
    },

    _onFirmListClick: function () {
        this._popup.off('scroll', this._onScroll);
    },

    _pasteLoader: function () {
        var loaderWrapper  = DG.DomUtil.create('div', 'dg-map-geoclicker__preloader-wrapper'),
            loader = this._view.initLoader();

        loaderWrapper.insertBefore(loader, loaderWrapper.firstChild);
        loaderWrapper.style.height = this._popup._contentNode.offsetHeight - 1 + 'px'; // MAGIC
        loaderWrapper.style.width = this._popup._contentNode.offsetWidth + 'px';
        this._clearAndRenderPopup({tmpl: loaderWrapper});
    },

    _initPopupClose: function () {
        if (this._initedPopupClose) { return; }

        this._controller.getMap().once('popupclose', DG.bind(this._onPopupClose, this));
        this._initedPopupClose = true;
    },

    _showListPopup: function () {
        var firmList = this._firmListObject;

        this._pasteLoader();

        if (!firmList) {
            firmList = this._api.firmsInHouse(this._id).then(DG.bind(this._initFirmList, this));
        } else {
            this._clearAndRenderPopup(firmList);
            this._firmList._toggleEventHandlers();
        }

        if (!this._onScroll) {
            this._onScroll = DG.Util.throttle(this._handlePopupScroll, this._scrollThrottleInterval, this);
        }

        this._popup.on('scroll', this._onScroll);
    },

    _renderFirmList: function () {
        if (!this._isFirmlistOpen) {
            this._popup.resize();
            this._isFirmlistOpen = true;
        }
    },

    _onPopupClose: function () {
        this._initedPopupClose = false;
        if (this._firmList) {
            this._firmList.clearList();
            this._firmList = null;
            this._popup.off('scroll', this._onScroll);
        }
        this._firmId = null;
        if (this.firmCard) {
            this.firmCard._toggleEventHandlers(true);
            this.firmCard = null;
        }
        this._firmListLoader = null;
        this._page = 1;
        this._clearEventHandlers();
    },

    _initShowMore: function () {
        var link = this._popup.findElement('.dg-popup__button_name_all');

        if (link) {
            this._addEventHandler('dg-popup__button_name_all', DG.bind(this._showListPopup, this));
        }
    },

    _clearAndRenderPopup: function (popupObject) {
        this._clearEventHandlers();
        this._popup.clear('header', 'footer');
        this._view.renderPopup(popupObject);
    },

    _appendFirmList: function (res) { // (Object)
        this._firmList.addFirms(res.result.items);
        this._popup._updateScrollPosition();
    },

    _handlePopupScroll: function (e) {
        var scroller = e.originalEvent.target || e.target._scroller;

        DG.DomEvent.stop(e);

        if (this._totalPages <= 1) { return; }
        if (scroller && scroller.scrollHeight <= scroller.scrollTop + scroller.offsetHeight + this._scrollHeightReserve) {
            this._handlePaging();
        }
    },

    _handlePaging: function () {
        this._page++;

        if (this._totalPages && this._page <= this._totalPages) {
            this._api.firmsInHouse(this._id, {page: this._page}).then(DG.bind(this._appendFirmList, this));
        }

        if (this._page === this._totalPages) {
            var loader = this._firmListLoader;

            if (loader && loader.parentNode) {
                loader.parentNode.removeChild(loader);
            }

            this._popup.off('scroll', this._onScroll);
        }
    }
});

DG.Geoclicker.Handler.House.include({
    _getAddressString: function (house) {
        if (!house.address || !house.address.components) {
            return '';
        }

        return house.address.components
            .filter(function (component) {
                return component.type === 'street_number';
            })
            .map(function (component) {
                return component.street + ', ' + component.number;
            })
            .join(' / ');
    },

    _fillBody: function (house) { // // (Object) -> (DOMElement)
        var data = {},
            wrapper = DG.DomUtil.create('div', 'dg-building-callout__body'),
            filials = house.links && house.links.branches;

        var drilldown = this._getDrilldown(house);

        if (house.building_name) {
            data.address = {
                header: this._getAddressString(house),
                drilldown: drilldown
            };
        } else if (drilldown) {
            data.address = {
                drilldown: drilldown
            };
        }

        data.purpose = house.purpose_name +
            (house.floors ? ', ' + this.t('n_floors', house.floors.ground_count) : '');

        if (filials && filials.count > 0) {
            this._totalPages = Math.ceil(house.links.branches.count / this._firmsOnPage);
        }

        if (house.links && house.links.attractions && house.links.attractions.length) {
            data.attractions = house.links.attractions.reduce(function (attractions, attraction) {
                if (attraction.name) {
                    attractions.push(attraction.name);
                }

                return attractions;
            }, []);
        }

        wrapper.innerHTML = this._view.render({
            tmpl: 'house',
            data: data
        });

        if (filials && filials.items) {
            wrapper.appendChild(this._initShortFirmList(filials.items));
        }

        return wrapper;
    },

    _fillHeader: function (house) { // (Object) -> (HTMLString)
        var header = {};

        if (house.building_name) {
            header.title = house.building_name;
        } else if (house.address && house.address.components) {
            header.title = this._getAddressString(house);
        } else {
            header.title = house.purpose_name;
        }

        this._header = this._view.render({
            tmpl: 'popupHeader',
            data: header
        });

        return this._header;
    },

    _fillFooter: function (house) { // (Object) -> (HTMLString)
        var btns = [];
        var houseFilials = house.links && house.links.branches;

        // Decide if we need to display 'more organisations' button
        if (
            houseFilials &&
            houseFilials.items &&
            houseFilials.items.length &&
            houseFilials.count > houseFilials.items.length
        ) {
            btns.push(this._getShowAllData(houseFilials.count));
        }

        if (this._isRouteSearchAllowed()) {
            btns.push({
                name: 'goto',
                label: this.t('go_to'),
                icon: true,
                href: this._directionsUrl
            });
        }

        return this._view.render({
            tmpl: 'popupFooterBtns',
            data: {'btns': btns}
        });
    },

    _getShowAllData: function (filialsCount) {
        return {
            name: 'all',
            label: this.t('show_organization_in_building', filialsCount)
        };
    },

    _fillHouseObject: function (house) { // (Object) -> (Object)
        var self = this;

        return {
            header: this._fillHeader(house),
            tmpl: this._fillBody(house),
            footer: this._fillFooter(house),
            afterRender: function () {
                self._initShowMore();
                self._initPopupClose();
            }
        };
    }
});

DG.Geoclicker.Handler.Poi = DG.Geoclicker.Handler.House.extend({

    handle: function (results) { // (Object) -> Promise
        if (!results.poi) {
            return false;
        }

        // initialization setup
        this.firmCard = null;
        this._page = 1;
        this._houseObject = null;
        this._firmList = null;
        this._firmListObject = null;
        this._firmCardObject = null;
        this._onScroll = false;
        this._isFirmlistOpen = false;

        this._id = results.poi.reference.id;
        this._totalPages = 1;
        this._api = this._controller.getCatalogApi();
        this._popup = this._view.getPopup();
        this._initedPopupClose = false;
        this._directionsUrl = this._getDirectionsUrl(results.poi.reference.name);
        this._firmListLoader = this._view.initLoader(true);

        // If the POI refers to a building (e.g. galleries in Santiago),
        // show a building callout
        if (results.poi.reference.type === 'building') {
            var self = this;

            return self._api.geoGet(results.poi.reference.id)
                .then(function (result) {
                    self._houseObject = self._fillHouseObject(result.result.items[0]);
                    return Promise.resolve(self._houseObject);
                });
        }

        // Otherwise, show a firm callout
        if (results.poi.reference.type === 'branch') {
            this._fillFirmCardObject(results.poi.reference.id);
            return true;
        }

        return false;
    }

});

DG.Geoclicker.Handler.Sight = DG.Geoclicker.Handler.Default.extend({

    handle: function (results) { // (Object, String) -> Promise
        if (!results.attraction) {
            return false;
        }

        this._popup = this._view.getPopup();
        this._initedPopupClose = false;

        return Promise.resolve(this._fillSightObject(results));
    },

    _fillSightObject: function (results) { // (Object) -> Object
        var attraction = results.attraction,
            data = {},
            self = this,
            footer = {
                btns: [
                    {
                        name: 'goto',
                        label: this.t('go_to'),
                        icon: true
                    }
                ]
            };

        if (attraction.name) {
            data.buildingName = attraction.name;
            data.purpose = attraction.subtype_name;
        } else {
            data.buildingName = attraction.subtype_name;
        }

        data.description = attraction.description;

        data.drillDown = this._getDrilldown(attraction);

        if (this._checkDescFieldHeight(data.description)) {
            data.showMoreText = this.t('show_more_about_sight');
        }

        footer.btns[0].href = this._getDirectionsUrl(data.buildingName);

        return {
            tmpl: 'sight',
            data: data,
            header: this._view.render({
                tmpl: 'popupHeader',
                data: {'title': data.buildingName}
            }),
            footer: this._view.render({
                tmpl: 'popupFooterBtns',
                data: footer
            }),
            afterRender: function () {
                if (self._needShowMore) {
                    self._initShowMore();
                }
                self._initPopupClose();
            }
        };
    },

    _initPopupClose: function () {
        if (this._initedPopupClose) {
            return;
        }

        this._controller.getMap().once('popupclose', DG.bind(this._clearPopup, this));
        this._initedPopupClose = true;
    },

    _clearPopup: function () {
        this._initedPopupClose = false;
        this._clearEventHandlers();
    },

    _showMoreText: function () {
        this._desc.style.maxHeight = '100%';
        this._link.parentNode.removeChild(this._link);
        this._popup.resize();
    },

    _initShowMore: function () {
        this._link = this._popup.findElement('.dg-map-geoclicker__show-more-sights-link');
        this._desc = this._popup.findElement('.dg-map-geoclicker__sight-description');

        if (this._link && this._desc) {
            this._addEventHandler('dg-map-geoclicker__show-more-sights-link', DG.bind(this._showMoreText, this));
        }
    },

    _checkDescFieldHeight: function (desc) {
        var el = DG.DomUtil.create('div', ''),
            height;

        el.style.visibility = 'hidden';
        el.innerHTML = desc;

        this._popup._contentNode.appendChild(el);
        height = el.offsetHeight;
        this._popup._contentNode.removeChild(el);
        this._needShowMore = (height > 40);

        return this._needShowMore;
    }
});

DG.Geoclicker.View = DG.Class.extend({

    initialize: function (map, options) { // (Object, Object)
        this._map = map;
        this._popup = DG.popup({
            maxHeight: 300,
            minHeight: 50,
            maxWidth: 385,
            minWidth: 310,
            sprawling: true,
            closeOnClick: true
        });

        if (options) {
            DG.Util.setOptions(this, options);
        }
    },

    initLoader: function (isSmall) {
        var loader = document.createElement('div');
        loader.innerHTML = DG.dust('DGGeoclicker/loader', {
            small: isSmall,
            anim: this._detectCssAnimation()
        });

        return loader.firstChild;
    },

    showPopup: function (latlng, content) { // (Object)
        this._popup
            .setContent(content)
            .setLatLng(latlng)
            .openOn(this._map);
    },

    render: function (options) { // (Object) -> String
        var html,
            data = {};

        options = options || {};
        options.tmpl = options.tmpl || '';

        if (options.data) {
            html = this.renderTemplate(options.tmpl, options.data);
        } else {
            html = options.tmpl;
        }

        if (options.beforeRender) {
            options.beforeRender();
        }

        if (options.popup) {
            if (options.header) {
                data.header = options.header;
            }
            if (options.footer) {
                data.footer = options.footer;
            }
            data.body = html;
            this._popup.setContent(data);
        }
        if (options.afterRender) {
            options.afterRender();
        }

        return html;
    },

    renderTemplate: function (name, data) {
        return DG.dust('DGGeoclicker/' + name, data);
    },

    renderPopup: function (options) { // (Object) -> String
        options.popup = true;
        return this.render(options);
    },

    getPopup: function () { // () -> Object
        return this._popup;
    },

    _detectCssAnimation: function () {
        var animation = false,
            domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),
            elm = document.createElement('div');

        if (elm.style.animationName) { animation = true; }

        if (animation === false) {
            for (var i = 0; i < domPrefixes.length; i++) {
                if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
                    animation = true;
                    break;
                }
            }
        }
        return animation;
    }
});

DG.Geoclicker.Controller = DG.Class.extend({

    options: {
        // if handler worked successfully, it should return rendering object that will be processed in View , otherwise it should return false
        // default handler always should return rendering object
        'handlersSequence': {
            'poi': DG.Geoclicker.Handler.Poi,
            'attraction': DG.Geoclicker.Handler.Sight,
            'building': DG.Geoclicker.Handler.House,
            'street': DG.Geoclicker.Handler.CityArea,
            'adm_div.place': DG.Geoclicker.Handler.CityArea,
            'adm_div.district': DG.Geoclicker.Handler.CityArea,
            'adm_div.division': DG.Geoclicker.Handler.CityArea,
            'adm_div.settlement': DG.Geoclicker.Handler.CityArea,
            'adm_div.city': DG.Geoclicker.Handler.CityArea,

            'default': DG.Geoclicker.Handler.Default,

            'apiError': DG.Geoclicker.Handler.ApiError

//            station_platform
//            project
//            station
//            crossbroad
//            metro
        }
    },

    initialize: function (map, options) { // (Object, Object)
        this._options = options;
        this._handlers = {};
        this._catalogApi = new DG.Geoclicker.Provider.CatalogApi(map);
        this._map = map;
        this._view = new DG.Geoclicker.View(map);

        this._renderHandlerResult = DG.bind(this._renderHandlerResult, this);
        this._lastHandleClickArguments = null;
    },

    handlePopupClose: function (popup) { // (Object)
        if (popup === this._view.getPopup()) {
            this._lastHandleClickArguments = null;
            this._catalogApi.cancelLastRequest();
        }
    },

    handleClick: function (latlng, zoom, meta) { // (Object, Number, Object)
        var self = this,
            args = Array.prototype.slice.call(arguments, 0);

        function beforeRequest () {
            var loader = self._view.initLoader();
            self._view._popup.clear();
            self._view.showPopup(latlng, loader);
            self._lastHandleClickArguments = args;
        }

        if (meta && meta.linked && meta.linked.type != 'sight' && meta.linked.type != 'attraction') {
            if (meta.linked.type != 'branch' && meta.linked.type != 'building') {
                return;
            }

            beforeRequest();
            self.handleResponse({
                poi: {
                    reference: meta.linked
                }
            });
        } else {
            this._catalogApi.getLocations({
                latlng: latlng,
                zoom: zoom,
                beforeRequest: beforeRequest
            }).then(function (result) {
                self.handleResponse(result);
            }, function (error) {
                self.handleResponse(error);
            });
        }
    },

    handleResponse: function (result) { // (Object)
        var type;

        if (!result) {
            this._runHandler('default');
            return;
        }

        if (result === 'no type') {
            return;
        }

        if (result === 'aborted') {
            this._runHandler('apiError');
            return;
        }

        type = this.findHandler(result);

        while (type) {
            if (this._runHandler(type, result)) {
                return;
            }
            delete result[type];

            type = this.findHandler(result);
        }
        this._runHandler('default');
    },

    findHandler: function (result) { // (Object) -> String|Null
        for (var i in this.options.handlersSequence) {
            if (result[i]) {
                return i;
            }
        }

        return null;
    },

    getCatalogApi: function () { // () -> Object
        return this._catalogApi;
    },

    getMap: function () {
        return this._map;
    },

    reinvokeHandler: function () {
        if (this._lastHandleClickArguments) {
            this.handleClick.apply(this, this._lastHandleClickArguments);
        }
    },

    _runHandler: function (type, data) { // (String, Object) -> Boolean
        data = data || {};
        this._initHandlerOnce(type);
        this._handlers[type].addClickEvent();

        var handlerResult = this._handlers[type].handle(data, type);

        return handlerResult && handlerResult.then ?
            handlerResult.then(this._renderHandlerResult) :
            handlerResult;
    },

    _renderHandlerResult: function (result) {
        this._view.renderPopup(result);
    },

    _initHandlerOnce: function (type) { // (String)
        if (!this._handlers[type]) {
            this._handlers[type] = new this.options.handlersSequence[type](this, this._view, this._map, this._options);
        }
    }
});

DG.Geoclicker.Handler.Default.Dictionary.it = DG.extend({
    apiErrorTitle: 'Oh oh, c\'è&nbsp;un&nbsp;errore',
    apiErrorBody: 'I nostri server si rifiutano di rispondere. Stiamo facendo del nostro meglio per convincerli a&nbsp;comportarsi bene. Ritorna tra qualche minuto.',
    we_have_not : 'Non disponiamo ancora di informazioni su questo posto',
    noname : 'Nome non indicato',
    'adm_div.place' : 'Luogo',
    'adm_div.division' : 'Zona',
    'adm_div.settlement' : 'Comune',
    street : 'Via',
    'adm_div.district' : 'Municipalità',
    'adm_div.city' : 'Сittà',
    go_to : 'Come arrivare',
    show_organization_in_building : ['{n} azienda in tutto', '{n} aziende in tutto'],
    show_more_about_sight : 'Maggiori informazioni',
    back_button: 'Indietro',
    n_floors : ['{n} piano', '{n} piani']
}, DG.Dictionary.it);

DG.Geoclicker.Handler.Default.Dictionary.ru = DG.extend({
    apiErrorTitle: 'Ошибочка вышла',
    apiErrorBody: 'Наши серверы отказываются отвечать. Мы уже прикладываем все силы, чтобы вразумить их. Возвращайтесь к&nbsp;нам через&nbsp;несколько минут.',
    we_have_not : 'Это место мы ещё не успели изучить',
    noname: 'Без названия',
    'adm_div.place': 'Место',
    'adm_div.division': 'Округ',
    'adm_div.settlement': 'Населенный пункт',
    street: 'Улица',
    'adm_div.district': 'Район',
    'adm_div.city': 'Город',
    go_to: 'Проехать сюда',
    show_organization_in_building: ['Всего {n} организация', 'Всего {n} организации', 'Всего {n} организаций'],
    show_more_about_sight: 'Подробнее',
    back_button: 'Назад',
    n_floors: ['{n} этаж', '{n} этажа', '{n} этажей']
}, DG.Dictionary.ru);

DG.Geoclicker.Handler.Default.Dictionary.en = DG.extend({
    apiErrorTitle: 'Oops! Error detected.',
    apiErrorBody: 'Our servers are not responding. We are doing our best to straighten them out. Please return to us in a few minutes.',
    we_have_not: 'We haven\'t collected info about this place yet',
    noname : 'No name',
    'adm_div.place' : 'Place',
    'adm_div.division' : 'Area',
    'adm_div.settlement' : 'Village',
    street : 'Street',
    'adm_div.district' : 'District',
    'adm_div.city' : 'City',
    go_to : 'Directions to here',
    show_organization_in_building : ['{n} organization total', '{n} organizations total'],
    back_button : 'Back',
    show_more_about_sight : 'More information',
    n_floors : ['{n} floor', '{n} floors']
}, DG.Dictionary.en);

DG.Geoclicker.Handler.Default.Dictionary.cs = DG.extend({
    apiErrorTitle: 'Chybička se&nbsp;vloudila',
    apiErrorBody: 'Naše servery odmítají reagovat. Již nyní vynakládáme veškeré úsilí, abychom je přivedli k rozumu. Zkuste akci opakovat za několik minut.',
    we_have_not : 'O tomto místě zatím nemáme informace',
    noname : 'Bez názvu',
    'adm_div.place' : 'Místo',
    'adm_div.division' : 'Správní obvod',
    'adm_div.settlement' : 'Obec',
    street : 'Ulice',
    'adm_div.district' : 'Městská část',
    'adm_div.city' : 'Město',
    go_to : 'Cesta sem',
    show_organization_in_building : ['Celkem {n} organizace', 'Celkem {n} organizace', 'Celkem {n} organizací'],
    back_button : 'Zpět',
    show_more_about_sight : 'Více',
    n_floors : ['{n} patro', '{n} patra', '{n} pater']
}, DG.Dictionary.cs);

DG.Geoclicker.Handler.Default.Dictionary.es = DG.extend({
    apiErrorTitle: 'Vaya, ha ocurrido un error',
    apiErrorBody: 'Nuestros servidores se niegan a responder. Ya nos estamos esforzando por hacerlos entrar en razón. Vuelva con nosotros pasados unos minutos.',
    we_have_not : 'Todavía no hemos recopilado la información sobre este lugar',
    noname : 'Sin nombre',
    'adm_div.place' : 'Lugar',
    'adm_div.division' : 'Comuna',
    'adm_div.settlement' : 'Población',
    street : 'Calle',
    'adm_div.district' : 'Comuna',
    'adm_div.city' : 'Ciudad',
    go_to : 'Ir para allá',
    show_organization_in_building : ['Total {n} organización', 'Total {n} organizaciones', 'Total {n} organizaciones'],
    show_more_about_sight : 'Read more',
    back_button: 'Atrás',
    n_floors : ['{n} piso', '{n} pisos']
}, DG.Dictionary.es);

var FirmCard = function (firm, options) {
    this._setOptions(options);
    this._firmContentObject = {};
    this._schedule = new FirmCard.Schedule({
        localLang: this.options.lang,
        dict: this.dict
    });

    this.render(firm);
};

FirmCard.prototype = {

    render: function (firmId) {
        if (!firmId) { return; }

        if (firmId !== this._firmId) {
            this._firmContentObject = {};
            this._renderCardById(firmId);
        } else {
            this._toggleEventHandlers();
        }

        return this._firmContentObject;
    },

    getSchedule: function () {
        return this._schedule;
    },

    getContainer: function () {
        return this._container;
    },

    _renderCardById: function (firmId) {
        var self = this;

        this.options.ajax(firmId).then(function (res) {
            if (!res) { return false; }
            var data = res.result.items;
            if (data !== 'undefined') {
                self._firmData = data[0];

                // Support for old WebAPI format.
                // TODO: remove this call after WebAPI release
                self._convertWebsite();

                self._firmId = firmId;
                self._renderFirmCard();
                self._toggleEventHandlers();
            }
        }, function (error) {
            self._renderError();
        });
    },

    _createFirmContainer: function () {
        var firm = document.createElement('div');
        firm.setAttribute('id', 'dg-map-firm-full-' + this._firmId);
        firm.setAttribute('class', 'dg-map-firm-full');

        return firm;
    },

    _getPaymentTypes: function (data) {
        var result = [],
            groupName = 'general_payment_type';

        if (!data.attribute_groups) {
            return result;
        }

        data.attribute_groups.forEach(function (group) {
            if (group.name) {
                return;
            }

            group.attributes.forEach(function (attr) {
                if (attr.tag.substring(0, groupName.length) === groupName) {
                    result.push(attr.name);
                }
            });
        });

        return result;
    },

    _groupRubrics: function (data) {
        var result = {
            primary: [],
            additional: []
        };

        if (!data.rubrics || !data.rubrics.length) {
            return result;
        }

        data.rubrics.forEach(function (rubric) {
            result[rubric.kind].push(rubric);
        });

        return result;
    },

    // Support for old WebAPI format.
    // TODO: remove this function after WebAPI release
    _convertWebsite: function () {
        if (!this._firmData.contact_groups) {
            return;
        }

        this._firmData.contact_groups.forEach(function (group) {
            if (!group.contacts) {
                return;
            }

            group.contacts.forEach(function (contact) {
                if (contact.type != 'website') {
                    return;
                }

                if (!contact.url) {
                    contact.url = contact.value;
                }
            });
        });
    },

    _renderFirmCard: function () {
        var firmCardBody, schedule, forecast, links, btns, paymentTypes, rubrics,
            data = this._firmData,
            container = this._container = this._createFirmContainer();

        schedule = this._schedule.transform(data.schedule, {
            zoneOffset: this.options.timezoneOffset,
            apiLang: this.options.lang,
            localLang: this.options.lang
        });

        forecast = this._schedule.forecast(schedule);

        paymentTypes = this._getPaymentTypes(data);
        rubrics = this._groupRubrics(data);

        firmCardBody = this._buildFirmCardBody(
            this._getConfigFirmCardBody(data, schedule, forecast, paymentTypes, rubrics)
        );

        links = this._fillHeaderLinks();
        btns = this._fillFooterButtons();

        //fill object for view render
        this._firmContentObject.header = this.options.render('firmCardHeader', {'firmName': data.name, 'links': links});
        container.innerHTML = firmCardBody;
        this._firmContentObject.tmpl = container;
        if (btns.length) {
            this._footerContainer = document.createElement('div');

            this._footerContainer.innerHTML = this.options.render('popupFooterBtns', {'btns': btns});
            this._firmContentObject.footer = this._footerContainer;
        }

        if (this.options.onFirmReady) {
            this.options.onFirmReady(this._firmContentObject);
        }
    },

    _renderError: function() {
        this._firmContentObject.header = this.options.render('popupHeader', {
            title: this.options.t('apiErrorTitle')
        });

        this._firmContentObject.tmpl = this.options.t('apiErrorBody');

        if (this.options.onFirmReady) {
            this.options.onFirmReady(this._firmContentObject);
        }
    },

    _getConfigFirmCardBody: function (data, schedule, forecast, attributes, rubrics) {
        return [
            {
                tmpl: 'firmCardAddr',
                data: {
                    address: data.address_name,
                    comment: data.address_comment
                }
            },
            {
                tmpl: 'firmCardContacts',
                data: {
                    groups: data.contact_groups
                }
            },
            {
                tmpl: 'firmCardSchedule',
                data: {
                    schedule: schedule,
                    forecast: forecast
                }
            },
            {
                tmpl: 'frimCardPayments',
                data: {
                    payments: attributes
                }
            },
            {
                tmpl: 'firmCardRubric',
                data: {
                    rubrics: rubrics
                }
            }
        ];
    },

    _buildFirmCardBody: function (parts) {
        var self = this;
        return parts.reduce(function (body, item) {
            var html = self.options.render(item.tmpl, item.data);
            return body + html;
        }, '');
    },

    _fillFooterButtons: function () {
        var btns = [];

        if (this.options.backBtn) {
            btns.push({ name: 'firm-card-back',
                        label: this.dict.t(this.options.lang, 'btnBack'),
                        icon: true
            });
        }

        if (this.options.showRouteSearch) {
            btns.push({ name: 'goto',
                        label: this.dict.t(this.options.lang, 'btnFindWay'),
                        icon: true,
                        href: this.options.gotoUrl
            });
        }

        if (
            this._firmData.links &&
                this._firmData.links.entrances &&
                this.options.showEntrance
        ) {
            btns.push({ name: 'show-entrance',
                        label: this.dict.t(this.options.lang, 'btnEntrance'),
                        icon: true
            });
        }

        return btns;
    },

    _fillHeaderLinks: function () {
        var links = [],
            reviewData = this._firmData.reviews,
            booklet,
            link;

        if (this._firmData.external_content) {
            this._firmData.external_content.forEach(function (el) {
                if (el && el.type == 'booklet') {
                    booklet = el;
                }
            });
        }

        if (reviewData && reviewData.is_reviewable) {
            links.push({
                name: 'flamp_stars',
                width: reviewData.rating * 20
            });
            links.push({
                name: 'flamp_reviews',
                label: this.dict.t(this.options.lang, 'linkReviews', reviewData.review_count ? reviewData.review_count : 0),
                href: FirmCard.DataHelper.getFlampUrl(this._firmId)
            });
        }

        // Retrieve photo data from external content block
        var photos;
        var externalContent = this._firmData.external_content;

        for (var i = 0; i < externalContent.length; i++) {
            if (
                externalContent[i].type == 'photo_album' &&
                externalContent[i].subtype == 'common'
            ) {
                photos = externalContent[i];
                break;
            }
        }

        if (!this.options.isMobile && photos && photos.count && this.options.showPhotos) {
            link = L.Util.template(DG.config.photosLink, {
                'id': this._firmId,
                'domain': this.options.domain
            });

            links.push({name: 'photos',
                href: link,
                label: this.dict.t(this.options.lang, 'linkPhoto', photos.count)
            });
        }

        if (!this.options.isMobile && booklet && booklet.url && this.options.showBooklet) {
            links.push({
                name: 'booklet',
                href:  booklet.url,
                label: this.dict.t(this.options.lang, 'linkBooklet')
            });
        }


        return links;
    },

    _events: {
        'dg-popup__button_name_firm-card-back': function() {
            this.options.backBtn();
            this._toggleEventHandlers(true);
        },
        'dg-popup__button_name_show-entrance': function() {
            var ent = new this.options.showEntrance({'vectors': this._firmData.links.entrances[0].geometry.vectors});
            ent.addTo(this.options.map);
            ent.fitBounds();
            this._toggleEventHandlers(true);
        },
        'dg-schedule__today': function() {
            this._onToggleSchedule();
        }
    },

    _toggleEventHandlers: function (flag) {
        this.options.popup[flag ? 'off' : 'on']('click', this._onClick, this);
        this.options.map[flag ? 'off' : 'on']('popupclose', this._onClose, this);
    },

    _onClick: function (e) {
        var target = e.originalEvent.target;

        for (var eventClass in this._events) {
            if (this._events.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                DG.DomEvent.preventDefault(e.originalEvent);
                this._events[eventClass].call(this, target);
                return;
            }
        }
    },

    _onClose: function (e) {
        this._toggleEventHandlers(true);
    },

    _onToggleSchedule: function () {
        var schedule = this._container.querySelector('.dg-schedule__table'),
            forecast = this._container.querySelector('.dg-schedule__now'),
            target = this._container.querySelector('.dg-schedule__today'),
            showClass = ' dg-schedule__today_shown_true';

        if (!schedule) { return; }

        if (schedule.style.display === 'block') {
            schedule.style.display = 'none';
            forecast.style.display = 'block';
            target.className = target.className.replace(showClass, '');
        } else {
            forecast.style.display = 'none';
            schedule.style.display = 'block';
            target.className += showClass;
        }

        if (this.options.onToggle) {
            this.options.onToggle();
        }
    },

    _setOptions: function (options) {
        var option,
            options = options || {};

        this.options = options;
        options.lang = options.lang || 'ru';

        for (option in options) {
            if (options.hasOwnProperty(option)) {
                this.options[option] = options[option];
            }
        }
    },

    _hasTouch: function () {
        return (('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0));
    }
};

FirmCard.DataHelper = {
	payMethods : [
		'americanexpress',
		'cash',
		'dinersclub',
		'goldcrown',
		'internet',
		'mastercard',
		'noncash',
		'visa'
	],

	_msgs : {},

	getFlampUrl : function (id) {
	    return DG.config.flampUrl.concat(id, '?', DG.config.flampGoogleAnalytics);
	},

	msg : function (msg) {
		if (this._msgs.hasOwnProperty(msg)) {
			return this._msgs[msg];
		}
		console && console.log("Cant't find translation for '" + msg + "'.");
		return msg.toString().replace('_', ' ');
	},

	getProjectTime: function (timezoneOffset, time) {
        var now, utc;

        if (time) {
            now = new Date(time);
        } else {
            now = new Date();
        }

        if (timezoneOffset) {
            utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            return new Date(utc + (60000 * timezoneOffset));
        } else {
            return now;
        }
    }
};

/* global
    FirmCard: false
*/
(function () {
    FirmCard.List = function (firms, options) {
        this._firms = {}; // {'firmID': firmDomObj}
        this._setOptions(options);

        this._container = options && options.container || document.createElement('ul');
        this._container.setAttribute('class', 'dg-building-callout__list');

        this._eventHandlersInited = false;
        this._firmCard = this._createFirm();
        this.renderList(firms);
    };

    FirmCard.List.prototype = {

        renderList: function (firms) {
            if (firms) {
                this._toggleEventHandlers();
                this.addFirms(firms);
            }
            if (this.options.onListReady) {
                this.options.onListReady(this._container);
            }

            return this._container;
        },

        _processFirms: function (firms, action) {
            if (!firms) { return; }
            var method = '_' + action + 'Firm';
            if (this._isArray(firms)) {
                for (var i = 0, l = firms.length; i < l; i++) {
                    this[method](firms[i]);
                }
            } else {
                this[method](firms);
            }

        },

        addFirms: function(firms) {
            this._processFirms(firms, 'add');
        },

        removeFirms: function(firms) {
            this._processFirms(firms, 'remove');
        },

        setLang: function (newLang) {
            this.options.firmCard.lang = newLang;
        },

        getLang: function () {
            return this.options.firmCard.lang;
        },

        getContainer: function () {
            return this._container;
        },

        clearList : function () {
            this._firms = {};
            this._toggleEventHandlers(true);
            this._clearContainer();
        },

        _removeFirm: function (id) {
            if (!this._firms[id]) { return false; }
            this._container.removeChild(this._firms[id]);
            delete this._firms[id];
        },

        _addFirm: function (firmData) {
            var tmpl = this.options.firmlistItemTmpl,
                domFirm, firm, content;

            firm = {
                name: firmData.name,
                id: firmData.id.split('_').slice(0, 1)
            };

            if (!(firm.id in this._firms)) {

                domFirm = this._createListItem();

                content = tmpl ? this.options.firmCard.render(tmpl, {'firm': firm}) : firm.name;

                domFirm.insertAdjacentHTML('beforeend', content);

                this._firms[firm.id] = domFirm;
                this._container.appendChild(domFirm);
            }
        },

        _createListItem: function () {
            var item = document.createElement('li');
            item.setAttribute('class', 'dg-building-callout__list-item');

            return item;
        },

        _isArray: function (obj) {
            return {}.toString.call(obj) === '[object Array]';
        },

        _createFirm: function (firmData) {
            return new FirmCard(firmData, this.options.firmCard);
        },

        _isEmptyObj: function (obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    return false;
                }
            }

            return true;
        },

        _events: {
            'dg-popup__link': function(target) {
                var s = this._firmCard.render(target.id);

                this.options.firmCard[this._isEmptyObj(s) ? 'pasteLoader' : 'onFirmReady'](s);

                this.options.firmCard.onFirmClick && this.options.firmCard.onFirmClick();

                this._toggleEventHandlers(true);
            },
            'dg-building-callout__list-item': function(target) {
                target = target.children[0];

                this._events['dg-popup__link'].call(this, target);
            },
            'dg-popup__button_name_back': function() {
                this.options.firmCard.onShowLess();

                this._toggleEventHandlers(true);
            }
        },

        _toggleEventHandlers : function (flag) {
            this.options.firmCard.popup[flag ? 'off' : 'on']('click', this._onClick, this);
        },

        _onClick: function (e) {
            var target = e.originalEvent.target;

            for (var eventClass in this._events) {
                if (this._events.hasOwnProperty(eventClass) && target.className.indexOf(eventClass) > -1) {
                    DG.DomEvent.preventDefault(e.originalEvent);
                    this._events[eventClass].call(this, target);
                    return;
                }
            }
        },

        _clearContainer: function () {
            var container = this._container;

            while (container.hasChildNodes()) {
                container.removeChild(container.firstChild);
            }
        },

        _setOptions: function (options) {
            options || (options = {});
            this.options = options;
            this.options.firmCard || (this.options.firmCard = {});

            if (!options.firmCard.lang) {
                this.options.firmCard.lang = 'ru';
            }

            for (var option in options) {
                if (options.hasOwnProperty(option)) {
                    this.options[option] = options[option];
                }
            }
        }
    };
})();

/*global
    FirmCard:false
*/
FirmCard.Schedule = function (options) {
    options = options || {};

    this.localLang = options.localLang || 'ru';
    this.dict = options.dict;
    return this;
};

FirmCard.Schedule.prototype = {

    setLang: function (lang) {
        this.localLang = lang || 'ru';
        return this;
    },

    transform: function (model, params) {
        if (!model) {
            return;
        }
        params = params || {};

        function bind(fn, obj) { // (Function, Object) -> Function
            var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
            return function () {
                return fn.apply(obj, args || arguments);
            };
        }

        var todayKey, // Mon, Tue ...
            today, // Объект модели - текущий день недели
            from, // Самое раннее время открытия за день
            to, // Самое позднее время закрытия за день
            zoneOffset = params.zoneOffset || 0,
            schedule = {}, // Объект-расписание, формируемый под шаблон
            now = params.now || FirmCard.DataHelper.getProjectTime(zoneOffset).getTime(), // Current timestamp in milliseconds
            weekKeys = [], // Ключи дней недели, определяют порядок дней и первый день недели. 0 - первый день недели в регионе (не обязательно Mon)
            weekKeysLocal = [],
            weekFullKeysLocal = [],
            weekKeysShort =  [ 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun' ],
            weekKeysFull = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'],
            localLang = params.localLang || this.localLang,
            localWorkingDays = params.localWorkingDays || [0, 1, 1, 1, 1, 1, 0],
            firstdayOffset = params.firstdayOffset || 1,
            minHoursToDisplayClosure = params.minHoursToDisplayClosure || 4,
            t = bind(this.dict.t, this.dict);


        function capitaliseFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function getHours(str) {
            return str.substr(0, 2);
        }

        function getMinutes(str) {
            return str.substr(3, 2);
        }

        // Конвертация временной точки формата апи в формат отображения (25:00 -> 01:00)
        function formatTime(str) {
            var hours = +getHours(str) % 24 + '';

            if (hours.length === 1) {
                hours = '0' + hours;
            }

            return hours + ':' + getMinutes(str);
        }

        // Конвертация int числа в номер дня недели (диапазон 0-6)
        function dayNum(n) {
            return n % 7;
        }


        /* jshint ignore:start */
        // Возвращает последний элемент массива
        // Взято из Underscore.js http://underscorejs.org/#last
        function getArrayLast(arr, n) {
            if ( arr == null ) return void 0;
            if (   n == null ) return arr[ arr.length - 1 ];
            return slice.call( arr, Math.max(arr.length - n , 0) );
        }


        // Выполняет глубокое сравнение объектов
        // Взято из Underscore.js http://underscorejs.org/#isEqual
        // Упрощено для тех трёх сравнений, которые выполняются в Shedule.js
        function isEqual(obj1, obj2) {
            if ( obj1 === obj2 ) return true;
            if ( ! ( obj1 instanceof Object ) || ! ( obj2 instanceof Object ) ) return false;
            if ( obj1.constructor !== obj2.constructor ) return false;
            for ( var prop in obj1 ) {
                if ( ! obj1.hasOwnProperty( prop ) ) continue;
                if ( ! obj2.hasOwnProperty( prop ) ) return false;
                if ( obj1[ prop ] === obj2[ prop ] ) continue;
                if ( typeof( obj1[ prop ] ) !== "object" ) return false;
                if ( ! isEqual( obj1[ prop ],  obj2[ prop ] ) ) return false;
            }
            for ( prop in obj2 ) {
            if ( obj2.hasOwnProperty( prop ) && ! obj1.hasOwnProperty( prop ) ) return false;
            }

            return true;
        }

        // Generate an integer Array containing an arithmetic progression. A port of
        // the native Python `range()` function. See
        // [the Python documentation](http://docs.python.org/library/functions.html#range).
        function range(start, stop, step) {
        if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
        }
        step = arguments[2] || 1;

        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(length);
        while(idx < length) {
            range[idx++] = start;
            start += step;
        }

        return range;
        }


        //Заполняет свойства объекта значениями по умолчанию
        //Взято из Underscore.js http://underscorejs.org/#defaults
        function fillDefaults(obj) {
         var args = Array.prototype.slice.call(arguments, 1);
         args.forEach(function(source) {
            if (source) {
                for (var prop in source) {
                    if (obj[prop] === void 0) obj[prop] = source[prop];
                }
            }
        });
        return obj;
        }

        //Сортирует значения согласно с итератором
        //Взято с Underscore.js http://underscorejs.org/#sortBy
        function sortBy(obj, iterator){
            return pluck(obj.map( function(value, index, list) {
                return {
                        value: value,
                        index: index,
                        criteria: iterator.call(this, value, index, list)
                        };
                }).sort(function(left, right) {
                        var a = left.criteria;
                        var b = right.criteria;
                        if (a !== b) {
                        if (a > b || a === void 0) return 1;
                        if (a < b || b === void 0) return -1;
                        }
                return left.index - right.index;
                }), 'value');
        }

        /* jshint ignore:end */

        function pluck(arr, key){
            var i, rv = [];
            for (i = 0; i < arr.length; ++i) {
            rv[i] = arr[i][key];
            }
            return rv;
        }


        // Преобразовать расписание на день в упорядоченный массив временных отсечек (string)
        // Сейчас полагается, что API уже выдаёт сортированный массив
        function getSortedTimePoints(day) {
            var points = [],
                from, to,
                deltaHours, deltaMinutes;

            if (!day || !day.working_hours) {
                return [];
            }

            for (var i = 0 ; i < day.working_hours.length ; i++) {
                from = day.working_hours[i].from;
                to = day.working_hours[i].to;

                deltaHours = getHours(to) - getHours(from);
                deltaMinutes = getMinutes(to) - getMinutes(from);
                if (deltaHours < 0 || (deltaHours === 0 && deltaMinutes <= 0)) { // Если "до" меньше или равно "от" - значит указывает на завтра
                    to = (+getHours(to) + 24) + ':' + getMinutes(to); // (01:00 -> 25:00)
                }

                points[i * 2] = {
                    time: from,
                    type: 'open'
                };
                points[i * 2 + 1] = {
                    time: to,
                    type: day.working_hours.length - 1 === i ? 'close' : 'lunch'
                };
            }

            return points;
        }

        // Возвращает массив timestamp всех точек, всех дней недели, от сегодняшнего и в будущее
        // Например, сегодня среда, отсечки будут взяты для дат со среды (сегодня) по следующий вторник включительно
        function getTimeStamps(model) {
            var timestamps = [],
                out = [],
                timePoints,
                num = weekKeys.indexOf(todayKey); // Номер сегодняшнего дня недели (для данного региона)


            // Цикл по дням недели начиная с сегодняшнего
            var j; // Номер текущего дня в массиве weekKeys
            for (var i = 0 ; i < 7 ; i++) {
                j = dayNum(num + i);
                timePoints = getSortedTimePoints(model[weekKeys[j]]);
                // Цикл по точкам времени с конвертацией в timestamp
                timePoints.forEach(
                    /* jshint -W083 */
                    function (point) {
                    // now - обязательно! иначе будет браться текущий timestamp что чревато несовпадениями при медленном быстродействии
                    // Вычислить таймстемп для данного дня недели, часа и минуты, в будущем, но ближайший к now
                    var tsp = new Date(now);
                    tsp.setDate(tsp.getDate()+i);
                    tsp.setHours(getHours(point.time));
                    tsp.setMinutes(getMinutes(point.time));
                    var ts = tsp.getTime();



                    timestamps.push({
                        ts: ts,
                        type: point.type
                    });

                    if (timestamps[timestamps.length - 1] && timestamps[timestamps.length - 2]) {
                        // Парно удаляем совпадающие точки (они не имеют смысла - это сегодня 24:00 и завтра 00:00)
                        if (timestamps[timestamps.length - 1].ts === timestamps[timestamps.length - 2].ts) {
                            timestamps.pop();
                            timestamps.pop();
                        }
                    }

                    if (timestamps[timestamps.length - 1] && timestamps[timestamps.length - 2]) {
                        // Парно переносим точки в будущее, если они обе в прошлом (первая точка ([0]) должна быть всегда открытием!)
                        if (timestamps[timestamps.length - 1].ts <= now && timestamps[timestamps.length - 2].ts <= now) {
                            timestamps[timestamps.length - 1].ts += (7 * 24 * 60 * 60 * 1000);
                            timestamps[timestamps.length - 2].ts += (7 * 24 * 60 * 60 * 1000);
                        }
                    }
                }
                /* jshint +W083 */
                );
            }

            // Сортируем на возрастание, ведь возможно были переносы в будущее
            timestamps = sortBy(timestamps, function (timestamp) { return timestamp.ts; });

            // Удаляем попарно совпадающие точки времени
            i = 0;
            while (i < timestamps.length) {
                if (timestamps[i + 1] && timestamps[i].ts === timestamps[i + 1].ts) {
                    i++;
                } else {
                    out.push(timestamps[i].ts);
                }
                i++;
            }

            // Проверка на ежедневно-круглосуточность
            if (out.length === 2 && (out[1] - out[0]) === (7 * 24 * 60 * 60 * 1000)) {
                return [];
            }

            return timestamps;
        }

        function whenOpenInverse(h, d, num) {
            if (d === 1 && h > minHoursToDisplayClosure ) {
                return t(localLang, 'tommorow');
            } else if (d > 1) {
                /* jshint -W015 */
                switch (num) {
                    case 0: return t(localLang, 'nextSun');
                    case 1: return t(localLang, 'nextMon');
                    case 2: return t(localLang, 'nextTue');
                    case 3: return t(localLang, 'nextWed');
                    case 4: return t(localLang, 'nextThu');
                    case 5: return t(localLang, 'nextFri');
                    case 6: return t(localLang, 'nextSat');
                }
                /* jshint +W015 */
            }

            return;
        }


        //Возвращает интервал в целых днях, с поправкой на смену дня в полночь, между
        // @param timestampEnd и @param dateStart
        function dayInterval(timestampEnd, dateStart) {

            var oneDay = 1000 * 60 * 60 * 24,
                dateEnd = new Date(timestampEnd.ts);

            var diff;

            diff = Math.round((dateEnd - dateStart) / oneDay);

            if( timestampEnd.type==='open' && dateEnd.getHours() < 1 )
                { diff ++; }

            return diff;
        }


        // Поместить данные в объект для шаблона о сегодняшнем дне
        function setTodayString(today) {

            var timePoints,
                periods = [],
                timestamps;

            schedule.now = {};

            // Timestamps всех отсечек
            timestamps = getTimeStamps(model);

            if (!timestamps.length) {
                schedule.always = true; // Работает ежедневно круглосуточно
                schedule.now.open = true;
            }


            for (var i = 0 ; i < timestamps.length ; i++) {
                // Попали между точками i-1 и i // Мы находимся заведомо в будущем относительно 1
                if (now >= (timestamps[i - 1] && timestamps[i - 1].ts || 0) && now < timestamps[i].ts) {
                    var h = Math.floor((timestamps[i].ts - now) / (1000 * 60 * 60)), // Количество часов до следующего timestamp
                        m = Math.floor((timestamps[i].ts - now) / (1000 * 60) - h * 60), // Количество минут (без часов) до следующего timestamp
                        dayNow = new Date(now),

                        // открыто если следующая итерация не открытие
                        nowIsOpen = timestamps[i].type !== 'open';

                        //var d = dayOfYear(dayTs) - dayOfYear(dayNow);
                        //var d = dayInterval(dayTs, dayNow, nowIsOpen);
                        var d = dayInterval(timestamps[i], dayNow);



                    // округляем минуты до кратных 5
                    m = Math.floor(m / 10) * 10 ? Math.floor(m / 10) * 10 : 5;

                    schedule.now.open = nowIsOpen;
                    schedule.now.lunch = !!(timestamps[i - 1] && timestamps[i - 1].type === 'lunch' || getArrayLast(timestamps).type === 'lunch');

                    schedule.will = {
                        willType: timestamps[i].type,
                        d: d,
                        h: h,
                        m: m
                    };

                    // Когда закроется или откроется
                    var willWhen = new Date(timestamps[i].ts);
                    schedule.will.when = whenOpenInverse(h, d, willWhen.getDay());


                    var willTill = new Date(timestamps[i].ts),
                        strHours = willTill.getHours(),
                        strMinutes = willTill.getMinutes();

                    if (strHours < 10) { strHours = '0' + strHours; }
                    if (strMinutes < 10) { strMinutes = '0' + strMinutes; }

                    schedule.will.till = strHours+':'+strMinutes;
                }
            }

            if (!today) {
                return; // На сегодня расписания нет - сейчас закрыто
            }

            timePoints = pluck(getSortedTimePoints(today), 'time');

            // Цикл по периодам работы за день
            for (i = 2 ; i < timePoints.length ; i = i + 2) {
                periods.push({ from: timePoints[i - 1], to: timePoints[i] });
            }

            from = formatTime(timePoints[0]);
            to = formatTime(timePoints[timePoints.length - 1]);

            if (from === to) { // Круглосуточно
                schedule.today = {
                    alltime: true,
                    alltimeStr: t(localLang, 'worksAroundTheClock'),
                    from: '00:00',
                    to: '24:00'
                };
            } else { // От from до to
                schedule.today = {
                    from: from,
                    to: to
                };
            }

            if (periods.length > 0) { // Перерывы на обед
                schedule.lunch = periods;
                schedule.lunchStr = t(localLang, 'lunch');
            }
        }

        // Формирование объекта-таблицы-расписания для шаблона
        function makeTable() {
            var column = [],
                hasLunch = false;

            for (var j = 0 ; j < 7 ; j++) {
                var dayKey = weekKeys[j],
                    lunchMaxLength = 0;

                column[j] = {};

                if (model[dayKey]) {
                    var day = model[dayKey],
                        timePoints = pluck(getSortedTimePoints(day), 'time'),
                        lunch = []; // Отрезки времени (отсортированные моменты) на обеды

                    // Цикл по периодам работы за день
                    for (var i = 2 ; i < timePoints.length ; i = i + 2) {
                        hasLunch = true;
                        lunch.push({ from: timePoints[i - 1], to: timePoints[i] });
                    }
                    lunchMaxLength = Math.max(timePoints.length / 2, lunchMaxLength);

                    column[j] = {
                        from: formatTime(timePoints[0]),
                        to: formatTime(timePoints[timePoints.length - 1]),
                        lunch: lunch
                    };
                }

                if (dayKey === todayKey) { // Сегодняшний день надо подсветить
                    column[j].active = true;
                }

                column[j].key = weekKeysLocal[j];
            }

            // Дополнение пустыми объектами массивов lunch
            column.forEach( function (col) {
                if (col.lunch) {
                    fillDefaults(col.lunch, range(1, lunchMaxLength));
                }
            });

            return {
                table: column,
                hasLunch: hasLunch
            };
        }

        // Сгенерировать строку для всех дней model, совпадающих с day
        function makeSimpleString(day, model) {
            var points,
                out = {
                    dayList: [],
                    lunch: []
                },
                lunchesTime = [];

            if (day && day.working_hours && day.working_hours.length) {
                points = pluck(getSortedTimePoints(day), 'time');
                points.forEach( function (point, key) {
                    if (key === 0) {
                        out.from = formatTime(point);
                    } else if (key === points.length - 1) {
                        out.to = formatTime(point);
                    } else {
                        lunchesTime.push(formatTime(point));
                    }
                });
                for (var i = 0; i < lunchesTime.length; i += 2) {
                    out.lunch.push({
                        from: lunchesTime[i],
                        to: lunchesTime[i + 1],
                        lunchStr: capitaliseFirstLetter(t(localLang, 'lunch'))
                    });
                }

                if (out.from == '00:00' && out.to == '00:00') {
                    out.to = '24:00';
                }

                if (day.round_the_clock) {
                    out.alltime = true;
                    out.alltimeStr = t(localLang, 'worksAroundTheClock');
                }
            } else { // Выходной
                out.holiday = true;
            }

            // Формируем список дней на локальном языке
            var groupWorkingDays = [0, 0, 0, 0, 0, 0, 0]; // Флаги работы фирмы в дни текущей группы
            var flow = 0;

            weekKeys.forEach( function (dayKey, numKey) { // 'Mon', 0
                if (isEqual(model[dayKey], day) || (!model[dayKey] && day === null)) {
                    out.dayList.push(weekFullKeysLocal[numKey]);
                    groupWorkingDays[dayNum(numKey + firstdayOffset)] = 1;
                    flow++;
                } else {
                    if (flow > 2) { // Более 2 дней подряд
                        var lastDay = out.dayList.pop();

                        for (var i = 1 ; i < flow - 1 ; i++) {
                            out.dayList.pop();
                        }

                        out.dayList[out.dayList.length - 1] += ' — ' + lastDay;
                    }

                    flow = 0;
                }
            });

            // Список дней в данной группе идентичен списку будних дней, значит можно заменить словом "Будни"
            out.budni = isEqual(localWorkingDays, groupWorkingDays);
            // Список рабочих дней - все дни недели, значит нужно выводить фразу "Ежедневно"
            out.everyday = ( Math.min.apply(Math, groupWorkingDays) === 1 );

            if ( out.holiday ) { out.holidayStr = t(localLang, 'restDay', out.dayList.length).slice(2); }

            // Делаем из массива строку и поднимаем первый символ
            out.dayList = out.dayList.join(', ');
            out.dayList = out.dayList.charAt(0).toUpperCase() + out.dayList.slice(1);


            return out;
        }

        // Возвращает массив simple строк на основе массива дней days
        function makeAdvancedString(days, model) {
            var out = [];

            for (var i = days.length - 1 ; i >= 0 ; i--) {
                out.push(makeSimpleString(days[i], model));
            }

            return out;
        }

        // Заполняем названия дней недели, 1 - понедельник. В заполненных массивах понедельник это 0

        for (var i = 0 ; i < 7 ; i++) {
            weekKeys[i] = weekKeysShort[i];
            weekKeysLocal[i] = this.dict.t(localLang, weekKeysShort[i].toLowerCase());
            weekFullKeysLocal[i] = this.dict.t(localLang, weekKeysFull[i]);
        }

        // Вычисляем сегодняшний день недели (ссылку на объект дня в модели)
        todayKey = weekKeysShort[(new Date(now).getDay()-firstdayOffset) % 7];
        today = model[todayKey]; // Объект расписания - текущий день недели
        setTodayString(today); // Сделать объект для шаблона - строка, которая описывает время работы сегодня

        // Находим количество разных расписаний и сохраняем их в массив
        var apiDifferentDays = [], // Массив различающихся дней из модели
            apiScheduleDaysCount = 0, // Количество описанных дней в расписании модели
            apiDifferentDaysCount = 0, // Количество разных дней в расписании модели
            differentWorkingHoursCount = []; // Количество рабочих часов в разных днях

        Object.keys(model).forEach( function(day) {
            if (model[day] && model[day].working_hours) { // Проверяем что это день, а не комментарий или что-то ещё
                apiScheduleDaysCount++;
                if (!isEqual(model[day], getArrayLast(apiDifferentDays))) {
                    apiDifferentDays.push(model[day]);
                }
            }
        });

        apiDifferentDaysCount = apiDifferentDays.length;
        // Если не все дни описаны в модели, значит есть ещё один тип дней - выходной (отсутствущий в модели)
        if (apiScheduleDaysCount < 7) {
            apiDifferentDaysCount++;
        }

        // Если разных более 2, то упростить не получится - делаем таблицу
        if (apiDifferentDaysCount > 2) {
            schedule.week = makeTable(model);
        } else { // Иначе, составляем комментарий из двух строк

            // Случай, когда все одинаковые
            if (apiDifferentDaysCount === 1) {
                schedule.week = {
                    evently: [makeSimpleString(model[weekKeys[0]], model)]
                };
            } else { // Остаётся случай, когда есть два типа дней
                // Определяем день с наибольшим количеством рабочих часов из числа разных дней
                for (i = 0 ; i < apiDifferentDaysCount ; i++) {
                    differentWorkingHoursCount[i] = 0;

                    if (apiDifferentDays[i]) {
                        var points = pluck(getSortedTimePoints(apiDifferentDays[i]), 'time');

                        for (var j = 0 ; j < points.length ; j = j + 2) {
                            var hours = (getHours(points[j + 1]) + getMinutes(points[j + 1]) / 60) - (getHours(points[j]) + getMinutes(points[j]) / 60);
                            differentWorkingHoursCount[i] += hours;
                        }
                    } else { // Выходной
                        apiDifferentDays[i] = null;
                    }
                }

                var apiSortedDifferentDays = sortBy(apiDifferentDays, function (day, key) {
                    return differentWorkingHoursCount[key];
                });

                schedule.week = {
                    evently: makeAdvancedString(apiSortedDifferentDays, model)
                };
            }
        }

        schedule.comment = model.comment;
        if (schedule.week && schedule.week.evently && schedule.week.evently.length === 1) {
            schedule.everyday = schedule.week.evently[0].everyday;
        }
        return schedule;
    },

    forecast: function (schedule, params) {
        var interval = '',
        open,
        today = {},
        nowText,
        maxHours = params && params.maxHours || 1;

        if (!schedule) {
            return {};
        }

        if (schedule.always) { // Круглосуточно ежедневно - более ничего выводить не нужно
            return {
                today: {
                    text: this.dict.t(this.localLang, 'aroundTheClock')
                },
                open: true
            };
        }

        // Формируем строку - через сколько произойдёт следующая инверсия открытости
        if (schedule.will && schedule.will.h < maxHours) {
            if (schedule.will.h) {
                interval += this.dict.t(this.localLang, 'nHours', schedule.will.h) + ' ';
            }

            if (schedule.will.m) {
                interval += this.dict.t(this.localLang, 'nMins', schedule.will.m);
            }
        }

        // Данные на сегодня
        if (schedule.today) {
            today.text = this.dict.t(this.localLang, 'today');
            if (schedule.everyday) {
                today.text = this.dict.t(this.localLang, 'everyday');
            }
            today.from = schedule.today.from;
            today.to = schedule.today.to;
            today.lunch = schedule.lunch;
            if (today.lunch) {
                today.lunchStr = this.dict.t(this.localLang, 'lunch');
            }
        } else {
            today.text = this.dict.t(this.localLang, 'todayIsRestDay');
        }

        // Текущий статус и прогноз
        if (schedule.always) { // Если круглосуточно, ничего кроме "Круглосуточно" выводить не нужно
            today.text = this.dict.t(this.localLang, 'aroundTheClock');
            open = true;
        } else if (schedule.now) {
            open = schedule.now.open;
            if (open) { // открыто
                if (schedule.will && schedule.will.willType === 'lunch') {
                    // далее - закрытие на обед
                    if (schedule.will && schedule.will.h < maxHours) {
                        // менее maxHours до закрытия  на обед
                        nowText = this.dict.t(this.localLang, '_in') + ' ' + this.dict.t(this.localLang, 'nMins', interval) + this.dict.t(this.localLang, 'isClosingOnDinner');
                    } else {
                        // больше maxHours до закрытия  на обед
                        nowText = this.dict.t(this.localLang, 'isOpen');
                    }

                } else {
                    // далее просто закрытие
                    if (schedule.will.h < maxHours) {
                        // менее maxHours до закрытия просто
                        nowText = this.dict.t(this.localLang, 'closeIn') + this.dict.t(this.localLang, 'nMins', interval);
                    } else {
                        // больше maxHours до закрытия просто
                        nowText = this.dict.t(this.localLang, 'isOpen');
                    }
                }
            } else { // закрыто
                if (schedule.will && schedule.will.when) {
                    // откроется не сегодня
                    nowText = this.dict.t(this.localLang, 'open') + schedule.will.when;
                } else {
                    // откроется сегодня
                    if (schedule.now && schedule.now.lunch) {
                        // сейчас обед
                        if (schedule.will.h < maxHours) {
                            // менее maxHours до открытия с обеда
                            nowText = this.dict.t(this.localLang, 'Lunch') + this.dict.t(this.localLang, 'openIn') + this.dict.t(this.localLang, 'nMins', interval);
                        } else {
                            // больше maxHours до открытия с обеда
                            nowText = this.dict.t(this.localLang, 'Lunch') + this.dict.t(this.localLang, 'openAt') + schedule.will.till;
                        }
                    } else {
                        // просто закрыто
                        if (schedule.will && schedule.will.h < maxHours) {
                            // менее maxHours до открытия просто
                            nowText = this.dict.t(this.localLang, 'openIn') + this.dict.t(this.localLang, 'nMins', interval);
                        } else {
                            // больше maxHours до открытия просто
                            nowText = this.dict.t(this.localLang, 'openAt') + schedule.will.till;
                        }
                    }
                }
            }
        }

        return {
            today: today,
            now: nowText,
            open: open,
            week: schedule.week,
            comment: schedule.comment,
            everyday: schedule.everyday
        };
    }
};

/*global
    FirmCard:false
*/
// FirmCard.dictionary = {};

FirmCard.prototype.dict = {

    t: function (lang, msg, argument) { // (String, Number) -> String
        var result,
            msgIsset = false,
            dictionaryMsg,
            exp;

        if (typeof this[lang] === 'undefined') {
            lang = 'ru';
        }
        dictionaryMsg = this[lang][msg];
        msgIsset = typeof dictionaryMsg !== 'undefined';
        if (!msgIsset) {
            return msg;
        }
        result = msgIsset ? dictionaryMsg : msg;

        if (argument !== undefined) {
            argument = parseInt(argument, 10);
            argument = isNaN(argument) ? 0 : argument;
            exp = this[lang].pluralRules(argument);
            result = argument + ' ' + dictionaryMsg[exp];
        }
        return result ? result : msg;
    },

    ru: {
        pluralRules: function (n) { // (Number)
            if (n % 10 === 1 && n % 100 !== 11) { // 1, 21
                return 0;
            }
            if ((n % 10 >= 2 && n % 10 <= 4 && (n % 10) % 1 === 0) && (n % 100 < 12 || n % 100 > 14)) { // 2, 3
                return 1;
            }

            if ((n % 10 === 0) || (n % 10 >= 5 && n % 10 <= 9 && (n % 10) % 1 === 0) || (n % 100 >= 11 && (n % 100) <= 14 && (n % 100) % 1 === 0)) { // 13, 17
                return 2;
            }
        },

        btnBack: 'Назад',
        btnFindWay: 'Проехать сюда',
        btnEntrance: 'Найти вход',
        linkReviews: ['отзыв', 'отзыва', 'отзывов'],
        linkPhoto: ['фото', 'фото', 'фото'],
        linkBooklet: 'Буклет',
        tommorow: 'завтра',
        afterTommorow: 'послезавтра',
        afterWeek: 'через неделю',
        nextSun: 'в воскресенье',
        nextMon: 'в понедельник',
        nextTue: 'во вторник',
        nextWed: 'в среду',
        nextThu: 'в четверг',
        nextFri: 'в пятницу',
        nextSat: 'в субботу',
        willOpen: 'откроется',
        willClose: 'закроется',
        isOpen: 'Открыто',
        openTill: 'Открыто до ',
        closeIn: 'Закроется через ',
        openAt: 'Откроется в ',
        openIn: 'Откроется через ',
        open: 'Откроется ',
        nHours: ['час', 'часа', 'часов'],
        nMins: ['минуту', 'минуты', 'минут'],
        lunch: 'обед',
        Lunch: 'Обед. ',
        workingDays: 'Рабочие дни',
        weekdays: 'Будние дни',
        restDay: ['выходной', 'выходные','выходные'],
        reviewsOnFlamp: 'Отзывы на Флампе',
        writeReviewOnFlamp: 'Написать отзыв на Флампе',
        payment: 'оплата',
        everyday: 'Ежедневно c',
        worksAroundTheClock: 'Работает круглосуточно',
        aroundTheClock: 'Круглосуточно',
        knowMore: 'узнать больше',
        toClose: 'до закрытия',
        monday: 'понедельник',
        tuesday: 'вторник',
        wednesday: 'среда',
        thursday: 'четверг',
        friday: 'пятница',
        saturday: 'суббота',
        sunday: 'воскресенье',
        mon: 'пон',
        tue: 'втр',
        wed: 'срд',
        thu: 'чтв',
        fri: 'птн',
        sat: 'сбт',
        sun: 'вск',
        toLunch: 'до обеда',
        today: 'Сегодня',
        lessThenHour: 'менее часа',
        youCouldLate: 'вы можете не успеть',
        workingTime: 'рабочее время',
        showAllOrgInRubric: 'Показать все организации рубрики',
        todayIsRestDay: 'Сегодня выходной',
        internet: 'Оплата через Интернет',
        noncash: 'Безналичный расчет',
        goldcrown: 'Золотая Корона',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Наличный расчет',
        americanexpress: 'American Express',
        hour : 'час',
        less: 'менее',
        _in : 'Через',
        isClosingOnDinner : ' закрывается на обед'
    },

    it: {
        pluralRules: function (n) { // (Number)
            if (n === 1) { // 1
                return 0;
            } else {
                return 1; //0, 2, 3, 4 ..
            }
        },

        btnBack: 'Indietro',
        btnFindWay: 'Come arrivare ',
        btnEntrance: 'Trova l\'ingresso',
        linkReviews: ['recensione', 'recensioni'],
        linkPhoto: ['fotografia', 'fotografie'],
        linkBooklet: 'Sull\'azienda',
        tommorow: 'domani',
        afterTommorow: 'dopodomani',
        afterWeek: 'tra una settimana',
        nextSun: 'la domenica',
        nextMon: 'il lunedi',
        nextTue: 'il martedì',
        nextWed: 'il mercoledì',
        nextThu: 'il giovedi',
        nextFri: 'il venerdì',
        nextSat: 'il sabato',
        willOpen: 'apre',
        willClose: 'ciuso',
        isOpen: 'Aperto',
        openTill: 'Aperto fino alle ',
        closeIn: 'Chiude tra ',
        openAt: 'Apre alle ',
        openIn: 'Apre tra ',
        open: 'Apre ',
        nHours: ['ora', 'ore'],
        nMins: ['minuto', 'minuti'],
        lunch: 'pausa pranzo',
        Lunch: 'Pausa pranzo. ',
        workingDays: 'Giorni feriali',
        weekdays: 'Giorni feriali',
        restDay: ['chiusura','chiusura'],
        reviewsOnFlamp: 'Recensioni su Flamp',
        writeReviewOnFlamp: 'Scrivi una recensione su Flamp',
        payment: 'pagamento',
        everyday: 'Ogni giorno dalole',
        worksAroundTheClock: 'Operativo 24 ore su 24',
        aroundTheClock: '24 ore su 24',
        knowMore: 'ulteriori informazioni',
        toClose: 'fino alla chiusura',
        monday: 'lunedi',
        tuesday: 'martedì',
        wednesday: 'mercoledì',
        thursday: 'giovedi',
        friday: 'venerdì',
        saturday: 'sabato',
        sunday: 'domenica',
        mon: 'lun',
        tue: 'mar',
        wed: 'mer',
        thu: 'gio',
        fri: 'ven',
        sat: 'sab',
        sun: 'dom',
        toLunch: 'fino alla pausa pranzo',
        today: 'Oggi',
        lessThenHour: 'meno di un\'ora',
        youCouldLate: 'affrettarsi, chiusura imminente',
        workingTime: 'orario di lavoro',
        showAllOrgInRubric: 'Visualizza tutte le aziende della categoria',
        todayIsRestDay: 'oggi chiuso',
        internet: 'Pagamento on-line',
        noncash: 'Pagamento non in contanti',
        goldcrown: 'Zolotaja Korona',
        dinersclub: 'Diners Club',
        mastercard: 'MasterCard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Pagamento in contanti',
        americanexpress: 'American Express',
        hour : 'un\'ora',
        less: 'meno di',
        _in : 'Tra',
        isClosingOnDinner : 'chiude per pausa pranzo'
    },

    en: {
        pluralRules: function (n) { // (Number)
            if (n === 1) { // 1
                return 0;
            } else {
                return 1; //0, 2, 3, 4 ..
            }
        },

        btnBack: 'Back',
        btnFindWay: 'Get here',
        btnEntrance: 'Find entrance',
        linkReviews: ['review', 'reviews'],
        linkPhoto: ['photo', 'photos'],
        linkBooklet: 'About company',
        tommorow: 'tomorrow',
        afterTommorow: 'the day after tomorrow',
        afterWeek: 'in a week',
        nextSun: 'on Sunday',
        nextMon: 'on Monday',
        nextTue: 'on Tuesday',
        nextWed: 'on Wednesday',
        nextThu: 'on Thursday',
        nextFri: 'on Friday',
        nextSat: 'on Saturday',
        willOpen: 'opens ',
        willClose: 'closes',
        isOpen: 'Open',
        openTill: 'Open till ',
        closeIn: 'Closes in ',
        openAt: 'Opens at ',
        openIn: 'Opens in ',
        open: 'Opens ',
        nHours: ['hour', 'hours'],
        nMins: ['minute', 'minutes'],
        lunch: 'lunch break',
        Lunch: 'Lunch break. ',
        workingDays: 'Working days',
        weekdays: 'Weekdays',
        restDay: ['day off','days off'],
        reviewsOnFlamp: 'Reviews on Flamp',
        writeReviewOnFlamp: 'Write a review on Flamp',
        payment: 'payment',
        everyday: 'Daily from',
        worksAroundTheClock: 'Open 24 hours',
        aroundTheClock: '24h',
        knowMore: 'see also',
        toClose: 'until closing',
        monday: 'Monday',
        tuesday: 'Tuesday',
        wednesday: 'Wednesday',
        thursday: 'Thursday',
        friday: 'Friday',
        saturday: 'Saturday',
        sunday: 'Sunday',
        mon: 'Mon',
        tue: 'Tue',
        wed: 'Wed',
        thu: 'Thu',
        fri: 'Fri',
        sat: 'Sat',
        sun: 'Sun',
        toLunch: 'until lunch',
        today: 'Today',
        lessThenHour: 'less then one hour',
        youCouldLate: 'you might be late',
        workingTime: 'working hours',
        showAllOrgInRubric: 'Show all organizations in the category',
        todayIsRestDay: 'closed today',
        internet: 'Online',
        noncash: ' No-cash',
        goldcrown: 'Golden Crown',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Cash',
        americanexpress: 'American Express',
        hour : 'hour',
        less: 'less',
        _in : 'In',
        isClosingOnDinner : 'will be closing for lunch'
    },

    cs: {
        pluralRules: function (n) { // (Number)
            return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
        },

        btnBack: 'Zpět',
        btnFindWay: 'Jet sem',
        btnEntrance: 'Hledat vstup',
        linkReviews: ['recenze', 'recenze', 'recenzí'],
        linkPhoto: ['fotografie', 'fotografie', 'fotografií'],
        linkBooklet: 'Leták',
        tommorow: 'zítra',
        afterTommorow: 'pozítří',
        afterWeek: 'za týden',
        nextSun: 'v neděli',
        nextMon: 'v pondělí',
        nextTue: 'v úterý',
        nextWed: 've středu',
        nextThu: 've čtvrtek',
        nextFri: 'v pátek',
        nextSat: 'v sobotu',
        willOpen: 'otevře se',
        willClose: 'zavře se',
        isOpen: 'Otevřeno',
        openTill: 'Otevřeno do ',
        closeIn: 'Zavře se za ',
        openAt: 'Otevře se v ',
        openIn: 'Otevře se za ',
        open: 'Otevře se ',
        nHours: [ 'hodinu' , 'hodiny' , 'hodin' ],
        nMins: [ 'minutu' , 'minuty' , 'minut' ],
        lunch: 'polední přestávka',
        Lunch: 'Polední přestávka. ',
        workingDays: 'Všední dny',
        weekdays: 'Všední dny',
        restDay: ['zavřeno', 'zavřeno'],
        reviewsOnFlamp: 'Recenze na Flampu',
        writeReviewOnFlamp: 'Napsat recenzi na Flampu',
        payment: 'platba',
        everyday: 'Denně od ',
        worksAroundTheClock: 'Pracuje nonstop',
        aroundTheClock: 'Nonstop',
        knowMore: 'dozvědět se více',
        toClose: 'do uzavření',
        monday: 'pondělí',
        tuesday: 'úterý',
        wednesday: 'středa',
        thursday: 'čtvrtek',
        friday: 'pátek',
        saturday: 'sobota',
        sunday: 'neděle',
        mon: 'po',
        tue: 'út',
        wed: 'st',
        thu: 'čt',
        fri: 'pá',
        sat: 'so',
        sun: 'ne',
        toLunch: 'do polední přestávky',
        today: 'Dnes',
        lessThenHour: 'méně než hodinu',
        youCouldLate: 'nemusíte to stihnout',
        workingTime: 'pracovní doba',
        showAllOrgInRubric: 'Zobrazit všechny organizace v rubrice',
        todayIsRestDay: 'Dnes je zavřeno',
        internet: 'Platba prostřednictvím Internetu',
        noncash: 'Bezhotovostní platba',
        goldcrown: 'Zolotaja Korona',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Platba hotově',
        americanexpress: 'American Express',
        hour : 'hodinu',
        less: 'méně',
        _in : 'Za',
        isClosingOnDinner : 'začíná polední přestávka'
    },

    es: {
        pluralRules: function (n) { // (Number)
          return (n === 1) ? 0 : (n >= 2 && n <= 4) ? 1 : 2;
        },

        btnBack: 'Atrás',
        btnFindWay: 'Ir para allá',
        btnEntrance: 'Buscar acceso',
        linkReviews: ['comentario', 'comentarios', 'comentarios'],
        linkPhoto: ['foto', 'fotos', 'fotos'],
        linkBooklet: 'Folleto',
        tommorow: 'mañana',
        afterTommorow: 'pasado mañana',
        afterWeek: 'en una semana más',
        nextSun: 'el domingo',
        nextMon: 'el lunes',
        nextTue: 'el martes',
        nextWed: 'el miércoles',
        nextThu: 'el jueves',
        nextFri: 'el viernes',
        nextSat: 'el sábado',
        willOpen: 'se abrirá',
        willClose: 'se cerrará',
        isOpen: 'Abierto',
        openTill: 'Abierto hasta ',
        closeIn: 'Se cerrará dentro de ',
        openAt: 'Se abrirá el ',
        openIn: 'Se abrirá dentro de ',
        open: 'Se abrirá ',
        nHours: ['hora', 'horas', 'horas'],
        nMins: ['minuto', 'minutos', 'minutos'],
        lunch: 'hora de colación',
        Lunch: 'Hora de colación. ',
        workingDays: 'Días laborables',
        weekdays: 'Días laborables',
        restDay: ['cerrado','cerrado'],
        reviewsOnFlamp: 'Comentarios en Flamp',
        writeReviewOnFlamp: 'Escribir un comentario en Flamp',
        payment: 'pago',
        everyday: 'Cada día desde',
        worksAroundTheClock: 'Abierto las 24 horas',
        aroundTheClock: '24 horas',
        knowMore: 'para saber más',
        toClose: 'hasta el cierre',
        monday: 'lunes',
        tuesday: 'martes',
        wednesday: 'miércoles',
        thursday: 'jueves',
        friday: 'viernes',
        saturday: 'sábado',
        sunday: 'domingo',
        mon: 'lun',
        tue: 'mar',
        wed: 'mié',
        thu: 'jue',
        fri: 'vie',
        sat: 'sáb',
        sun: 'dom',
        toLunch: 'antes de la hora de colación',
        today: 'Hoy',
        lessThenHour: 'menos de una hora',
        youCouldLate: 'puede ser que no alcanzas a llegar',
        workingTime: 'horario de trabajo',
        showAllOrgInRubric: 'Mostrar todas las empresas de la categoría',
        todayIsRestDay: 'Hoy cerrado',
        internet: 'Pago por Internet',
        noncash: 'Pago sin efectivo',
        goldcrown: 'Zolotaya Korona',
        dinersclub: 'Diners Club',
        mastercard: 'Mastercard',
        maestrocard: 'MaestroCard',
        visa: 'Visa',
        cash: 'Pago en efectivo',
        americanexpress: 'American Express',
        hour : 'hora',
        less: 'menos de',
        _in : 'Dentro de',
        isClosingOnDinner : 'se cierra por hora de colación'
    }
};

DG.Traffic = DG.TileLayer.extend({
    options: {
        period: 0,
        disableLabel: false
    },

    statics: {
        Dictionary: {}
    },

    initialize: function (options) {
        this._tileUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTrafficTileServer : DG.config.trafficTileServer);
        this._metaUrl = DG.config.protocol + (DG.Browser.retina ? DG.config.retinaTrafficMetaServer : DG.config.trafficMetaServer);
        this._timeUrl = DG.config.protocol + DG.config.trafficTimestampServer;
        this._updateInterval = DG.config.trafficLayerUpdateInterval;

        this._layersOptions = {
            errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
            subdomains: '012345679',
            maxNativeZoom: 18,
            detectRetina: true,
            minZoom: DG.config.trafficLayerMinZoom
        };

        options = DG.setOptions(this, DG.extend(options || {}, this._layersOptions));
        options.timestampString = options.period ? '' : ('?' +  (new Date()).getTime());
        this._metaLayer = DG.Meta.layer(null, {
            detectRetina: options.detectRetina,
            maxNativeZoom: options.maxNativeZoom,
            dataFilter: DG.bind(this._processData, this),
            minZoom: options.minZoom
        });
        this._isDg = true;
        this._onTimer = DG.bind(this._onTimer, this);
        DG.TileLayer.prototype.initialize.call(this, this._tileUrl, options);
    },

    // #setTime(day [0-6], time[0-23]) ????

    onAdd: function (map) {
        this._updateLayerProject();

        map
            .addLayer(this._metaLayer)
            .on('projectchange projectleave', this._onMapProjectChange, this);

        if (!this.options.disableLabel) {
            this._metaLayer.on(this._layerEventsListeners, this);
            this._labelHelper = DG.label();
        }

        if (this._updateInterval) {
            this._updateTimer = setInterval(this._onTimer, this._updateInterval);
        }

        DG.TileLayer.prototype.onAdd.call(this, map);
    },

    onRemove: function (map) {
        clearInterval(this._updateTimer);

        map
            .removeLayer(this._metaLayer)
            .off('projectchange projectleave', this._onMapProjectChange, this);

        if (!this.options.disableLabel) {
            this._metaLayer.off(this._layerEventsListeners, this);
            this._map.removeLayer(this._labelHelper);
            this._labelHelper = null;
        }

        DG.TileLayer.prototype.onRemove.call(this, map);
    },

    update: function () {
        var self = this;
        this._getTimestampString().then(
            function (response) {
                self.options.timestampString = '?' + response;
            },
            function () {
                self.options.timestampString = '?' + (new Date()).getTime();
            }).then(
            function () {
                self.fire('update', {timestamp: self.options.timestampString});
                self._layerEventsListeners.mouseout.call(self);
                self._metaLayer.getOrigin().setURL(self._prepareMetaURL(), self);
                self.redraw();
            }
        );
    },

    getSubdomain: function () {
        return this._layersOptions.subdomains[
            Math.floor(Math.random() * this._layersOptions.subdomains.length)
        ];
    },

    _getTimestampString: function () {
        return DG.ajax(
            DG.Util.template(
                this._timeUrl,
                DG.extend({
                    s : this.getSubdomain(),
                    projectCode: this._map.projectDetector.getProject().code
                }, this.options || {})),
            {type: 'get'}
        );
    },

    _onTimer: function () {
        if (this.options.period === 0) {
            this.update();
        }
    },

    _processData: function (trafficData, coord) {
        var tileOriginPoint = coord.scaleBy(this.getTileSize());
        var polygonLngLatToPoints = DG.bind(this._polygonLngLatToPoints, this, tileOriginPoint);
        var hints = {};

        if (!DG.Util.isArray(trafficData)) {    // TODO remove
            return [];
        }

        trafficData[1].forEach(function (item) {
            this[item.graph_id] = item.speed_text;
        }, hints);

        return trafficData[0]
            .map(function (item) {
                return {
                    id: item.graph_id,
                    speed: hints[item.graph_id],
                    geometry: DG.Wkt.toGeoJSON(item.geometry[0].object[0])
                };
            })
            .filter(function (item) {
                return item.geometry.type == 'Polygon' ||
                    item.geometry.type == 'MultiPolygon';
            })
            .map(function (item) {
                var geoJson = item.geometry;

                if (geoJson.type == 'Polygon') {
                    geoJson.coordinates = polygonLngLatToPoints(geoJson.coordinates);
                } else if (geoJson.type == 'MultiPolygon') {
                    geoJson.coordinates = geoJson.coordinates.map(polygonLngLatToPoints);
                }

                return item;
            });
    },

    _polygonLngLatToPoints: function (originPoint, polygon) {
        var map = this._map;

        return polygon.map(function (contour) {
            return contour.map(function (lngLat) {
                return map
                    .project([lngLat[1], lngLat[0]]).round()
                    .subtract(originPoint);
            });
        });
    },

    _prepareMetaURL: function () {
        return DG.Util.template(this._metaUrl, DG.extend({
            x: '{x}',
            y: '{y}',
            z: '{z}',
            s: '{s}'
        }, this.options));
    },

    _updateLayerProject: function () {
        var project = this._map.projectDetector.getProject();
        DG.setOptions(this, project && project.traffic ? {
            projectCode: project.code,
            bounds: project.latLngBounds,
            minZoom: Math.max(project.minZoom, this._layersOptions.minZoom),
            maxZoom: project.maxZoom
        } : {
            maxZoom: 0,
            minZoom: 0
        });
        this._metaLayer.getOrigin().setURL(this._prepareMetaURL());
    },

    _onMapProjectChange: function () {
        this._updateLayerProject();
        this.redraw();
    },

    _layerEventsListeners: {
        mouseover: function (e) { // (Object)
            this._setCursor('pointer');
            if (this._labelHelper && e.meta.speed) {
                this._labelHelper
                    .setPosition(e.latlng)
                    .setContent(e.meta.speed + ' ' + this.t('speed_unit_km_h'))
                    .addTo(this._map);
            }
        },
        mouseout: function () {
            this._setCursor('');
            if (this._labelHelper) {
                this._map.removeLayer(this._labelHelper);
            }
        },
        mousemove: function (e) {
            if (this._labelHelper) {
                this._labelHelper.setPosition(e.latlng);
            }
        }
    },

    _setCursor: function (cursor) { // (String)
        this._map.getContainer().style.cursor = cursor;
    }

});

DG.Traffic.include(DG.Locale);

DG.traffic = function (options) { // (Object)
    return new DG.Traffic(options);
};

DG.Traffic.Dictionary.ru = {
    speed_unit_km_h: 'км/ч'
};
DG.Traffic.Dictionary.it = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.cs = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.es = {
    speed_unit_km_h: 'km/h'
};
DG.Traffic.Dictionary.en = {
    speed_unit_km_h: 'km/h'
};
DG.Control.Traffic = DG.RoundControl.extend({
    options: {
        position: 'topright',
        iconClass: 'traffic'
    },

    statics: {
        Dictionary: {}
    },

    initialize: function (options) {
        this._trafficClass = 'dg-traffic-control';
        this._controlHideClass = 'dg-control-round_is-hidden_true';

        DG.setOptions(this, options);
        DG.extend(this, {
            _active: false,
            _trafficLayer: null
        }).on(this._controlEvents, this);
    },

    _controlEvents: {
        add: function () {
            this._trafficLayer = DG.traffic();
            this._map.on('zoomend projectchange projectleave', this._updateControlVisibility, this);
        },
        click: function () {
            this._active = !this._active;

            if (this._active) {
                this.setState('active');
                this._showTraffic();
            } else {
                this.setState('');
                this._hideTraffic();
            }
        },
        remove: function () {
            this.off(this._controlEvents, this);
            this._map.off('zoomend projectchange projectleave', this._updateControlVisibility, this);
            if (this._active) {
                this._map.removeLayer(this._trafficLayer);
                this._active = false;
            }
            this._trafficLayer = null;
        }
    },

    _showTraffic: function () { // ()
        this._updateTrafficScore();
        this._map.addLayer(this._trafficLayer);
    },

    _hideTraffic: function () { // ()
        this._handleDom('remove');
        this._map.removeLayer(this._trafficLayer);
    },

    _handleDom: function (method, score) {
        var a = this._link;

        a.innerHTML = score || '';
        DG.DomUtil[method + 'Class'](a, this._trafficClass);
        DG.DomUtil[method + 'Class'](a, this._trafficClass + '_color_' + this._scoreRate);
    },

    _getTrafficColor: function (score) { // (Number) -> String
        var result = 'green';

        if (score > 7) {
            result = 'red';
        } else if (score > 4) {
            result = 'yellow';
        }

        return result;
    },

    _updateControlVisibility: function () {
        var project = this._map.projectDetector.getProject(),
            projectHasTraffic = project && project.traffic,
            method = ((this._map.getZoom() < DG.config.trafficLayerMinZoom) ||
            (!projectHasTraffic)) ? 'addClass' : 'removeClass';

        DG.DomUtil[method](this._container, this._controlHideClass);
        if (this._active && projectHasTraffic) {
            this._updateTrafficScore();
        }
    },

    _updateTrafficScore: function () {
        var self = this;

        this._getTrafficScore().then(function (score) {
            score = parseInt(score, 10); // sometimes webapi returns something like '5,+'

            self._scoreRate = self._getTrafficColor(score);
            self._handleDom('add', score);
        });
    },

    _getTrafficScore: function () { // () -> Promise
        var url = DG.Util.template(
            DG.config.protocol + DG.config.trafficScoreServer,
            {
                s: this._trafficLayer.getSubdomain(),
                projectCode: this._map.projectDetector.getProject().code
            }
        );

        return DG.ajax(url, {type: 'get'});
    },

    _renderTranslation: function () { // ()
        this._link.title = this.t('button_title');
    }
});

DG.control.traffic = function (options) {
    return new DG.Control.Traffic(options);
};

DG.Map.mergeOptions({
    trafficControl: false
});

DG.Map.addInitHook(function () {
    if (this.options.trafficControl) {
        this.trafficControl = DG.control.traffic(this.options.trafficControl);
        this.addControl(this.trafficControl);
    }
});

DG.Control.Traffic.Dictionary.ru = {
	button_title: 'Пробки'
};

DG.Control.Traffic.Dictionary.it = {
	button_title: 'Colonna'
};

DG.Control.Traffic.Dictionary.cs = {
	button_title: 'Zácpy'
};

DG.Control.Traffic.Dictionary.es = {
	button_title: 'Taco'
};

DG.Control.Traffic.Dictionary.en = {
	button_title: 'Traffic'
};

DG.Ruler = DG.Layer.extend({

    options: {
        editable: true
    },

    includes: [DG.Locale],

    statics: {
        Dictionary: {}
    },

    initialize: function (latlngs, options) { // (Array, Object)
        DG.Util.setOptions(this, options);

        this._layers = {
            back : null,
            middle : null,
            front : null,
            mouse : null
        };
        this._points = [];

        this._layersContainer = DG.featureGroup();
        Object.keys(this._layers).forEach(function (name) {
            this._layersContainer.addLayer(this._layers[name] = DG.featureGroup());
        }, this);

        this._reset();

        if (DG.Browser.mobile) {
            delete this._lineMouseEvents.mouseover;
            delete this._lineMouseEvents.mouseout;
            delete this._lineMouseEvents.mousemove;
        } else {
            delete this._lineMouseEvents.click;
        }

        if (latlngs && latlngs.length) {
            this.setLatLngs(latlngs);
        }
    },

    onAdd: function (map) { // (Map)
        this._map = map.on('langchange', this._updateDistance, this);

        //  Pane for ruler Markers
        if (!this._map.getPane('rulerMarkerPane')) {
            this._map.createPane('rulerMarkerPane');
        }

        //  Main ruler pane (svg objects and runner)
        if (!this._map.getPane('rulerPane')) {
            this._map.createPane('rulerPane');
        }

        this._layersContainer.addTo(this._map);

        if (this._points.length) {
            this._layers.mouse.fire('layeradd');
            this._updateDistance();
        }

        this._layers.mouse.on(this._lineMouseEvents, this);
    },

    onRemove: function (map) { // (Map)
        map
            .off('langchange', this._updateDistance, this)
            .removeLayer(this._layersContainer);

        this._layers.mouse.off(this._lineMouseEvents, this);
        this._reset();
    },

    getTotalDistance: function () { // () -> Number
        return this._calcDistance();
    },

    spliceLatLngs: function (index) { // (Number, Number, args ...) -> Array
        var oldLength = this._points.length,
            mutationStart = index >= 0 ? Math.min(index, oldLength) : oldLength - index,
            removed = Array.prototype.splice.apply(this._points, arguments).map(function (point) {
                this._layers.mouse.removeLayer(point);
                return point.off().getLatLng();
            }, this),
            length = this._points.length;

        if (length) {
            for (var i = mutationStart; i < length; i++) {
                if (!(this._points[i] instanceof DG.Ruler.LayeredMarker)) {
                    this._points[i] = this._createPoint(this._points[i], this.options.iconStyles.large)
                        .on(this._pointEvents, this)
                        .once('add', this._addCloseHandler, this)
                        .addTo(this._layers.mouse, this._layers);
                }
                if (i && !this._points[i - 1]._legs) {
                    this._addLegs(this._points[i - 1]);
                }
                this._points[i].setPointStyle(this.options.iconStyles[i && i < length - 1 ? 'small' : 'large']);
                this._points[i]._pos = i;
            }
            this._removeLegs(this._points[length - 1]);
            if (oldLength > 0 && oldLength < length) {
                this._points[oldLength - 1].collapse();
            }
            if (this._points[mutationStart]) {
                this._updateLegs(this._points[mutationStart]);
            }
            if (mutationStart > 1) {
                this._points[mutationStart - 1].setPointStyle(this.options.iconStyles.small);
            }
            this._updateDistance();
            this._normalizeRulerPoints();
        }
        if (DG.Browser.touch && this._lineMarkerHelper) {
            this._lineMarkerHelper.collapse();
        }
        this._fireChangeEvent();
        return removed;
    },

    addLatLng: function (latlng) { // (LatLng) -> Ruler
        var lastPoint = this._points[this._points.length - 1] || null;
        latlng = DG.latLng(latlng);

        if (lastPoint) {
            latlng = this._normalizeLatLng(latlng, lastPoint.getLatLng());
        }

        this.spliceLatLngs(this._points.length, 0, latlng);
        return this;
    },

    getLatLngs: function () { // () -> Array
        return this._points.map(function (point) {
            return point.getLatLng();
        });
    },

    setLatLngs: function (latlngs) { // (Array) -> Ruler
        var args = latlngs.slice();
        args.unshift(0, this._points.length);
        this.spliceLatLngs.apply(this, args);
        return this;
    },

    _reset: function () { // ()
        DG.extend(this, {
            _lineMarkerHelper: null,
            _morphingNow: false
        });
    },

    _lineMouseEvents: {
        click: function (event) {
            var target = event.layer;
            if (target instanceof DG.Marker && target._pos !== this._points.length - 1) {
                if (this._lineMarkerHelper) {
                    this._lineMarkerHelper.collapse();
                }
                target.setText(this._getFormatedDistance(target));
                this._lineMarkerHelper = target;
            } else if (target instanceof DG.Path && this.options.editable) {
                var latlng = event.latlng,
                    insertPos = target._point._pos + 1;
                this.spliceLatLngs(insertPos, 0, latlng);
            }
        },
        mouseover: function (event) { // (MouseEvent)
            var target = event.layer;

            target._hovered = true;
            if (this._morphingNow) {
                return;
            }
            if (target instanceof DG.Marker && target._pos !== this._points.length - 1) {
                target.setText(this._getFormatedDistance(target));
            } else if (target instanceof DG.Path && !this._lineMarkerHelper) {
                var point = target._point;

                this._lineMarkerHelper = this._addRunningLabel(
                    this._nearestPoint(point._legs.middle, event.latlng),
                    point
                );
            }
        },
        mouseout: function (event) { // (MouseEvent)
            var target = event.layer,
                originalEv = event.originalEvent;

            target._hovered = false;
            if (this._morphingNow || target._pos === this._points.length - 1) {
                return;
            }
            if (target instanceof DG.Marker) {
                // collapse only when we move out from label container (if browser support relatedTarget)
                if (!originalEv.relatedTarget ||
                    (originalEv.relatedTarget !== target.querySelector('container') &&
                    originalEv.relatedTarget.parentNode !== target.querySelector('container'))) {
                    target.collapse();
                }
            } else {
                this._removeRunningLabel();
            }
        },
        mousemove: function (event) { // (MouseEvent)
            if (this._morphingNow || !this._lineMarkerHelper) {
                return;
            }

            var point = event.layer._point,
                latlng = this._nearestPoint(point._legs.middle, event.latlng);

            this._lineMarkerHelper
                    .setLatLng(latlng)
                    .setText(this._getFormatedDistance(point, point.getLatLng().distanceTo(latlng)));
        },
        layeradd: function () { // ()
            Object.keys(this._layers).forEach(function (name) {
                this._layers[name].bringToFront();
            }, this);
        }
    },

    _fireChangeEvent: function () {
        this.fire('changed', {latlngs : this.getLatLngs()});
    },

    _addRunningLabel: function (latlng, previousPoint) { // (LatLng, Ruler.LayeredMarker)
        var point = this._createPoint(latlng).addTo(this._layers.mouse, this._layers);
        var pane = this._map.getPane('rulerPane');
        pane.insertBefore(point._icon, pane.lastElementChild);
        return point.setText(this._getFormatedDistance(previousPoint, previousPoint.getLatLng().distanceTo(latlng)));
    },

    _removeRunningLabel: function () { // ()
        if (this._lineMarkerHelper) {
            this._layers.mouse.removeLayer(this._lineMarkerHelper);
            this._lineMarkerHelper = null;
        }
    },

    _insertPointInLine: function (event) { // (MouseEvent)
        var latlng = this._lineMarkerHelper.getLatLng(),
            insertPos = event.target._point._pos + 1,
            point;

        if (L.Browser.ie) {
            var path = event.originalEvent.target || event.originalEvent.srcElement,
                parent = path.parentNode;
            parent.appendChild(path); // IE click event leaking problem solution: we reappend mousedown event target element
        }

        L.DomEvent.stopPropagation(event.originalEvent);

        this.spliceLatLngs(insertPos, 0, latlng);
        point = this._points[insertPos];
        point.setText(this._getFormatedDistance(point));

        setTimeout(function () {
            if (document.createEvent) {
                var e = document.createEvent('MouseEvents');
                e.initMouseEvent('mouseup', false, false, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 1, point._icon);
                document.dispatchEvent(e);

                e = document.createEvent('MouseEvents');
                e.initMouseEvent('mousedown', false, false, document.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 1, point._icon);
                point._icon.dispatchEvent(e);
            } else {
                point._icon.fireEvent('onMouseUp', DG.extend(document.createEventObject(), {
                    button: 1,
                    bubbles: false,
                    cancelable: false
                }));
                point._icon.fireEvent('onMouseDown', DG.extend(document.createEventObject(), {
                    button: 1,
                    bubbles: false,
                    cancelable: false
                }));
            }
        }, 0);

        this._removeRunningLabel();

        this._updateLegs(point);
    },

    // Find the point on given polyline which is closest to given latlng
    _nearestPoint: function (polyline, latlng) { // (Polyline, LatLng) -> LatLng
        var self = this;

        // Convert everything to pixel coordinates
        var point = this._project(latlng);
        var linePoints = polyline.getLatLngs().map(function (latlng) {
            return self._project(latlng);
        });

        // First look for closest polyline segment
        var minDistance;
        var closestSegmentIndex;
        for (var i = 0; i < linePoints.length - 1; i++) {
            var distance = DG.LineUtil.pointToSegmentDistance(
                point,
                linePoints[i],
                linePoints[i + 1]
            );

            if (minDistance === undefined || distance < minDistance) {
                minDistance = distance;
                closestSegmentIndex = i;
            }
        }

        // Then look for closest point on that segment
        var closestPoint = DG.LineUtil.closestPointOnSegment(
            point,
            linePoints[closestSegmentIndex],
            linePoints[closestSegmentIndex + 1]
        );

        // Convert back to LatLng
        return this._unproject(closestPoint);
    },

    _addCloseHandler: function (event) { // (Event)
        event.target
                .on('click', this._deletePoint, this)
                .querySelector('remove-link').style.display = 'inline-block';
    },

    _createPoint: function (latlng, style) { // (LatLng, Object) -> Ruler.LayeredMarker
        var pointStyle = style ? style : this.options.iconStyles.large,
            layers = {};
        Object.keys(pointStyle).forEach(function (layer) {
            layers[layer] = DG.circleMarker(latlng, pointStyle[layer]);
        });

        return DG.Ruler.layeredMarker(latlng, {
            layers : layers,
            draggable : this.options.editable
        });
    },

    // Moves curr LatLng to correct world if necessary so that ruler section
    // between curr and base can be plotted correctly. Returns a new LatLng
    // object.
    _normalizeLatLng: function (curr, base) { // (LatLng, LatLng) -> LatLng
        var diff = (curr.lng < base.lng) ? 360 : -360;

        var newLng = curr.lng;
        while (Math.abs(newLng - base.lng) > 180) {
            newLng += diff;
        }

        return DG.latLng(curr.lat, newLng);
    },

    // Rearranges ruler points between worlds based on point param so that all
    // ruler sections can be plotted correctly.
    _normalizeRulerPoints: function (point) { // (Ruler.LayeredMarker)
        point = point || this._points[0];

        var self = this;
        var position = point._pos;
        var changedPoints = [];
        var i, currPoint, prevPoint, latlng, normalized;

        // Check points to the right
        for (i = position + 1; i < this._points.length; i++) {
            currPoint = this._points[i];
            prevPoint = this._points[i - 1];

            latlng = currPoint.getLatLng();
            normalized = this._normalizeLatLng(latlng, prevPoint.getLatLng());

            if (!normalized.equals(latlng)) {
                currPoint.setLatLng(normalized);
                changedPoints.push(i);
            }
        }

        // Check points to the left
        for (i = position - 1; i >= 0; i--) {
            currPoint = this._points[i];
            prevPoint = this._points[i + 1];

            latlng = currPoint.getLatLng();
            normalized = this._normalizeLatLng(latlng, prevPoint.getLatLng());

            if (!normalized.equals(latlng)) {
                currPoint.setLatLng(normalized);
                changedPoints.push(i);
            }
        }

        // Update legs of all points that changed position
        changedPoints.sort().reduce(function (previous, current) {
            var skipPrevious = previous && previous === current - 1;

            self._updateLegs(self._points[current], skipPrevious);

            return current;
        }, null);
    },

    _pointEvents: {
        drag: function (event) { // (Event)
            var point = event.target;

            this._normalizeRulerPoints(point);

            if (!DG.Browser.touch && point !== this._points[this._points.length - 1]) {
                point.setText(this._getFormatedDistance(point));
            }

            this._updateLegs(point);
            this._updateDistance();
        },
        dragend: function (event) { // (Event)
            var point = event.target;
            this._morphingNow = false;
            if (!point._hovered && point !== this._points[this._points.length - 1]) {
                point.collapse();
            }
            this._fireChangeEvent();
        },
        dragstart: function () { // ()
            if (DG.Browser.touch && this._lineMarkerHelper) {
                this._lineMarkerHelper.collapse();
            }
            this._morphingNow = true;
        }
    },

    _deletePoint: function (event) { // (MouseEvent)
        var originalEvent = event.originalEvent,
            target = originalEvent.target  || originalEvent.srcElement;

        if (target.className !== 'dg-ruler__label-remove-link' &&
            target.className !== 'dg-ruler__remove-link-overlay') {
            return;
        }
        DG.DomEvent.stop(event.originalEvent);
        this.spliceLatLngs(event.target._pos, 1);
    },

    _degToRad: function (deg) {
        return (Math.PI / 180) * deg;
    },

    _radToDeg: function (rad) {
        return (180 / Math.PI) * rad;
    },

    // Map-independent project method
    _project: function (latlng) {
        if (this._map) {
            return this._map.project(latlng);
        }

        return DG.CRS.EPSG3857.latLngToPoint(latlng, 1);
    },

    // Map-independent unproject method
    _unproject: function (point) {
        if (this._map) {
            return this._map.unproject(point);
        }

        return DG.CRS.EPSG3857.pointToLatLng(point, 1);
    },

    // Calculates the size of angle point1-point-point2
    _calcAngle: function (point, point1, point2) { // (LatLng, LatLng, LatLng) -> Number
        point1 = this._normalizeLatLng(point1, point);
        point2 = this._normalizeLatLng(point2, point);

        point = this._project(point);
        point1 = this._project(point1);
        point2 = this._project(point2);

        var x1 = point1.x - point.x;
        var x2 = point2.x - point.x;
        var y1 = point1.y - point.y;
        var y2 = point2.y - point.y;

        var dotProduct = x1 * x2 + y1 * y2;
        var mag1 = Math.sqrt(x1 * x1 + y1 * y1);
        var mag2 = Math.sqrt(x2 * x2 + y2 * y2);

        return Math.acos(dotProduct / (mag1 * mag2));
    },

    // Calculates the midpoint on the great circle between two LatLngs
    _calcMidPoint: function (latlng1, latlng2) { // (LatLng, LatLng) -> LatLng
        var lon1 = this._degToRad(latlng1.lng);
        var lat1 = this._degToRad(latlng1.lat);

        var lon2 = this._degToRad(latlng2.lng);
        var lat2 = this._degToRad(latlng2.lat);

        // Based on formulae from
        // http://williams.best.vwh.net/avform.htm#Intermediate
        var d = Math.acos(Math.sin(lat1) * Math.sin(lat2) +
            Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon1 - lon2));

        // Split the arc in half
        var f = 0.5;

        var A = Math.sin((1 - f) * d) / Math.sin(d);
        var B = Math.sin(f * d) / Math.sin(d);

        var x = A * Math.cos(lat1) * Math.cos(lon1) +
            B * Math.cos(lat2) * Math.cos(lon2);

        var y = A * Math.cos(lat1) * Math.sin(lon1) +
            B * Math.cos(lat2) * Math.sin(lon2);

        var z = A * Math.sin(lat1) + B * Math.sin(lat2);

        var lat = Math.atan2(z, Math.sqrt(x * x + y * y));
        var lon = Math.atan2(y, x);

        return DG.latLng(this._radToDeg(lat), this._radToDeg(lon));
    },

    // Adaptive sampling algorithm based on
    // http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf
    _adaptiveSample: function (left, right, depth, middle) { // (LatLng, LatLng, Number[, LatLng]) -> LatLng[]
        if (depth > 9) {
            // Max recursion depth reached
            return [];
        }

        middle = middle || this._calcMidPoint(left, right);

        var leftMiddle = this._calcMidPoint(left, middle);
        var rightMiddle = this._calcMidPoint(middle, right);

        var angle1 = this._calcAngle(leftMiddle, middle, left);
        var angle2 = this._calcAngle(middle, left, right);
        var angle3 = this._calcAngle(rightMiddle, middle, right);

        // left --- leftMiddle --- middle --- rightMiddle --- right
        //            angle1       angle2       angle3

        var minAngle = 3.1;
        if (angle1 > minAngle && angle2 > minAngle && angle3 > minAngle) {
            // This section is straight enough, no intermediate points needed.
            return [];
        } else {
            // Angles are too small. Recursively sample halves of this section.
            var result = [];
            result = result.concat(this._adaptiveSample(left, middle, depth + 1, leftMiddle));
            result.push(middle);
            result = result.concat(this._adaptiveSample(middle, right, depth + 1, rightMiddle));

            return result;
        }
    },

    // Calculates the great circle arc between two LatLngs.
    _calcGreatCircle: function (latlng1, latlng2) { // (LatLng, LatLng) -> LatLng[]
        latlng2 = this._normalizeLatLng(latlng2, latlng1);

        // Special case: points are close to each other (within 1 degree)
        if (latlng1.equals(latlng2, 1)) {
            return [latlng1, latlng2];
        }

        // Special case: the great circle crosses a pole
        if (Math.abs(latlng2.lng - latlng1.lng) == 180) {
            // North or south pole?
            var latitude = (latlng1.lat + latlng2.lat > 0) ? 90 : -90;

            return [
                latlng1,
                DG.latLng(latitude, latlng1.lng),
                DG.latLng(latitude, latlng2.lng),
                latlng2
            ];
        }

        var result = [];

        result.push(latlng1);
        result = result.concat(this._adaptiveSample(latlng1, latlng2, 0));
        result.push(latlng2);

        // Make sure the arc doesn't jump between worlds
        for (var i = 1; i < result.length; i++) {
            result[i] = this._normalizeLatLng(result[i], result[i - 1]);
        }

        return result;
    },

    _addLegs: function (point) {
        var pathStyles = this.options.pathStyles;

        var greatCirclePoints = this._calcGreatCircle(
            point.getLatLng(),
            this._points[point._pos + 1].getLatLng()
        );

        point._legs = {};
        Object.keys(pathStyles).forEach(function (layer) {
            point._legs[layer] = DG.polyline(greatCirclePoints, pathStyles[layer]).addTo(this._layers[layer]);
        }, this);

        point._legs.mouse._point = point.once('remove', this._clearRemovingPointLegs, this);

        if (this.options.editable && !DG.Browser.mobile) {
            point._legs.mouse.on('mousedown', this._insertPointInLine, this);
        }

        if (this._map) {
            this._layers.mouse.addLayer(point._legs.mouse);
        }
    },

    _clearRemovingPointLegs: function (event) { // (Event)
        this._removeLegs(event.target);
    },

    _removeLegs: function (point) { // (Ruler.LayeredMarker)
        if (point._legs) {
            Object.keys(point._legs).forEach(function (layer) {
                this._layers[layer].removeLayer(point._legs[layer]);
            }, this);
            point._legs = null;
        }
    },

    _updateLegs: function (point, skipPrevious) { // (Ruler.LayeredMarker, Boolean)
        var latlng = point.getLatLng(),
            previousPoint = this._points[point._pos - 1],
            nextPoint = this._points[point._pos + 1],
            self = this,
            newPoints;

        if (previousPoint && !skipPrevious) {
            newPoints = self._calcGreatCircle(previousPoint.getLatLng(), latlng);

            Object.keys(previousPoint._legs).forEach(function (layer) {
                previousPoint._legs[layer].setLatLngs(newPoints);
            });
        }

        if (nextPoint) {
            newPoints = self._calcGreatCircle(latlng, nextPoint.getLatLng());

            Object.keys(point._legs).forEach(function (layer) {
                point._legs[layer].setLatLngs(newPoints);
            });
        }
    },

    _calcDistance: function (finishPoint, tail) { // (Ruler.LayeredMarker, Number) -> Number
        var distance = tail ? tail : 0,
            calcTo = finishPoint ? finishPoint._pos : this._points.length - 1;

        for (var i = 0; i < calcTo; i++) {
            distance += this._points[i].getLatLng().distanceTo(this._points[i + 1].getLatLng());
        }

        return distance;
    },

    _getFormatedDistance: function () { // () -> String
        var distance = this._calcDistance.apply(this, arguments),
            units = 'm';

        if (distance > 1000) {
            distance /= 1000;
            units = 'km';
            if (distance > 1000) {
                distance = distance.toFixed();
                distance = distance.slice(0, -3) + ' ' + distance.slice(-3);
            } else {
                distance = distance.toFixed(2).split('.').join(this.t('delimiter'));
            }
        } else {
            distance = Math.round(distance);
        }

        return [distance || 0, ' ', this.t(units)].join('');
    },

    _updateDistance: function () { // ()
        if (this._map && this._points.length) {
            this._points[this._points.length - 1].setText(this._getFormatedDistance());
        }
    }
});

DG.ruler = function (latlngs, options) { // (Array, Object)
    return new DG.Ruler(latlngs, options);
};

DG.Ruler.LayeredMarker = DG.Marker.extend({
    options: {
        draggable: false,
        keyboard: false,
        riseOnHover: true,
        pane: 'rulerMarkerPane',
        iconHTML: [
            '<img class="dg-ruler__label-spacer" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" width="26" height="26" />',
            '<div class="dg-ruler__label-container">',
            '    <div class="dg-ruler__point"></div>',
            '    <span class="dg-ruler__label-distance">0 км</span>',
            '    <span class="dg-ruler__label-remove-link"></span>',
            '    <div class="dg-ruler__remove-link-overlay"></div>',
            '</div>'
        ].join('\n')
    },

    statics: {
        domClass : 'dg-ruler__label'
    },

    addTo : function (map, layers) {
        Object.keys(this._layers).forEach(function (name) {
            layers[name].addLayer(this._layers[name]);
        }, this);

        this._viewport = layers;
        return DG.Marker.prototype.addTo.call(this.on('move', this._onMove), map);
    },

    onRemove : function (map) {
        Object.keys(this._layers).forEach(function (name) {
            this._viewport[name].removeLayer(this._layers[name]);
        }, this);
        this.off('move', this._onMove);
        this._viewport = null;
        this._style = null;
        return DG.Marker.prototype.onRemove.call(this, map);
    },

    setText : function (text) {
        if (this._iconCollapsed) {
            this.expand();
        }
        this._iconNodes.label.innerHTML = text;
        return this;
    },

    setPointStyle : function (style) {
        if (this._style !== style) {
            Object.keys(this._style = style).forEach(function (name) {
                this._layers[name].setStyle(style[name]);
            }, this);
        }
        return this;
    },

    expand : function () {
        this._iconCollapsed = false;
        this._iconNodes.container.style.display = 'block';
        this._iconNodes.spacer.style.display = 'none';
        return this;
    },

    collapse : function () {
        this._iconCollapsed = true;
        this._iconNodes.container.style.display = 'none';
        this._iconNodes.spacer.style.display = 'block';
        return this;
    },

    querySelector : function (selector) {
        return this._icon.querySelector('.' + DG.Ruler.LayeredMarker.domClass + '-' + selector);
    },

    _onMove : function (event) {
        var latlng = event.latlng;
        Object.keys(this._layers).forEach(function (name) {
            this._layers[name].setLatLng(latlng);
        }, this);
    },

    _initIcon : function () {
        DG.Marker.prototype._initIcon.call(this);
        this._iconCollapsed = true;
        this._icon.style.width = '';
        this._iconNodes = {
            label : this.querySelector('distance'),
            spacer : this.querySelector('spacer'),
            container : this.querySelector('container')
        };
    },

    // don't change icon zIndex
    _setPos: function (pos) {
        L.DomUtil.setPosition(this._icon, pos);

        if (this._shadow) {
            L.DomUtil.setPosition(this._shadow, pos);
        }
    },

    _afterInit : function () {
        this._layers = this.options.layers || null;
        this.options.icon = DG.divIcon({
            className: DG.Ruler.LayeredMarker.domClass,
            iconSize: [26, 26],
            iconAnchor: [13, 13],
            html: this.options.iconHTML
        });
    }

});

DG.Ruler.LayeredMarker.addInitHook('_afterInit');

DG.Ruler.layeredMarker = function (latlng, options) {
    return new DG.Ruler.LayeredMarker(latlng, options);
};

var rulerRenderer = DG.svg({pane: 'rulerPane'});
var hoverRenderer = DG.svg({pane: 'rulerPane'});

DG.Ruler.mergeOptions({
    pathStyles: {
        back: {
            color: '#fff',
            opacity: 1,
            weight: 12,
            pointerEvents: 'none',
            noClip: true,
            renderer: rulerRenderer,
            smoothFactor: 0
        },
        middle: {
            color: '#0da5d5',
            opacity: 1,
            weight: 4,
            pointerEvents: 'none',
            noClip: true,
            renderer: rulerRenderer,
            smoothFactor: 0
        },
        mouse: {
            color: '#fff',
            opacity: DG.Browser.vml ? 0.1 : 0,
            weight: DG.Browser.touch ? 40 : 20,
            pointerEvents: 'painted',
            noClip: true,
            renderer: hoverRenderer,
            smoothFactor: 0
        }
    },
    iconStyles: {
        large: {
            back: {
                color: '#fff',
                opacity: 1,
                fillColor: '#fff',
                fillOpacity: 1,
                weight: 1,
                radius: 13,
                renderer: rulerRenderer
            },
            middle: {
                color: '#0da5d5',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 1,
                radius: 9,
                renderer: rulerRenderer
            },
            front: {
                color: '#fff',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 4,
                radius: 5,
                renderer: rulerRenderer
            }
        },
        small: {
            back: {
                color: '#fff',
                opacity: 1,
                fillColor: '#fff',
                fillOpacity: 1,
                weight: 1,
                radius: 9,
                renderer: rulerRenderer
            },
            middle: {
                color: '#0da5d5',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 1,
                radius: 5,
                renderer: rulerRenderer
            },
            front: {
                color: '#fff',
                opacity: 1,
                fillColor: '#0da5d5',
                fillOpacity: 1,
                weight: 4,
                radius: 2,
                renderer: rulerRenderer
            }
        }
    }
});

DG.Ruler.Dictionary.ru = {
	km : 'км',
	m : 'м',
	delimiter : ','
};

DG.Ruler.Dictionary.it = {
	km : 'km',
	m : 'm',
	delimiter : ','
};
DG.Ruler.Dictionary.cs = {
	km: 'km',
	m: 'm',
	delimiter: ','
};
DG.Ruler.Dictionary.es = {
	km : 'km',
	m : 'm',
	delimiter : ','
};
DG.Ruler.Dictionary.en = {
	km : 'km',
	m : 'm',
	delimiter : '.'
};

DG.Control.Ruler = DG.RoundControl.extend({

    options: {
        position: 'topright',
        iconClass: 'ruler'
    },

    statics: {
        Dictionary: {}
    },

    initialize: function (options) {
        DG.setOptions(this, options);
        DG.extend(this, {
            _active: false,
            _drawingHelper: null,
            _geoclickerNeedRestore: false
        }).on(this._controlEvents, this);
    },

    _controlEvents: {
        add: function () {
            this._drawingHelper = DG.ruler([]);
        },
        click: function () {
            this._active = !this._active;

            if (this._active) {
                this.setState('active');
                this._startDrawing();
            } else {
                this.setState('');
                this._finishDrawing();
            }
        },
        remove: function () {
            this.off(this._controlEvents, this);
            if (this._active) {
                this._map.removeLayer(this._drawingHelper);
                this._active = false;
            }
            this._drawingHelper = null;
        }
    },

    _startDrawing: function () { // ()
        this._map
            .addLayer(this._drawingHelper)
            .on('click', this._handleMapClick, this);

        this._map.fire('rulerstart');
    },

    _finishDrawing: function () { // ()
        this._map
            .off('click', this._handleMapClick, this)
            .removeLayer(this._drawingHelper);

        this._drawingHelper.setLatLngs([]);

        this._map.fire('rulerend');
    },

    _handleMapClick: function (event) { // (MouseEvents)
        this._drawingHelper.addLatLng(event.latlng);
    },

    _renderTranslation: function () { // ()
        this._link.title = this.t('button_title');
    }
});

DG.control.ruler = function (options) {
    return new DG.Control.Ruler(options);
};

DG.Map.mergeOptions({
    rulerControl: false
});

DG.Map.addInitHook(function () {
    if (this.options.rulerControl) {
        this.rulerControl = DG.control.ruler(this.options.rulerControl);
        this.addControl(this.rulerControl);
    }
});

DG.Control.Ruler.Dictionary.ru = {
	button_title: 'Линейка'
};
DG.Control.Ruler.Dictionary.it = {
	button_title : 'Righello'
};
DG.Control.Ruler.Dictionary.cs = {
	button_title: 'Pravítko'
};
DG.Control.Ruler.Dictionary.es = {
	button_title : 'Regla'
};

DG.Control.Ruler.Dictionary.en = {
	button_title : 'Ruler'
};
(function(dust){dust.register("DGAttribution\/copyright",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-attribution__copyright\"><ul class=\"dg-attribution__links\"><li class=\"dg-attribution__link-item\">").x(ctx.get(["osm"], false),ctx,{"block":body_1},{}).w("<a href=\"").f(ctx.get(["copyright_apilink"], false),ctx,"h").w("\" target=\"_blank\" class=\"dg-attribution__link\">").nx(ctx.get(["osm"], false),ctx,{"block":body_2},{}).f(ctx.get(["API_2GIS"], false),ctx,"h").w("</a></li><li class=\"dg-attribution__link-item\"><a href=\"").f(ctx.get(["copyright_license"], false),ctx,"h").w("\" target=\"_blank\" class=\"dg-attribution__link\">").f(ctx.get(["license_agreement"], false),ctx,"h").w("</a></li></ul><a href=\"").f(ctx.get(["copyright_logo"], false),ctx,"h").w("\" target=\"_blank\" class=\"dg-attribution__logo-url\"></a></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("© <a href=\"http://www.openstreetmap.org/copyright\" target=\"_blank\" class=\"dg-attribution__link\">OpenStreetMap contributors</a>, ");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.f(ctx.get(["work_on"], false),ctx,"h").w(" ");}body_2.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/cityarea",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_").f(ctx.get(["type"], false),ctx,"h").w("\">").f(ctx.get(["purpose"], false),ctx,"h").w("</div>").s(ctx.get(["drilldown"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__drilldown\">").f(ctx.get(["drilldown"], false),ctx,"h").w("</div>");}body_1.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardAddr",body_0);function body_0(chk,ctx){return chk.w("<address class=\"dg-firm-card__address dg-firm-card__icon\">").f(ctx.get(["address"], false),ctx,"h").s(ctx.get(["comment"], false),ctx,{"block":body_1},{}).w("</address>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<span class=\"dg-firm-card__comment\">&mdash; ").f(ctx.getPath(true, []),ctx,"h").w("</span>");}body_1.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardContacts",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["groups"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.s(ctx.get(["contacts"], false),ctx,{"block":body_2},{});}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.h("select",ctx,{"block":body_3},{"key":ctx.get(["type"], false),"type":"string"},"h");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.h("eq",ctx,{"block":body_4},{"value":"phone","type":"string"},"h").h("eq",ctx,{"block":body_6},{"value":"fax","type":"string"},"h").h("eq",ctx,{"block":body_8},{"value":"website","type":"string"},"h").h("eq",ctx,{"block":body_9},{"value":"email","type":"string"},"h");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<div class=\"dg-firm-card__phone dg-firm-card__icon\"><span class=\"dg-firm-card__phone-num\">").f(ctx.get(["text"], false),ctx,"h").s(ctx.get(["comment"], false),ctx,{"block":body_5},{}).w("</span></div>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<span class=\"dg-firm-card__comment\" title=\"").f(ctx.getPath(true, []),ctx,"h").w("\">&mdash;&nbsp;&nbsp;").f(ctx.getPath(true, []),ctx,"h").w("</span>");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<div class=\"dg-firm-card__phone dg-firm-card__icon\"><span class=\"dg-firm-card__phone-num\">").f(ctx.get(["text"], false),ctx,"h").s(ctx.get(["comment"], false),ctx,{"block":body_7},{}).w("</span></div>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.w("<span class=\"dg-firm-card__comment\" title=\"").f(ctx.getPath(true, []),ctx,"h").w("\">&mdash;&nbsp;&nbsp;").f(ctx.getPath(true, []),ctx,"h").w("</span>");}body_7.__dustBody=!0;function body_8(chk,ctx){return chk.w("<div class=\"dg-firm-card__link dg-firm-card__site dg-firm-card__icon\"><a href=\"").f(ctx.get(["url"], false),ctx,"h").w("\" target=\"_blank\" class=\"dg-link_scheme_dark dg-firm-card__sitelink\">").f(ctx.get(["text"], false),ctx,"h").w("</a></div>");}body_8.__dustBody=!0;function body_9(chk,ctx){return chk.w("<div class=\"dg-firm-card__link dg-firm-card__email dg-firm-card__icon\"><a href=\"mailto:").f(ctx.get(["value"], false),ctx,"h").w("\">").f(ctx.get(["value"], false),ctx,"h").w("</a></div>");}body_9.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardHeader",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-popup__header-title dg-popup__header-title_for_firmcard\" title=\"").f(ctx.get(["firmName"], false),ctx,"h").w("\">").f(ctx.get(["firmName"], false),ctx,"h").w("</div>").x(ctx.get(["links"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div class=\"dg-popup__header-links\">").s(ctx.get(["links"], false),ctx,{"block":body_2},{}).w("</div>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.h("eq",ctx,{"else":body_3,"block":body_6},{"key":body_7,"value":"flamp_stars","type":"string"},"h");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<a class=\"dg-popup__header-link dg-popup__link dg-popup__link_type_").f(ctx.get(["name"], false),ctx,"h").w("\"").x(ctx.get(["href"], false),ctx,{"else":body_4,"block":body_5},{}).w(">").f(ctx.get(["label"], false),ctx,"h").w("</a>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("href=\"javascript:void(0)\"");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("href=").f(ctx.get(["href"], false),ctx,"h").w(" target=\"_blank\"");}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<div class=\"dg-popup__rating\"><div class=\"dg-popup__rating-stars\" style=\"width: ").f(ctx.get(["width"], false),ctx,"h").w("%\"></div></div>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.f(ctx.get(["name"], false),ctx,"h");}body_7.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardRubric",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["rubrics"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<section class=\"dg-firm-card__rubrics\">").x(ctx.get(["primary"], false),ctx,{"block":body_2},{}).x(ctx.get(["additional"], false),ctx,{"block":body_4},{}).w("</section>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<ul class=\"dg-firm-card__rubrics-list dg-firm-card__rubrics-list_type_primary\">").s(ctx.get(["primary"], false),ctx,{"block":body_3},{}).w("</ul>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<li class=\"dg-firm-card__rubrics-list-item\">").f(ctx.get(["name"], false),ctx,"h").w("</li>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<ul class=\"dg-firm-card__rubrics-list dg-firm-card__rubrics-list_type_additional\">").s(ctx.get(["additional"], false),ctx,{"block":body_5},{}).w("</ul>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<li class=\"dg-firm-card__rubrics-list-item\">").f(ctx.get(["name"], false),ctx,"h").w("</li>");}body_5.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmCardSchedule",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-firm-card__schedule dg-schedule dg-schedule_open_").x(ctx.getPath(false, ["forecast","open"]),ctx,{"else":body_1,"block":body_2},{}).w(" dg-schedule_works-everyday_").x(ctx.getPath(false, ["schedule","everyday"]),ctx,{"else":body_3,"block":body_4},{}).w("\">").x(ctx.get(["schedule"], false),ctx,{"block":body_5},{}).w("</div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("false");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("true");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("false");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("true");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.x(ctx.getPath(false, ["forecast","today"]),ctx,{"block":body_6},{}).s(ctx.getPath(false, ["forecast","now"]),ctx,{"block":body_10},{}).nx(ctx.getPath(false, ["schedule","everyday"]),ctx,{"block":body_12},{});}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<div class=\"dg-schedule__today\"><div class=\"dg-schedule__today-inner\">").f(ctx.getPath(false, ["forecast","today","text"]),ctx,"h").w("&nbsp;").x(ctx.getPath(false, ["forecast","today","from"]),ctx,{"block":body_7},{}).x(ctx.getPath(false, ["schedule","lunch"]),ctx,{"block":body_8},{}).w("</div></div>");}body_6.__dustBody=!0;function body_7(chk,ctx){return chk.f(ctx.getPath(false, ["forecast","today","from"]),ctx,"h").w("&ndash;").f(ctx.getPath(false, ["forecast","today","to"]),ctx,"h");}body_7.__dustBody=!0;function body_8(chk,ctx){return chk.w(",&nbsp;").f(ctx.getPath(false, ["forecast","today","lunchStr"]),ctx,"h").w("&nbsp;").s(ctx.getPath(false, ["schedule","lunch"]),ctx,{"block":body_9},{});}body_8.__dustBody=!0;function body_9(chk,ctx){return chk.f(ctx.get(["from"], false),ctx,"h").w("&ndash;").f(ctx.get(["to"], false),ctx,"h");}body_9.__dustBody=!0;function body_10(chk,ctx){return chk.w("<div class=\"dg-schedule__now\"><span class=\"dg-schedule__now-text\">").f(ctx.getPath(true, []),ctx,"h").s(ctx.getPath(false, ["schedule","comment"]),ctx,{"block":body_11},{}).w("</span></div>");}body_10.__dustBody=!0;function body_11(chk,ctx){return chk.w(", ").f(ctx.getPath(true, []),ctx,"h");}body_11.__dustBody=!0;function body_12(chk,ctx){return chk.x(ctx.getPath(false, ["schedule","week"]),ctx,{"block":body_13},{});}body_12.__dustBody=!0;function body_13(chk,ctx){return chk.x(ctx.getPath(false, ["schedule","week","evently"]),ctx,{"block":body_14},{}).x(ctx.getPath(false, ["schedule","week","table"]),ctx,{"block":body_22},{});}body_13.__dustBody=!0;function body_14(chk,ctx){return chk.w("<div class=\"dg-schedule__table\">").s(ctx.getPath(false, ["schedule","week","evently"]),ctx,{"block":body_15},{}).w("</div>");}body_14.__dustBody=!0;function body_15(chk,ctx){return chk.w("<div class=\"dg-schedule__string\">").x(ctx.get(["alltime"], false),ctx,{"block":body_16},{}).x(ctx.get(["everyday"], false),ctx,{"else":body_17,"block":body_18},{}).x(ctx.get(["holiday"], false),ctx,{"else":body_19,"block":body_21},{}).w("</div>");}body_15.__dustBody=!0;function body_16(chk,ctx){return chk.f(ctx.get(["alltimeStr"], false),ctx,"h");}body_16.__dustBody=!0;function body_17(chk,ctx){return chk.f(ctx.get(["dayList"], false),ctx,"h");}body_17.__dustBody=!0;function body_18(chk,ctx){return chk.f(ctx.getPath(false, ["forecast","today","text"]),ctx,"h");}body_18.__dustBody=!0;function body_19(chk,ctx){return chk.w("<span class=\"schedule__string-time\">&nbsp;").f(ctx.get(["from"], false),ctx,"h").w("&ndash;").f(ctx.get(["to"], false),ctx,"h").w("</span>").s(ctx.get(["lunch"], false),ctx,{"block":body_20},{});}body_19.__dustBody=!0;function body_20(chk,ctx){return chk.w("<p>").f(ctx.get(["lunchStr"], false),ctx,"h").w("&mdash;<span class=\"schedule__string-time\">").f(ctx.get(["from"], false),ctx,"h").w("&ndash;").f(ctx.get(["to"], false),ctx,"h").w("</span></p>");}body_20.__dustBody=!0;function body_21(chk,ctx){return chk.w("&nbsp;&mdash;<span class=\"schedule__string-time\">&nbsp;").f(ctx.get(["holidayStr"], false),ctx,"h").w("</span>");}body_21.__dustBody=!0;function body_22(chk,ctx){return chk.w("<div><div class=\"dg-schedule__table\"><div class=\"dg-schedule__tc dg-schedule__tc_pre\"><div class=\"dg-schedule__day-name\">&nbsp;</div><div class=\"dg-schedule__table-clock dg-schedule__td\"></div>").x(ctx.getPath(false, ["schedule","week","hasLunch"]),ctx,{"block":body_23},{}).w("</div>").s(ctx.getPath(false, ["schedule","week","table"]),ctx,{"block":body_24},{}).w("</div>  </div>");}body_22.__dustBody=!0;function body_23(chk,ctx){return chk.w("<div class=\"dg-schedule__table-lunch dg-schedule__td\"></div>");}body_23.__dustBody=!0;function body_24(chk,ctx){return chk.h("if",ctx,{"block":body_25},{"cond":body_26},"h").w("<div class=\"dg-schedule__tc").x(ctx.get(["active"], false),ctx,{"block":body_27},{}).w("\"><div class=\"dg-schedule__day-name\">").f(ctx.get(["key"], false),ctx,"h").w("</div><div class=\"dg-schedule__td\">").x(ctx.get(["from"], false),ctx,{"else":body_28,"block":body_29},{}).w("</div>").s(ctx.get(["lunch"], false),ctx,{"block":body_30},{}).w("</div> ").h("if",ctx,{"block":body_33},{"cond":body_34},"h");}body_24.__dustBody=!0;function body_25(chk,ctx){return chk.w("<span class=\"dg-schedule__table-cell-group\">");}body_25.__dustBody=!0;function body_26(chk,ctx){return chk.w("(").f(ctx.get(["$idx"], false),ctx,"h").w(" == ").f(ctx.get(["$len"], false),ctx,"h").w(" - 2)");}body_26.__dustBody=!0;function body_27(chk,ctx){return chk.w(" dg-schedule__tc_active_true");}body_27.__dustBody=!0;function body_28(chk,ctx){return chk.w("&ndash;");}body_28.__dustBody=!0;function body_29(chk,ctx){return chk.f(ctx.get(["from"], false),ctx,"h").w(" ").f(ctx.get(["to"], false),ctx,"h");}body_29.__dustBody=!0;function body_30(chk,ctx){return chk.w("<div class=\"dg-schedule__td\">").x(ctx.get(["from"], false),ctx,{"else":body_31,"block":body_32},{}).w("</div>");}body_30.__dustBody=!0;function body_31(chk,ctx){return chk.w("&ndash;");}body_31.__dustBody=!0;function body_32(chk,ctx){return chk.f(ctx.get(["from"], false),ctx,"h").w(" ").f(ctx.get(["to"], false),ctx,"h");}body_32.__dustBody=!0;function body_33(chk,ctx){return chk.w("</span>");}body_33.__dustBody=!0;function body_34(chk,ctx){return chk.w("(").f(ctx.get(["$idx"], false),ctx,"h").w(" == ").f(ctx.get(["$len"], false),ctx,"h").w(")");}body_34.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/firmlistItem",body_0);function body_0(chk,ctx){return chk.w("<a id=\"").f(ctx.getPath(false, ["firm","id"]),ctx,"h").w("\" class=\"dg-popup__link\" href=\"#\">").f(ctx.getPath(false, ["firm","name"]),ctx,"h").w("</a>");}body_0.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/frimCardPayments",body_0);function body_0(chk,ctx){return chk.x(ctx.get(["payments"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<section class=\"dg-firm-card__aa\"><ul class=\"dg-firm-card__aa-list\">").s(ctx.get(["payments"], false),ctx,{"block":body_2},{}).w("</ul></section>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<li class=\"dg-firm-card__aa-list-item\">").f(ctx.getPath(true, []),ctx,"h").w("</li>");}body_2.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/house",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["address"], false),ctx,{"block":body_1},{}).s(ctx.get(["purpose"], false),ctx,{"block":body_4},{}).s(ctx.get(["attractions"], false),ctx,{"block":body_5},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<address class=\"dg-map-geoclicker__address\">").s(ctx.getPath(false, ["address","header"]),ctx,{"block":body_2},{}).s(ctx.getPath(false, ["address","drilldown"]),ctx,{"block":body_3},{}).w("</address>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__address-header\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__address-drilldown\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__purpose\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_sight\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_5.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/loader",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-preloader dg-preloader_scheme_regular dg-preloader_animation_").x(ctx.get(["anim"], false),ctx,{"else":body_1,"block":body_2},{}).x(ctx.get(["small"], false),ctx,{"block":body_3},{}).w("\"></div>");}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("false");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("true");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w(" dg-preloader_size_small");}body_3.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/popupFooter",body_0);function body_0(chk,ctx){return chk.w("<div class=\"dg-popup__footer-title\"><a class=\"dg-popup__show-less-house-link\" href=\"javascript:void(0)\">").f(ctx.get(["hideFirmsText"], false),ctx,"h").w("</a></div>");}body_0.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/popupFooterBtns",body_0);function body_0(chk,ctx){return chk.x(ctx.get(["btns"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<footer class=\"dg-popup__footer-buttons\">").s(ctx.get(["btns"], false),ctx,{"block":body_2},{}).w("</footer>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<div class=\"dg-popup__footer-button-wrapper\"><a class=\"dg-popup__button_name_").f(ctx.get(["name"], false),ctx,"h").w(" dg-popup__footer-button").x(ctx.get(["icon"], false),ctx,{"block":body_3},{}).w("\"").x(ctx.get(["href"], false),ctx,{"else":body_4,"block":body_5},{}).w(">").f(ctx.get(["label"], false),ctx,"h").w("</a></div>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w(" dg-popup__footer-icon-button");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("href=\"javascript:void(0)\"");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("href=").f(ctx.get(["href"], false),ctx,"h").w(" target=\"_blank\"");}body_5.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/popupHeader",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["title"], false),ctx,{"block":body_1},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div class=\"dg-popup__header-title\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_1.__dustBody=!0;return body_0}(dust));
(function(dust){dust.register("DGGeoclicker\/sight",body_0);function body_0(chk,ctx){return chk.s(ctx.get(["purpose"], false),ctx,{"block":body_1},{}).s(ctx.get(["address"], false),ctx,{"block":body_2},{}).s(ctx.get(["description"], false),ctx,{"block":body_5},{});}body_0.__dustBody=!0;function body_1(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__purpose dg-map-geoclicker__purpose_type_sight\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_1.__dustBody=!0;function body_2(chk,ctx){return chk.w("<address class=\"dg-map-geoclicker__address\">").s(ctx.getPath(false, ["address","header"]),ctx,{"block":body_3},{}).s(ctx.getPath(false, ["address","drilldown"]),ctx,{"block":body_4},{}).w("</address>");}body_2.__dustBody=!0;function body_3(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__address-header\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_3.__dustBody=!0;function body_4(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__address-drilldown\">").f(ctx.getPath(true, []),ctx,"h").w("</div>");}body_4.__dustBody=!0;function body_5(chk,ctx){return chk.w("<div class=\"dg-map-geoclicker__sight-description\">").f(ctx.getPath(true, []),ctx,"h").w("</div>").s(ctx.get(["showMoreText"], false),ctx,{"block":body_6},{});}body_5.__dustBody=!0;function body_6(chk,ctx){return chk.w("<a class=\"dg-map-geoclicker__show-more-sights-link\" href=\"javascript:void(0)\">").f(ctx.getPath(true, []),ctx,"h").w("</a>");}body_6.__dustBody=!0;return body_0}(dust));DG.fallbackProjectsList = JSON.parse('[{"name":"Cyprus","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"com.cy","bounds":"POLYGON((32.646616 34.47507,32.357465 34.559162,32.137711 34.848336,32.109708 35.28792,34.753746 35.822229,34.221031 34.869272,33.100897 34.396654,32.646616 34.47507))","zoom_level":{"min":9,"max":19},"code":"cyprus","country_code":"cy","id":"173","type":"region","time_zone":{"name":"Asia/Nicosia","offset":120}},{"name":"Dubai. Sharjah. Ajman","flags":{"metro":true,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ae","bounds":"POLYGON((55.680597 24.772487,54.879687 24.763288,54.86679 25.507556,55.672568 25.51707,55.680597 24.772487))","zoom_level":{"min":9,"max":18},"code":"dubai","country_code":"ae","id":"99","type":"region","time_zone":{"name":"Asia/Dubai","offset":240}},{"name":"Praha","flags":{"public_transport":true,"metro":true,"road_network":true,"flamp":false},"domain":"cz","bounds":"POLYGON((14.219495 49.934897,14.215528 50.17879,14.713797 50.181086,14.715245 49.937173,14.219495 49.934897))","zoom_level":{"min":10,"max":18},"code":"praha","country_code":"cz","id":"92","type":"region","time_zone":{"name":"Europe/Prague","offset":60}},{"name":"Santiago","flags":{"public_transport":true,"metro":true,"road_network":true,"flamp":false},"domain":"cl","bounds":"POLYGON((-70.483526 -33.665691,-70.857156 -33.660641,-70.849333 -33.293335,-70.477276 -33.298315,-70.483526 -33.665691))","zoom_level":{"min":9,"max":19},"code":"santiago","country_code":"cl","id":"101","type":"region","time_zone":{"name":"America/Santiago","offset":-180}},{"name":"Venezia e Padova","flags":{"public_transport":true,"metro":false,"road_network":false,"flamp":false},"domain":"it","bounds":"POLYGON((11.381405 45.733677,12.61199 45.701369,12.572035 45.071337,11.355023 45.102946,11.381405 45.733677))","zoom_level":{"min":9,"max":18},"code":"padova","country_code":"it","id":"66","type":"region","time_zone":{"name":"Europe/Rome","offset":60}},{"name":"Абакан","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((91.144335 53.893079,91.817626 53.901599,91.826689 53.577496,91.158554 53.569076,91.144335 53.893079))","zoom_level":{"min":9,"max":18},"code":"abakan","country_code":"ru","id":"69","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Алматы","flags":{"metro":true,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"kz","bounds":"POLYGON((76.72599 43.469093,77.1084 43.462692,77.096182 43.108051,76.715991 43.114387,76.72599 43.469093))","zoom_level":{"min":9,"max":18},"code":"almaty","country_code":"kz","id":"67","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Альметьевск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((52.206024 54.949956,52.478673 54.946945,52.473188 54.796869,52.20155 54.799862,52.206024 54.949956))","zoom_level":{"min":9,"max":18},"code":"almetevsk","country_code":"ru","id":"108","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Армавир","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((40.8594 44.729852,40.876282 45.249444,41.322578 45.241236,41.301688 44.721791,40.8594 44.729852))","zoom_level":{"min":9,"max":18},"code":"armawir","country_code":"ru","id":"106","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Архангельск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.467082 64.829966,41.321175 64.812571,41.276671 64.284305,39.458118 64.301293,39.467082 64.829966))","zoom_level":{"min":9,"max":18},"code":"arkhangelsk","country_code":"ru","id":"49","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Астана","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"kz","bounds":"POLYGON((71.18796 51.371885,71.882791 51.35684,71.856572 50.934375,71.168047 50.949196,71.18796 51.371885))","zoom_level":{"min":9,"max":18},"code":"astana","country_code":"kz","id":"68","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Астрахань","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((47.863046 46.503348,48.172299 46.511418,48.185812 46.249257,47.878034 46.241258,47.863046 46.503348))","zoom_level":{"min":9,"max":18},"code":"astrakhan","country_code":"ru","id":"8","type":"region","time_zone":{"name":"Europe/Astrakhan","offset":240}},{"name":"Барнаул","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((84.087935 53.472209,84.065362 53.158598,83.445791 53.172941,83.463815 53.486716,84.087935 53.472209))","zoom_level":{"min":9,"max":18},"code":"barnaul","country_code":"ru","id":"4","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"Белгород","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((36.419278 50.695,36.719872 50.701271,36.729779 50.495879,36.430487 50.489654,36.419278 50.695))","zoom_level":{"min":9,"max":18},"code":"belgorod","country_code":"ru","id":"46","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Бийск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((85.467428 52.646705,85.492485 51.91455,84.608614 51.899905,84.568894 52.63167,85.467428 52.646705))","zoom_level":{"min":9,"max":18},"code":"biysk","country_code":"ru","id":"20","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"Бишкек","flags":{"metro":false,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"kg","bounds":"POLYGON((74.4117 43.079799,74.961984 43.081306,74.962352 42.560778,74.416615 42.559297,74.4117 43.079799))","zoom_level":{"min":9,"max":18},"code":"bishkek","country_code":"kg","id":"112","type":"region","time_zone":{"name":"Asia/Bishkek","offset":360}},{"name":"Благовещенск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((127.345035 50.596534,127.754667 50.601634,127.764413 50.228495,127.357983 50.223461,127.345035 50.596534))","zoom_level":{"min":9,"max":18},"code":"blagoveshensk","country_code":"ru","id":"52","type":"region","time_zone":{"name":"Asia/Yakutsk","offset":540}},{"name":"Братск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((101.089619 56.502645,102.059766 56.482523,102.016041 55.92995,101.059727 55.949659,101.089619 56.502645))","zoom_level":{"min":9,"max":18},"code":"bratsk","country_code":"ru","id":"51","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"Брянск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((34.115433 53.143963,34.122949 53.431556,34.604425 53.426058,34.593689 53.138522,34.115433 53.143963))","zoom_level":{"min":9,"max":18},"code":"bryansk","country_code":"ru","id":"62","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Великий Новгород","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((31.131394 58.678746,31.505415 58.683631,31.514694 58.465262,31.142992 58.460419,31.131394 58.678746))","zoom_level":{"min":9,"max":18},"code":"v_novgorod","country_code":"ru","id":"77","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Владивосток","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((132.300602 42.803446,131.558591 42.822446,131.592018 43.61615,132.343685 43.596619,132.300602 42.803446))","zoom_level":{"min":9,"max":18},"code":"vladivostok","country_code":"ru","id":"25","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Владимир","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((40.178443 56.46782,40.695168 56.461839,40.676114 56.02824,40.165193 56.034124,40.178443 56.46782))","zoom_level":{"min":9,"max":18},"code":"vladimir","country_code":"ru","id":"59","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Волгоград","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((43.982875 48.314123,43.970587 48.922097,44.93003 48.92667,44.930866 48.3186,43.982875 48.314123))","zoom_level":{"min":9,"max":18},"code":"volgograd","country_code":"ru","id":"33","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Вологда","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((39.611585 59.337288,40.07794 59.334267,40.072156 59.150523,39.608303 59.153523,39.611585 59.337288))","zoom_level":{"min":9,"max":18},"code":"vologda","country_code":"ru","id":"78","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Воронеж","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.607251 51.475591,38.991243 51.477162,38.991159 51.910994,39.613084 51.909398,39.607251 51.475591))","zoom_level":{"min":9,"max":18},"code":"voronezh","country_code":"ru","id":"31","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Горно-Алтайск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((86.458369 51.25739,85.514346 51.249215,85.48461 52.148049,87.909246 52.154279,87.891399 51.255249,86.458369 51.25739))","zoom_level":{"min":9,"max":18},"code":"gornoaltaysk","country_code":"ru","id":"27","type":"region","time_zone":{"name":"Asia/Barnaul","offset":420}},{"name":"Днепр","flags":{"metro":true,"has_net_booklet":true,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ua","bounds":"POLYGON((34.749305 48.687967,35.296754 48.67835,35.281569 48.341385,34.737733 48.35089,34.749305 48.687967))","zoom_level":{"min":9,"max":18},"code":"dnepropetrovsk","country_code":"ua","id":"105","type":"region","time_zone":{"name":"Europe/Kiev","offset":120}},{"name":"Донецк","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"ua","bounds":"POLYGON((37.510512 48.182783,38.240528 48.189925,38.246188 47.802815,37.521609 47.795769,37.510512 48.182783))","zoom_level":{"min":9,"max":18},"code":"donetsk","country_code":"ua","id":"79","type":"region","time_zone":{"name":"Europe/Kiev","offset":120}},{"name":"Екатеринбург","flags":{"metro":true,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.714357 57.010251,60.919831 57.036097,60.943224 56.611802,59.751258 56.586369,59.714357 57.010251))","zoom_level":{"min":9,"max":18},"code":"ekaterinburg","country_code":"ru","id":"9","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Иваново","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.806886 57.089556,41.189405 57.083456,41.177466 56.879061,40.796997 56.885115,40.806886 57.089556))","zoom_level":{"min":9,"max":18},"code":"ivanovo","country_code":"ru","id":"65","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Ижевск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":false,"road_network":true},"domain":"ru","bounds":"POLYGON((52.95169 57.057889,53.495625 57.04823,53.470393 56.667543,52.931947 56.677063,52.95169 57.057889))","zoom_level":{"min":9,"max":18},"code":"izhevsk","country_code":"ru","id":"41","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"Иркутск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((103.618853 52.641505,104.97019 52.64955,104.970807 51.718225,103.647397 51.710443,103.618853 52.641505))","zoom_level":{"min":9,"max":18},"code":"irkutsk","country_code":"ru","id":"11","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"Йошкар-Ола","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((47.588902 56.761482,48.153297 56.748478,48.133249 56.507529,47.572432 56.520416,47.588902 56.761482))","zoom_level":{"min":9,"max":18},"code":"yoshkarola","country_code":"ru","id":"70","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Кавказские Минеральные Воды","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((42.596866 44.289522,43.518711 44.305202,43.530679 43.823418,42.616267 43.807998,42.596866 44.289522))","zoom_level":{"min":9,"max":18},"code":"minvody","country_code":"ru","id":"89","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Казань","flags":{"metro":true,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((48.29118 55.977651,49.519957 55.998533,49.535477 55.587187,48.319555 55.566624,48.29118 55.977651))","zoom_level":{"min":9,"max":18},"code":"kazan","country_code":"ru","id":"21","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Калининград","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((19.839261 55.044274,20.509974 55.055009,21.037803 55.267592,20.660212 54.93589,20.663516 54.5391,19.853783 54.534137,19.839261 55.044274))","zoom_level":{"min":9,"max":18},"code":"kaliningrad","country_code":"ru","id":"40","type":"region","time_zone":{"name":"Europe/Kaliningrad","offset":120}},{"name":"Калуга","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.894818 54.755461,36.455305 54.768523,36.482233 54.33388,35.927655 54.321024,35.894818 54.755461))","zoom_level":{"min":9,"max":18},"code":"kaluga","country_code":"ru","id":"61","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Каменск-Уральский","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((61.715751 56.571122,62.254705 56.57552,62.260467 56.279794,61.725677 56.275445,61.715751 56.571122))","zoom_level":{"min":9,"max":18},"code":"k_uralskiy","country_code":"ru","id":"109","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Караганда","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"kz","bounds":"POLYGON((73.394974 50.132623,73.41063 49.658415,72.880917 49.64993,72.860052 50.123995,73.394974 50.132623))","zoom_level":{"min":9,"max":18},"code":"karaganda","country_code":"kz","id":"84","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Кемерово","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((86.326511 55.27068,86.327501 55.212118,85.914901 55.209146,85.906046 55.53142,86.322012 55.534428,86.326511 55.27068))","zoom_level":{"min":9,"max":18},"code":"kemerovo","country_code":"ru","id":"5","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Киев","flags":{"metro":true,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ua","bounds":"POLYGON((30.210468 50.619492,31.021354 50.636093,31.039177 50.206516,30.235576 50.190165,30.210468 50.619492))","zoom_level":{"min":9,"max":18},"code":"kiev","country_code":"ua","id":"107","type":"region","time_zone":{"name":"Europe/Kiev","offset":120}},{"name":"Киров","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((49.036766 58.786454,49.936128 58.797004,49.947791 58.410879,49.058277 58.400486,49.036766 58.786454))","zoom_level":{"min":9,"max":18},"code":"kirov","country_code":"ru","id":"58","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Комсомольск-на-Амуре","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((136.792391 50.721413,137.258493 50.713313,137.233696 50.189815,136.772704 50.197767,136.792391 50.721413))","zoom_level":{"min":9,"max":18},"code":"komsomolsk","country_code":"ru","id":"94","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Кострома","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((40.721432 57.682077,40.733014 57.924383,41.151865 57.917978,41.137488 57.675732,40.721432 57.682077))","zoom_level":{"min":9,"max":18},"code":"kostroma","country_code":"ru","id":"34","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Краснодар","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.650083 45.265382,39.378568 45.26529,39.376448 44.943556,38.65204 44.943646,38.650083 45.265382))","zoom_level":{"min":9,"max":18},"code":"krasnodar","country_code":"ru","id":"23","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Красноярск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((92.126846 56.306635,93.59929 56.308263,93.591657 55.813004,92.137966 55.811406,92.126846 56.306635))","zoom_level":{"min":9,"max":18},"code":"krasnoyarsk","country_code":"ru","id":"7","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Курган","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((65.163165 55.530326,65.48286 55.524262,65.473103 55.368657,65.154662 55.374687,65.163165 55.530326))","zoom_level":{"min":9,"max":18},"code":"kurgan","country_code":"ru","id":"10","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Курск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((35.889369 51.829944,36.419838 51.842787,36.435346 51.569517,35.908055 51.556799,35.889369 51.829944))","zoom_level":{"min":9,"max":18},"code":"kursk","country_code":"ru","id":"73","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Ленинск-Кузнецкий","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((85.750103 54.768861,86.495701 54.774252,86.502903 54.184679,85.767947 54.179404,85.750103 54.768861))","zoom_level":{"min":9,"max":18},"code":"lenkuz","country_code":"ru","id":"86","type":"region","time_zone":{"name":"Asia/Novokuznetsk","offset":420}},{"name":"Липецк","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.376422 52.719879,39.82336 52.717618,39.819113 52.490547,39.37448 52.49279,39.376422 52.719879))","zoom_level":{"min":9,"max":18},"code":"lipetsk","country_code":"ru","id":"56","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Магнитогорск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.504226 53.910884,59.464288 53.229865,58.523119 53.245612,58.547823 53.927025,59.504226 53.910884))","zoom_level":{"min":9,"max":18},"code":"magnitogorsk","country_code":"ru","id":"26","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Махачкала","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"ru","bounds":"POLYGON((47.20145 43.164765,47.748162 43.160885,47.727392 42.692228,47.185086 42.703864,47.20145 43.164765))","zoom_level":{"min":9,"max":18},"code":"makhachkala","country_code":"ru","id":"113","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Миасс и Златоуст","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.545758 55.280232,60.258434 55.263275,60.228055 54.888197,59.522002 54.90492,59.545758 55.280232))","zoom_level":{"min":9,"max":18},"code":"miass","country_code":"ru","id":"87","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Москва","flags":{"metro":true,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((36.751702 56.216166,39.120953 56.236539,39.117281 55.026003,36.819893 55.006528,36.751702 56.216166))","zoom_level":{"min":9,"max":18},"code":"moscow","country_code":"ru","id":"32","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Мурманск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((33.225325 69.064731,33.222252 68.761176,32.705233 68.761065,32.701158 69.064619,33.225325 69.064731))","zoom_level":{"min":9,"max":18},"code":"murmansk","country_code":"ru","id":"96","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Набережные Челны","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((51.717261 55.865183,52.62818 55.856503,52.614937 55.536675,51.711425 55.545252,51.717261 55.865183))","zoom_level":{"min":9,"max":18},"code":"nabchelny","country_code":"ru","id":"29","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Находка","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((132.750811 42.90212,133.241339 42.910709,133.248191 42.668281,132.759571 42.659764,132.750811 42.90212))","zoom_level":{"min":10,"max":18},"code":"nahodka","country_code":"ru","id":"82","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Нижневартовск","flags":{"metro":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((75.931826 61.190935,77.028582 61.178947,77.007766 60.851181,75.922257 60.863009,75.931826 61.190935))","zoom_level":{"min":9,"max":18},"code":"nizhnevartovsk","country_code":"ru","id":"12","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Нижний Новгород","flags":{"metro":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((43.297073 56.468016,44.247071 56.477411,44.254811 56.081492,43.31457 56.072236,43.297073 56.468016))","zoom_level":{"min":9,"max":18},"code":"n_novgorod","country_code":"ru","id":"19","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Нижний Тагил","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((59.788601 58.091707,60.347887 58.078228,60.317394 57.749299,59.763185 57.762607,59.788601 58.091707))","zoom_level":{"min":9,"max":18},"code":"ntagil","country_code":"ru","id":"45","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Новокузнецк","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((86.517836 53.497554,86.510624 54.121371,87.463657 54.121473,87.456823 53.497654,86.517836 53.497554))","zoom_level":{"min":9,"max":18},"code":"novokuznetsk","country_code":"ru","id":"6","type":"region","time_zone":{"name":"Asia/Novokuznetsk","offset":420}},{"name":"Новороссийск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((36.968059 44.305963,36.936306 45.204638,38.650344 45.222751,38.655728 44.32352,36.968059 44.305963))","zoom_level":{"min":9,"max":18},"code":"novorossiysk","country_code":"ru","id":"74","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Новосибирск","flags":{"metro":true,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((85.088133 54.816411,84.810533 54.546933,84.093196 54.728848,83.763786 54.3856,83.998623 54.175215,83.349582 53.933688,83.292679 54.085893,82.76229 54.012318,82.661704 54.35505,82.470375 54.420101,81.542805 53.909614,81.613035 54.021479,81.137057 54.109871,80.95166 54.375446,81.719479 54.657871,81.360969 54.937569,81.477305 55.251991,81.330338 55.319242,82.154603 55.51402,81.553507 56.235201,82.774176 56.409006,82.862728 56.535243,83.285825 56.445179,83.064804 56.230587,83.403008 55.896203,83.211507 55.729573,83.972523 55.555768,84.000495 55.408305,84.660798 55.479568,84.916854 55.324764,84.837145 54.997021,85.088133 54.816411))","zoom_level":{"min":9,"max":18},"code":"novosibirsk","country_code":"ru","id":"1","type":"region","time_zone":{"name":"Asia/Novosibirsk","offset":420}},{"name":"Норильск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((88.529535 69.242435,86.000942 69.246318,85.986318 69.559455,88.551918 69.555507,88.529535 69.242435))","zoom_level":{"min":9,"max":18},"code":"norilsk","country_code":"ru","id":"76","type":"region","time_zone":{"name":"Asia/Krasnoyarsk","offset":420}},{"name":"Ноябрьск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((74.30478 63.879187,76.263372 63.875343,76.226155 63.018251,74.325265 63.021954,74.30478 63.879187))","zoom_level":{"min":9,"max":18},"code":"noyabrsk","country_code":"ru","id":"103","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Одесса","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"ua","bounds":"POLYGON((30.512168 46.64901,30.896079 46.656702,30.911286 46.261025,30.530141 46.253438,30.512168 46.64901))","zoom_level":{"min":9,"max":18},"code":"odessa","country_code":"ua","id":"14","type":"region","time_zone":{"name":"Europe/Kiev","offset":120}},{"name":"Омск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((72.9275 54.78532,72.844079 55.404999,73.75247 55.41764,73.771665 54.796804,72.9275 54.78532))","zoom_level":{"min":9,"max":18},"code":"omsk","country_code":"ru","id":"2","type":"region","time_zone":{"name":"Asia/Omsk","offset":360}},{"name":"Оренбург","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((54.932518 51.663479,54.920411 51.927322,55.487422 51.935975,55.496231 51.672052,54.932518 51.663479))","zoom_level":{"min":9,"max":18},"code":"orenburg","country_code":"ru","id":"48","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Орёл","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.870923 53.103739,36.315298 53.092181,36.295963 52.838995,35.85417 52.850448,35.870923 53.103739))","zoom_level":{"min":9,"max":18},"code":"orel","country_code":"ru","id":"71","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Павлодар","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"kz","bounds":"POLYGON((76.677763 52.439519,77.2347 52.430303,77.213446 52.005015,76.661799 52.014092,76.677763 52.439519))","zoom_level":{"min":9,"max":18},"code":"pavlodar","country_code":"kz","id":"111","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Пенза","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((44.79682 53.065926,44.795477 53.349082,45.35881 53.348717,45.356452 53.065566,44.79682 53.065926))","zoom_level":{"min":9,"max":18},"code":"penza","country_code":"ru","id":"42","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Пермь","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((55.631623 57.685995,55.610475 58.236816,56.656815 58.243911,56.66204 57.69294,55.631623 57.685995))","zoom_level":{"min":9,"max":18},"code":"perm","country_code":"ru","id":"16","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Петрозаводск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((34.102722 61.959477,34.70885 61.953295,34.694352 61.691472,34.093364 61.697587,34.102722 61.959477))","zoom_level":{"min":9,"max":18},"code":"petrozavodsk","country_code":"ru","id":"80","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Петропавловск-Камчатский","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((158.195687 53.346954,159.025519 53.349662,159.02523 52.858368,158.204799 52.855708,158.195687 53.346954))","zoom_level":{"min":9,"max":18},"code":"p_kamchatskiy","country_code":"ru","id":"95","type":"region","time_zone":{"name":"Asia/Kamchatka","offset":720}},{"name":"Псков","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((28.168619 57.889106,28.491531 57.885724,28.484999 57.727138,28.1635 57.7305,28.168619 57.889106))","zoom_level":{"min":9,"max":18},"code":"pskov","country_code":"ru","id":"90","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Ростов-на-Дону","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.358722 47.368152,39.924838 47.364983,39.919436 47.053314,39.356627 47.05645,39.358722 47.368152))","zoom_level":{"min":9,"max":18},"code":"rostov","country_code":"ru","id":"24","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Рязань","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.40589 54.882191,39.992113 54.878993,39.982607 54.487343,39.402002 54.490668,39.40589 54.882191))","zoom_level":{"min":9,"max":18},"code":"ryazan","country_code":"ru","id":"44","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Самара","flags":{"metro":true,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((50.524471 53.044185,49.796735 53.03905,49.777726 53.708125,50.516995 53.713386,50.524471 53.044185))","zoom_level":{"min":9,"max":18},"code":"samara","country_code":"ru","id":"18","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"Санкт-Петербург","flags":{"metro":true,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((29.41089 60.259339,30.98445 60.292561,31.031377 59.5092,29.494307 59.477002,29.41089 60.259339))","zoom_level":{"min":9,"max":18},"code":"spb","country_code":"ru","id":"38","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Саранск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((44.867017 54.301903,45.511721 54.300891,45.507836 53.984632,44.868027 53.985633,44.867017 54.301903))","zoom_level":{"min":9,"max":18},"code":"saransk","country_code":"ru","id":"85","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Саратов","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((46.304971 51.353163,45.730611 51.358153,45.7361 51.699809,46.314773 51.694758,46.304971 51.353163))","zoom_level":{"min":9,"max":18},"code":"saratov","country_code":"ru","id":"43","type":"region","time_zone":{"name":"Europe/Saratov","offset":240}},{"name":"Смоленск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((31.755002 54.885154,32.265103 54.889311,32.268673 54.692002,31.761048 54.687875,31.755002 54.885154))","zoom_level":{"min":9,"max":18},"code":"smolensk","country_code":"ru","id":"63","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Сочи","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((40.464281 43.36325,38.937514 43.372607,38.93648 44.354812,40.488511 44.345131,40.464281 43.36325))","zoom_level":{"min":9,"max":18},"code":"sochi","country_code":"ru","id":"30","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Ставрополь","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((41.679025 44.89293,41.658117 45.252393,42.307255 45.269558,42.324115 44.909882,41.679025 44.89293))","zoom_level":{"min":9,"max":18},"code":"stavropol","country_code":"ru","id":"57","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Старый Оскол","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((37.748371 51.246862,37.744862 51.375661,37.979312 51.377938,37.982166 51.249129,37.748371 51.246862))","zoom_level":{"min":10,"max":18},"code":"staroskol","country_code":"ru","id":"60","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Стерлитамак","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((55.805672 53.734238,56.123975 53.736987,56.13283 53.305583,55.817744 53.302876,55.805672 53.734238))","zoom_level":{"min":9,"max":18},"code":"sterlitamak","country_code":"ru","id":"54","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Сургут","flags":{"metro":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((72.38176 61.388553,73.781358 61.408288,73.797164 60.996565,72.41568 60.977161,72.38176 61.388553))","zoom_level":{"min":9,"max":18},"code":"surgut","country_code":"ru","id":"39","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Сыктывкар","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((50.431525 61.921812,51.275081 61.92271,51.271963 61.571227,50.437968 61.570342,50.431525 61.921812))","zoom_level":{"min":9,"max":18},"code":"syktyvkar","country_code":"ru","id":"72","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Тамбов","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((41.268899 52.567826,41.283161 52.841816,41.602492 52.835242,41.58624 52.561316,41.268899 52.567826))","zoom_level":{"min":9,"max":18},"code":"tambov","country_code":"ru","id":"81","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Тверь","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((35.531082 56.998794,36.290293 57.017546,36.3143 56.68411,35.561787 56.665594,35.531082 56.998794))","zoom_level":{"min":9,"max":18},"code":"tver","country_code":"ru","id":"47","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Тобольск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((68.027461 58.334051,68.627747 58.337205,68.630591 58.064257,68.03489 58.061137,68.027461 58.334051))","zoom_level":{"min":9,"max":18},"code":"tobolsk","country_code":"ru","id":"97","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Тольятти","flags":{"metro":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((48.961827 53.69702,49.777726 53.708125,49.796735 53.03905,48.993508 53.028211,48.961827 53.69702))","zoom_level":{"min":9,"max":18},"code":"togliatti","country_code":"ru","id":"22","type":"region","time_zone":{"name":"Europe/Samara","offset":240}},{"name":"Томск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((84.768656 56.588195,85.235419 56.595694,85.246532 56.355458,84.782704 56.348026,84.768656 56.588195))","zoom_level":{"min":9,"max":18},"code":"tomsk","country_code":"ru","id":"3","type":"region","time_zone":{"name":"Asia/Tomsk","offset":420}},{"name":"Тула","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((38.421585 53.908416,37.429616 53.899539,37.414045 54.309532,38.415847 54.318543,38.421585 53.908416))","zoom_level":{"min":9,"max":18},"code":"tula","country_code":"ru","id":"36","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Тюмень","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((66.690851 57.236046,66.609235 56.397678,65.213221 56.430463,65.263355 57.26989,66.690851 57.236046))","zoom_level":{"min":9,"max":18},"code":"tyumen","country_code":"ru","id":"13","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Улан-Удэ","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((107.376889 52.056483,107.990789 52.042492,107.96757 51.691351,107.358424 51.705168,107.376889 52.056483))","zoom_level":{"min":9,"max":18},"code":"ulanude","country_code":"ru","id":"37","type":"region","time_zone":{"name":"Asia/Irkutsk","offset":480}},{"name":"Ульяновск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((48.031111 54.455092,48.869524 54.472913,48.888501 54.122688,48.056193 54.105046,48.031111 54.455092))","zoom_level":{"min":9,"max":18},"code":"ulyanovsk","country_code":"ru","id":"55","type":"region","time_zone":{"name":"Europe/Ulyanovsk","offset":240}},{"name":"Уральск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"kz","bounds":"POLYGON((51.526154 51.284431,51.567598 51.109229,51.255488 51.110327,51.256457 51.285243,51.526154 51.284431))","zoom_level":{"min":9,"max":18},"code":"uralsk","country_code":"kz","id":"162","type":"region","time_zone":{"name":"Asia/Oral","offset":300}},{"name":"Уссурийск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((131.762993 43.708079,131.749241 43.961672,132.129905 43.971877,132.142052 43.718194,131.762993 43.708079))","zoom_level":{"min":9,"max":18},"code":"ussuriysk","country_code":"ru","id":"83","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Усть-Каменогорск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":false},"domain":"kz","bounds":"POLYGON((82.444837 49.862906,82.450724 50.059192,82.805717 50.054212,82.798391 49.857959,82.444837 49.862906))","zoom_level":{"min":9,"max":18},"code":"ustkam","country_code":"kz","id":"91","type":"region","time_zone":{"name":"Asia/Qyzylorda","offset":360}},{"name":"Уфа","flags":{"metro":false,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((56.304345 54.957284,56.312416 54.48324,55.729992 54.478524,55.71509 54.952485,56.304345 54.957284))","zoom_level":{"min":9,"max":18},"code":"ufa","country_code":"ru","id":"17","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Хабаровск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((135.259151 48.629372,135.257422 48.288578,134.874409 48.288797,134.873526 48.629594,135.259151 48.629372))","zoom_level":{"min":9,"max":18},"code":"khabarovsk","country_code":"ru","id":"35","type":"region","time_zone":{"name":"Asia/Vladivostok","offset":600}},{"name":"Харьков","flags":{"metro":true,"public_transport":true,"flamp":false,"traffic":true,"road_network":true},"domain":"ua","bounds":"POLYGON((36.031103 50.115121,36.467033 50.125456,36.481687 49.845767,36.048271 49.835534,36.031103 50.115121))","zoom_level":{"min":9,"max":18},"code":"kharkov","country_code":"ua","id":"110","type":"region","time_zone":{"name":"Europe/Kiev","offset":120}},{"name":"Чебоксары","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((47.00778 56.342026,47.60576 56.33089,47.58216 55.980845,46.989585 55.991836,47.00778 56.342026))","zoom_level":{"min":9,"max":18},"code":"cheboksary","country_code":"ru","id":"53","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}},{"name":"Челябинск","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"traffic":true,"road_network":true},"domain":"ru","bounds":"POLYGON((61.185486 55.312905,61.734408 55.319826,61.74458 54.997301,61.200066 54.990462,61.185486 55.312905))","zoom_level":{"min":9,"max":18},"code":"chelyabinsk","country_code":"ru","id":"15","type":"region","time_zone":{"name":"Asia/Yekaterinburg","offset":300}},{"name":"Чита","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((113.113845 52.186114,113.639184 52.175527,113.624543 51.926502,113.102113 51.936995,113.113845 52.186114))","zoom_level":{"min":9,"max":18},"code":"chita","country_code":"ru","id":"64","type":"region","time_zone":{"name":"Asia/Chita","offset":540}},{"name":"Южно-Сахалинск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((142.47294 47.515634,142.971757 47.50814,142.937954 46.583209,142.44768 46.590465,142.47294 47.515634))","zoom_level":{"min":9,"max":18},"code":"yuzhnosakhalinsk","country_code":"ru","id":"88","type":"region","time_zone":{"name":"Asia/Sakhalin","offset":660}},{"name":"Якутск","flags":{"public_transport":true,"metro":false,"road_network":true,"flamp":true},"domain":"ru","bounds":"POLYGON((129.532475 62.187831,129.992303 62.185302,129.979868 61.800501,129.525802 61.80299,129.532475 62.187831))","zoom_level":{"min":9,"max":18},"code":"yakutsk","country_code":"ru","id":"50","type":"region","time_zone":{"name":"Asia/Yakutsk","offset":540}},{"name":"Ярославль","flags":{"metro":false,"has_net_booklet":true,"public_transport":true,"flamp":true,"road_network":true},"domain":"ru","bounds":"POLYGON((39.722892 57.776199,40.012883 57.774213,40.005807 57.519309,39.717841 57.521275,39.722892 57.776199))","zoom_level":{"min":9,"max":18},"code":"yaroslavl","country_code":"ru","id":"28","type":"region","time_zone":{"name":"Europe/Moscow","offset":180}}]');DG.config = {"host":null,"port":3000,"defaultSkin":"dark","defaultLang":"ru","trafficLayerMinZoom":10,"trafficLayerUpdateInterval":300000,"ppnotLink":"http://2gis.{domain}/{projectCode}/center/{center}/zoom/{zoom}/routeTab/rsType/{rsType}/to/{point}╎{name}","photosLink":"http://2gis.{domain}/photos/{id}","poiLayerMinZoom":11,"detectRetina":false,"webApiKey":"ruregt3044","webApiVersion":"2.0","regionListFields":"items.bounds,items.zoom_level,items.time_zone,items.code,items.flags,items.country_code,items.domain,items.default_pos","firmInfoFields":"items.reviews,items.links,items.external_content","geoAdditionalFields":"items.geometry.selection,items.links,items.adm_div,items.address,items.floors,items.description","geoclickerCatalogApiKey":"ruregt3044","projectLeaveMaxZoom":13,"flampUrl":"http://flamp.ru/r/","flampGoogleAnalytics":"utm_source=api2gis&utm_medium=api&utm_campaign=geoclicker","gaCode":"UA-38243181-2","protocol":"https:","baseUrl":"//maps.api.2gis.ru/2.0","tileServer":"//tile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1","retinaTileServer":"//rtile{s}.maps.2gis.com/tiles?x={x}&y={y}&z={z}&v=1","trafficTileServer":"//traffic{s}.maps.2gis.com/{projectCode}/traffic/{z}/{x}/{y}/speed/{period}/{timestampString}","retinaTrafficTileServer":"//traffic{s}.maps.2gis.com/{projectCode}/traffic/{z}/{x}/{y}/speed/{period}/{timestampString}","trafficMetaServer":"//meta{s}.maps.2gis.com/{projectCode}/meta/{z}/{x}/{y}/graph_speed/{period}/{timestampString}","retinaTrafficMetaServer":"//meta{s}.maps.2gis.com/{projectCode}/meta/{z}/{x}/{y}/graph_speed/{period}/{timestampString}","trafficTimestampServer":"//traffic{s}.maps.2gis.com/{projectCode}/meta/speed/time/","trafficScoreServer":"//traffic{s}.maps.2gis.com/{projectCode}/meta/score/0/","poiMetaServer":"//tile{s}.maps.2gis.com/?x={x}&y={y}&z={z}&v=1&type=poi","retinaPoiMetaServer":"//rtile{s}.maps.2gis.com/?x={x}&y={y}&z={z}&v=1&type=poi","webApiServer":"//catalog.api.2gis.ru","analytics":"//maps.api.2gis.ru/analytics/track-user.png","googleAnalytics":"//www.google-analytics.com/analytics.js","loadProjectListTimeout":5000};_dereq_('../../../dist/css/styles.full.dark.css');


}).call(this,_dereq_('_process'))

},{"../../../dist/css/styles.full.dark.css":1,"../../../vendors/baron":9,"_process":4,"dustjs-helpers":5,"dustjs-linkedin":6,"html5shiv":7,"leaflet":8}],3:[function(_dereq_,module,exports){
'use strict';
// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.

var styleElementsInsertedAtTop = [];

var insertStyleElement = function(styleElement, options) {
    var head = document.head || document.getElementsByTagName('head')[0];
    var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];

    options = options || {};
    options.insertAt = options.insertAt || 'bottom';

    if (options.insertAt === 'top') {
        if (!lastStyleElementInsertedAtTop) {
            head.insertBefore(styleElement, head.firstChild);
        } else if (lastStyleElementInsertedAtTop.nextSibling) {
            head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
        } else {
            head.appendChild(styleElement);
        }
        styleElementsInsertedAtTop.push(styleElement);
    } else if (options.insertAt === 'bottom') {
        head.appendChild(styleElement);
    } else {
        throw new Error('Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.');
    }
};

module.exports = {
    // Create a <link> tag with optional data attributes
    createLink: function(href, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0];
        var link = document.createElement('link');

        link.href = href;
        link.rel = 'stylesheet';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            link.setAttribute('data-' + key, value);
        }

        head.appendChild(link);
    },
    // Create a <style> tag with optional data attributes
    createStyle: function(cssText, attributes, extraOptions) {
        extraOptions = extraOptions || {};

        var style = document.createElement('style');
        style.type = 'text/css';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            style.setAttribute('data-' + key, value);
        }

        if (style.sheet) { // for jsdom and IE9+
            style.innerHTML = cssText;
            style.sheet.cssText = cssText;
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
        } else if (style.styleSheet) { // for IE8 and below
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
            style.styleSheet.cssText = cssText;
        } else { // for Chrome, Firefox, and Safari
            style.appendChild(document.createTextNode(cssText));
            insertStyleElement(style, { insertAt: extraOptions.insertAt });
        }
    }
};

},{}],4:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(_dereq_,module,exports){
(function(root, factory) {
  if (typeof define === 'function' && define.amd && define.amd.dust === true) {
    define(['dust.core'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(_dereq_('dustjs-linkedin'));
  } else {
    factory(root.dust);
  }
}(this, function(dust) {

function log(helper, msg, level) {
  level = level || "INFO";
  helper = helper ? '{@' + helper + '}: ' : '';
  dust.log(helper + msg, level);
}

var _deprecatedCache = {};
function _deprecated(target) {
  if(_deprecatedCache[target]) { return; }
  log(target, "Deprecation warning: " + target + " is deprecated and will be removed in a future version of dustjs-helpers", "WARN");
  log(null, "For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#" + target.replace(/\W+/g, ""), "WARN");
  _deprecatedCache[target] = true;
}

function isSelect(context) {
  return context.stack.tail &&
         context.stack.tail.head &&
         typeof context.stack.tail.head.__select__ !== "undefined";
}

function getSelectState(context) {
  return isSelect(context) && context.get('__select__');
}

/**
 * Adds a special __select__ key behind the head of the context stack. Used to maintain the state
 * of {@select} blocks
 * @param context {Context} add state to this Context
 * @param opts {Object} add these properties to the state (`key` and `type`)
 */
function addSelectState(context, opts) {
  var head = context.stack.head,
      newContext = context.rebase(),
      key;

  if(context.stack && context.stack.tail) {
    newContext.stack = context.stack.tail;
  }

  var state = {
    isPending: false,
    isResolved: false,
    isDeferredComplete: false,
    deferreds: []
  };

  for(key in opts) {
    state[key] = opts[key];
  }

  return newContext
  .push({ "__select__": state })
  .push(head, context.stack.index, context.stack.of);
}

/**
 * After a {@select} or {@math} block is complete, they invoke this function
 */
function resolveSelectDeferreds(state) {
  var x, len;
  state.isDeferredPending = true;
  if(state.deferreds.length) {
    state.isDeferredComplete = true;
    for(x=0, len=state.deferreds.length; x<len; x++) {
      state.deferreds[x]();
    }
  }
  state.isDeferredPending = false;
}

/**
 * Used by {@contextDump}
 */
function jsonFilter(key, value) {
  if (typeof value === "function") {
    return value.toString()
      .replace(/(^\s+|\s+$)/mg, '')
      .replace(/\n/mg, '')
      .replace(/,\s*/mg, ', ')
      .replace(/\)\{/mg, ') {');
  }
  return value;
}

/**
 * Generate a truth test helper
 */
function truthTest(name, test) {
  return function(chunk, context, bodies, params) {
    return filter(chunk, context, bodies, params, name, test);
  };
}

/**
 * This function is invoked by truth test helpers
 */
function filter(chunk, context, bodies, params, helperName, test) {
  var body = bodies.block,
      skip = bodies['else'],
      selectState = getSelectState(context) || {},
      willResolve, key, value, type;

  // Once one truth test in a select passes, short-circuit the rest of the tests
  if (selectState.isResolved && !selectState.isDeferredPending) {
    return chunk;
  }

  // First check for a key on the helper itself, then look for a key on the {@select}
  if (params.hasOwnProperty('key')) {
    key = params.key;
  } else if (selectState.hasOwnProperty('key')) {
    key = selectState.key;
  } else {
    log(helperName, "No key specified", "WARN");
    return chunk;
  }

  type = params.type || selectState.type;

  key = coerce(context.resolve(key), type);
  value = coerce(context.resolve(params.value), type);

  if (test(key, value)) {
    // Once a truth test passes, put the select into "pending" state. Now we can render the body of
    // the truth test (which may contain truth tests) without altering the state of the select.
    if (!selectState.isPending) {
      willResolve = true;
      selectState.isPending = true;
    }
    if (body) {
      chunk = chunk.render(body, context);
    }
    if (willResolve) {
      selectState.isResolved = true;
    }
  } else if (skip) {
    chunk = chunk.render(skip, context);
  }
  return chunk;
}

function coerce(value, type) {
  if (type) {
    type = type.toLowerCase();
  }
  switch (type) {
    case 'number': return +value;
    case 'string': return String(value);
    case 'boolean':
      value = (value === 'false' ? false : value);
      return Boolean(value);
    case 'date': return new Date(value);
  }

  return value;
}

var helpers = {

  // Utility helping to resolve dust references in the given chunk
  // uses native Dust Context#resolve (available since Dust 2.6.2)
  "tap": function(input, chunk, context) {
    // deprecated for removal in 1.8
    _deprecated("tap");
    return context.resolve(input);
  },

  "sep": function(chunk, context, bodies) {
    var body = bodies.block;
    if (context.stack.index === context.stack.of - 1) {
      return chunk;
    }
    if (body) {
      return body(chunk, context);
    } else {
      return chunk;
    }
  },

  "first": function(chunk, context, bodies) {
    if (context.stack.index === 0) {
      return bodies.block(chunk, context);
    }
    return chunk;
  },

  "last": function(chunk, context, bodies) {
    if (context.stack.index === context.stack.of - 1) {
      return bodies.block(chunk, context);
    }
    return chunk;
  },

  /**
   * {@contextDump}
   * @param key {String} set to "full" to the full context stack, otherwise the current context is dumped
   * @param to {String} set to "console" to log to console, otherwise outputs to the chunk
   */
  "contextDump": function(chunk, context, bodies, params) {
    var to = context.resolve(params.to),
        key = context.resolve(params.key),
        target, output;
    switch(key) {
      case 'full':
        target = context.stack;
        break;
      default:
        target = context.stack.head;
    }
    output = JSON.stringify(target, jsonFilter, 2);
    switch(to) {
      case 'console':
        log('contextDump', output);
        break;
      default:
        output = output.replace(/</g, '\\u003c');
        chunk = chunk.write(output);
    }
    return chunk;
  },

  /**
   * {@math}
   * @param key first value
   * @param method {String} operation to perform
   * @param operand second value (not required for operations like `abs`)
   * @param round if truthy, round() the result
   */
  "math": function (chunk, context, bodies, params) {
    var key = params.key,
        method = params.method,
        operand = params.operand,
        round = params.round,
        output, state, x, len;

    if(!params.hasOwnProperty('key') || !params.method) {
      log("math", "`key` or `method` was not provided", "ERROR");
      return chunk;
    }

    key = parseFloat(context.resolve(key));
    operand = parseFloat(context.resolve(operand));

    switch(method) {
      case "mod":
        if(operand === 0) {
          log("math", "Division by 0", "ERROR");
        }
        output = key % operand;
        break;
      case "add":
        output = key + operand;
        break;
      case "subtract":
        output = key - operand;
        break;
      case "multiply":
        output = key * operand;
        break;
      case "divide":
        if(operand === 0) {
          log("math", "Division by 0", "ERROR");
        }
        output = key / operand;
        break;
      case "ceil":
      case "floor":
      case "round":
      case "abs":
        output = Math[method](key);
        break;
      case "toint":
        output = parseInt(key, 10);
        break;
      default:
        log("math", "Method `" + method + "` is not supported", "ERROR");
    }

    if (typeof output !== 'undefined') {
      if (round) {
        output = Math.round(output);
      }
      if (bodies && bodies.block) {
        context = addSelectState(context, { key: output });
        chunk = chunk.render(bodies.block, context);
        resolveSelectDeferreds(getSelectState(context));
      } else {
        chunk = chunk.write(output);
      }
    }

    return chunk;
  },

  /**
   * {@select}
   * Groups a set of truth tests and outputs the first one that passes.
   * Also contains {@any} and {@none} blocks.
   * @param key a value or reference to use as the left-hand side of comparisons
   * @param type coerce all truth test keys without an explicit type to this type
   */
  "select": function(chunk, context, bodies, params) {
    var body = bodies.block,
        state = {};

    if (params.hasOwnProperty('key')) {
      state.key = context.resolve(params.key);
    }
    if (params.hasOwnProperty('type')) {
      state.type = params.type;
    }

    if (body) {
      context = addSelectState(context, state);
      chunk = chunk.render(body, context);
      resolveSelectDeferreds(getSelectState(context));
    } else {
      log("select", "Missing body block", "WARN");
    }
    return chunk;
  },

  /**
   * Truth test helpers
   * @param key a value or reference to use as the left-hand side of comparisons
   * @param value a value or reference to use as the right-hand side of comparisons
   * @param type if specified, `key` and `value` will be forcibly cast to this type
   */
  "eq": truthTest('eq', function(left, right) {
    return left === right;
  }),
  "ne": truthTest('ne', function(left, right) {
    return left !== right;
  }),
  "lt": truthTest('lt', function(left, right) {
    return left < right;
  }),
  "lte": truthTest('lte', function(left, right) {
    return left <= right;
  }),
  "gt": truthTest('gt', function(left, right) {
    return left > right;
  }),
  "gte": truthTest('gte', function(left, right) {
    return left >= right;
  }),

  /**
   * {@any}
   * Outputs as long as at least one truth test inside a {@select} has passed.
   * Must be contained inside a {@select} block.
   * The passing truth test can be before or after the {@any} block.
   */
  "any": function(chunk, context, bodies, params) {
    var selectState = getSelectState(context);

    if(!selectState) {
      log("any", "Must be used inside a {@select} block", "ERROR");
    } else {
      if(selectState.isDeferredComplete) {
        log("any", "Must not be nested inside {@any} or {@none} block", "ERROR");
      } else {
        chunk = chunk.map(function(chunk) {
          selectState.deferreds.push(function() {
            if(selectState.isResolved) {
              chunk = chunk.render(bodies.block, context);
            }
            chunk.end();
          });
        });
      }
    }
    return chunk;
  },

  /**
   * {@none}
   * Outputs if no truth tests inside a {@select} pass.
   * Must be contained inside a {@select} block.
   * The position of the helper does not matter.
   */
  "none": function(chunk, context, bodies, params) {
    var selectState = getSelectState(context);

    if(!selectState) {
      log("none", "Must be used inside a {@select} block", "ERROR");
    } else {
      if(selectState.isDeferredComplete) {
        log("none", "Must not be nested inside {@any} or {@none} block", "ERROR");
      } else {
        chunk = chunk.map(function(chunk) {
          selectState.deferreds.push(function() {
            if(!selectState.isResolved) {
              chunk = chunk.render(bodies.block, context);
            }
            chunk.end();
          });
        });
      }
    }
    return chunk;
  },

  /**
  * {@size}
  * Write the size of the target to the chunk
  * Falsy values and true have size 0
  * Numbers are returned as-is
  * Arrays and Strings have size equal to their length
  * Objects have size equal to the number of keys they contain
  * Dust bodies are evaluated and the length of the string is returned
  * Functions are evaluated and the length of their return value is evaluated
  * @param key find the size of this value or reference
  */
  "size": function(chunk, context, bodies, params) {
    var key = params.key,
        value, k;

    key = context.resolve(params.key);
    if (!key || key === true) {
      value = 0;
    } else if(dust.isArray(key)) {
      value = key.length;
    } else if (!isNaN(parseFloat(key)) && isFinite(key)) {
      value = key;
    } else if (typeof key === "object") {
      value = 0;
      for(k in key){
        if(key.hasOwnProperty(k)){
          value++;
        }
      }
    } else {
      value = (key + '').length;
    }
    return chunk.write(value);
  }

};

for(var key in helpers) {
  dust.helpers[key] = helpers[key];
}

return dust;

}));

},{"dustjs-linkedin":6}],6:[function(_dereq_,module,exports){
(function (process){
(function (root, factory) {
  if (typeof define === 'function' && define.amd && define.amd.dust === true) {
    define('dust.core', [], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.dust = factory();
  }
}(this, function() {
  var dust = {
        "version": "2.7.2"
      },
      NONE = 'NONE', ERROR = 'ERROR', WARN = 'WARN', INFO = 'INFO', DEBUG = 'DEBUG',
      EMPTY_FUNC = function() {};

  dust.config = {
    whitespace: false,
    amd: false,
    cjs: false,
    cache: true
  };

  // Directive aliases to minify code
  dust._aliases = {
    "write": "w",
    "end": "e",
    "map": "m",
    "render": "r",
    "reference": "f",
    "section": "s",
    "exists": "x",
    "notexists": "nx",
    "block": "b",
    "partial": "p",
    "helper": "h"
  };

  (function initLogging() {
    /*global process, console*/
    var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },
        consoleLog,
        log;

    if (typeof console !== 'undefined' && console.log) {
      consoleLog = console.log;
      if(typeof consoleLog === 'function') {
        log = function() {
          consoleLog.apply(console, arguments);
        };
      } else {
        log = function() {
          consoleLog(Array.prototype.slice.apply(arguments).join(' '));
        };
      }
    } else {
      log = EMPTY_FUNC;
    }

    /**
     * Filters messages based on `dust.debugLevel`.
     * This default implementation will print to the console if it exists.
     * @param {String|Error} message the message to print/throw
     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)
     * @public
     */
    dust.log = function(message, type) {
      type = type || INFO;
      if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {
        log('[DUST:' + type + ']', message);
      }
    };

    dust.debugLevel = NONE;
    if(typeof process !== 'undefined' && process.env && /\bdust\b/.test(process.env.DEBUG)) {
      dust.debugLevel = DEBUG;
    }

  }());

  dust.helpers = {};

  dust.cache = {};

  dust.register = function(name, tmpl) {
    if (!name) {
      return;
    }
    tmpl.templateName = name;
    if (dust.config.cache !== false) {
      dust.cache[name] = tmpl;
    }
  };

  dust.render = function(nameOrTemplate, context, callback) {
    var chunk = new Stub(callback).head;
    try {
      load(nameOrTemplate, chunk, context).end();
    } catch (err) {
      chunk.setError(err);
    }
  };

  dust.stream = function(nameOrTemplate, context) {
    var stream = new Stream(),
        chunk = stream.head;
    dust.nextTick(function() {
      try {
        load(nameOrTemplate, chunk, context).end();
      } catch (err) {
        chunk.setError(err);
      }
    });
    return stream;
  };

  /**
   * Extracts a template function (body_0) from whatever is passed.
   * @param nameOrTemplate {*} Could be:
   *   - the name of a template to load from cache
   *   - a CommonJS-compiled template (a function with a `template` property)
   *   - a template function
   * @param loadFromCache {Boolean} if false, don't look in the cache
   * @return {Function} a template function, if found
   */
  function getTemplate(nameOrTemplate, loadFromCache/*=true*/) {
    if(!nameOrTemplate) {
      return;
    }
    if(typeof nameOrTemplate === 'function' && nameOrTemplate.template) {
      // Sugar away CommonJS module templates
      return nameOrTemplate.template;
    }
    if(dust.isTemplateFn(nameOrTemplate)) {
      // Template functions passed directly
      return nameOrTemplate;
    }
    if(loadFromCache !== false) {
      // Try loading a template with this name from cache
      return dust.cache[nameOrTemplate];
    }
  }

  function load(nameOrTemplate, chunk, context) {
    if(!nameOrTemplate) {
      return chunk.setError(new Error('No template or template name provided to render'));
    }

    var template = getTemplate(nameOrTemplate, dust.config.cache);

    if (template) {
      return template(chunk, Context.wrap(context, template.templateName));
    } else {
      if (dust.onLoad) {
        return chunk.map(function(chunk) {
          // Alias just so it's easier to read that this would always be a name
          var name = nameOrTemplate;
          // Three possible scenarios for a successful callback:
          //   - `require(nameOrTemplate)(dust); cb()`
          //   - `src = readFile('src.dust'); cb(null, src)`
          //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`
          function done(err, srcOrTemplate) {
            var template;
            if (err) {
              return chunk.setError(err);
            }
            // Prefer a template that is passed via callback over the cached version.
            template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);
            if (!template) {
              // It's a template string, compile it and register under `name`
              if(dust.compile) {
                template = dust.loadSource(dust.compile(srcOrTemplate, name));
              } else {
                return chunk.setError(new Error('Dust compiler not available'));
              }
            }
            template(chunk, Context.wrap(context, template.templateName)).end();
          }

          if(dust.onLoad.length === 3) {
            dust.onLoad(name, context.options, done);
          } else {
            dust.onLoad(name, done);
          }
        });
      }
      return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));
    }
  }

  dust.loadSource = function(source) {
    /*jshint evil:true*/
    return eval(source);
  };

  if (Array.isArray) {
    dust.isArray = Array.isArray;
  } else {
    dust.isArray = function(arr) {
      return Object.prototype.toString.call(arr) === '[object Array]';
    };
  }

  dust.nextTick = (function() {
    return function(callback) {
      setTimeout(callback, 0);
    };
  })();

  /**
   * Dust has its own rules for what is "empty"-- which is not the same as falsy.
   * Empty arrays, null, and undefined are empty
   */
  dust.isEmpty = function(value) {
    if (value === 0) {
      return false;
    }
    if (dust.isArray(value) && !value.length) {
      return true;
    }
    return !value;
  };

  dust.isEmptyObject = function(obj) {
    var key;
    if (obj === null) {
      return false;
    }
    if (obj === undefined) {
      return false;
    }
    if (obj.length > 0) {
      return false;
    }
    for (key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  };

  dust.isTemplateFn = function(elem) {
    return typeof elem === 'function' &&
           elem.__dustBody;
  };

  /**
   * Decide somewhat-naively if something is a Thenable.
   * @param elem {*} object to inspect
   * @return {Boolean} is `elem` a Thenable?
   */
  dust.isThenable = function(elem) {
    return elem &&
           typeof elem === 'object' &&
           typeof elem.then === 'function';
  };

  /**
   * Decide very naively if something is a Stream.
   * @param elem {*} object to inspect
   * @return {Boolean} is `elem` a Stream?
   */
  dust.isStreamable = function(elem) {
    return elem &&
           typeof elem.on === 'function' &&
           typeof elem.pipe === 'function';
  };

  // apply the filter chain and return the output string
  dust.filter = function(string, auto, filters, context) {
    var i, len, name, filter;
    if (filters) {
      for (i = 0, len = filters.length; i < len; i++) {
        name = filters[i];
        if (!name.length) {
          continue;
        }
        filter = dust.filters[name];
        if (name === 's') {
          auto = null;
        } else if (typeof filter === 'function') {
          string = filter(string, context);
        } else {
          dust.log('Invalid filter `' + name + '`', WARN);
        }
      }
    }
    // by default always apply the h filter, unless asked to unescape with |s
    if (auto) {
      string = dust.filters[auto](string, context);
    }
    return string;
  };

  dust.filters = {
    h: function(value) { return dust.escapeHtml(value); },
    j: function(value) { return dust.escapeJs(value); },
    u: encodeURI,
    uc: encodeURIComponent,
    js: function(value) { return dust.escapeJSON(value); },
    jp: function(value) {
      if (!JSON) {dust.log('JSON is undefined; could not parse `' + value + '`', WARN);
        return value;
      } else {
        return JSON.parse(value);
      }
    }
  };

  function Context(stack, global, options, blocks, templateName) {
    if(stack !== undefined && !(stack instanceof Stack)) {
      stack = new Stack(stack);
    }
    this.stack = stack;
    this.global = global;
    this.options = options;
    this.blocks = blocks;
    this.templateName = templateName;
  }

  dust.makeBase = dust.context = function(global, options) {
    return new Context(undefined, global, options);
  };

  /**
   * Factory function that creates a closure scope around a Thenable-callback.
   * Returns a function that can be passed to a Thenable that will resume a
   * Context lookup once the Thenable resolves with new data, adding that new
   * data to the lookup stack.
   */
  function getWithResolvedData(ctx, cur, down) {
    return function(data) {
      return ctx.push(data)._get(cur, down);
    };
  }

  Context.wrap = function(context, name) {
    if (context instanceof Context) {
      return context;
    }
    return new Context(context, {}, {}, null, name);
  };

  /**
   * Public API for getting a value from the context.
   * @method get
   * @param {string|array} path The path to the value. Supported formats are:
   * 'key'
   * 'path.to.key'
   * '.path.to.key'
   * ['path', 'to', 'key']
   * ['key']
   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the
   * current context (true), or if get should search in parent contexts as well (false).
   * @public
   * @returns {string|object}
   */
  Context.prototype.get = function(path, cur) {
    if (typeof path === 'string') {
      if (path[0] === '.') {
        cur = true;
        path = path.substr(1);
      }
      path = path.split('.');
    }
    return this._get(cur, path);
  };

  /**
   * Get a value from the context
   * @method _get
   * @param {boolean} cur Get only from the current context
   * @param {array} down An array of each step in the path
   * @private
   * @return {string | object}
   */
  Context.prototype._get = function(cur, down) {
    var ctx = this.stack || {},
        i = 1,
        value, first, len, ctxThis, fn;

    first = down[0];
    len = down.length;

    if (cur && len === 0) {
      ctxThis = ctx;
      ctx = ctx.head;
    } else {
      if (!cur) {
        // Search up the stack for the first value
        while (ctx) {
          if (ctx.isObject) {
            ctxThis = ctx.head;
            value = ctx.head[first];
            if (value !== undefined) {
              break;
            }
          }
          ctx = ctx.tail;
        }

        // Try looking in the global context if we haven't found anything yet
        if (value !== undefined) {
          ctx = value;
        } else {
          ctx = this.global && this.global[first];
        }
      } else if (ctx) {
        // if scope is limited by a leading dot, don't search up the tree
        if(ctx.head) {
          ctx = ctx.head[first];
        } else {
          // context's head is empty, value we are searching for is not defined
          ctx = undefined;
        }
      }

      while (ctx && i < len) {
        if (dust.isThenable(ctx)) {
          // Bail early by returning a Thenable for the remainder of the search tree
          return ctx.then(getWithResolvedData(this, cur, down.slice(i)));
        }
        ctxThis = ctx;
        ctx = ctx[down[i]];
        i++;
      }
    }

    if (typeof ctx === 'function') {
      fn = function() {
        try {
          return ctx.apply(ctxThis, arguments);
        } catch (err) {
          dust.log(err, ERROR);
          throw err;
        }
      };
      fn.__dustBody = !!ctx.__dustBody;
      return fn;
    } else {
      if (ctx === undefined) {
        dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);
      }
      return ctx;
    }
  };

  Context.prototype.getPath = function(cur, down) {
    return this._get(cur, down);
  };

  Context.prototype.push = function(head, idx, len) {
    if(head === undefined) {
      dust.log("Not pushing an undefined variable onto the context", INFO);
      return this;
    }
    return this.rebase(new Stack(head, this.stack, idx, len));
  };

  Context.prototype.pop = function() {
    var head = this.current();
    this.stack = this.stack && this.stack.tail;
    return head;
  };

  Context.prototype.rebase = function(head) {
    return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());
  };

  Context.prototype.clone = function() {
    var context = this.rebase();
    context.stack = this.stack;
    return context;
  };

  Context.prototype.current = function() {
    return this.stack && this.stack.head;
  };

  Context.prototype.getBlock = function(key) {
    var blocks, len, fn;

    if (typeof key === 'function') {
      key = key(new Chunk(), this).data.join('');
    }

    blocks = this.blocks;

    if (!blocks) {
      dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);
      return false;
    }

    len = blocks.length;
    while (len--) {
      fn = blocks[len][key];
      if (fn) {
        return fn;
      }
    }

    dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');
    return false;
  };

  Context.prototype.shiftBlocks = function(locals) {
    var blocks = this.blocks,
        newBlocks;

    if (locals) {
      if (!blocks) {
        newBlocks = [locals];
      } else {
        newBlocks = blocks.concat([locals]);
      }
      return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());
    }
    return this;
  };

  Context.prototype.resolve = function(body) {
    var chunk;

    if(typeof body !== 'function') {
      return body;
    }
    chunk = new Chunk().render(body, this);
    if(chunk instanceof Chunk) {
      return chunk.data.join(''); // ie7 perf
    }
    return chunk;
  };

  Context.prototype.getTemplateName = function() {
    return this.templateName;
  };

  function Stack(head, tail, idx, len) {
    this.tail = tail;
    this.isObject = head && typeof head === 'object';
    this.head = head;
    this.index = idx;
    this.of = len;
  }

  function Stub(callback) {
    this.head = new Chunk(this);
    this.callback = callback;
    this.out = '';
  }

  Stub.prototype.flush = function() {
    var chunk = this.head;

    while (chunk) {
      if (chunk.flushable) {
        this.out += chunk.data.join(''); //ie7 perf
      } else if (chunk.error) {
        this.callback(chunk.error);
        dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.callback(null, this.out);
  };

  /**
   * Creates an interface sort of like a Streams2 ReadableStream.
   */
  function Stream() {
    this.head = new Chunk(this);
  }

  Stream.prototype.flush = function() {
    var chunk = this.head;

    while(chunk) {
      if (chunk.flushable) {
        this.emit('data', chunk.data.join('')); //ie7 perf
      } else if (chunk.error) {
        this.emit('error', chunk.error);
        this.emit('end');
        dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);
        this.flush = EMPTY_FUNC;
        return;
      } else {
        return;
      }
      chunk = chunk.next;
      this.head = chunk;
    }
    this.emit('end');
  };

  /**
   * Executes listeners for `type` by passing data. Note that this is different from a
   * Node stream, which can pass an arbitrary number of arguments
   * @return `true` if event had listeners, `false` otherwise
   */
  Stream.prototype.emit = function(type, data) {
    var events = this.events || {},
        handlers = events[type] || [],
        i, l;

    if (!handlers.length) {
      dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);
      return false;
    }

    handlers = handlers.slice(0);
    for (i = 0, l = handlers.length; i < l; i++) {
      handlers[i](data);
    }
    return true;
  };

  Stream.prototype.on = function(type, callback) {
    var events = this.events = this.events || {},
        handlers = events[type] = events[type] || [];

    if(typeof callback !== 'function') {
      dust.log('No callback function provided for `' + type + '` event listener', WARN);
    } else {
      handlers.push(callback);
    }
    return this;
  };

  /**
   * Pipes to a WritableStream. Note that backpressure isn't implemented,
   * so we just write as fast as we can.
   * @param stream {WritableStream}
   * @return self
   */
  Stream.prototype.pipe = function(stream) {
    if(typeof stream.write !== 'function' ||
       typeof stream.end !== 'function') {
      dust.log('Incompatible stream passed to `pipe`', WARN);
      return this;
    }

    var destEnded = false;

    if(typeof stream.emit === 'function') {
      stream.emit('pipe', this);
    }

    if(typeof stream.on === 'function') {
      stream.on('error', function() {
        destEnded = true;
      });
    }

    return this
    .on('data', function(data) {
      if(destEnded) {
        return;
      }
      try {
        stream.write(data, 'utf8');
      } catch (err) {
        dust.log(err, ERROR);
      }
    })
    .on('end', function() {
      if(destEnded) {
        return;
      }
      try {
        stream.end();
        destEnded = true;
      } catch (err) {
        dust.log(err, ERROR);
      }
    });
  };

  function Chunk(root, next, taps) {
    this.root = root;
    this.next = next;
    this.data = []; //ie7 perf
    this.flushable = false;
    this.taps = taps;
  }

  Chunk.prototype.write = function(data) {
    var taps = this.taps;

    if (taps) {
      data = taps.go(data);
    }
    this.data.push(data);
    return this;
  };

  Chunk.prototype.end = function(data) {
    if (data) {
      this.write(data);
    }
    this.flushable = true;
    this.root.flush();
    return this;
  };

  Chunk.prototype.map = function(callback) {
    var cursor = new Chunk(this.root, this.next, this.taps),
        branch = new Chunk(this.root, cursor, this.taps);

    this.next = branch;
    this.flushable = true;
    try {
      callback(branch);
    } catch(err) {
      dust.log(err, ERROR);
      branch.setError(err);
    }
    return cursor;
  };

  Chunk.prototype.tap = function(tap) {
    var taps = this.taps;

    if (taps) {
      this.taps = taps.push(tap);
    } else {
      this.taps = new Tap(tap);
    }
    return this;
  };

  Chunk.prototype.untap = function() {
    this.taps = this.taps.tail;
    return this;
  };

  Chunk.prototype.render = function(body, context) {
    return body(this, context);
  };

  Chunk.prototype.reference = function(elem, context, auto, filters) {
    if (typeof elem === 'function') {
      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);
      if (elem instanceof Chunk) {
        return elem;
      } else {
        return this.reference(elem, context, auto, filters);
      }
    }
    if (dust.isThenable(elem)) {
      return this.await(elem, context, null, auto, filters);
    } else if (dust.isStreamable(elem)) {
      return this.stream(elem, context, null, auto, filters);
    } else if (!dust.isEmpty(elem)) {
      return this.write(dust.filter(elem, auto, filters, context));
    } else {
      return this;
    }
  };

  Chunk.prototype.section = function(elem, context, bodies, params) {
    var body = bodies.block,
        skip = bodies['else'],
        chunk = this,
        i, len, head;

    if (typeof elem === 'function' && !dust.isTemplateFn(elem)) {
      try {
        elem = elem.apply(context.current(), [this, context, bodies, params]);
      } catch(err) {
        dust.log(err, ERROR);
        return this.setError(err);
      }
      // Functions that return chunks are assumed to have handled the chunk manually.
      // Make that chunk the current one and go to the next method in the chain.
      if (elem instanceof Chunk) {
        return elem;
      }
    }

    if (dust.isEmptyObject(bodies)) {
      // No bodies to render, and we've already invoked any function that was available in
      // hopes of returning a Chunk.
      return chunk;
    }

    if (!dust.isEmptyObject(params)) {
      context = context.push(params);
    }

    /*
    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.
    When elem resolves to a value or object instead of an array, Dust sets the current context to the value
    and renders the block one time.
    */
    if (dust.isArray(elem)) {
      if (body) {
        len = elem.length;
        if (len > 0) {
          head = context.stack && context.stack.head || {};
          head.$len = len;
          for (i = 0; i < len; i++) {
            head.$idx = i;
            chunk = body(chunk, context.push(elem[i], i, len));
          }
          head.$idx = undefined;
          head.$len = undefined;
          return chunk;
        } else if (skip) {
          return skip(this, context);
        }
      }
    } else if (dust.isThenable(elem)) {
      return this.await(elem, context, bodies);
    } else if (dust.isStreamable(elem)) {
      return this.stream(elem, context, bodies);
    } else if (elem === true) {
     // true is truthy but does not change context
      if (body) {
        return body(this, context);
      }
    } else if (elem || elem === 0) {
       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )
       // zero is truthy
       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value
      if (body) {
        return body(this, context.push(elem));
      }
     // nonexistent, scalar false value, scalar empty string, null,
     // undefined are all falsy
    } else if (skip) {
      return skip(this, context);
    }
    dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);
    return this;
  };

  Chunk.prototype.exists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (!dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
      dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);
    } else if (skip) {
      return skip(this, context);
    }
    return this;
  };

  Chunk.prototype.notexists = function(elem, context, bodies) {
    var body = bodies.block,
        skip = bodies['else'];

    if (dust.isEmpty(elem)) {
      if (body) {
        return body(this, context);
      }
      dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);
    } else if (skip) {
      return skip(this, context);
    }
    return this;
  };

  Chunk.prototype.block = function(elem, context, bodies) {
    var body = elem || bodies.block;

    if (body) {
      return body(this, context);
    }
    return this;
  };

  Chunk.prototype.partial = function(elem, context, partialContext, params) {
    var head;

    if(params === undefined) {
      // Compatibility for < 2.7.0 where `partialContext` did not exist
      params = partialContext;
      partialContext = context;
    }

    if (!dust.isEmptyObject(params)) {
      partialContext = partialContext.clone();
      head = partialContext.pop();
      partialContext = partialContext.push(params)
                                     .push(head);
    }

    if (dust.isTemplateFn(elem)) {
      // The eventual result of evaluating `elem` is a partial name
      // Load the partial after getting its name and end the async chunk
      return this.capture(elem, context, function(name, chunk) {
        partialContext.templateName = name;
        load(name, chunk, partialContext).end();
      });
    } else {
      partialContext.templateName = elem;
      return load(elem, this, partialContext);
    }
  };

  Chunk.prototype.helper = function(name, context, bodies, params, auto) {
    var chunk = this,
        filters = params.filters,
        ret;

    // Pre-2.7.1 compat: if auto is undefined, it's an old template. Automatically escape
    if (auto === undefined) {
      auto = 'h';
    }

    // handle invalid helpers, similar to invalid filters
    if(dust.helpers[name]) {
      try {
        ret = dust.helpers[name](chunk, context, bodies, params);
        if (ret instanceof Chunk) {
          return ret;
        }
        if(typeof filters === 'string') {
          filters = filters.split('|');
        }
        if (!dust.isEmptyObject(bodies)) {
          return chunk.section(ret, context, bodies, params);
        }
        // Helpers act slightly differently from functions in context in that they will act as
        // a reference if they are self-closing (due to grammar limitations)
        // In the Chunk.await function we check to make sure bodies is null before acting as a reference
        return chunk.reference(ret, context, auto, filters);
      } catch(err) {
        dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);
        return chunk.setError(err);
      }
    } else {
      dust.log('Helper `' + name + '` does not exist', WARN);
      return chunk;
    }
  };

  /**
   * Reserve a chunk to be evaluated once a thenable is resolved or rejected
   * @param thenable {Thenable} the target thenable to await
   * @param context {Context} context to use to render the deferred chunk
   * @param bodies {Object} must contain a "body", may contain an "error"
   * @param auto {String} automatically apply this filter if the Thenable is a reference
   * @param filters {Array} apply these filters if the Thenable is a reference
   * @return {Chunk}
   */
  Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {
    return this.map(function(chunk) {
      thenable.then(function(data) {
        if (bodies) {
          chunk = chunk.section(data, context, bodies);
        } else {
          // Actually a reference. Self-closing sections don't render
          chunk = chunk.reference(data, context, auto, filters);
        }
        chunk.end();
      }, function(err) {
        var errorBody = bodies && bodies.error;
        if(errorBody) {
          chunk.render(errorBody, context.push(err)).end();
        } else {
          dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`', INFO);
          chunk.end();
        }
      });
    });
  };

  /**
   * Reserve a chunk to be evaluated with the contents of a streamable.
   * Currently an error event will bomb out the stream. Once an error
   * is received, we push it to an {:error} block if one exists, and log otherwise,
   * then stop listening to the stream.
   * @param streamable {Streamable} the target streamable that will emit events
   * @param context {Context} context to use to render each thunk
   * @param bodies {Object} must contain a "body", may contain an "error"
   * @return {Chunk}
   */
  Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {
    var body = bodies && bodies.block,
        errorBody = bodies && bodies.error;
    return this.map(function(chunk) {
      var ended = false;
      stream
        .on('data', function data(thunk) {
          if(ended) {
            return;
          }
          if(body) {
            // Fork a new chunk out of the blockstream so that we can flush it independently
            chunk = chunk.map(function(chunk) {
              chunk.render(body, context.push(thunk)).end();
            });
          } else if(!bodies) {
            // When actually a reference, don't fork, just write into the master async chunk
            chunk = chunk.reference(thunk, context, auto, filters);
          }
        })
        .on('error', function error(err) {
          if(ended) {
            return;
          }
          if(errorBody) {
            chunk.render(errorBody, context.push(err));
          } else {
            dust.log('Unhandled stream error in `' + context.getTemplateName() + '`', INFO);
          }
          if(!ended) {
            ended = true;
            chunk.end();
          }
        })
        .on('end', function end() {
          if(!ended) {
            ended = true;
            chunk.end();
          }
        });
    });
  };

  Chunk.prototype.capture = function(body, context, callback) {
    return this.map(function(chunk) {
      var stub = new Stub(function(err, out) {
        if (err) {
          chunk.setError(err);
        } else {
          callback(out, chunk);
        }
      });
      body(stub.head, context).end();
    });
  };

  Chunk.prototype.setError = function(err) {
    this.error = err;
    this.root.flush();
    return this;
  };

  // Chunk aliases
  for(var f in Chunk.prototype) {
    if(dust._aliases[f]) {
      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];
    }
  }

  function Tap(head, tail) {
    this.head = head;
    this.tail = tail;
  }

  Tap.prototype.push = function(tap) {
    return new Tap(tap, this);
  };

  Tap.prototype.go = function(value) {
    var tap = this;

    while(tap) {
      value = tap.head(value);
      tap = tap.tail;
    }
    return value;
  };

  var HCHARS = /[&<>"']/,
      AMP    = /&/g,
      LT     = /</g,
      GT     = />/g,
      QUOT   = /\"/g,
      SQUOT  = /\'/g;

  dust.escapeHtml = function(s) {
    if (typeof s === "string" || (s && typeof s.toString === "function")) {
      if (typeof s !== "string") {
        s = s.toString();
      }
      if (!HCHARS.test(s)) {
        return s;
      }
      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');
    }
    return s;
  };

  var BS = /\\/g,
      FS = /\//g,
      CR = /\r/g,
      LS = /\u2028/g,
      PS = /\u2029/g,
      NL = /\n/g,
      LF = /\f/g,
      SQ = /'/g,
      DQ = /"/g,
      TB = /\t/g;

  dust.escapeJs = function(s) {
    if (typeof s === 'string') {
      return s
        .replace(BS, '\\\\')
        .replace(FS, '\\/')
        .replace(DQ, '\\"')
        .replace(SQ, '\\\'')
        .replace(CR, '\\r')
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(NL, '\\n')
        .replace(LF, '\\f')
        .replace(TB, '\\t');
    }
    return s;
  };

  dust.escapeJSON = function(o) {
    if (!JSON) {
      dust.log('JSON is undefined; could not escape `' + o + '`', WARN);
      return o;
    } else {
      return JSON.stringify(o)
        .replace(LS, '\\u2028')
        .replace(PS, '\\u2029')
        .replace(LT, '\\u003c');
    }
  };

  return dust;

}));

}).call(this,_dereq_('_process'))

},{"_process":4}],7:[function(_dereq_,module,exports){
/**
* @preserve HTML5 Shiv 3.7.3 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
*/
;(function(window, document) {
/*jshint evil:true */
  /** version */
  var version = '3.7.3-pre';

  /** Preset options */
  var options = window.html5 || {};

  /** Used to skip problem elements */
  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

  /** Not all elements can be cloned in IE **/
  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

  /** Detect whether the browser supports default html5 styles */
  var supportsHtml5Styles;

  /** Name of the expando, to work with multiple documents or to re-shiv one document */
  var expando = '_html5shiv';

  /** The id for the the documents expando */
  var expanID = 0;

  /** Cached data for each document */
  var expandoData = {};

  /** Detect whether the browser supports unknown elements */
  var supportsUnknownElements;

  (function() {
    try {
        var a = document.createElement('a');
        a.innerHTML = '<xyz></xyz>';
        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
        supportsHtml5Styles = ('hidden' in a);

        supportsUnknownElements = a.childNodes.length == 1 || (function() {
          // assign a false positive if unable to shiv
          (document.createElement)('a');
          var frag = document.createDocumentFragment();
          return (
            typeof frag.cloneNode == 'undefined' ||
            typeof frag.createDocumentFragment == 'undefined' ||
            typeof frag.createElement == 'undefined'
          );
        }());
    } catch(e) {
      // assign a false positive if detection fails => unable to shiv
      supportsHtml5Styles = true;
      supportsUnknownElements = true;
    }

  }());

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a style sheet with the given CSS text and adds it to the document.
   * @private
   * @param {Document} ownerDocument The document.
   * @param {String} cssText The CSS text.
   * @returns {StyleSheet} The style element.
   */
  function addStyleSheet(ownerDocument, cssText) {
    var p = ownerDocument.createElement('p'),
        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

    p.innerHTML = 'x<style>' + cssText + '</style>';
    return parent.insertBefore(p.lastChild, parent.firstChild);
  }

  /**
   * Returns the value of `html5.elements` as an array.
   * @private
   * @returns {Array} An array of shived element node names.
   */
  function getElements() {
    var elements = html5.elements;
    return typeof elements == 'string' ? elements.split(' ') : elements;
  }

  /**
   * Extends the built-in list of html5 elements
   * @memberOf html5
   * @param {String|Array} newElements whitespace separated list or array of new element names to shiv
   * @param {Document} ownerDocument The context document.
   */
  function addElements(newElements, ownerDocument) {
    var elements = html5.elements;
    if(typeof elements != 'string'){
      elements = elements.join(' ');
    }
    if(typeof newElements != 'string'){
      newElements = newElements.join(' ');
    }
    html5.elements = elements +' '+ newElements;
    shivDocument(ownerDocument);
  }

   /**
   * Returns the data associated to the given document
   * @private
   * @param {Document} ownerDocument The document.
   * @returns {Object} An object of data.
   */
  function getExpandoData(ownerDocument) {
    var data = expandoData[ownerDocument[expando]];
    if (!data) {
        data = {};
        expanID++;
        ownerDocument[expando] = expanID;
        expandoData[expanID] = data;
    }
    return data;
  }

  /**
   * returns a shived element for the given nodeName and document
   * @memberOf html5
   * @param {String} nodeName name of the element
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived element.
   */
  function createElement(nodeName, ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createElement(nodeName);
    }
    if (!data) {
        data = getExpandoData(ownerDocument);
    }
    var node;

    if (data.cache[nodeName]) {
        node = data.cache[nodeName].cloneNode();
    } else if (saveClones.test(nodeName)) {
        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
    } else {
        node = data.createElem(nodeName);
    }

    // Avoid adding some elements to fragments in IE < 9 because
    // * Attributes like `name` or `type` cannot be set/changed once an element
    //   is inserted into a document/fragment
    // * Link elements with `src` attributes that are inaccessible, as with
    //   a 403 response, will cause the tab/window to crash
    // * Script elements appended to fragments will execute when their `src`
    //   or `text` property is set
    return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
  }

  /**
   * returns a shived DocumentFragment for the given document
   * @memberOf html5
   * @param {Document} ownerDocument The context document.
   * @returns {Object} The shived DocumentFragment.
   */
  function createDocumentFragment(ownerDocument, data){
    if (!ownerDocument) {
        ownerDocument = document;
    }
    if(supportsUnknownElements){
        return ownerDocument.createDocumentFragment();
    }
    data = data || getExpandoData(ownerDocument);
    var clone = data.frag.cloneNode(),
        i = 0,
        elems = getElements(),
        l = elems.length;
    for(;i<l;i++){
        clone.createElement(elems[i]);
    }
    return clone;
  }

  /**
   * Shivs the `createElement` and `createDocumentFragment` methods of the document.
   * @private
   * @param {Document|DocumentFragment} ownerDocument The document.
   * @param {Object} data of the document.
   */
  function shivMethods(ownerDocument, data) {
    if (!data.cache) {
        data.cache = {};
        data.createElem = ownerDocument.createElement;
        data.createFrag = ownerDocument.createDocumentFragment;
        data.frag = data.createFrag();
    }


    ownerDocument.createElement = function(nodeName) {
      //abort shiv
      if (!html5.shivMethods) {
          return data.createElem(nodeName);
      }
      return createElement(nodeName, ownerDocument, data);
    };

    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
      'var n=f.cloneNode(),c=n.createElement;' +
      'h.shivMethods&&(' +
        // unroll the `createElement` calls
        getElements().join().replace(/[\w\-:]+/g, function(nodeName) {
          data.createElem(nodeName);
          data.frag.createElement(nodeName);
          return 'c("' + nodeName + '")';
        }) +
      ');return n}'
    )(html5, data.frag);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Shivs the given document.
   * @memberOf html5
   * @param {Document} ownerDocument The document to shiv.
   * @returns {Document} The shived document.
   */
  function shivDocument(ownerDocument) {
    if (!ownerDocument) {
        ownerDocument = document;
    }
    var data = getExpandoData(ownerDocument);

    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
      data.hasCSS = !!addStyleSheet(ownerDocument,
        // corrects block display not defined in IE6/7/8/9
        'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
        // adds styling not present in IE6/7/8/9
        'mark{background:#FF0;color:#000}' +
        // hides non-rendered elements
        'template{display:none}'
      );
    }
    if (!supportsUnknownElements) {
      shivMethods(ownerDocument, data);
    }
    return ownerDocument;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The `html5` object is exposed so that more elements can be shived and
   * existing shiving can be detected on iframes.
   * @type Object
   * @example
   *
   * // options can be changed before the script is included
   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
   */
  var html5 = {

    /**
     * An array or space separated string of node names of the elements to shiv.
     * @memberOf html5
     * @type Array|String
     */
    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',

    /**
     * current version of html5shiv
     */
    'version': version,

    /**
     * A flag to indicate that the HTML5 style sheet should be inserted.
     * @memberOf html5
     * @type Boolean
     */
    'shivCSS': (options.shivCSS !== false),

    /**
     * Is equal to true if a browser supports creating unknown/HTML5 elements
     * @memberOf html5
     * @type boolean
     */
    'supportsUnknownElements': supportsUnknownElements,

    /**
     * A flag to indicate that the document's `createElement` and `createDocumentFragment`
     * methods should be overwritten.
     * @memberOf html5
     * @type Boolean
     */
    'shivMethods': (options.shivMethods !== false),

    /**
     * A string to describe the type of `html5` object ("default" or "default print").
     * @memberOf html5
     * @type String
     */
    'type': 'default',

    // shivs the document according to the specified `html5` object options
    'shivDocument': shivDocument,

    //creates a shived element
    createElement: createElement,

    //creates a shived documentFragment
    createDocumentFragment: createDocumentFragment,

    //extends list of elements
    addElements: addElements
  };

  /*--------------------------------------------------------------------------*/

  // expose html5
  window.html5 = html5;

  // shiv the document
  shivDocument(document);

  if(typeof module == 'object' && module.exports){
    module.exports = html5;
  }

}(typeof window !== "undefined" ? window : this, document));

},{}],8:[function(_dereq_,module,exports){

var L = {
	version: '1.0.1'
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed
if (typeof window !== 'undefined') {
	expose();
}

/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

L.Util = {

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	extend: function (dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// @function bind(fn: Function, …): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assiging it one if it doesn't have it.
	stamp: function (obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
		/*eslint-enable */
	},

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	lastId: 0,

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.bind` shortcut.
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	falseFn: function () { return false; },

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values — they will be evaluated passing `data` as an argument.
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_\-]+) *\}/g,

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	indexOf: function (array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	},

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	L.Util.requestAnimFrame = function (fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context));
		}
	};

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;


// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

L.Class = function () {};

L.Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
L.Class.include = function (props) {
	L.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */


L.Evented = L.Class.extend({

	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
		typeListeners.count++;
	},

	_off: function (type, fn, context) {
		var listeners,
		    i,
		    len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = L.Util.falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = L.Util.falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event might can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
proto.addEventListener = proto.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
proto.removeEventListener = proto.clearAllEventListeners = proto.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
proto.addOneTimeEventListener = proto.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
proto.fireEvent = proto.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,
	    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

	    win = navigator.platform.indexOf('Win') === 0,

	    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
	    pointer = window.PointerEvent || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera12 = 'OTransition' in doc.style;


	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {

		// @property ie: Boolean
		// `true` for all Internet Explorer versions (not Edge).
		ie: ie,

		// @property ielt9: Boolean
		// `true` for Internet Explorer versions less than 9.
		ielt9: ie && !document.addEventListener,

		// @property edge: Boolean
		// `true` for the Edge web browser.
		edge: 'msLaunchUri' in navigator && !('documentMode' in document),

		// @property webkit: Boolean
		// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
		webkit: webkit,

		// @property gecko: Boolean
		// `true` for gecko-based browsers like Firefox.
		gecko: gecko,

		// @property android: Boolean
		// `true` for any browser running on an Android platform.
		android: ua.indexOf('android') !== -1,

		// @property android23: Boolean
		// `true` for browsers running on Android 2 or Android 3.
		android23: android23,

		// @property chrome: Boolean
		// `true` for the Chrome browser.
		chrome: chrome,

		// @property safari: Boolean
		// `true` for the Safari browser.
		safari: !chrome && ua.indexOf('safari') !== -1,


		// @property win: Boolean
		// `true` when the browser is running in a Windows platform
		win: win,


		// @property ie3d: Boolean
		// `true` for all Internet Explorer versions supporting CSS transforms.
		ie3d: ie3d,

		// @property webkit3d: Boolean
		// `true` for webkit-based browsers supporting CSS transforms.
		webkit3d: webkit3d,

		// @property gecko3d: Boolean
		// `true` for gecko-based browsers supporting CSS transforms.
		gecko3d: gecko3d,

		// @property opera12: Boolean
		// `true` for the Opera browser supporting CSS transforms (version 12 or later).
		opera12: opera12,

		// @property any3d: Boolean
		// `true` for all browsers supporting CSS transforms.
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


		// @property mobile: Boolean
		// `true` for all browsers running in a mobile device.
		mobile: mobile,

		// @property mobileWebkit: Boolean
		// `true` for all webkit-based browsers in a mobile device.
		mobileWebkit: mobile && webkit,

		// @property mobileWebkit3d: Boolean
		// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
		mobileWebkit3d: mobile && webkit3d,

		// @property mobileOpera: Boolean
		// `true` for the Opera browser in a mobile device.
		mobileOpera: mobile && window.opera,

		// @property mobileGecko: Boolean
		// `true` for gecko-based browsers running in a mobile device.
		mobileGecko: mobile && gecko,


		// @property touch: Boolean
		// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
		touch: !!touch,

		// @property msPointer: Boolean
		// `true` for browsers implementing the Microsoft touch events model (notably IE10).
		msPointer: !!msPointer,

		// @property pointer: Boolean
		// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
		pointer: !!pointer,


		// @property retina: Boolean
		// `true` for browsers on a high-resolution "retina" screen.
		retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
	};

}());

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

L.Point = function (x, y, round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(L.point(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new L.Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new L.Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new L.Point(x.x, x.y);
	}
	return new L.Point(x, y, round);
};

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

L.Bounds = function (a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = L.point(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new L.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(topLeft: Point, bottomRight: Point)
// Creates a Bounds object from two coordinates (usually top-left and bottom-right corners).
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the points it contains
L.bounds = function (a, b) {
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = new L.Transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts real `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts real `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

L.DomUtil = {

	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	empty: function (el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	},

	// @function toFront(el: HTMLElement)
	// Makes `el` the last children of its parent, so it renders in front of the other children.
	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	// @function toBack(el: HTMLElement)
	// Makes `el` the first children of its parent, so it renders back from the other children.
	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {
			L.DomUtil._setOpacityIE(el, value);
		}
	},

	_setOpacityIE: function (el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	},

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0);

		el.style[L.DomUtil.TRANSFORM] =
			(L.Browser.ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	},

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

		/*eslint-disable */
		el._leaflet_pos = point;
		/*eslint-enable */

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new L.Point(0, 0);
	}
};


(function () {
	// prefix style property names

	// @property TRANSFORM: String
	// Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transform style name.
	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	L.DomUtil.preventOutline = function (element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element || !element.style) { return; }
		L.DomUtil.restoreOutline();
		this._outlineElement = element;
		this._outlineStyle = element.style.outline;
		element.style.outline = 'none';
		L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
	};

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	L.DomUtil.restoreOutline = function () {
		if (!this._outlineElement) { return; }
		this._outlineElement.style.outline = this._outlineStyle;
		delete this._outlineElement;
		delete this._outlineStyle;
		L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
})();

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return L.latLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new L.LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

L.latLng = function (a, b, c) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new L.LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b, c);
};

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var southWest = L.latLng(40.712, -74.227),
 * northEast = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(southWest, northEast);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
	equals: function (bounds) {
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(southWest: LatLng, northEast: LatLng)
// Creates a `LatLngBounds` object by defining south-west and north-east corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
L.latLngBounds = function (a, b) {
	if (a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:3395` and `Simple` CRS.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

L.Projection.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};

/*
 * @class CRS
 * @aka L.CRS
 * Abstract class that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

L.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return L.latLng(lat, lng, alt);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) +
		        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

L.Map = L.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: L.CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = undefined
		// Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
		minZoom: undefined,

		// @option maxZoom: Number = undefined
		// Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back when he tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom) {
		// replaced by animation-powered implementation in Map.PanAnimation.js
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), zoom);
		return this;
	},

	// @method setZoom(zoom: Number, options: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && (this.getZoom() > this.options.maxZoom)) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},


	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/*eslint-enable */
			this._containerId = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		for (var i in this._layers) {
			this._layers[i].remove();
		}

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a children of `container`, or
	// as a children of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);
		padding = L.point(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;

		var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return L.DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
		this._containerId = L.Util.stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		L.Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove) {
		if (!L.DomEvent) { return; }

		this._targets = {};
		this._targets[L.stamp(this._container)] = this;

		var onOff = remove ? 'off' : 'on';

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}

		if (L.Browser.any3d && this.options.transform3DLimit) {
			this[onOff]('moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[L.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && L.DomEvent._isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

		if (type === 'mousedown') {
			// prevents outline when clicking on keyboard-focusable element
			L.DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = L.Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			L.DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target instanceof L.Marker;
			data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = L.bounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
L.map = function (id, options) {
	return new L.Map(id, options);
};


/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


L.Layer = L.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',
		nonBubblingEvents: []  // Array of events that should not be bubbled to DOM parents (like the map)
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map): this
	 * Adds the layer to the given map
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[L.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[L.stamp(targetEl)];
		return this;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && this._map.attributionControl) {
			this._map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	}
});

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


L.GridLayer = L.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = depends
		// If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
		updateWhenIdle: L.Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
		attribution: null,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level that tiles will be loaded at. By default the entire map.
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level that tiles will be loaded at.
		maxZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof L.Point ? s : new L.Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (L.Browser.ielt9) { return; }

		L.DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			L.DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) { willPrune = true; }
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
			} else {
				L.DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			L.Util.falseFn(level.el.offsetWidth);
		}

		this._level = level;

		return level;
	},

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			L.DomUtil.remove(this._levels[z].el);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new L.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new L.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = Math.round(zoom);
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(level.el, translate, scale);
		} else {
			L.DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = map.getZoom();

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new L.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),

		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),

		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z);

		if (!this.options.noWrap) {
			nw = map.wrapLatLng(nw);
			se = map.wrapLatLng(se);
		}

		return new L.LatLngBounds(nw, se);
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new L.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		L.DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		L.DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
		}

		L.DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			L.DomUtil.setOpacity(tile.el, 0);
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (L.Browser.ielt9 || !this._map._fadeAnimated) {
				L.Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(L.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new L.Point(
			this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new L.Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
L.gridLayer = function (options) {
	return new L.GridLayer(options);
};

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add @2x to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


L.TileLayer = L.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// Minimum zoom number.
		minZoom: 0,

		// @option maxZoom: Number = 18
		// Maximum zoom number.
		maxZoom: 18,

		// @option maxNativeZoom: Number = null
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: null,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
		L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: L.Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return L.Util.template(this._url, L.extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (L.Browser.ielt9) {
			setTimeout(L.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	getTileSize: function () {
		var map = this._map,
		    tileSize = L.GridLayer.prototype.getTileSize.call(this),
		    zoom = this._tileZoom + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom;

		// increase tile size when overscaling
		return zoomN !== null && zoom > zoomN ?
				tileSize.divideBy(map.getZoomScale(zoomN, zoom)).round() :
				tileSize;
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._tileZoom;

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom !== null ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;

				if (!tile.complete) {
					tile.src = L.Util.emptyImageUrl;
					L.DomUtil.remove(tile);
				}
			}
		}
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

L.TileLayer.WMS = L.TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);

		return url +
			L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

L.ImageOverlay = L.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option attribution: String = null
		// An optional string containing HTML to be shown on the `Attribution control`
		attribution: null,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			L.DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	setBounds: function (bounds) {
		this._bounds = bounds;

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	getBounds: function () {
		return this._bounds;
	},

	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);

		L.DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};

/*
 * @class Icon
 * @aka L.Icon
 * @inherits Layer
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

L.Icon = L.Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = null
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	initialize: function (options) {
		L.setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = L.point(sizeOption),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
L.icon = function (options) {
	return new L.Icon(options);
};

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to change the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!L.Icon.Default.imagePath) {	// Deprecated, backwards-compatibility only
			L.Icon.Default.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `L.Icon.Default` will try to auto-detect the absolute location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right absolute path.
		return (this.options.imagePath || L.Icon.Default.imagePath) + L.Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = L.DomUtil.create('div',  'leaflet-default-icon-path', document.body);
		var path = L.DomUtil.getStyle(el, 'background-image') ||
		           L.DomUtil.getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		return path.indexOf('url') === 0 ?
			path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '') : '';
	}
});

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

L.Marker = L.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. If not specified, a new `L.Icon.Default` is used.
		icon: new L.Icon.Default(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// FIXME: shadowPane is no longer a valid option
		nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		L.DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (L.Handler.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new L.Handler.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

L.DivIcon = L.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = L.point(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
L.divIcon = function (options) {
	return new L.DivIcon(options);
};

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
L.DivOverlay = L.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
L.Popup = L.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when user clicks the map (set globally by
		// the Map's [closePopupOnClick](#map-closepopuponclick) option).
		autoClose: true,

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof L.Path)) {
				this._source.on('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof L.Path)) {
				this._source.off('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		L.DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

		var map = this._map,
		    marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(L.DomUtil.getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return L.point(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
L.popup = function (options, source) {
	return new L.Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
L.Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof L.Popup)) {
			popup = new L.Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
L.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return this._popup.isOpen();
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		L.DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof L.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});

/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor || [0, 0];
	}
});

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
L.Tooltip = L.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if (L.Browser.touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = L.DomUtil.create('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(L.point(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y));
		} else if (direction === 'bottom') {
			pos = pos.subtract(L.point(tooltipWidth / 2 - offset.x, -offset.y));
		} else if (direction === 'center') {
			pos = pos.subtract(L.point(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add([offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y]);
		} else {
			direction = 'left';
			pos = pos.subtract(L.point(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y));
		}

		L.DomUtil.removeClass(container, 'leaflet-tooltip-right');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-left');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-top');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		L.DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		L.DomUtil.setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return L.point(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
L.tooltip = function (options, source) {
	return new L.Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof L.Tooltip)) {
			tooltip = new L.Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
L.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof L.Tooltip) {
			L.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = L.tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove) {
		if (!remove && this._tooltipHandlersAdded) { return; }
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (L.Browser.touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/*
 * Tooltip extension to L.Marker, adding tooltip-related methods.
 */

L.Marker.include({
	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});


// @factory L.layerGroup(layers: Layer[])
// Create a layer group, optionally given an initial set of layers.
L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

L.Renderer = L.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = L.DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			L.DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});


L.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

L.Path = L.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
		this._renderer.on('update', this._update, this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
		this._renderer.off('update', this._update, this);
	},

	getEvents: function () {
		return {
			zoomend: this._project,
			viewreset: this._reset
		};
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in children classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	pointToSegmentDistance:  function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},


	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	clipSegment: function (a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = this._getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, round);
	},

	_getBitCode: function (p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[-122.68, 45.51],
 * 	[-122.43, 37.77],
 * 	[-118.2, 34.04]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[-122.68, 45.51],
 * 	 [-122.43, 37.77],
 * 	 [-118.2, 34.04]],
 * 	[[-73.91, 40.78],
 * 	 [-87.62, 41.83],
 * 	 [-96.72, 32.76]]
 * ];
 * ```
 */

L.Polyline = L.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = L.latLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = L.Polyline._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new L.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};

L.Polyline._flat = function (latlngs) {
	// true if it's a flat array of latlngs; false if nested
	return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

L.PolyUtil = {};

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
L.PolyUtil.clipPolygon = function (points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *   [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[-111.03, 41],[-111.04, 45],[-104.05, 45],[-104.05, 41]], // outer ring
 *     [[-108.58,37.29],[-108.58,40.71],[-102.50,40.71],[-102.50,37.29]] // hole
 *   ],
 *   [ // second polygon
 *     [[-109.05, 37],[-109.03, 41],[-102.05, 41],[-102.04, 37],[-109.05, 38]]
 *   ]
 * ];
 * ```
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		L.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (L.Polyline._flat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

L.CircleMarker = L.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = L.extend({}, legacyOptions, {radius: options});
		}
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
L.circle = function (latlng, options, legacyOptions) {
	return new L.Circle(latlng, options, legacyOptions);
};

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.SVG = L.Renderer.extend({

	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = L.SVG.create('g');
		this._container.appendChild(this._rootGroup);
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			L.DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		L.DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	}
});


// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:
L.extend(L.SVG, {
	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	create: function (name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	},

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
		    i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

// @namespace Browser; @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);


// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// @namespace Browser; @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._container);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._container);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.Canvas = L.Renderer.extend({

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		this._layers = this._layers || {};

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
			.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		this._drawnLayers = {};

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: L.Util.falseFn,

	_removePath: function (layer) {
		layer._removed = true;
		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		this._redrawBounds = layer._pxBounds;
		this._draw(true);
		layer._project();
		layer._update();
		this._draw();
		this._redrawBounds = null;
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		var padding = (layer.options.weight || 0) + 1;
		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
		this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));

		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_redraw: function () {
		this._redrawRequest = null;

		this._draw(true); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_draw: function (clear) {
		this._clear = clear;
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);
			this._ctx.clip();
		}

		for (var id in this._layers) {
			layer = this._layers[id];
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
			if (clear && layer._removed) {
				delete layer._removed;
				delete this._layers[id];
			}
		}
		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		if (ctx.setLineDash) {
			ctx.setLineDash(layer.options && layer.options._dashArray || []);
		}

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var clear = this._clear,
		    options = layer.options;

		ctx.globalCompositeOperation = clear ? 'destination-out' : 'source-over';

		if (options.fill) {
			ctx.globalAlpha = clear ? 1 : options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			ctx.globalAlpha = clear ? 1 : options.opacity;

			// if clearing shape, do it with the previously drawn line width
			layer._prevWeight = ctx.lineWidth = clear ? layer._prevWeight + 1 : options.weight;

			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layers = [], layer;

		for (var id in this._layers) {
			layer = this._layers[id];
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				L.DomEvent._fakeStop(e);
				layers.push(layer);
			}
		}
		if (layers.length)  {
			this._fireEvent(layers, e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseOut(e, point);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e, point) {
		var layer = this._hoveredLayer;
		if (layer && (e.type === 'mouseout' || !layer._containsPoint(point))) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var id, layer;

		for (id in this._drawnLayers) {
			layer = this._drawnLayers[id];
			if (layer.options.interactive && layer._containsPoint(point)) {
				L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([layer], e, 'mouseover');
				this._hoveredLayer = layer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	// TODO _bringToFront & _bringToBack, pretty tricky

	_bringToFront: L.Util.falseFn,
	_bringToBack: L.Util.falseFn
});

// @namespace Browser; @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @namespace Canvas
// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

L.GeoJSON = L.FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): Layer
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): Layer
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = L.Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): Layer
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:
L.extend(L.GeoJSON, {
	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	// @function latLngToCoords(latlng: LatLng): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	asFeature: function (geojson) {
		if (geojson.type === 'Feature') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
L.Polyline.prototype.toGeoJSON = function () {
	var multi = !L.Polyline._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
L.Polygon.prototype.toGeoJSON = function () {
	var holes = !L.Polyline._flat(this._latlngs),
	    multi = holes && !L.Polyline._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


// @namespace LayerGroup
L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `GeometryCollection`).
	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
L.geoJSON = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};
// Backward compatibility.
L.geoJson = L.geoJSON;

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.



var eventsKey = '_leaflet_events';

L.DomEvent = {

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function. If no function is specified,
	// it will remove all the listeners of that particular DOM event from the element.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.addPointerListener(obj, type, handler, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (L.DomEvent._isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel', L.DomEvent.stopPropagation);
	},

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	// @function stop(ev): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` or to the whole page if not specified.
	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	_wheelPxFactor: (L.Browser.win && L.Browser.chrome) ? 2 :
	                L.Browser.gecko ? window.devicePixelRatio :
	                1,

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	getWheelDelta: function (e) {
		return (L.Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / L.DomEvent._wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_isExternalTarget: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		handler(e);
	}
};

// @function addListener(…): this
// Alias to [`L.DomEvent.on`](#domevent-on)
L.DomEvent.addListener = L.DomEvent.on;

// @function removeListener(…): this
// Alias to [`L.DomEvent.off`](#domevent-off)
L.DomEvent.removeListener = L.DomEvent.off;

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

L.Draggable = L.Evented.extend({

	options: {
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline: Boolean)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches) || !this._enabled) { return; }
		L.Draggable._dragging = true;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			L.DomUtil.preventOutline(this._element);
		}

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);

		L.DomEvent
			.on(document, L.Draggable.MOVE[e.type], this._onMove, this)
			.on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		L.DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
				.off(document, L.Draggable.MOVE[i], this._onMove, this)
				.off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		L.Draggable._dragging = false;
	}
});

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !L.Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		L.DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-grab');
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDown: function () {
		this._map._stop();
	},

	_onDragStart: function () {
		var map = this._map;

		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = L.latLngBounds(this._map.options.maxBounds);

			this._offsetLimit = L.bounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

L.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

L.PosAnimation = L.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		L.DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});

/*
 * Extends L.Map to handle zoom animations.
 */

// @namespace Map
// @section Animation Options
L.Map.mergeOptions({
	// @option zoomAnimation: Boolean = true
	// Whether the map zoom animation is enabled. By default it's enabled
	// in all browsers that support CSS3 Transitions except Android.
	zoomAnimation: true,

	// @option zoomAnimationThreshold: Number = 4
	// Won't animate zoom if the zoom difference exceeds this value.
	zoomAnimationThreshold: 4
});

var zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera;

if (zoomAnimated) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {

			this._createAnimProxy();

			L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!zoomAnimated ? {} : {

	_createAnimProxy: function () {

		var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = L.DomUtil.TRANSFORM,
			    transform = proxy.style[prop];

			L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    ._moveStart(true)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		L.Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @namespace Map
// @section Methods for modifying map state
L.Map.include({

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !L.Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = L.latLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = L.Util.requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	}
});

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				count = L.DomEvent._pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd() {
			if (doubleTap && !touch.cancelBubble) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;
		obj[pre + 'dblclick' + id] = handler;

		obj.addEventListener(touchstart, onTouchStart, false);
		obj.addEventListener(touchend, onTouchEnd, false);

		// On some platforms (notably, chrome on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		if (!L.Browser.edge) {
			obj.addEventListener('dblclick', handler, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    touchstart = obj[pre + this._touchstart + id],
		    touchend = obj[pre + this._touchend + id],
		    dblclick = obj[pre + 'dblclick' + id];

		obj.removeEventListener(this._touchstart, touchstart, false);
		obj.removeEventListener(this._touchend, touchend, false);
		if (!L.Browser.edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}
});

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
	TAG_WHITE_LIST: ['INPUT', 'SELECT', 'OPTION'],

	_pointers: {},
	_pointersCount: 0,

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (this.TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					L.DomEvent.preventDefault(e);
				} else {
					return;
				}
			}

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!this._pointerDocListener) {
			var pointerUp = L.bind(this._globalPointerUp, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
			document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
			document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
			document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

			this._pointerDocListener = true;
		}
	},

	_globalPointerDown: function (e) {
		this._pointers[e.pointerId] = e;
		this._pointersCount++;
	},

	_globalPointerMove: function (e) {
		if (this._pointers[e.pointerId]) {
			this._pointers[e.pointerId] = e;
		}
	},

	_globalPointerUp: function (e) {
		delete this._pointers[e.pointerId];
		this._pointersCount--;
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: L.Browser.touch && !L.Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;


		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);

		var moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);

		L.DomEvent.preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_resetState: function () {
		this._moved = false;
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		this._resetState();

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		setTimeout(L.bind(this._resetState, this), 0);

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
L.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = L.point(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27) {
			map.closePopup();

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch).
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});

/*
 * @class Control
 * @aka L.Control
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

L.Control.Zoom = L.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '-'
		// The text set on the 'zoom out' button.
		zoomOutText: '-',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		L.DomEvent
		    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
		    .on(link, 'click', L.DomEvent.stop)
		    .on(link, 'click', fn, this)
		    .on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

L.Control.Attribution = L.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		if (L.DomEvent) {
			L.DomEvent.disableClickPropagation(this._container);
		}

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new L.Control.Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

L.Control.Scale = L.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
L.control.scale = function (options) {
	return new L.Control.Scale(options);
};

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control.html)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */


L.Control.Layers = L.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		return this._container;
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(L.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		L.DomEvent.disableClickPropagation(container);
		if (!L.Browser.touch) {
			L.DomEvent.disableScrollPropagation(container);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}

			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this.expand, this);
			} else {
				L.DomEvent.on(link, 'focus', this.expand, this);
			}

			// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this.collapse, this);
			// TODO keyboard accessibility
		} else {
			this.expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return this; }

		L.DomUtil.empty(this._baseLayersList);
		L.DomUtil.empty(this._overlaysList);

		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(L.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				addedLayers.push(layer);

			} else if (!input.checked && hasLayer) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			this._map.removeLayer(removedLayers[i]);
		}
		for (i = 0; i < addedLayers.length; i++) {
			this._map.addLayer(addedLayers[i]);
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};

/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

// @namespace Map

L.Map.include({
	// @section Geolocation methods
	_defaultLocateOptions: {
		timeout: 10000,
		watch: false
		// setView: false
		// maxZoom: <Number>
		// maximumAge: 0
		// enableHighAccuracy: false
	},

	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = L.extend({}, this._defaultLocateOptions, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
		    onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	}
});

},{}],9:[function(_dereq_,module,exports){
(function(window, undefined) {
    'use strict';

    if (!window) return; // Server side

var
    _baron = window.baron, // Stored baron value for noConflict usage
    $ = window.jQuery, // Trying to use jQuery
    origin = {
        v: { // Vertical
            x: 'Y', pos: 'top', crossPos: 'left', size: 'height', crossSize: 'width',
            client: 'clientHeight', crossClient: 'clientWidth', offset: 'offsetHeight', crossOffset: 'offsetWidth', offsetPos: 'offsetTop',
            scroll: 'scrollTop', scrollSize: 'scrollHeight'
        },
        h: { // Horizontal
            x: 'X', pos: 'left', crossPos: 'top', size: 'width', crossSize: 'height',
            client: 'clientWidth', crossClient: 'clientHeight', offset: 'offsetWidth', crossOffset: 'offsetHeight', offsetPos: 'offsetLeft',
            scroll: 'scrollLeft', scrollSize: 'scrollWidth'
        }
    },

    each = function(obj, iterator) {
        var i = 0;

        if (obj.length === undefined || obj === window) obj = [obj];

        while (obj[i]) {
            iterator.call(this, obj[i], i);
            i++;
        }
    },

    baron = function(params) { // this - window or jQuery instance
        var jQueryMode = false,//(this && this[0] && this[0].nodeType),
            roots,
            $;

        params = params || {};
        $ = params.$ || window.jQuery;

        if (jQueryMode) {
            params.root = roots = this;
        } else {
            roots = $(params.root || params.scroller);
        }

        return new baron.fn.constructor(roots, params, $);
    };

    baron.fn = {
        constructor: function(roots, input, $) {
            var params = validate(input);

            params.$ = $;
            each.call(this, roots, function(root, i) {
                var localParams = clone(params);

                if (params.root && params.scroller) {
                    localParams.scroller = params.$(params.scroller, root);
                    if (!localParams.scroller.length) {
                        localParams.scroller = root;
                    }
                } else {
                    localParams.scroller = root;
                }

                localParams.root = root;
                this[i] = init(localParams);
                this.length = i + 1;
            });

            this.params = params;
        },

        dispose: function() {
            var params = this.params;

            each(this, function(item) {
                item.dispose(params);
            });
            this.params = null;
        },

        update: function() {
            var i = 0;

            while (this[i]) {
                this[i].update.apply(this[i], arguments);
                i++;
            }
        },

        baron: function(params) {
            params.root = [];
            params.scroller = this.params.scroller;

            each.call(this, this, function(elem) {
                params.root.push(elem.root);
            });
            params.direction = (this.params.direction == 'v') ? 'h' : 'v';
            params._chain = true;

            return baron(params);
        }
    };

    function manageEvents(item, eventManager, mode) {
        item._eventHandlers = item._eventHandlers || [ // Creating new functions for one baron item only one time
            {
                // onScroll:
                element: item.scroller,

                handler: function(e) {
                    item.scroll(e);
                },

                type: 'scroll'
            }, {
                // onMouseDown:
                element: item.bar,

                handler: function(e) {
                    e.preventDefault ? e.preventDefault() : e.returnValue = false; // Text selection disabling in Opera... and all other browsers?
                    item.selection(); // Disable text selection in ie8
                    item.drag.now = 1; // Save private byte
                },

                type: 'touchstart mousedown'
            }, {
                // onMouseUp:
                element: document,

                handler: function() {
                    item.selection(1); // Enable text selection
                    item.drag.now = 0;
                },

                type: 'mouseup blur touchend'
            }, {
                // onCoordinateReset:
                element: item.bar,

                handler: function(e) {
                    if (e.button != 2) { // Not RM
                        item._pos0(e);
                    }
                },

                type: 'touchstart mousedown'
            }, {
                // onMouseMove:
                element: document,

                handler: function(e) {
                    if (item.drag.now) {
                        item.drag(e);
                    }
                },

                type: 'mousemove touchmove'
            }, {
                // onResize:
                element: window,

                handler: function() {
                    item.update();
                },

                type: 'resize'
            }, {
                // sizeChange:
                element: item.root,

                handler: function() {
                    item.update();
                },

                type: 'sizeChange'
            }
        ];

        each(item._eventHandlers, function(event) {
            if (event.element) {
                eventManager(event.element, event.type, event.handler, mode);
            }
        });

        // if (item.scroller) {
        //     event(item.scroller, 'scroll', item._eventHandlers.onScroll, mode);
        // }
        // if (item.bar) {
        //     event(item.bar, 'touchstart mousedown', item._eventHandlers.onMouseDown, mode);
        // }
        // event(document, 'mouseup blur touchend', item._eventHandlers.onMouseUp, mode);
        // event(document, 'touchstart mousedown', item._eventHandlers.onCoordinateReset, mode);
        // event(document, 'mousemove touchmove', item._eventHandlers.onMouseMove, mode);
        // event(window, 'resize', item._eventHandlers.onResize, mode);
        // if (item.root) {
        //     event(item.root, 'sizeChange', item._eventHandlers.onResize, mode); // Custon event for alternate baron update mechanism
        // }
    }

    function manageAttr(node, direction, mode) {
        var attrName = 'data-baron-' + direction;

        if (mode == 'on') {
            node.setAttribute(attrName, 'inited');
        } else if (mode == 'off') {
            node.removeAttribute(attrName);
        } else {
            return node.getAttribute(attrName);
        }
    }

    function init(params) {
        if (manageAttr(params.root, params.direction)) return;

        var out = new item.prototype.constructor(params); // __proto__ of returning object is baron.prototype

        manageEvents(out, params.event, 'on');

        manageAttr(out.root, params.direction, 'on');

        out.update();

        return out;
    }

    function clone(input) {
        var output = {};

        input = input || {};

        for (var key in input) {
            if (input.hasOwnProperty(key)) {
                output[key] = input[key];
            }
        }

        return output;
    }

    function validate(input) {
        var output = clone(input);

        output.direction = output.direction || 'v';

        var event = input.event || function(elem, event, func, mode) {
            output.$(elem)[mode || 'on'](event, func);
        };

        output.event = function(elems, e, func, mode) {
            each(elems, function(elem) {
                event(elem, e, func, mode);
            });
        };

        return output;
    }

    function fire(eventName) {
        /* jshint validthis:true */
        if (this.events && this.events[eventName]) {
            for (var i = 0 ; i < this.events[eventName].length ; i++) {
                var args = Array.prototype.slice.call( arguments, 1 );

                this.events[eventName][i].apply(this, args);
            }
        }
    }

    var item = {};

    item.prototype = {
        constructor: function(params) {
            var $,
                barPos,
                scrollerPos0,
                track,
                resizePauseTimer,
                scrollPauseTimer,
                pause,
                scrollLastFire,
                resizeLastFire;

            resizeLastFire = scrollLastFire = new Date().getTime();

            $ = this.$ = params.$;
            this.event = params.event;
            this.events = {};

            function getNode(sel, context) {
                return $(sel, context)[0]; // Can be undefined
            }

            // DOM elements
            this.root = params.root; // Always html node, not just selector
            this.scroller = getNode(params.scroller); // (params.scroller) ? getNode(params.scroller, this.root) : this.root;
            this.bar = getNode(params.bar, this.root);
            track = this.track = getNode(params.track, this.root);
            if (!this.track && this.bar) {
                track = this.bar.parentNode;
            }
            this.clipper = this.scroller.parentNode;

            // Parameters
            this.direction = params.direction;
            this.origin = origin[this.direction];
            this.barOnCls = params.barOnCls;
            this.barTopLimit = 0;
            pause = params.pause * 1000 || 0;

            // Updating height or width of bar
            function setBarSize(size) {
                /* jshint validthis:true */
                var barMinSize = this.barMinSize || 20;

                if (size > 0 && size < barMinSize) {
                    size = barMinSize;
                }

                if (this.bar) {
                    $(this.bar).css(this.origin.size, parseInt(size, 10) + 'px');
                }
            }

            // Updating top or left bar position
            function posBar(pos) {
                /* jshint validthis:true */
                if (this.bar) {
                    $(this.bar).css(this.origin.pos, +pos + 'px');
                }
            }

            // Free path for bar
            function k() {
                /* jshint validthis:true */
                return track[this.origin.client] - this.barTopLimit - this.bar[this.origin.offset];
            }

            // Relative content top position to bar top position
            function relToPos(r) {
                /* jshint validthis:true */
                return r * k.call(this) + this.barTopLimit;
            }

            // Bar position to relative content position
            function posToRel(t) {
                /* jshint validthis:true */
                return (t - this.barTopLimit) / k.call(this);
            }

            // Cursor position in main direction in px // Now with iOs support
            this.cursor = function(e) {
                return e['client' + this.origin.x] || (((e.originalEvent || e).touches || {})[0] || {})['page' + this.origin.x];
            };

            // Text selection pos preventing
            function dontPosSelect() {
                return false;
            }

            this.pos = function(x) { // Absolute scroller position in px
                var ie = 'page' + this.origin.x + 'Offset',
                    key = (this.scroller[ie]) ? ie : this.origin.scroll;

                if (x !== undefined) this.scroller[key] = x;

                return this.scroller[key];
            };

            this.rpos = function(r) { // Relative scroller position (0..1)
                var free = this.scroller[this.origin.scrollSize] - this.scroller[this.origin.client],
                    x;

                if (r) x = this.pos(r * free);
                else x = this.pos();

                return x / (free || 1);
            };

            // Switch on the bar by adding user-defined CSS classname to scroller
            this.barOn = function(dispose) {
                if (this.barOnCls) {
                    if (dispose || this.scroller[this.origin.client] >= this.scroller[this.origin.scrollSize]) {
                        $(this.root).removeClass(this.barOnCls);
                    } else {
                        $(this.root).addClass(this.barOnCls);
                    }
                }
            };

            this._pos0 = function(e) {
                scrollerPos0 = this.cursor(e) - barPos;
            };

            this.drag = function(e) {
                this.scroller[this.origin.scroll] = posToRel.call(this, this.cursor(e) - scrollerPos0) * (this.scroller[this.origin.scrollSize] - this.scroller[this.origin.client]);
            };

            // Text selection preventing on drag
            this.selection = function(enable) {
                this.event(document, 'selectpos selectstart', dontPosSelect, enable ? 'off' : 'on');
            };

            // onResize & DOM modified handler
            this.resize = function() {
                var self = this,
                    delay = 0;

                if (new Date().getTime() - resizeLastFire < pause) {
                    clearTimeout(resizePauseTimer);
                    delay = pause;
                }

                function upd() {
                    var delta = self.scroller[self.origin.crossOffset] - self.scroller[self.origin.crossClient];

                    if (params.freeze && !self.clipper.style[self.origin.crossSize]) { // Sould fire only once
                        $(self.clipper).css(self.origin.crossSize, self.clipper[self.origin.crossClient] - delta + 'px');
                    }
                    $(self.scroller).css(self.origin.crossSize, self.clipper[self.origin.crossClient] + delta + 'px');

                    Array.prototype.unshift.call(arguments, 'resize');
                    fire.apply(self, arguments);

                    resizeLastFire = new Date().getTime();
                }

                if (delay) {
                    resizePauseTimer = setTimeout(upd, delay);
                } else {
                    upd();
                }
            };

            // onScroll handler
            this.scroll = function() {
                var oldBarSize, newBarSize,
                    delay = 0,
                    self = this;

                if (new Date().getTime() - scrollLastFire < pause) {
                    clearTimeout(scrollPauseTimer);
                    delay = pause;
                }

                function upd() {
                    if (self.bar) {
                        newBarSize = (track[self.origin.client] - self.barTopLimit) * self.scroller[self.origin.client] / self.scroller[self.origin.scrollSize];

                        // Positioning bar
                        if (oldBarSize != newBarSize) {
                            setBarSize.call(self, newBarSize);
                            oldBarSize = newBarSize;
                        }

                        barPos = relToPos.call(self, self.rpos());

                        posBar.call(self, barPos);
                    }

                    Array.prototype.unshift.call( arguments, 'scroll' );
                    fire.apply(self, arguments);

                    scrollLastFire = new Date().getTime();
                }

                if (delay) {
                    scrollPauseTimer = setTimeout(upd, delay);
                } else {
                    upd();
                }

            };

            return this;
        },

        update: function(params) {
            fire.call(this, 'upd', params); // Обновляем параметры всех плагинов

            this.resize(1);
            this.barOn();
            this.scroll();

            return this;
        },

        dispose: function(params) {
            manageEvents(this, this.event, 'off');
            manageAttr(this.root, params.direction, 'off');
            $(this.scroller).css(this.origin.crossSize, '');
            this.barOn(true);
            fire.call(this, 'dispose');
        },

        on: function(eventName, func, arg) {
            var names = eventName.split(' ');

            for (var i = 0 ; i < names.length ; i++) {
                if (names[i] == 'init') {
                    func.call(this, arg);
                } else {
                    this.events[names[i]] = this.events[names[i]] || [];

                    this.events[names[i]].push(function(userArg) {
                        func.call(this, userArg || arg);
                    });
                }
            }
        }
    };

    baron.fn.constructor.prototype = baron.fn;
    item.prototype.constructor.prototype = item.prototype;

    // Use when you need "baron" global var for another purposes
    baron.noConflict = function() {
        window.baron = _baron; // Restoring original value of "baron" global var
        return baron;
    };

    baron.version = '0.6.6';

    if ($ && $.fn) { // Adding baron to jQuery as plugin
        $.fn.baron = baron;
    }
    window.baron = baron; // Use noConflict method if you need window.baron var for another purposes

    var fix = function(userParams) {
        var elements, viewPortSize,
            params = { // Default params
                outside: '',
                before: '',
                after: '',
                past: '',
                future: '',
                radius: 0,
                minView: 0
            },
            topFixHeights = [], // inline style for element
            topRealHeights = [], // real offset position when not fixed
            headerTops = [],
            scroller = this.scroller,
            eventManager = this.event,
            $ = this.$,
            self = this;

        function fixElement(i, pos) {
            if (viewPortSize < (params.minView || 0)) { // No headers fixing when no enought space for viewport
                pos = undefined;
            }

            if (pos !== undefined) {
                pos += 'px';
                this.$(elements[i]).css(this.origin.pos, pos).addClass(params.outside);
            } else {
                this.$(elements[i]).css(this.origin.pos, '').removeClass(params.outside);
            }
        }

        function bubbleWheel(e) {
            try {
                i = document.createEvent('WheelEvent'); // i - for extra byte
                // evt.initWebKitWheelEvent(deltaX, deltaY, window, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
                i.initWebKitWheelEvent(e.originalEvent.wheelDeltaX, e.originalEvent.wheelDeltaY);
                scroller.dispatchEvent(i);
                e.preventDefault();
            } catch (e) {}
        }

        function init(_params) {
            var pos;

            for (var key in _params) {
                params[key] = _params[key];
            }

            elements = this.$(params.elements, this.scroller);

            if (elements) {
                viewPortSize = this.scroller[this.origin.client];
                for (var i = 0 ; i < elements.length ; i++) {
                    // Variable header heights
                    pos = {};
                    pos[this.origin.size] = elements[i][this.origin.offset];
                    if (elements[i].parentNode !== this.scroller) {
                        this.$(elements[i].parentNode).css(pos);
                    }
                    pos = {};
                    pos[this.origin.crossSize] = elements[i].parentNode[this.origin.crossClient];
                    this.$(elements[i]).css(pos);

                    // Between fixed headers
                    viewPortSize -= elements[i][this.origin.offset];

                    headerTops[i] = elements[i].parentNode[this.origin.offsetPos]; // No paddings for parentNode

                    // Summary elements height above current
                    topFixHeights[i] = (topFixHeights[i - 1] || 0); // Not zero because of negative margins
                    topRealHeights[i] = (topRealHeights[i - 1] || Math.min(headerTops[i], 0));

                    if (elements[i - 1]) {
                        topFixHeights[i] += elements[i - 1][this.origin.offset];
                        topRealHeights[i] += elements[i - 1][this.origin.offset];
                    }

                    if ( !(i == 0 && headerTops[i] == 0)/* && force */) {
                        this.event(elements[i], 'mousewheel', bubbleWheel, 'off');
                        this.event(elements[i], 'mousewheel', bubbleWheel);
                    }
                }

                if (params.limiter && elements[0]) { // Bottom edge of first header as top limit for track
                    if (this.track && this.track != this.scroller) {
                        pos = {};
                        pos[this.origin.pos] = elements[0].parentNode[this.origin.offset];
                        this.$(this.track).css(pos);
                    } else {
                        this.barTopLimit = elements[0].parentNode[this.origin.offset];
                    }
                    // this.barTopLimit = elements[0].parentNode[this.origin.offset];
                    this.scroll();
                }

                if (params.limiter === false) { // undefined (in second fix instance) should have no influence on bar limit
                    this.barTopLimit = 0;
                }
            }

            var event = {
                element: elements,

                handler: function() {
                    var parent = $(this)[0].parentNode,
                        top = parent.offsetTop,
                        num;

                    // finding num -> elements[num] === this
                    for (var i = 0 ; i < elements.length ; i++ ) {
                        if (elements[i] === this) num = i;
                    }

                    var pos = top - topFixHeights[num];

                    if (params.scroll) { // User defined callback
                        params.scroll({
                            x1: self.scroller.scrollTop,
                            x2: pos
                        });
                    } else {
                        self.scroller.scrollTop = pos;
                    }
                },

                type: 'click'
            };

            if (params.clickable) {
                this._eventHandlers.push(event); // For auto-dispose
                eventManager(event.element, event.type, event.handler, 'off');
                eventManager(event.element, event.type, event.handler, 'on');
            }
        }

        this.on('init', init, userParams);

        this.on('init scroll', function() {
            var fixState, hTop,
                fixFlag = []; // 1 - past, 2 - future, 3 - current (not fixed)

            if (elements) {
                var change;

                // fixFlag update
                for (var i = 0 ; i < elements.length ; i++) {
                    fixState = 0;
                    if (headerTops[i] - this.pos() < topRealHeights[i] + params.radius) {
                        // Header trying to go up
                        fixState = 1;
                        hTop = topFixHeights[i];
                    } else if (headerTops[i] - this.pos() > topRealHeights[i] + viewPortSize - params.radius) {
                        // Header trying to go down
                        fixState = 2;
                        hTop = topFixHeights[i] + viewPortSize;
                    } else {
                        // Header in viewport
                        fixState = 3;
                        hTop = undefined;
                    }
                    if (fixState != fixFlag[i]) {
                        fixElement.call(this, i, hTop);
                        fixFlag[i] = fixState;
                        change = true;
                    }
                }

                // Adding positioning classes (on last top and first bottom header)
                if (change) { // At leats one change in elements flag structure occured
                    for (i = 0 ; i < elements.length ; i++) {
                        if (fixFlag[i] == 1 && params.past) {
                            this.$(elements[i]).addClass(params.past).removeClass(params.future);
                        }

                        if (fixFlag[i] == 2 && params.future) {
                            this.$(elements[i]).addClass(params.future).removeClass(params.past);
                        }

                        if (fixFlag[i] == 3 && (params.future || params.past)) {
                            this.$(elements[i]).removeClass(params.past).removeClass(params.future);
                        }

                        if (fixFlag[i] != fixFlag[i + 1] && fixFlag[i] == 1 && params.before) {
                            this.$(elements[i]).addClass(params.before).removeClass(params.after); // Last top fixed header
                        } else if (fixFlag[i] != fixFlag[i - 1] && fixFlag[i] == 2 && params.after) {
                            this.$(elements[i]).addClass(params.after).removeClass(params.before); // First bottom fixed header
                        } else {
                            this.$(elements[i]).removeClass(params.before).removeClass(params.after);
                        }
                    }
                }
            }
        });

        this.on('resize upd', function(updParams) {
            init.call(this, updParams && updParams.fix);
        });
    };

    baron.fn.fix = function(params) {
        var i = 0;

        while (this[i]) {
            fix.call(this[i], params);
            i++;
        }

        return this;
    };

    var controls = function(params) {
        var forward, backward, track, screen,
            self = this; // AAAAAA!!!!!11

        screen = params.screen || 0.9;

        if (params.forward) {
            forward = this.$(params.forward, this.clipper);

            this.event(forward, 'click', function() {
                var y = self.pos() - params.delta || 30;

                self.pos(y);
            });
        }

        if (params.backward) {
            backward = this.$(params.backward, this.clipper);

            this.event(backward, 'click', function() {
                var y = self.pos() + params.delta || 30;

                self.pos(y);
            });
        }

        if (params.track) {
            if (params.track === true) {
                track = this.track;
            } else {
                track = this.$(params.track, this.clipper)[0];
            }

            if (track) {
                this.event(track, 'mousedown', function(e) {
                    var x = e['offset' + self.origin.x],
                        xBar = self.bar[self.origin.offsetPos],
                        sign = 0;

                    if (x < xBar) {
                        sign = -1;
                    } else if (x > xBar + self.bar[self.origin.offset]) {
                        sign = 1;
                    }

                    var y = self.pos() + sign * screen * self.scroller[self.origin.client];
                    self.pos(y);
                });
            }
        }

    };

    baron.fn.controls = function(params) {
        var i = 0;

        while (this[i]) {
            controls.call(this[i], params);
            i++;
        }

        return this;
    };

    var pull = function(params) {
        var block = this.$(params.block),
            size = params.size || this.origin.size,
            limit = params.limit || 80,
            onExpand = params.onExpand,
            elements = params.elements || [],
            inProgress = params.inProgress || '',
            self = this,
            _insistence = 0,
            _zeroXCount = 0,
            _interval,
            _timer,
            _x = 0,
            _onExpandCalled,
            _waiting = params.waiting || 500,
            _on;

        function getSize() {
            return self.scroller[self.origin.scroll] + self.scroller[self.origin.offset];
        }

        // Scroller content height
        function getContentSize() {
            return self.scroller[self.origin.scrollSize];
        }

        // Scroller height
        function getScrollerSize() {
            return self.scroller[self.origin.client];
        }

        function step(x, force) {
            var k = x * 0.0005;

            return Math.floor(force - k * (x + 550));
        }

        function toggle(on) {
            _on = on;

            if (on) {
                update(); // First time with no delay
                _interval = setInterval(update, 200);
            } else {
                clearInterval(_interval);
            }
        }

        function update() {
            var pos = {},
                height = getSize(),
                scrollHeight = getContentSize(),
                dx,
                op4,
                scrollInProgress = _insistence == 1;

            op4 = 0; // Возвращающая сила
            if (_insistence > 0) {
                op4 = 40;
            }
            //if (_insistence > -1) {
                dx = step(_x, op4);
                if (height >= scrollHeight - _x && _insistence > -1) {
                    if (scrollInProgress) {
                        _x += dx;
                    }
                } else {
                    _x = 0;
                }

                if (_x < 0) _x = 0;

                pos[size] = _x + 'px';
                if (getScrollerSize() <= getContentSize()) {
                    self.$(block).css(pos);
                    for (var i = 0 ; i < elements.length ; i++) {
                        self.$(elements[i].self).css(elements[i].property, Math.min(_x / limit * 100, 100) + '%');
                    }
                }

                if (inProgress && _x) {
                    self.$(self.root).addClass(inProgress);
                }

                if (_x == 0) {
                    if (params.onCollapse) {
                        params.onCollapse();
                    }
                }

                _insistence = 0;
                _timer = setTimeout(function() {
                    _insistence = -1;
                }, _waiting);
            //}

            if (onExpand && _x > limit && !_onExpandCalled) {
                onExpand();
                _onExpandCalled = true;
            }

            if (_x == 0) {
                _zeroXCount++;
            } else {
                _zeroXCount = 0;

            }
            if (_zeroXCount > 1) {
                toggle(false);
                _onExpandCalled = false;
                if (inProgress) {
                    self.$(self.root).removeClass(inProgress);
                }
            }
        }

        this.on('init', function() {
            toggle(true);
        });

        this.on('dispose', function() {
            toggle(false);
        });

        this.event(this.scroller, 'mousewheel DOMMouseScroll', function(e) {
            var down = e.wheelDelta < 0 || (e.originalEvent && e.originalEvent.wheelDelta < 0) || e.detail > 0;

            if (down) {
                _insistence = 1;
                clearTimeout(_timer);
                if (!_on && getSize() >= getContentSize()) {
                    toggle(true);
                }
            }
            //  else {
            //     toggle(false);
            // }
        });
    };

    baron.fn.pull = function(params) {
        var i = 0;

        while (this[i]) {
            pull.call(this[i], params);
            i++;
        }

        return this;
    };
})(window);

},{}]},{},[2])(2)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2Nzcy9zdHlsZXMuZnVsbC5kYXJrLmNzcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvcG9seWZpbGxzL2VzNS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvcG9seWZpbGxzL3Byb21pc2UuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER0NvcmUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER3RoZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDb3JlL3NyYy9ER3BsdWdpbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0FqYXgvc3JjL0RHQWpheC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1drdC9ER1drdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1Byb2plY3REZXRlY3Rvci9zcmMvREdQcm9qZWN0RGV0ZWN0b3IuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdNZXRyaWMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdWZXJ0ZXhUcmFuc2Zvcm0uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBcnJvd1BhdGhUcmFuc2Zvcm0uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBcnJvd1RpcFRyYW5zZm9ybS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0VudHJhbmNlL3NyYy9ER0NvbXBsZXhQYXRoLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHRW50cmFuY2Uvc3JjL0RHUmVuZGVyZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdCZXppZXJDdXJ2ZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdBbmltYXRpb24uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdFbnRyYW5jZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0VudHJhbmNlL3NyYy9ER0VudHJhbmNlQXJyb3cuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdFbnRyYW5jZS9zcmMvREdFbnRyYW5jZUFycm93U2hhcGUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMYWJlbC9zcmMvREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xhYmVsL3NyYy9NYXJrZXIuREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xhYmVsL3NyYy9QYXRoLkRHTGFiZWwuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMYWJlbC9zcmMvRW50cmFuY2UuREdMYWJlbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1BvcHVwL3NraW4vYmFzaWMvc2tpbi5jb25maWcuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdQb3B1cC9zcmMvREdQb3B1cC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xvY2FsZS9zcmMvREdEaWN0aW9uYXJ5LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYWxlL3NyYy9ER0xvY2FsZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1JvdW5kQ29udHJvbC9zcmMvREdSb3VuZENvbnRyb2wuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NraW4vYmFzaWMvc2tpbi5jb25maWcuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER0N1c3RvbWl6YXRpb24uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER01hcC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0N1c3RvbWl6YXRpb24vc3JjL0RHTWFwLkJhc2VMYXllci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0N1c3RvbWl6YXRpb24vc3JjL0RHTWFwLlRpbGVzQ2hlY2suanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdDdXN0b21pemF0aW9uL3NyYy9ER01hcC5EcmFnLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQ3VzdG9taXphdGlvbi9zcmMvREdQb2x5VXRpbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1pvb21Db250cm9sL3NyYy9ER1pvb21Db250cm9sLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHWm9vbUNvbnRyb2wvbGFuZy9ydS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1pvb21Db250cm9sL2xhbmcvaXQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdab29tQ29udHJvbC9sYW5nL2NzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHWm9vbUNvbnRyb2wvbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1pvb21Db250cm9sL2xhbmcvZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdEdXN0L3NyYy9ER0R1c3QuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdBdHRyaWJ1dGlvbi9zcmMvREdBdHRyaWJ1dGlvbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0F0dHJpYnV0aW9uL2xhbmcvcnUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdBdHRyaWJ1dGlvbi9sYW5nL2l0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHQXR0cmlidXRpb24vbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0F0dHJpYnV0aW9uL2xhbmcvZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdBdHRyaWJ1dGlvbi9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vc3JjL0RHTG9jYXRpb24uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMb2NhdGlvbi9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0xvY2F0aW9uL2xhbmcvY3MuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdMb2NhdGlvbi9sYW5nL2VuLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHTG9jYXRpb24vbGFuZy9lcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vc3JjL0RHU2NyZWVuZnVsbC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vc3JjL0RHRnVsbFNjcmVlbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9ydS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0Z1bGxTY3JlZW4vbGFuZy9lcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER01ldGEvc3JjL0RHTWV0YS5MYXllci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER01ldGEvc3JjL0RHTWV0YS5PcmlnaW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdQb2kvc3JjL0RHUG9pLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvREdHZW9jbGlja2VyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvQ2xhbXBIZWxwZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9wcm92aWRlci9Qcm92aWRlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL3Byb3ZpZGVyL0NhdGFsb2dBcGkuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0hhbmRsZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0RlZmF1bHQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0FwaUVycm9yLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvaGFuZGxlci9DaXR5QXJlYS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvSG91c2UuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL0hvdXNlLlZpZXcuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9oYW5kbGVyL1BPSS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvc3JjL2hhbmRsZXIvU2lnaHQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdHZW9jbGlja2VyL3NyYy9WaWV3LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHR2VvY2xpY2tlci9zcmMvQ29udHJvbGxlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9ydS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER0dlb2NsaWNrZXIvbGFuZy9lcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvZmlybWNhcmQvc3JjL0Zpcm1DYXJkLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvdmVuZG9ycy9maXJtY2FyZC9zcmMvRmlybUNhcmQuRGF0YUhlbHBlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3ZlbmRvcnMvZmlybWNhcmQvc3JjL0Zpcm1MaXN0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvdmVuZG9ycy9maXJtY2FyZC9zcmMvU2NoZWR1bGUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy92ZW5kb3JzL2Zpcm1jYXJkL3NyYy9EaWN0aW9uYXJ5LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9zcmMvREdUcmFmZmljLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL2l0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL2NzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpYy9sYW5nL2VuLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpY0NvbnRyb2wvc3JjL0NvbnRyb2wuVHJhZmZpYy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWNDb250cm9sL2xhbmcvcnUuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdUcmFmZmljQ29udHJvbC9sYW5nL2l0LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHVHJhZmZpY0NvbnRyb2wvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1RyYWZmaWNDb250cm9sL2xhbmcvZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdUcmFmZmljQ29udHJvbC9sYW5nL2VuLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvc3JjL1J1bGVyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvc3JjL0xheWVyZWRNYXJrZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9zcmMvR2VvbWV0cnlTdHlsZXMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvbGFuZy9pdC5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyL2xhbmcvY3MuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlci9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXIvbGFuZy9lbi5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9zcmMvQ29udHJvbC5SdWxlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9sYW5nL3J1LmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXJDb250cm9sL2xhbmcvaXQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zcmMvREdSdWxlckNvbnRyb2wvbGFuZy9jcy5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3NyYy9ER1J1bGVyQ29udHJvbC9sYW5nL2VzLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvc3JjL0RHUnVsZXJDb250cm9sL2xhbmcvZW4uanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9jb3B5cmlnaHQuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9jaXR5YXJlYS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1DYXJkQWRkci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1DYXJkQ29udGFjdHMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9maXJtQ2FyZEhlYWRlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1DYXJkUnVicmljLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvZmlybUNhcmRTY2hlZHVsZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2Zpcm1saXN0SXRlbS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2ZyaW1DYXJkUGF5bWVudHMuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9ob3VzZS5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL2xvYWRlci5qcyIsImd1bHAvdG1wL2pzL2d1bHAvdG1wL2pzL3BvcHVwRm9vdGVyLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvcG9wdXBGb290ZXJCdG5zLmpzIiwiZ3VscC90bXAvanMvZ3VscC90bXAvanMvcG9wdXBIZWFkZXIuanMiLCJndWxwL3RtcC9qcy9ndWxwL3RtcC9qcy9zaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kdXN0anMtaGVscGVycy9saWIvZHVzdC1oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2R1c3Rqcy1saW5rZWRpbi9saWIvZHVzdC5qcyIsIm5vZGVfbW9kdWxlcy9odG1sNXNoaXYvZGlzdC9odG1sNXNoaXYuanMiLCJub2RlX21vZHVsZXMvbGVhZmxldC9kaXN0L2xlYWZsZXQtc3JjLmpzIiwidmVuZG9ycy9iYXJvbi9iYXJvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JGQTtBQUNBO0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN0tBO0FBQ0E7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BPQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdEZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTtBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FDSEE7QUFDQTtBQUNBO0FDRkE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbG5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgY3NzID0gXCIubGVhZmxldC1pbWFnZS1sYXllciwubGVhZmxldC1sYXllciwubGVhZmxldC1tYXAtcGFuZSBjYW52YXMsLmxlYWZsZXQtbWFwLXBhbmUgc3ZnLC5sZWFmbGV0LW1hcmtlci1pY29uLC5sZWFmbGV0LW1hcmtlci1zaGFkb3csLmxlYWZsZXQtcGFuZSwubGVhZmxldC10aWxlLC5sZWFmbGV0LXRpbGUtY29udGFpbmVyLC5sZWFmbGV0LXpvb20tYm94e3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MH0ubGVhZmxldC1jb250YWluZXJ7b3ZlcmZsb3c6aGlkZGVufS5sZWFmbGV0LW1hcmtlci1pY29uLC5sZWFmbGV0LW1hcmtlci1zaGFkb3csLmxlYWZsZXQtdGlsZXstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC11c2VyLWRyYWc6bm9uZX0ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZXtpbWFnZS1yZW5kZXJpbmc6LXdlYmtpdC1vcHRpbWl6ZS1jb250cmFzdH0ubGVhZmxldC1zYWZhcmkgLmxlYWZsZXQtdGlsZS1jb250YWluZXJ7d2lkdGg6MTYwMHB4O2hlaWdodDoxNjAwcHg7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjAgMH0ubGVhZmxldC1tYXJrZXItaWNvbiwubGVhZmxldC1tYXJrZXItc2hhZG93e2Rpc3BsYXk6YmxvY2t9LmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LW1hcmtlci1wYW5lIGltZywubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2ZywubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtdGlsZS1wYW5lIGltZywubGVhZmxldC1jb250YWluZXIgaW1nLmxlYWZsZXQtaW1hZ2UtbGF5ZXJ7bWF4LXdpZHRoOm5vbmUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lci5sZWFmbGV0LXRvdWNoLXpvb217LW1zLXRvdWNoLWFjdGlvbjpwYW4teCBwYW4teTt0b3VjaC1hY3Rpb246cGFuLXggcGFuLXl9LmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZ3stbXMtdG91Y2gtYWN0aW9uOnBpbmNoLXpvb219LmxlYWZsZXQtY29udGFpbmVyLmxlYWZsZXQtdG91Y2gtZHJhZy5sZWFmbGV0LXRvdWNoLWRyYWd7LW1zLXRvdWNoLWFjdGlvbjpub25lO3RvdWNoLWFjdGlvbjpub25lfS5sZWFmbGV0LXRpbGV7LXdlYmtpdC1maWx0ZXI6aW5oZXJpdDtmaWx0ZXI6aW5oZXJpdDt2aXNpYmlsaXR5OmhpZGRlbn0ubGVhZmxldC10aWxlLWxvYWRlZHt2aXNpYmlsaXR5OmluaGVyaXR9LmxlYWZsZXQtem9vbS1ib3h7d2lkdGg6MDtoZWlnaHQ6MDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ei1pbmRleDo4MDB9LmxlYWZsZXQtb3ZlcmxheS1wYW5lIHN2Z3stbW96LXVzZXItc2VsZWN0Om5vbmV9LmxlYWZsZXQtcGFuZXt6LWluZGV4OjQwMH0ubGVhZmxldC10aWxlLXBhbmV7ei1pbmRleDoyMDB9LmxlYWZsZXQtb3ZlcmxheS1wYW5le3otaW5kZXg6NDAwfS5sZWFmbGV0LXNoYWRvdy1wYW5le3otaW5kZXg6NTAwfS5sZWFmbGV0LW1hcmtlci1wYW5le3otaW5kZXg6NjAwfS5sZWFmbGV0LXRvb2x0aXAtcGFuZXt6LWluZGV4OjY1MH0ubGVhZmxldC1wb3B1cC1wYW5le3otaW5kZXg6NzAwfS5sZWFmbGV0LW1hcC1wYW5lIGNhbnZhc3t6LWluZGV4OjEwMH0ubGVhZmxldC1tYXAtcGFuZSBzdmd7ei1pbmRleDoyMDB9LmxlYWZsZXQtdm1sLXNoYXBle3dpZHRoOjFweDtoZWlnaHQ6MXB4fS5sdm1se2JlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlfS5sZWFmbGV0LWNvbnRyb2x7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDo4MDA7cG9pbnRlci1ldmVudHM6dmlzaWJsZVBhaW50ZWQ7cG9pbnRlci1ldmVudHM6YXV0b30ubGVhZmxldC1ib3R0b20sLmxlYWZsZXQtdG9we3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTAwMDtwb2ludGVyLWV2ZW50czpub25lfS5sZWFmbGV0LXRvcHt0b3A6MH0ubGVhZmxldC1yaWdodHtyaWdodDowfS5sZWFmbGV0LWJvdHRvbXtib3R0b206MH0ubGVhZmxldC1sZWZ0e2xlZnQ6MH0ubGVhZmxldC1jb250cm9se2Zsb2F0OmxlZnQ7Y2xlYXI6Ym90aH0ubGVhZmxldC1yaWdodCAubGVhZmxldC1jb250cm9se2Zsb2F0OnJpZ2h0fS5sZWFmbGV0LXRvcCAubGVhZmxldC1jb250cm9se21hcmdpbi10b3A6MTBweH0ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbHttYXJnaW4tYm90dG9tOjEwcHh9LmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9se21hcmdpbi1sZWZ0OjEwcHh9LmxlYWZsZXQtcmlnaHQgLmxlYWZsZXQtY29udHJvbHttYXJnaW4tcmlnaHQ6MTBweH0ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtdGlsZXt3aWxsLWNoYW5nZTpvcGFjaXR5fS5sZWFmbGV0LWZhZGUtYW5pbSAubGVhZmxldC1wb3B1cHtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjJzIGxpbmVhcn0ubGVhZmxldC1mYWRlLWFuaW0gLmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXB7b3BhY2l0eToxfS5sZWFmbGV0LXpvb20tYW5pbWF0ZWR7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjAgMDstbXMtdHJhbnNmb3JtLW9yaWdpbjowIDA7dHJhbnNmb3JtLW9yaWdpbjowIDB9LmxlYWZsZXQtem9vbS1hbmltIC5sZWFmbGV0LXpvb20tYW5pbWF0ZWR7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtOy13ZWJraXQtdHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuMjVzIGN1YmljLWJlemllcigwLDAsLjI1LDEpO3RyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjI1cyBjdWJpYy1iZXppZXIoMCwwLC4yNSwxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMjVzIGN1YmljLWJlemllcigwLDAsLjI1LDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIC4yNXMgY3ViaWMtYmV6aWVyKDAsMCwuMjUsMSksLXdlYmtpdC10cmFuc2Zvcm0gLjI1cyBjdWJpYy1iZXppZXIoMCwwLC4yNSwxKX0ubGVhZmxldC1wYW4tYW5pbSAubGVhZmxldC10aWxlLC5sZWFmbGV0LXpvb20tYW5pbSAubGVhZmxldC10aWxley13ZWJraXQtdHJhbnNpdGlvbjpub25lO3RyYW5zaXRpb246bm9uZX0ubGVhZmxldC16b29tLWFuaW0gLmxlYWZsZXQtem9vbS1oaWRle3Zpc2liaWxpdHk6aGlkZGVufS5sZWFmbGV0LWludGVyYWN0aXZle2N1cnNvcjpwb2ludGVyfS5sZWFmbGV0LWdyYWJ7Y3Vyc29yOi13ZWJraXQtZ3JhYjtjdXJzb3I6LW1vei1ncmFifS5sZWFmbGV0LWNyb3NzaGFpciwubGVhZmxldC1jcm9zc2hhaXIgLmxlYWZsZXQtaW50ZXJhY3RpdmV7Y3Vyc29yOmNyb3NzaGFpcn0ubGVhZmxldC1jb250cm9sLC5sZWFmbGV0LXBvcHVwLXBhbmV7Y3Vyc29yOmF1dG99LmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtZ3JhYiwubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1ncmFiIC5sZWFmbGV0LWludGVyYWN0aXZlLC5sZWFmbGV0LWRyYWdnaW5nIC5sZWFmbGV0LW1hcmtlci1kcmFnZ2FibGV7Y3Vyc29yOm1vdmU7Y3Vyc29yOi13ZWJraXQtZ3JhYmJpbmc7Y3Vyc29yOi1tb3otZ3JhYmJpbmd9LmxlYWZsZXQtaW1hZ2UtbGF5ZXIsLmxlYWZsZXQtbWFya2VyLWljb24sLmxlYWZsZXQtbWFya2VyLXNoYWRvdywubGVhZmxldC1wYW5lPnN2ZyBwYXRoLC5sZWFmbGV0LXRpbGUtY29udGFpbmVye3BvaW50ZXItZXZlbnRzOm5vbmV9LmxlYWZsZXQtaW1hZ2UtbGF5ZXIubGVhZmxldC1pbnRlcmFjdGl2ZSwubGVhZmxldC1tYXJrZXItaWNvbi5sZWFmbGV0LWludGVyYWN0aXZlLC5sZWFmbGV0LXBhbmU+c3ZnIHBhdGgubGVhZmxldC1pbnRlcmFjdGl2ZXtwb2ludGVyLWV2ZW50czp2aXNpYmxlUGFpbnRlZDtwb2ludGVyLWV2ZW50czphdXRvfS5sZWFmbGV0LWNvbnRhaW5lcntvdXRsaW5lOjB9LmxlYWZsZXQtY29udGFpbmVyIGF7Y29sb3I6IzAwNzhBOH0ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LWFjdGl2ZXtvdXRsaW5lOm9yYW5nZSBzb2xpZCAycHh9LmxlYWZsZXQtem9vbS1ib3h7Ym9yZGVyOjJweCBkb3R0ZWQgIzM4ZjtiYWNrZ3JvdW5kOnJnYmEoMjU1LDI1NSwyNTUsLjUpfS5sZWFmbGV0LWNvbnRhaW5lcntmb250OjEycHgvMS41IFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsQXJpYWwsSGVsdmV0aWNhLHNhbnMtc2VyaWZ9LmxlYWZsZXQtYmFyey13ZWJraXQtYm94LXNoYWRvdzowIDFweCA1cHggcmdiYSgwLDAsMCwuNjUpO2JveC1zaGFkb3c6MCAxcHggNXB4IHJnYmEoMCwwLDAsLjY1KTtib3JkZXItcmFkaXVzOjRweH0ubGVhZmxldC1iYXIgYSwubGVhZmxldC1iYXIgYTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2NjYzt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2xpbmUtaGVpZ2h0OjI2cHg7ZGlzcGxheTpibG9jazt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjojMDAwfS5sZWFmbGV0LWJhciBhLC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZXtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJSA1MCU7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2Rpc3BsYXk6YmxvY2t9LmxlYWZsZXQtYmFyIGE6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZjRmNGY0fS5sZWFmbGV0LWJhciBhOmZpcnN0LWNoaWxke2JvcmRlci10b3AtbGVmdC1yYWRpdXM6NHB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjRweH0ubGVhZmxldC1iYXIgYTpsYXN0LWNoaWxke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6NHB4O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjRweDtib3JkZXItYm90dG9tOm5vbmV9LmxlYWZsZXQtYmFyIGEubGVhZmxldC1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdDtiYWNrZ3JvdW5kLWNvbG9yOiNmNGY0ZjQ7Y29sb3I6I2JiYn0ubGVhZmxldC10b3VjaCAubGVhZmxldC1iYXIgYXt3aWR0aDozMHB4O2hlaWdodDozMHB4O2xpbmUtaGVpZ2h0OjMwcHh9LmxlYWZsZXQtY29udHJvbC16b29tLWluLC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udDo3MDAgMThweCAnTHVjaWRhIENvbnNvbGUnLE1vbmFjbyxtb25vc3BhY2U7dGV4dC1pbmRlbnQ6MXB4fS5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udC1zaXplOjIwcHh9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC16b29tLWlue2ZvbnQtc2l6ZToyMnB4fS5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtem9vbS1vdXR7Zm9udC1zaXplOjI0cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnN7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDVweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93OjAgMXB4IDVweCByZ2JhKDAsMCwwLC40KTtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyLXJhZGl1czo1cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRpc3QvY3NzL2ltYWdlcy9sYXllcnMucG5nKTt3aWR0aDozNnB4O2hlaWdodDozNnB4fS5sZWFmbGV0LXJldGluYSAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGlzdC9jc3MvaW1hZ2VzL2xheWVycy0yeC5wbmcpO2JhY2tncm91bmQtc2l6ZToyNnB4IDI2cHh9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnMtdG9nZ2xle3dpZHRoOjQ0cHg7aGVpZ2h0OjQ0cHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMgLmxlYWZsZXQtY29udHJvbC1sYXllcnMtbGlzdCwubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCAubGVhZmxldC1jb250cm9sLWxheWVycy10b2dnbGV7ZGlzcGxheTpub25lfS5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWxpc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZHtwYWRkaW5nOjZweCAxMHB4IDZweCA2cHg7Y29sb3I6IzMzMztiYWNrZ3JvdW5kOiNmZmZ9LmxlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFye292ZXJmbG93LXk6c2Nyb2xsO3BhZGRpbmctcmlnaHQ6NXB4fS5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9ye21hcmdpbi10b3A6MnB4O3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDoxcHh9LmxlYWZsZXQtY29udHJvbC1sYXllcnMgbGFiZWx7ZGlzcGxheTpibG9ja30ubGVhZmxldC1jb250cm9sLWxheWVycy1zZXBhcmF0b3J7aGVpZ2h0OjA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2RkZDttYXJnaW46NXB4IC0xMHB4IDVweCAtNnB4fS5sZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoe2JhY2tncm91bmQtaW1hZ2U6dXJsKGRpc3QvY3NzL2ltYWdlcy9tYXJrZXItaWNvbi5wbmcpfS5sZWFmbGV0LWNvbnRhaW5lciAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9ue2JhY2tncm91bmQ6I2ZmZjtiYWNrZ3JvdW5kOnJnYmEoMjU1LDI1NSwyNTUsLjcpO21hcmdpbjowfS5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtY29udHJvbC1zY2FsZS1saW5le3BhZGRpbmc6MCA1cHg7Y29sb3I6IzMzM30ubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uIGF7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiBhOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtY29udGFpbmVyIC5sZWFmbGV0LWNvbnRyb2wtc2NhbGV7Zm9udC1zaXplOjExcHh9LmxlYWZsZXQtbGVmdCAubGVhZmxldC1jb250cm9sLXNjYWxle21hcmdpbi1sZWZ0OjVweH0ubGVhZmxldC1ib3R0b20gLmxlYWZsZXQtY29udHJvbC1zY2FsZXttYXJnaW4tYm90dG9tOjVweH0ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmV7Ym9yZGVyOjJweCBzb2xpZCAjNzc3O2JvcmRlci10b3A6bm9uZTtsaW5lLWhlaWdodDoxLjE7cGFkZGluZzoycHggNXB4IDFweDtmb250LXNpemU6MTFweDt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtiYWNrZ3JvdW5kOiNmZmY7YmFja2dyb3VuZDpyZ2JhKDI1NSwyNTUsMjU1LC41KX0ubGVhZmxldC1jb250cm9sLXNjYWxlLWxpbmU6bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLXRvcDoycHggc29saWQgIzc3Nztib3JkZXItYm90dG9tOm5vbmU7bWFyZ2luLXRvcDotMnB4fS5sZWFmbGV0LWNvbnRyb2wtc2NhbGUtbGluZTpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1ib3R0b206MnB4IHNvbGlkICM3Nzd9LmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtYmFyLC5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24sLmxlYWZsZXQtdG91Y2ggLmxlYWZsZXQtY29udHJvbC1sYXllcnN7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5sZWFmbGV0LXRvdWNoIC5sZWFmbGV0LWJhciwubGVhZmxldC10b3VjaCAubGVhZmxldC1jb250cm9sLWxheWVyc3tib3JkZXI6MnB4IHNvbGlkIHJnYmEoMCwwLDAsLjIpO2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveH0ubGVhZmxldC1wb3B1cHtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcn0ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXJ7dGV4dC1hbGlnbjpsZWZ0fS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJ7d2lkdGg6NDBweDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTttYXJnaW4tbGVmdDotMjBweDtvdmVyZmxvdzpoaWRkZW47cG9pbnRlci1ldmVudHM6bm9uZX0ubGVhZmxldC1wb3B1cC10aXB7d2lkdGg6MTdweDtoZWlnaHQ6MTdweDtwYWRkaW5nOjFweDttYXJnaW46LTEwcHggYXV0byAwOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoNDVkZWcpO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlciwubGVhZmxldC1wb3B1cC10aXB7YmFja2dyb3VuZDojZmZmO2NvbG9yOiMzMzM7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE0cHggcmdiYSgwLDAsMCwuNCk7Ym94LXNoYWRvdzowIDNweCAxNHB4IHJnYmEoMCwwLDAsLjQpfS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9ue2JvcmRlcjpub25lO2ZvbnQ6MTZweC8xNHB4IFRhaG9tYSxWZXJkYW5hLHNhbnMtc2VyaWY7Y29sb3I6I2MzYzNjMzt0ZXh0LWRlY29yYXRpb246bm9uZTtiYWNrZ3JvdW5kOjAgMH0ubGVhZmxldC1jb250YWluZXIgYS5sZWFmbGV0LXBvcHVwLWNsb3NlLWJ1dHRvbjpob3Zlcntjb2xvcjojOTk5fS5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcnt6b29tOjF9LmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtdGlwe3dpZHRoOjI0cHg7bWFyZ2luOjAgYXV0bzstbXMtZmlsdGVyOlxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0wLjcwNzEwNjc4LCBNMTI9MC43MDcxMDY3OCwgTTIxPS0wLjcwNzEwNjc4LCBNMjI9MC43MDcxMDY3OClcXFwiO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT0uNzA3MTA2NzgsIE0xMj0uNzA3MTA2NzgsIE0yMT0tLjcwNzEwNjc4LCBNMjI9LjcwNzEwNjc4KX0ubGVhZmxldC1vbGRpZSAubGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVye21hcmdpbi10b3A6LTFweH0ubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLWxheWVycywubGVhZmxldC1vbGRpZSAubGVhZmxldC1jb250cm9sLXpvb20sLmxlYWZsZXQtb2xkaWUgLmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVyLC5sZWFmbGV0LW9sZGllIC5sZWFmbGV0LXBvcHVwLXRpcHtib3JkZXI6MXB4IHNvbGlkICM5OTl9LmxlYWZsZXQtZGl2LWljb257YmFja2dyb3VuZDojZmZmO2JvcmRlcjoxcHggc29saWQgIzY2Nn0ubGVhZmxldC10b29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmc6NnB4O2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNmZmY7Ym9yZGVyLXJhZGl1czozcHg7Y29sb3I6IzIyMjt3aGl0ZS1zcGFjZTpub3dyYXA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC40KX0ubGVhZmxldC10b29sdGlwLmxlYWZsZXQtY2xpY2thYmxle2N1cnNvcjpwb2ludGVyO3BvaW50ZXItZXZlbnRzOmF1dG99LmxlYWZsZXQtdG9vbHRpcC1ib3R0b206YmVmb3JlLC5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3BvaW50ZXItZXZlbnRzOm5vbmU7Ym9yZGVyOjZweCBzb2xpZCB0cmFuc3BhcmVudDtiYWNrZ3JvdW5kOjAgMDtjb250ZW50OlxcXCJcXFwifS5sZWFmbGV0LXRvb2x0aXAtYm90dG9te21hcmdpbi10b3A6NnB4fS5sZWFmbGV0LXRvb2x0aXAtdG9we21hcmdpbi10b3A6LTZweH0ubGVhZmxldC10b29sdGlwLWJvdHRvbTpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi02cHh9LmxlYWZsZXQtdG9vbHRpcC10b3A6YmVmb3Jle2JvdHRvbTowO21hcmdpbi1ib3R0b206LTEycHg7Ym9yZGVyLXRvcC1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtYm90dG9tOmJlZm9yZXt0b3A6MDttYXJnaW4tdG9wOi0xMnB4O21hcmdpbi1sZWZ0Oi02cHg7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtbGVmdHttYXJnaW4tbGVmdDotNnB4fS5sZWFmbGV0LXRvb2x0aXAtcmlnaHR7bWFyZ2luLWxlZnQ6NnB4fS5sZWFmbGV0LXRvb2x0aXAtbGVmdDpiZWZvcmUsLmxlYWZsZXQtdG9vbHRpcC1yaWdodDpiZWZvcmV7dG9wOjUwJTttYXJnaW4tdG9wOi02cHh9LmxlYWZsZXQtdG9vbHRpcC1sZWZ0OmJlZm9yZXtyaWdodDowO21hcmdpbi1yaWdodDotMTJweDtib3JkZXItbGVmdC1jb2xvcjojZmZmfS5sZWFmbGV0LXRvb2x0aXAtcmlnaHQ6YmVmb3Jle2xlZnQ6MDttYXJnaW4tbGVmdDotMTJweDtib3JkZXItcmlnaHQtY29sb3I6I2ZmZn1bY2xhc3NePWRnLV0sW2NsYXNzXj1kZy1dOmFmdGVyLFtjbGFzc149ZGctXTpiZWZvcmV7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7bWFyZ2luOjA7cGFkZGluZzowO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2ZvbnQtd2VpZ2h0OmluaGVyaXQ7Zm9udC1zdHlsZTppbmhlcml0O2ZvbnQtc2l6ZToxZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDoxLjJ9W2NsYXNzXj1kZy1dPltjbGFzc149ZGctXTpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH1bY2xhc3NePWRnLV0gYWJicixbY2xhc3NePWRnLV0gZmllbGRzZXQsW2NsYXNzXj1kZy1dIGltZ3tib3JkZXI6MH1bY2xhc3NePWRnLV0gYmxvY2txdW90ZSxbY2xhc3NePWRnLV0gcXtxdW90ZXM6bm9uZX1bY2xhc3NePWRnLV0gYmxvY2txdW90ZTphZnRlcixbY2xhc3NePWRnLV0gYmxvY2txdW90ZTpiZWZvcmUsW2NsYXNzXj1kZy1dIHE6YWZ0ZXIsW2NsYXNzXj1kZy1dIHE6YmVmb3Jle2NvbnRlbnQ6Jyc7Y29udGVudDpub25lfVtjbGFzc149ZGctXSBvbCxbY2xhc3NePWRnLV0gdWx7bGlzdC1zdHlsZTpub25lfVtjbGFzc149ZGctXSB0YWJsZXtib3JkZXItc3BhY2luZzowO2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZX1bY2xhc3NePWRnLV0gY2FwdGlvbixbY2xhc3NePWRnLV0gdGh7dGV4dC1hbGlnbjpsZWZ0fVtjbGFzc149ZGctXSB0ZCxbY2xhc3NePWRnLV0gdGh7dmVydGljYWwtYWxpZ246bWlkZGxlfVtjbGFzc149ZGctXSBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsW2NsYXNzXj1kZy1dIGlucHV0OjotbW96LWZvY3VzLWlubmVye3BhZGRpbmc6MDtib3JkZXI6MH0uZGctbGFiZWx7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO21heC13aWR0aDpub25lO21heC1oZWlnaHQ6bm9uZTt3aWR0aDozMDBweDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmRnLWxhYmVsX19jb250ZW50e2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjNweCA3cHg7bWluLXdpZHRoOjMwcHg7bWF4LXdpZHRoOjMwMHB4O3dpZHRoOmF1dG87Ym9yZGVyLXdpZHRoOjFweDtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXJhZGl1czoycHg7dmVydGljYWwtYWxpZ246dG9wO2ZvbnQtc2l6ZToxMnB4fS5sZWFmbGV0LXRvcCAuZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcnt0b3A6NXB4fS5sZWFmbGV0LXJpZ2h0IC5kZy1sYWJlbF9uYW1lX2xvY2F0aW9uLWVycm9ye3JpZ2h0OjQwcHg7bGVmdDphdXRvO3RleHQtYWxpZ246cmlnaHR9LmxlYWZsZXQtYm90dG9tIC5kZy1sYWJlbF9uYW1lX2xvY2F0aW9uLWVycm9ye3RvcDo0cHh9LmxlYWZsZXQtbGVmdCAuZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcntsZWZ0OjQwcHh9LmRnLWxhYmVsX19jb250ZW50e2JvcmRlci1jb2xvcjojMzIzMjMyO2JvcmRlci1jb2xvcjpyZ2JhKDUwLDUwLDUwLC44NSk7YmFja2dyb3VuZDojMzIzMjMyO2JhY2tncm91bmQ6cmdiYSg1MCw1MCw1MCwuODUpO2NvbG9yOiNmZmQyNmV9LmxlYWZsZXQtcG9wdXB7bWFyZ2luLWJvdHRvbTowfS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJ7aGVpZ2h0OjB9LmxlYWZsZXQtcG9wdXAtY29udGVudC13cmFwcGVye292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7bWluLXdpZHRoOjYwcHg7bWluLWhlaWdodDo1MHB4O2JvcmRlcjowO2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQ6MCAwOy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZTtjb2xvcjojZTZlNmU2O2ZvbnQtc2l6ZToxNHB4Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IGVhc2Utb3V0IC4ycyxtYXgtaGVpZ2h0IGVhc2Utb3V0IC4ycyxoZWlnaHQgZWFzZS1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLW91dCAuMnMsbWF4LWhlaWdodCBlYXNlLW91dCAuMnMsaGVpZ2h0IGVhc2Utb3V0IC4yczstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7LW1zLXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJX0ubGVhZmxldC1wb3B1cC1jb250ZW50LXdyYXBwZXI6YmVmb3Jle2Zsb2F0OnJpZ2h0O3dpZHRoOjMwcHg7aGVpZ2h0OjE3cHg7Y29udGVudDonJ30ubGVhZmxldC1wb3B1cC1jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjoxNnB4O3dpZHRoOmF1dG87bGluZS1oZWlnaHQ6MS40fS5sZWFmbGV0LXBvcHVwIGF7b3V0bGluZTowfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQgcHttYXJnaW46MH0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZHtvdmVyZmxvdzp2aXNpYmxlO2JvcmRlcjowfS5sZWFmbGV0LXBvcHVwLWlubmVye3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MH0ubGVhZmxldC1wb3B1cF9zaG93X3RydWV7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnMsLXdlYmtpdC10cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLWluLW91dCAuMnMsaGVpZ2h0IGVhc2Utb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzLG9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnM7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzLG9wYWNpdHkgZWFzZS1pbi1vdXQgLjJzLGhlaWdodCBlYXNlLW91dCAuMnMsLXdlYmtpdC10cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEpOy1tcy10cmFuc2Zvcm06c2NhbGUoMSk7dHJhbnNmb3JtOnNjYWxlKDEpfS5sZWFmbGV0LXBvcHVwX3Nob3dfZmFsc2V7b3BhY2l0eTowIWltcG9ydGFudDstd2Via2l0LXRyYW5zaXRpb246YWxsIGVhc2UtaW4tb3V0IC4xczt0cmFuc2l0aW9uOmFsbCBlYXNlLWluLW91dCAuMXM7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMC4yKTstbXMtdHJhbnNmb3JtOnNjYWxlKDAuMik7dHJhbnNmb3JtOnNjYWxlKDAuMil9LmxlYWZsZXQtcG9wdXBfcHJlbG9hZGVyX3RydWV7d2lkdGg6Mzg0cHg7aGVpZ2h0OjUycHh9LmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6YXV0bztib3R0b206MDtsZWZ0OjUwJTttYXJnaW4tbGVmdDotMjlweDt3aWR0aDo1OHB4O2hlaWdodDo0N3B4O2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDQ3cHgpOy1tcy10cmFuc2Zvcm06dHJhbnNsYXRlWSg0N3B4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg0N3B4KTtwb2ludGVyLWV2ZW50czpub25lfS5sZWFmbGV0LXBvcHVwLXRpcHtkaXNwbGF5Om5vbmV9LmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcl9zdmd7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHUG9wdXBfX3BvcHVwU2hhZG93LnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjo1MCUgOTUlO2JhY2tncm91bmQtc2l6ZTozNnB4IDEycHh9LmxlYWZsZXQtcmV0aW5hIC5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJfc3Zne2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHUG9wdXBfX3BvcHVwU2hhZG93QDJ4LnBuZyl9LmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjNweDtyaWdodDozcHg7ei1pbmRleDoxO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOjE4cHg7bGluZS1oZWlnaHQ6MzBweDtjdXJzb3I6cG9pbnRlcn0ubm8tdG91Y2ggLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXJ7Ym9yZGVyLXJhZGl1czoycHg7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnM7dHJhbnNpdGlvbjphbGwgLjJzfS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmFjdGl2ZXtjb2xvcjojNzc3fS5sZWFmbGV0LWNvbnRhaW5lciBhLmxlYWZsZXQtcG9wdXAtY2xvc2UtYnV0dG9uOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6Mjtjb250ZW50OicnfS5sZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoNTAsNTAsNTAsLjkpfS5sZWFmbGV0LXBvcHVwLXRpcC1jb250YWluZXJfaW1hZ2V7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjU4JTIyJTIwaGVpZ2h0JTNEJTIyNDclMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0wJTIwMGMxMi42NDMlMjAwJTIwMjglMjA3LjExNSUyMDI4JTIwNDRoMmMwLTM2Ljg4NSUyMDE1LjM1OC00NCUyMDI4LTQ0aC01OHolMjIlMjBmaWxsJTNEJTIycmdiYSg1MCUyQzUwJTJDNTAlMkMuOSklMjIlM0UlM0MlMkZwYXRoJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9LmxlYWZsZXQtbWFwLXBhbmUgLmxlYWZsZXQtcG9wdXAtdGlwLWNvbnRhaW5lcl9zdmd7ZmlsbDpyZ2JhKDUwLDUwLDUwLC45KX0ubm8tdG91Y2ggLmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjIyOy13ZWJraXQtYm94LXNoYWRvdzowIDFweCAzcHggcmdiYSgwLDAsMCwuNSk7Ym94LXNoYWRvdzowIDFweCAzcHggcmdiYSgwLDAsMCwuNSl9LmxlYWZsZXQtY29udGFpbmVyIGEubGVhZmxldC1wb3B1cC1jbG9zZS1idXR0b246YWZ0ZXJ7dG9wOi0zcHg7cmlnaHQ6LTVweDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4fS5kZy13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbn0uZGctc2Nyb2xsZXJ7aGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTpzY3JvbGw7Ym9yZGVyOjB9LmRnLXNjcm9sbGVyX19iYXJ7ei1pbmRleDoxO3JpZ2h0OjA7YmFja2dyb3VuZDojOTk5fS5kZy1zY3JvbGxlcl9fYmFyX2h7Ym90dG9tOjJweDtoZWlnaHQ6OHB4fS5kZy1oZWFkZXJfX3RpdGxle3dpZHRoOjEwMCU7bWFyZ2luOjA7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2JhY2tncm91bmQ6Izk5OX0uZGctaGVhZGVyX190aXRsZV9zdGF0ZV9maXhlZHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjF9LmRnLXNjcm9sbGVyX2hpZGRlbl90cnVle292ZXJmbG93OmF1dG99LmRnLXNjcm9sbGVyOjotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDowfS5kZy1zY3JvbGxlcl9fd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59LmRnLXNjcm9sbGVyX19iYXItd3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MThweDtyaWdodDozcHg7Ym90dG9tOjRweDt3aWR0aDo3cHg7Ym9yZGVyLXJhZGl1czo1cHh9LmRnLXNjcm9sbGVyX2hpZGRlbl90cnVlIC5kZy1zY3JvbGxlcl9fYmFyLXdyYXBwZXJ7dmlzaWJpbGl0eTpoaWRkZW59LmRnLXBvcHVwX19oZWFkZXIrLmRnLXBvcHVwX19jb250YWluZXItd3JhcHBlciAuZGctc2Nyb2xsZXJfX2Jhci13cmFwcGVye3RvcDo0cHh9LmRnLXNjcm9sbGVyX19iYXJ7cG9zaXRpb246YWJzb2x1dGU7bWluLWhlaWdodDoyMHB4O3dpZHRoOjdweDtib3JkZXItcmFkaXVzOjNweDtwb2ludGVyLWV2ZW50czphdXRvfS5zY3JvbGxlcl9fYmFyLXdyYXBwZXIgLnNjcm9sbGVyX19iYXJ7YmFja2dyb3VuZC1jb2xvcjojNjY1YjRmfS5zY3JvbGxlcl9fYmFyLXdyYXBwZXI6aG92ZXIgLnNjcm9sbGVyX19iYXJ7YmFja2dyb3VuZC1jb2xvcjojODk3YTZifS5kZy1wb3B1cF9fY29udGFpbmVye21hcmdpbjowfS5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIC5kZy1wb3B1cF9fY29udGFpbmVye3BhZGRpbmc6OHB4IDE0cHggOHB4IDB9LmRnLXBvcHVwX19oZWFkZXJ7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZy1ib3R0b206MTJweH0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2hlYWRlcjphZnRlcntwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MTJweDtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjFweDtjb250ZW50OicnfS5kZy1wb3B1cF9fZm9vdGVye3Bvc2l0aW9uOnJlbGF0aXZlO2JvdHRvbTowO292ZXJmbG93OmhpZGRlbn0ubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2Zvb3RlcjpiZWZvcmV7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO2hlaWdodDoxcHg7Y29udGVudDonJ30uZGctcG9wdXBfaGlkZGVuX3RydWV7ZGlzcGxheTpub25lfS5sZWFmbGV0LXBvcHVwLXNjcm9sbGVkIC5kZy1wb3B1cF9fZm9vdGVyOmJlZm9yZSwubGVhZmxldC1wb3B1cC1zY3JvbGxlZCAuZGctcG9wdXBfX2hlYWRlcjphZnRlcntib3JkZXItYm90dG9tOjFweCBzb2xpZCAjNjM2MzYzO2JhY2tncm91bmQtY29sb3I6IzQ5NDk0OX0uZGctY29udHJvbC1yb3VuZHtwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjVweDt3aWR0aDozMHB4O2hlaWdodDozMHB4O2JvcmRlci1yYWRpdXM6NTAlO2N1cnNvcjpkZWZhdWx0fS5kZy1jb250cm9sLXJvdW5kX19pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOiNmMGYwZjA7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxsZWZ0IGJvdHRvbSxjb2xvci1zdG9wKDAsI2ZmZiksdG8oI2UwZTBlMCkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNmZmYgMCwjZTBlMGUwIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZmZmIDAsI2UwZTBlMCAxMDAlKTtjb2xvcjojMmIyYTI5O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtc2hhZG93OjAgMXB4IDAgI2ZmZjtmb250LXNpemU6MjJweDtsaW5lLWhlaWdodDozMHB4O2N1cnNvcjpwb2ludGVyfS5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjU7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxsZWZ0IGJvdHRvbSxjb2xvci1zdG9wKDAsI2ViZWJlYiksdG8oI2ZmZikpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNlYmViZWIgMCwjZmZmIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZWJlYmViIDAsI2ZmZiAxMDAlKX0uZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmUsLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojZWJlYmViO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AsbGVmdCBib3R0b20sY29sb3Itc3RvcCgwLCNkNmQ2ZDYpLHRvKCNmZmYpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZDZkNmQ2IDAsI2ZmZiAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sI2Q2ZDZkNiAwLCNmZmYgMTAwJSl9LmxlYWZsZXQtZGlzYWJsZWQgLmRnLWNvbnRyb2wtcm91bmRfX2ljb24sLmxlYWZsZXQtZGlzYWJsZWQgLmRnLWNvbnRyb2wtcm91bmRfX2ljb246YWN0aXZlLC5uby10b3VjaCAubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbjpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOm5vbmU7Y3Vyc29yOmRlZmF1bHR9LmxlYWZsZXQtdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb246YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMTBweDtyaWdodDotMTVweDtib3R0b206LTEwcHg7bGVmdDotMTVweDtjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX2lzLWhpZGRlbl90cnVle2Rpc3BsYXk6bm9uZX0uZGctY29udHJvbC1yb3VuZHtiYWNrZ3JvdW5kLWNvbG9yOiMzZDNkM2Q7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDVweCAwIHJnYmEoMCwwLDAsLjMpO2JveC1zaGFkb3c6MCAzcHggNXB4IDAgcmdiYSgwLDAsMCwuMyl9LmRnLWNvbnRyb2wtcm91bmRfX2ljb257LXdlYmtpdC1ib3gtc2hhZG93OjAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjQpO2JveC1zaGFkb3c6MCAycHggMnB4IDAgcmdiYSgwLDAsMCwuNCl9Lm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmhvdmVyey13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAjZmZmLDAgMCAwIDFweCByZ2JhKDAsMCwwLC4zKSwwIDFweCAwIDFweCByZ2JhKDAsMCwwLC40KTtib3gtc2hhZG93Omluc2V0IDAgMXB4ICNmZmYsMCAwIDAgMXB4IHJnYmEoMCwwLDAsLjMpLDAgMXB4IDAgMXB4IHJnYmEoMCwwLDAsLjQpfS5kZy1jb250cm9sLXJvdW5kX19pY29uOmFjdGl2ZSwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmFjdGl2ZXstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IDFweCByZ2JhKDAsMCwwLC4yKSwwIDAgMCAxcHggcmdiYSgwLDAsMCwuMyksMCAtMXB4IDFweCAwICMwMDA7Ym94LXNoYWRvdzppbnNldCAwIDFweCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpLDAgMCAwIDFweCByZ2JhKDAsMCwwLC4zKSwwIC0xcHggMXB4IDAgIzAwMH0ubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbiwubGVhZmxldC1kaXNhYmxlZCAuZGctY29udHJvbC1yb3VuZF9faWNvbjphY3RpdmUsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy1jb250cm9sLXJvdW5kX19pY29uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2I4YjhiODstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmxlYWZsZXQtY29udGFpbmVye3otaW5kZXg6MDtiYWNrZ3JvdW5kOiNmN2YzZGY7Y3Vyc29yOmRlZmF1bHR9LmxlYWZsZXQtY29udGFpbmVyOi13ZWJraXQtZnVsbC1zY3JlZW57d2lkdGg6MTAwJSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lcjotbW96LWZ1bGwtc2NyZWVue3dpZHRoOjEwMCUhaW1wb3J0YW50O2hlaWdodDoxMDAlIWltcG9ydGFudH0ubGVhZmxldC1jb250YWluZXI6LW1zLWZ1bGxzY3JlZW57d2lkdGg6MTAwJSFpbXBvcnRhbnQ7aGVpZ2h0OjEwMCUhaW1wb3J0YW50fS5sZWFmbGV0LWNvbnRhaW5lcjpmdWxsc2NyZWVue3dpZHRoOjEwMCUhaW1wb3J0YW50O2hlaWdodDoxMDAlIWltcG9ydGFudH0ubGVhZmxldC1kcmFnZ2luZywubGVhZmxldC1kcmFnZ2luZyAubGVhZmxldC1jbGlja2FibGUsLmxlYWZsZXQtZHJhZ2dpbmcgLmxlYWZsZXQtY29udGFpbmVye2N1cnNvcjptb3ZlfS5sZWFmbGV0LWNvbnRyb2wgYSwubGVhZmxldC1jb250cm9sIGE6Zm9jdXN7b3V0bGluZTowIWltcG9ydGFudH0ubGVhZmxldC1jb250YWluZXIgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uZGctY3VzdG9taXphdGlvbl9fbWFya2Vye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdH0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWltYWdlOmluaGVyaXQ7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7dHJhbnNpdGlvbjpvcGFjaXR5IGVhc2UtaW4tb3V0IC4ycyx0cmFuc2Zvcm0gZWFzZS1pbi1vdXQgLjJzO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlLWluLW91dCAuMnMsdHJhbnNmb3JtIGVhc2UtaW4tb3V0IC4ycywtd2Via2l0LXRyYW5zZm9ybSBlYXNlLWluLW91dCAuMnM7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTstbXMtdHJhbnNmb3JtOnNjYWxlKDEsMSk7dHJhbnNmb3JtOnNjYWxlKDEsMSk7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjUwJSAxMDAlOy1tcy10cmFuc2Zvcm0tb3JpZ2luOjUwJSAxMDAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCV9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29te2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlci5wbmcpO2JhY2tncm91bmQtc2l6ZToyMnB4IDM0cHg7d2lkdGg6MjJweDtoZWlnaHQ6MzRweDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7LW1zLXRyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJTstd2Via2l0LWFuaW1hdGlvbjpkZy1jdXN0b21pemF0aW9uX19zaG93LW1hcmtlciAuMnM7YW5pbWF0aW9uOmRnLWN1c3RvbWl6YXRpb25fX3Nob3ctbWFya2VyIC4yc30ubGVhZmxldC1yZXRpbmEgLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29te2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHQ3VzdG9taXphdGlvbl9fbWFya2VyQDJ4LnBuZyl9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmZvY3Vze291dGxpbmU6MH0ubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmhvdmVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckhvdmVyLnBuZyk7YmFja2dyb3VuZC1zaXplOjIycHggMzRweH0ubGVhZmxldC1yZXRpbmEgLm5vLXRvdWNoIC5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfdHlwZV9tdXNocm9vbTpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckhvdmVyQDJ4LnBuZyl9LmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZSwubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvREdDdXN0b21pemF0aW9uX19tYXJrZXJBY3RpdmUucG5nKTtiYWNrZ3JvdW5kLXNpemU6MjJweCAzNHB4fS5sZWFmbGV0LXJldGluYSAuZGctY3VzdG9taXphdGlvbl9fbWFya2VyX3R5cGVfbXVzaHJvb206YWN0aXZlLC5sZWFmbGV0LXJldGluYSAubm8tdG91Y2ggLmRnLWN1c3RvbWl6YXRpb25fX21hcmtlcl90eXBlX211c2hyb29tOmFjdGl2ZXtiYWNrZ3JvdW5kLWltYWdlOnVybChodHRwczovL21hcHMuYXBpLjJnaXMucnUvMi4wL2ltZy9ER0N1c3RvbWl6YXRpb25fX21hcmtlckFjdGl2ZUAyeC5wbmcpfUAtd2Via2l0LWtleWZyYW1lcyBkZy1jdXN0b21pemF0aW9uX19zaG93LW1hcmtlcntmcm9te29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fUBrZXlmcmFtZXMgZGctY3VzdG9taXphdGlvbl9fc2hvdy1tYXJrZXJ7ZnJvbXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2FwcGVhcntiYWNrZ3JvdW5kLXBvc2l0aW9uOjk5OXB4fS5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfYXBwZWFyOmJlZm9yZXtjb250ZW50OicnfS5kZy1jdXN0b21pemF0aW9uX19tYXJrZXJfZGlzYXBwZWFye2JhY2tncm91bmQtcG9zaXRpb246OTk5cHg7cG9pbnRlci1ldmVudHM6bm9uZX0uZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2Rpc2FwcGVhcjpiZWZvcmV7dmlzaWJpbGl0eTpoaWRkZW47Y29udGVudDonJztvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7LW1zLXRyYW5zZm9ybTpzY2FsZSgxLjIsMS44KTt0cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7LXdlYmtpdC1hbmltYXRpb246ZGctY3VzdG9taXphdGlvbl9fbWFya2VyLXRvLWNhbGxvdXQgLjJzO2FuaW1hdGlvbjpkZy1jdXN0b21pemF0aW9uX19tYXJrZXItdG8tY2FsbG91dCAuMnN9QC13ZWJraXQta2V5ZnJhbWVzIGRnLWN1c3RvbWl6YXRpb25fX21hcmtlci10by1jYWxsb3V0ezAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTt0cmFuc2Zvcm06c2NhbGUoMSwxKX0xMDAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7dHJhbnNmb3JtOnNjYWxlKDEuMiwxLjgpfX1Aa2V5ZnJhbWVzIGRnLWN1c3RvbWl6YXRpb25fX21hcmtlci10by1jYWxsb3V0ezAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSwxKTt0cmFuc2Zvcm06c2NhbGUoMSwxKX0xMDAle3Zpc2liaWxpdHk6dmlzaWJsZTtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMS4yLDEuOCk7dHJhbnNmb3JtOnNjYWxlKDEuMiwxLjgpfX0uZGctZHJhZ2dpbmctZmFsc2V7dG91Y2gtYWN0aW9uOmF1dG87LW1zLXRvdWNoLWFjdGlvbjphdXRvfS5sZWFmbGV0LWltYWdlLWxheWVyLC5sZWFmbGV0LXRpbGUtY29udGFpbmVye3BvaW50ZXItZXZlbnRzOmF1dG99LmRnLXpvb217d2lkdGg6NDBweDtoZWlnaHQ6NzRweH0uZGctem9vbV9faW57cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowfS5sZWFmbGV0LXRvdWNoIC5kZy16b29tX19pbjpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOi01cHg7cmlnaHQ6LTEwcHg7Ym90dG9tOjA7bGVmdDotMTBweDtjb250ZW50OicnfS5kZy16b29tX19pbjphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTotMXB4O2xlZnQ6MDt6LWluZGV4Oi0xO21hcmdpbjphdXRvO3dpZHRoOjEycHg7aGVpZ2h0OjJweDstd2Via2l0LWJveC1zaGFkb3c6MCAwIDNweCAycHggcmdiYSgwLDAsMCwuMyk7Ym94LXNoYWRvdzowIDAgM3B4IDJweCByZ2JhKDAsMCwwLC4zKTtjb250ZW50OicnfS5kZy16b29tX19idXR0b25fdHlwZV9pbjphZnRlciwuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YmVmb3JlLC5sZWFmbGV0LXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7bWFyZ2luOmF1dG87d2lkdGg6MTRweDtoZWlnaHQ6MnB4O2JhY2tncm91bmQtY29sb3I6IzdhN2E3YTstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggI2ZmZjtib3gtc2hhZG93OjAgMXB4ICNmZmY7Y29udGVudDonJ30uZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWZ0ZXJ7d2lkdGg6MnB4O2hlaWdodDoxNHB4fS5uby10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46aG92ZXI6YWZ0ZXIsLm5vLXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpob3ZlcjpiZWZvcmV7YmFja2dyb3VuZC1jb2xvcjojNjE2MTYxfS5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YWZ0ZXIsLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmFjdGl2ZTpiZWZvcmUsLm5vLXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YWZ0ZXIsLm5vLXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YmVmb3Jle2JhY2tncm91bmQtY29sb3I6IzU3NTc1N30ubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmFmdGVyLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YmVmb3JlLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphZnRlciwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YmVmb3JlLC5uby10b3VjaCAubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46aG92ZXI6YWZ0ZXIsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpob3ZlcjpiZWZvcmV7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5kZy16b29tX19vdXR7cG9zaXRpb246YWJzb2x1dGU7dG9wOjQwcHg7cmlnaHQ6MDtsZWZ0OjA7bWFyZ2luOmF1dG87d2lkdGg6MjJweDtoZWlnaHQ6MjJweH0uZGctem9vbV9fb3V0OmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDotMXB4O3JpZ2h0OjA7bGVmdDowO21hcmdpbjphdXRvO3dpZHRoOjEycHg7aGVpZ2h0OjJweDtjb250ZW50OicnfS5kZy16b29tX19idXR0b25fdHlwZV9vdXR7d2lkdGg6MjJweDtoZWlnaHQ6MjJweH0ubGVhZmxldC10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmJlZm9yZXt0b3A6LTVweDtyaWdodDotMTlweDtib3R0b206LTE5cHg7bGVmdDotMTlweH0uZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO21hcmdpbjphdXRvO3dpZHRoOjEwcHg7aGVpZ2h0OjJweDtiYWNrZ3JvdW5kOiM3YTdhN2E7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4ICNmZmY7Ym94LXNoYWRvdzowIDFweCAjZmZmO2NvbnRlbnQ6Jyd9Lm5vLXRvdWNoIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZDojNjE2MTYxfS5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctem9vbV9fYnV0dG9uX3R5cGVfb3V0OmFjdGl2ZTphZnRlcntiYWNrZ3JvdW5kOiM1NzU3NTd9LmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDphY3RpdmU6YWZ0ZXIsLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDphZnRlciwubm8tdG91Y2ggLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDpob3ZlcjphZnRlcnstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmRnLXpvb21fX291dHstd2Via2l0LWJveC1zaGFkb3c6MCAycHggM3B4IDAgcmdiYSgwLDAsMCwuMyk7Ym94LXNoYWRvdzowIDJweCAzcHggMCByZ2JhKDAsMCwwLC4zKX0uZGctem9vbV9fb3V0OmFmdGVye2JhY2tncm91bmQtY29sb3I6IzNkM2QzZH0ubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YWN0aXZlOmFmdGVyLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphY3RpdmU6YmVmb3JlLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjphZnRlciwubGVhZmxldC1kaXNhYmxlZCAuZGctem9vbV9fYnV0dG9uX3R5cGVfaW46YmVmb3JlLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6YWN0aXZlOmFmdGVyLC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9vdXQ6YWZ0ZXIsLm5vLXRvdWNoIC5sZWFmbGV0LWRpc2FibGVkIC5kZy16b29tX19idXR0b25fdHlwZV9pbjpob3ZlcjphZnRlciwubm8tdG91Y2ggLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX2luOmhvdmVyOmJlZm9yZSwubm8tdG91Y2ggLmxlYWZsZXQtZGlzYWJsZWQgLmRnLXpvb21fX2J1dHRvbl90eXBlX291dDpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLWNvbG9yOiM3MDcwNzB9LmRnLWF0dHJpYnV0aW9ue2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQhaW1wb3J0YW50fS5kZy1hdHRyaWJ1dGlvbl9fY29weXJpZ2h0e21hcmdpbjowIDU1cHggNXB4IDA7dGV4dC1hbGlnbjpyaWdodDt3aGl0ZS1zcGFjZTpub3dyYXA7Zm9udC1zaXplOjlweDtmb250LWZhbWlseTpIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZn0uZGctYXR0cmlidXRpb25fX2xpbmtze2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowO3BhZGRpbmc6MCA1cHggMCAwfS5kZy1hdHRyaWJ1dGlvbl9fbGluay1pdGVte3BhZGRpbmc6MDtsaXN0LXN0eWxlLXR5cGU6bm9uZX0ubGVhZmxldC1jb250YWluZXIgLmRnLWF0dHJpYnV0aW9uX19saW5re2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20ocmdiYSg4LDgsOCwuMykpLHRvKHJnYmEoOCw4LDgsLjMpKSkgMCA5NSUvMTBweCAxcHggcmVwZWF0LXg7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LHJnYmEoOCw4LDgsLjMpLHJnYmEoOCw4LDgsLjMpIDEwMCUpIDAgOTUlLzEwcHggMXB4IHJlcGVhdC14O2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoOCw4LDgsLjMpLHJnYmEoOCw4LDgsLjMpIDEwMCUpIDAgOTUlLzEwcHggMXB4IHJlcGVhdC14O2NvbG9yOiMzMzM7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Zm9udC1zaXplOjlweDtmb250LWZhbWlseTpIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtjdXJzb3I6cG9pbnRlcn0ubGVhZmxldC1jb250YWluZXIgLmRnLWF0dHJpYnV0aW9uX19saW5rOmhvdmVye2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20oIzA4MDgwOCksdG8oIzA4MDgwOCkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwjMDgwODA4LCMwODA4MDggMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIzA4MDgwOCwjMDgwODA4IDEwMCUpO2NvbG9yOiMzMzM7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmRnLWF0dHJpYnV0aW9uX19sb2dvLXVybHtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMGhlaWdodCUzRCUyMjI0JTIyJTIwd2lkdGglM0QlMjI1NSUyMiUzRSUwQSUyMCUzQ3BhdGglMjBmaWxsJTNEJTIyJTIzYTJjMTI0JTIyJTIwZCUzRCUyMm0yNC4zOTUlMjAxMmMwLTEuNDU0NS0wLjIyMTc3LTIuNjU0NS0wLjY2NTMyLTQtMC4xNDc4NSUyMDQuMjU0NS00Ljg3OSUyMDcuODE4Mi03LjQ2NjQlMjAxMGg2Ljc2NDFjMC43MDIyOS0yJTIwMS4zNjc2LTMuOTI3MyUyMDEuMzY3Ni02bS00LjczMS05LjM0NTVjLTIuMDMzLTEuNi00LjYyLTIuNjU0NS03LjQ2Ni0yLjY1NDUtNi43Mjc2JTIwMC0xMi4xOTglMjA1LjQxODItMTIuMTk4JTIwMTJzNS40NzA0JTIwMTIlMjAxMi4xOTglMjAxMmMzLjEwNDglMjAwJTIwNS45NTA5LTEuNDU0NSUyMDguMTMxNy0zLjM0NTVoLTguNzk3di0yLjY1NDVjNS4zNTk1LTQuNTQ1NSUyMDguNzk3LTcuMzQ1NSUyMDguNzk3LTEwJTIwMC0xLjEyNzMtMC44MTMxNy0yLjY1NDUtMi42OTgzLTIuNjU0NS0xLjQ3ODUlMjAwLTIuNjk4MyUyMDEuMzQ1NS0yLjY5ODMlMjA0LjY1NDVoLTMuNDAwNWMtMC43MzkyNS00LjIxODIlMjAxLjg0ODEtNy42NzI3JTIwNi4yNDY2LTcuNjcyNyUyMDAuNjY1MzIlMjAwJTIwMS4yNTY3JTIwMC4yMTgxOCUyMDEuODg1MSUyMDAuMzI3MjclMjIlMkYlM0UlMEElMjAlM0NwYXRoJTIwZmlsbCUzRCUyMiUyMzNjNDM0NyUyMiUyMGQlM0QlMjJtMzYuNTkzJTIwOS4zNDU1aDEuMzY3NmMwLTItMC42NjUzMi01LjEyNzMtNC43MzEyLTUuMjcyNy00LjczMi0wLjIxODMtNi4xJTIwMi42MTgxLTYuMSUyMDUuOTI3MnY1LjM0NTVjMCUyMDQuNCUyMDMuNDM3NSUyMDUuMzQ1NSUyMDYuMDk4OCUyMDUuMzQ1NSUyMDEuNTUyNCUyMDAlMjAzLjQwMDUtMC44NzI3MyUyMDQuNzMxMi0ydi02LjY5MDloLTUuNDMzNXYyLjY1NDVoMi42OTgzdjIuNjU0NWMtMS4zNjc2JTIwMS4zNDU1LTUuNDMzNSUyMDEuMzQ1NS01LjQzMzUtMi42NTQ1di01LjMwOTFjMC00JTIwNS45NTA5LTQuMTQ1NSUyMDUuNjE4MyUyMDBoMS4xODI4em0xOC4yOTYlMjA2LjY1NDVjMC01LjgxODItNi45ODU5LTQuMDcyNy02Ljk4NTktNy42JTIwMC0xLjIlMjAwLjgxMzE3LTIlMjAyLjE4MDgtMiUyMDEuNDQxNSUyMDAlMjAyLjI1NDclMjAxLjAxODIlMjAyLjI1NDclMjAyLjk4MThoMi41ODc0YzAtMi0wLjY2NTMyLTUuMzQ1NS00LjczMTItNS4zNDU1LTIuNzcyMiUyMDAtNC44NzklMjAxLjQxODItNC44NzklMjA0LjMyNzMlMjAwJTIwNi4wNzI3JTIwNy4xNzA3JTIwNC4wNzI3JTIwNy4wNTk4JTIwNy42NzI3LTAuMDczOTIlMjAxLjQ1NDUtMS4xNDU4JTIwMi4wNzI3LTIuMzY1NiUyMDIuMDcyNy0xLjQ0MTUlMjAwLTIuNjk4My0wLjcyNzI3LTIuNDM5NS0zLjM4MThoLTIuNjYxM2MtMC4yNTg3NCUyMDMuMzQ1NSUyMDEuNDQxNSUyMDYlMjA1LjM1OTUlMjA2JTIwMi42OTklMjAwJTIwNC43MzItMi4xNDUlMjA0LjczMi01LjM0NWwtMC4xMTElMjAwLjYxOHptLTEyLjE5OCUyMDRoLTIuNjk4M3YtMTZoMi42OTgzdjE2eiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjU1cHg7aGVpZ2h0OjI0cHg7YmFja2dyb3VuZC1zaXplOjU1cHggMjRweDtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW46MCAzcHggMCAwfS5kZy1sb2NhdGlvbl9fcGlue2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL3Nwcml0ZS5iYXNpYy5wbmcpO2JhY2tncm91bmQtcG9zaXRpb246LTIycHggLTI0cHg7YmFja2dyb3VuZC1zaXplOjg3cHggNzRweH0ubGVhZmxldC1yZXRpbmEgLmRnLWxvY2F0aW9uX19waW57YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvc3ByaXRlQDJ4LmJhc2ljLnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjotMjFweCAtMjRweDtiYWNrZ3JvdW5kLXNpemU6OTFweCA3MS41cHh9LmRnLWxvY2F0aW9uX19waW5fc3RhdGVfZm9sbG93aW5ne2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL3Nwcml0ZS5iYXNpYy5wbmcpO2JhY2tncm91bmQtcG9zaXRpb246LTU1cHggMDtiYWNrZ3JvdW5kLXNpemU6ODdweCA3NHB4fS5sZWFmbGV0LXJldGluYSAuZGctbG9jYXRpb25fX3Bpbl9zdGF0ZV9mb2xsb3dpbmd7YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvc3ByaXRlQDJ4LmJhc2ljLnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjotNTVweCAwO2JhY2tncm91bmQtc2l6ZTo5MXB4IDcxLjVweH0uZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDttYXJnaW46YXV0bztjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFjdGl2ZTphZnRlciwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE4JTIyJTIwaGVpZ2h0JTNEJTIyMTglMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyMzIzYTVkNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE3JTJDOCUyMEglMjAxNS45MiUyMEMlMjAxNS40OCUyQzQuOTM3JTIwMTMuMDY0JTJDMi41MiUyMDEwJTJDMi4wOCUyMFYlMjAxJTIwQyUyMDEwJTJDMC40NDglMjA5LjU1MyUyQzAlMjA5JTJDMCUyMDguNDQ3JTJDMCUyMDglMkMwLjQ0OCUyMDglMkMxJTIwViUyMDIuMDglMjBDJTIwNC45MzYlMkMyLjUyJTIwMi41MiUyQzQuOTM3JTIwMi4wOCUyQzglMjBIJTIwMSUyMEMlMjAwLjQ0NyUyQzglMjAwJTJDOC40NDglMjAwJTJDOSUyMDAlMkM5LjU1MyUyMDAuNDQ3JTJDMTAlMjAxJTJDMTAlMjBIJTIwMi4wOCUyMEMlMjAyLjUyJTJDMTMuMDYzJTIwNC45MzYlMkMxNS40OCUyMDglMkMxNS45MiUyMFYlMjAxNyUyMGMlMjAwJTJDMC41NTMlMjAwLjQ0NyUyQzElMjAxJTJDMSUyMDAuNTUzJTJDMCUyMDElMkMtMC40NDclMjAxJTJDLTElMjBWJTIwMTUuOTIlMjBDJTIwMTMuMDY0JTJDMTUuNDgxJTIwMTUuNDglMkMxMy4wNjQlMjAxNS45MiUyQzEwJTIwSCUyMDE3JTIwQyUyMDE3LjU1MyUyQzEwJTIwMTglMkM5LjU1MyUyMDE4JTJDOSUyMDE4JTJDOC40NDglMjAxNy41NTMlMkM4JTIwMTclMkM4JTIweiUyME0lMjA5JTJDMTQlMjBDJTIwNi4yNCUyQzE0JTIwNCUyQzExLjc2MiUyMDQlMkM5JTIwNCUyQzYuMjM4JTIwNi4yNCUyQzQlMjA5JTJDNCUyMGMlMjAyLjc2MSUyQzAlMjA1JTJDMi4yMzglMjA1JTJDNSUyMDAlMkMyLjc2MiUyMC0yLjIzOSUyQzUlMjAtNSUyQzUlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDY2lyY2xlJTIwY3glM0QlMjI5JTIyJTIwY3klM0QlMjI5JTIyJTIwciUzRCUyMjMlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTQlMkMxMC4wMDQlMjBDJTIwMTQlMkM5LjgzNCUyMDEzLjk5MSUyQzkuNjY3JTIwMTMuOTc1JTJDOS41MDIlMjAxMy43MjMlMkMxMi4wMjclMjAxMS41OTIlMkMxNCUyMDklMkMxNCUyMDYuNDA4JTJDMTQlMjA0LjI3NyUyQzEyLjAyNyUyMDQuMDI1JTJDOS41MDIlMjA0LjAwOSUyQzkuNjY3JTIwNCUyQzkuODM0JTIwNCUyQzEwLjAwNCUyMGMlMjAwJTJDMi43NjIlMjAyLjI0JTJDNSUyMDUlMkM1JTIwMi43NjElMkMwJTIwNSUyQy0yLjIzOCUyMDUlMkMtNSUyMHolMjBNJTIwMTAlMkMzLjA4MyUyMGMlMjAzLjA2NCUyQzAuNDM5JTIwNS40OCUyQzIuODU2JTIwNS45MiUyQzUuOTIxJTIwSCUyMDE3JTIwYyUyMDAuMzY5JTJDMCUyMDAuNjg4JTJDMC4yMDElMjAwLjg2JTJDMC40OTglMjBDJTIwMTcuOTQ3JTJDOS4zNTQlMjAxOCUyQzkuMTg0JTIwMTglMkM5JTIwMTglMkM4LjQ0OCUyMDE3LjU1MyUyQzglMjAxNyUyQzglMjBIJTIwMTUuOTIlMjBDJTIwMTUuNDglMkM0LjkzNyUyMDEzLjA2NCUyQzIuNTIlMjAxMCUyQzIuMDglMjBWJTIwMy4wODMlMjB6JTIwTSUyMDElMkM5LjAwNCUyMEglMjAyLjA4JTIwQyUyMDIuNTIlMkM1LjkzOSUyMDQuOTM2JTJDMy41MjIlMjA4JTJDMy4wODMlMjBWJTIwMi4wOCUyMEMlMjA0LjkzNiUyQzIuNTIlMjAyLjUyJTJDNC45MzclMjAyLjA4JTJDOCUyMEglMjAxJTIwQyUyMDAuNDQ3JTJDOCUyMDAlMkM4LjQ0OCUyMDAlMkM5JTIwMCUyQzkuMTg0JTIwMC4wNTMlMkM5LjM1NCUyMDAuMTQlMkM5LjUwMiUyMDAuMzEyJTJDOS4yMDUlMjAwLjYzMSUyQzkuMDA0JTIwMSUyQzkuMDA0JTIweiUyMG0lMjA4JTJDLTglMjBjJTIwMC41NTMlMkMwJTIwMSUyQzAuNDQ3JTIwMSUyQzElMjBWJTIwMSUyMEMlMjAxMCUyQzAuNDQ4JTIwOS41NTMlMkMwJTIwOSUyQzAlMjA4LjQ0NyUyQzAlMjA4JTJDMC40NDglMjA4JTJDMSUyMHYlMjAxLjAwNCUyMGMlMjAwJTJDLTAuNTUzJTIwMC40NDclMkMtMSUyMDElMkMtMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMjY4NWFhJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwOSUyQzclMjBjJTIwMS40ODYlMkMwJTIwMi43MTclMkMxLjA4MiUyMDIuOTU1JTJDMi41JTIwQyUyMDExLjk4MiUyQzkuMzM3JTIwMTIlMkM5LjE3MSUyMDEyJTJDOSUyMDEyJTJDNy4zNDQlMjAxMC42NTYlMkM2JTIwOSUyQzYlMjA3LjM0NCUyQzYlMjA2JTJDNy4zNDQlMjA2JTJDOSUyMDYlMkM5LjE3MSUyMDYuMDE4JTJDOS4zMzclMjA2LjA0NSUyQzkuNSUyMDYuMjgzJTJDOC4wODIlMjA3LjUxNCUyQzclMjA5JTJDNyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMWM4NWFiJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIil9QC13ZWJraXQta2V5ZnJhbWVzIERHTG9jYXRpb25fX2xvY2F0ZUljb25SZXF1ZXN0aW5nQW5pbXt0b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgREdMb2NhdGlvbl9fbG9jYXRlSWNvblJlcXVlc3RpbmdBbmlte3Rvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE4JTIyJTIwaGVpZ2h0JTNEJTIyMTglMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyMzYxNjE2MSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE3JTJDOCUyMEglMjAxNS45MiUyMEMlMjAxNS40OCUyQzQuOTM3JTIwMTMuMDY0JTJDMi41MiUyMDEwJTJDMi4wOCUyMFYlMjAxJTIwQyUyMDEwJTJDMC40NDglMjA5LjU1MyUyQzAlMjA5JTJDMCUyMDguNDQ3JTJDMCUyMDglMkMwLjQ0OCUyMDglMkMxJTIwViUyMDIuMDglMjBDJTIwNC45MzYlMkMyLjUyJTIwMi41MiUyQzQuOTM3JTIwMi4wOCUyQzglMjBIJTIwMSUyMEMlMjAwLjQ0NyUyQzglMjAwJTJDOC40NDglMjAwJTJDOSUyMDAlMkM5LjU1MyUyMDAuNDQ3JTJDMTAlMjAxJTJDMTAlMjBIJTIwMi4wOCUyMEMlMjAyLjUyJTJDMTMuMDYzJTIwNC45MzYlMkMxNS40OCUyMDglMkMxNS45MiUyMFYlMjAxNyUyMGMlMjAwJTJDMC41NTMlMjAwLjQ0NyUyQzElMjAxJTJDMSUyMDAuNTUzJTJDMCUyMDElMkMtMC40NDclMjAxJTJDLTElMjBWJTIwMTUuOTIlMjBDJTIwMTMuMDY0JTJDMTUuNDgxJTIwMTUuNDglMkMxMy4wNjQlMjAxNS45MiUyQzEwJTIwSCUyMDE3JTIwQyUyMDE3LjU1MyUyQzEwJTIwMTglMkM5LjU1MyUyMDE4JTJDOSUyMDE4JTJDOC40NDglMjAxNy41NTMlMkM4JTIwMTclMkM4JTIweiUyME0lMjA5JTJDMTQlMjBDJTIwNi4yNCUyQzE0JTIwNCUyQzExLjc2MiUyMDQlMkM5JTIwNCUyQzYuMjM4JTIwNi4yNCUyQzQlMjA5JTJDNCUyMGMlMjAyLjc2MSUyQzAlMjA1JTJDMi4yMzglMjA1JTJDNSUyMDAlMkMyLjc2MiUyMC0yLjIzOSUyQzUlMjAtNSUyQzUlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDY2lyY2xlJTIwY3glM0QlMjI5JTIyJTIwY3klM0QlMjI5JTIyJTIwciUzRCUyMjMlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDZyUyMGZpbGwlM0QlMjIlMjM0NDQlMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNCUyQzEwLjAwNCUyMEMlMjAxNCUyQzkuODM0JTIwMTMuOTkxJTJDOS42NjclMjAxMy45NzUlMkM5LjUwMiUyMDEzLjcyMyUyQzEyLjAyNyUyMDExLjU5MiUyQzE0JTIwOSUyQzE0JTIwNi40MDglMkMxNCUyMDQuMjc3JTJDMTIuMDI3JTIwNC4wMjUlMkM5LjUwMiUyMDQuMDA5JTJDOS42NjclMjA0JTJDOS44MzQlMjA0JTJDMTAuMDA0JTIwYyUyMDAlMkMyLjc2MiUyMDIuMjQlMkM1JTIwNSUyQzUlMjAyLjc2MSUyQzAlMjA1JTJDLTIuMjM4JTIwNSUyQy01JTIweiUyME0lMjAxMCUyQzMuMDgzJTIwYyUyMDMuMDY0JTJDMC40MzklMjA1LjQ4JTJDMi44NTYlMjA1LjkyJTJDNS45MjElMjBIJTIwMTclMjBjJTIwMC4zNjklMkMwJTIwMC42ODglMkMwLjIwMSUyMDAuODYlMkMwLjQ5OCUyMEMlMjAxNy45NDclMkM5LjM1NCUyMDE4JTJDOS4xODQlMjAxOCUyQzklMjAxOCUyQzguNDQ4JTIwMTcuNTUzJTJDOCUyMDE3JTJDOCUyMEglMjAxNS45MiUyMEMlMjAxNS40OCUyQzQuOTM3JTIwMTMuMDY0JTJDMi41MiUyMDEwJTJDMi4wOCUyMFYlMjAzLjA4MyUyMHolMjBNJTIwMSUyQzkuMDA0JTIwSCUyMDIuMDglMjBDJTIwMi41MiUyQzUuOTM5JTIwNC45MzYlMkMzLjUyMiUyMDglMkMzLjA4MyUyMFYlMjAyLjA4JTIwQyUyMDQuOTM2JTJDMi41MiUyMDIuNTIlMkM0LjkzNyUyMDIuMDglMkM4JTIwSCUyMDElMjBDJTIwMC40NDclMkM4JTIwMCUyQzguNDQ4JTIwMCUyQzklMjAwJTJDOS4xODQlMjAwLjA1MyUyQzkuMzU0JTIwMC4xNCUyQzkuNTAyJTIwMC4zMTIlMkM5LjIwNSUyMDAuNjMxJTJDOS4wMDQlMjAxJTJDOS4wMDQlMjB6JTIwbSUyMDglMkMtOCUyMGMlMjAwLjU1MyUyQzAlMjAxJTJDMC40NDclMjAxJTJDMSUyMFYlMjAxJTIwQyUyMDEwJTJDMC40NDglMjA5LjU1MyUyQzAlMjA5JTJDMCUyMDguNDQ3JTJDMCUyMDglMkMwLjQ0OCUyMDglMkMxJTIwdiUyMDEuMDA0JTIwYyUyMDAlMkMtMC41NTMlMjAwLjQ0NyUyQy0xJTIwMSUyQy0xJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjA5JTJDNyUyMGMlMjAxLjQ4NiUyQzAlMjAyLjcxNyUyQzEuMDgyJTIwMi45NTUlMkMyLjUlMjBDJTIwMTEuOTgyJTJDOS4zMzclMjAxMiUyQzkuMTcxJTIwMTIlMkM5JTIwMTIlMkM3LjM0NCUyMDEwLjY1NiUyQzYlMjA5JTJDNiUyMDcuMzQ0JTJDNiUyMDYlMkM3LjM0NCUyMDYlMkM5JTIwNiUyQzkuMTcxJTIwNi4wMTglMkM5LjMzNyUyMDYuMDQ1JTJDOS41JTIwNi4yODMlMkM4LjA4MiUyMDcuNTE0JTJDNyUyMDklMkM3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0NDQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxOHB4O2hlaWdodDoxOHB4O2JhY2tncm91bmQtc2l6ZToxOHB4IDE4cHh9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTglMjIlMjBoZWlnaHQlM0QlMjIxOCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ2clMjBmaWxsJTNEJTIyJTIzNDI0MjQyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTclMkM4JTIwSCUyMDE1LjkyJTIwQyUyMDE1LjQ4JTJDNC45MzclMjAxMy4wNjQlMkMyLjUyJTIwMTAlMkMyLjA4JTIwViUyMDElMjBDJTIwMTAlMkMwLjQ0OCUyMDkuNTUzJTJDMCUyMDklMkMwJTIwOC40NDclMkMwJTIwOCUyQzAuNDQ4JTIwOCUyQzElMjBWJTIwMi4wOCUyMEMlMjA0LjkzNiUyQzIuNTIlMjAyLjUyJTJDNC45MzclMjAyLjA4JTJDOCUyMEglMjAxJTIwQyUyMDAuNDQ3JTJDOCUyMDAlMkM4LjQ0OCUyMDAlMkM5JTIwMCUyQzkuNTUzJTIwMC40NDclMkMxMCUyMDElMkMxMCUyMEglMjAyLjA4JTIwQyUyMDIuNTIlMkMxMy4wNjMlMjA0LjkzNiUyQzE1LjQ4JTIwOCUyQzE1LjkyJTIwViUyMDE3JTIwYyUyMDAlMkMwLjU1MyUyMDAuNDQ3JTJDMSUyMDElMkMxJTIwMC41NTMlMkMwJTIwMSUyQy0wLjQ0NyUyMDElMkMtMSUyMFYlMjAxNS45MiUyMEMlMjAxMy4wNjQlMkMxNS40ODElMjAxNS40OCUyQzEzLjA2NCUyMDE1LjkyJTJDMTAlMjBIJTIwMTclMjBDJTIwMTcuNTUzJTJDMTAlMjAxOCUyQzkuNTUzJTIwMTglMkM5JTIwMTglMkM4LjQ0OCUyMDE3LjU1MyUyQzglMjAxNyUyQzglMjB6JTIwTSUyMDklMkMxNCUyMEMlMjA2LjI0JTJDMTQlMjA0JTJDMTEuNzYyJTIwNCUyQzklMjA0JTJDNi4yMzglMjA2LjI0JTJDNCUyMDklMkM0JTIwYyUyMDIuNzYxJTJDMCUyMDUlMkMyLjIzOCUyMDUlMkM1JTIwMCUyQzIuNzYyJTIwLTIuMjM5JTJDNSUyMC01JTJDNSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NjaXJjbGUlMjBjeCUzRCUyMjklMjIlMjBjeSUzRCUyMjklMjIlMjByJTNEJTIyMyUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyMzJlMmUyZSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE0JTJDMTAuMDA0JTIwQyUyMDE0JTJDOS44MzQlMjAxMy45OTElMkM5LjY2NyUyMDEzLjk3NSUyQzkuNTAyJTIwMTMuNzIzJTJDMTIuMDI3JTIwMTEuNTkyJTJDMTQlMjA5JTJDMTQlMjA2LjQwOCUyQzE0JTIwNC4yNzclMkMxMi4wMjclMjA0LjAyNSUyQzkuNTAyJTIwNC4wMDklMkM5LjY2NyUyMDQlMkM5LjgzNCUyMDQlMkMxMC4wMDQlMjBjJTIwMCUyQzIuNzYyJTIwMi4yNCUyQzUlMjA1JTJDNSUyMDIuNzYxJTJDMCUyMDUlMkMtMi4yMzglMjA1JTJDLTUlMjB6JTIwTSUyMDEwJTJDMy4wODMlMjBjJTIwMy4wNjQlMkMwLjQzOSUyMDUuNDglMkMyLjg1NiUyMDUuOTIlMkM1LjkyMSUyMEglMjAxNyUyMGMlMjAwLjM2OSUyQzAlMjAwLjY4OCUyQzAuMjAxJTIwMC44NiUyQzAuNDk4JTIwQyUyMDE3Ljk0NyUyQzkuMzU0JTIwMTglMkM5LjE4NCUyMDE4JTJDOSUyMDE4JTJDOC40NDglMjAxNy41NTMlMkM4JTIwMTclMkM4JTIwSCUyMDE1LjkyJTIwQyUyMDE1LjQ4JTJDNC45MzclMjAxMy4wNjQlMkMyLjUyJTIwMTAlMkMyLjA4JTIwViUyMDMuMDgzJTIweiUyME0lMjAxJTJDOS4wMDQlMjBIJTIwMi4wOCUyMEMlMjAyLjUyJTJDNS45MzklMjA0LjkzNiUyQzMuNTIyJTIwOCUyQzMuMDgzJTIwViUyMDIuMDglMjBDJTIwNC45MzYlMkMyLjUyJTIwMi41MiUyQzQuOTM3JTIwMi4wOCUyQzglMjBIJTIwMSUyMEMlMjAwLjQ0NyUyQzglMjAwJTJDOC40NDglMjAwJTJDOSUyMDAlMkM5LjE4NCUyMDAuMDUzJTJDOS4zNTQlMjAwLjE0JTJDOS41MDIlMjAwLjMxMiUyQzkuMjA1JTIwMC42MzElMkM5LjAwNCUyMDElMkM5LjAwNCUyMHolMjBtJTIwOCUyQy04JTIwYyUyMDAuNTUzJTJDMCUyMDElMkMwLjQ0NyUyMDElMkMxJTIwViUyMDElMjBDJTIwMTAlMkMwLjQ0OCUyMDkuNTUzJTJDMCUyMDklMkMwJTIwOC40NDclMkMwJTIwOCUyQzAuNDQ4JTIwOCUyQzElMjB2JTIwMS4wMDQlMjBjJTIwMCUyQy0wLjU1MyUyMDAuNDQ3JTJDLTElMjAxJTJDLTElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDklMkM3JTIwYyUyMDEuNDg2JTJDMCUyMDIuNzE3JTJDMS4wODIlMjAyLjk1NSUyQzIuNSUyMEMlMjAxMS45ODIlMkM5LjMzNyUyMDEyJTJDOS4xNzElMjAxMiUyQzklMjAxMiUyQzcuMzQ0JTIwMTAuNjU2JTJDNiUyMDklMkM2JTIwNy4zNDQlMkM2JTIwNiUyQzcuMzQ0JTIwNiUyQzklMjA2JTJDOS4xNzElMjA2LjAxOCUyQzkuMzM3JTIwNi4wNDUlMkM5LjUlMjA2LjI4MyUyQzguMDgyJTIwNy41MTQlMkM3JTIwOSUyQzclMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzJlMmUyZSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfS5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX3JlcXVlc3RpbmcuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2xvY2F0ZTphY3RpdmU6YWZ0ZXIsLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9yZXF1ZXN0aW5nLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9sb2NhdGU6aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O3dpZHRoOjI0cHg7aGVpZ2h0OjI0cHg7YmFja2dyb3VuZC1pbWFnZTp1cmwoaHR0cHM6Ly9tYXBzLmFwaS4yZ2lzLnJ1LzIuMC9pbWcvc3ByaXRlLmRhcmsucG5nKTtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgMDtiYWNrZ3JvdW5kLXNpemU6NzhweCA2NXB4Oy13ZWJraXQtYW5pbWF0aW9uOkRHTG9jYXRpb25fX2xvY2F0ZUljb25SZXF1ZXN0aW5nQW5pbSAxcyBsaW5lYXIgaW5maW5pdGU7YW5pbWF0aW9uOkRHTG9jYXRpb25fX2xvY2F0ZUljb25SZXF1ZXN0aW5nQW5pbSAxcyBsaW5lYXIgaW5maW5pdGU7aW1hZ2UtcmVuZGVyaW5nOm9wdGltaXplUXVhbGl0eX0ubGVhZmxldC1yZXRpbmEgLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFjdGl2ZTphZnRlciwubGVhZmxldC1yZXRpbmEgLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmFmdGVyLC5sZWFmbGV0LXJldGluYSAubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfcmVxdWVzdGluZy5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfbG9jYXRlOmhvdmVyOmFmdGVye2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL3Nwcml0ZUAyeC5kYXJrLnBuZyk7YmFja2dyb3VuZC1wb3NpdGlvbjowIDA7YmFja2dyb3VuZC1zaXplOjc4cHggNjVweH0uZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2Z1bGxzY3JlZW46YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7bWFyZ2luOmF1dG87Y29udGVudDonJ30uZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX2Z1bGxzY3JlZW46YWN0aXZlOmFmdGVyLC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9mdWxsc2NyZWVuOmhvdmVyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxNiUyMiUyMGhlaWdodCUzRCUyMjE2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzElMjBIJTIwMSUyMFYlMjA2JTIwSCUyMDMlMjBWJTIwMyUyMGglMjAzJTIweiUyMG0lMjA0JTJDMTQlMjBoJTIwNSUyMHYlMjAtNSUyMGglMjAtMiUyMHYlMjAzJTIwSCUyMDEwJTIweiUyME0lMjAxNSUyQzYlMjBWJTIwMSUyMGglMjAtNSUyMHYlMjAyJTIwaCUyMDMlMjBWJTIwNiUyMHolMjBNJTIwMSUyQzEwJTIwdiUyMDUlMjBIJTIwNiUyMFYlMjAxMyUyMEglMjAzJTIwdiUyMC0zJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwZGE0ZDQlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxJTJDMSUyMEglMjA2JTIwViUyMDIlMjBIJTIwMSUyMHolMjBtJTIwOSUyQzAlMjBoJTIwNSUyMHYlMjAxJTIwaCUyMC01JTIweiUyMG0lMjAzJTJDOSUyMGglMjAyJTIwdiUyMDElMjBoJTIwLTIlMjB6JTIwbSUyMC0zJTJDMyUyMGglMjAzJTIwdiUyMDElMjBoJTIwLTMlMjB6JTIwbSUyMC03JTJDMCUyMGglMjAzJTIwdiUyMDElMjBIJTIwMyUyMHolMjBNJTIwMSUyQzEwJTIwaCUyMDIlMjB2JTIwMSUyMEglMjAxJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwYTg0YWIlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxJTJDNiUyMEglMjAzJTIwViUyMDclMjBIJTIwMSUyMHolMjBtJTIwMTIlMkMwJTIwaCUyMDIlMjBWJTIwNyUyMEglMjAxMyUyMHolMjBNJTIwMSUyQzE1JTIwaCUyMDUlMjB2JTIwMSUyMEglMjAxJTIweiUyMG0lMjA5JTJDMCUyMGglMjA1JTIwdiUyMDElMjBoJTIwLTUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjIxNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDElMkMzJTIwSCUyMDYlMjBWJTIwNCUyMEglMjAxJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA2JTJDMSUyMEglMjAxJTIwViUyMDYlMjBIJTIwMyUyMFYlMjAzJTIwaCUyMDMlMjB6JTIwbSUyMDQlMkMxNCUyMGglMjA1JTIwdiUyMC01JTIwaCUyMC0yJTIwdiUyMDMlMjBoJTIwLTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzZjNmM2YyUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDEwJTJDMyUyMGglMjA1JTIwdiUyMDElMjBoJTIwLTUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE1JTJDNiUyMFYlMjAxJTIwaCUyMC01JTIwdiUyMDIlMjBoJTIwMyUyMFYlMjA2JTIweiUyME0lMjAxJTJDMTAlMjB2JTIwNSUyMEglMjA2JTIwViUyMDEzJTIwSCUyMDMlMjB2JTIwLTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzZjNmM2YyUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDElMkMxJTIwSCUyMDYlMjBWJTIwMiUyMEglMjAxJTIweiUyMG0lMjA5JTJDMCUyMGglMjA1JTIwdiUyMDElMjBoJTIwLTUlMjB6JTIwbSUyMDMlMkM5JTIwaCUyMDIlMjB2JTIwMSUyMGglMjAtMiUyMHolMjBtJTIwLTMlMkMzJTIwaCUyMDMlMjB2JTIwMSUyMGglMjAtMyUyMHolMjBtJTIwLTclMkMwJTIwaCUyMDMlMjB2JTIwMSUyMEglMjAzJTIweiUyME0lMjAxJTJDMTAlMjBoJTIwMiUyMHYlMjAxJTIwSCUyMDElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzRiNGI0YiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDElMkM2JTIwSCUyMDMlMjBWJTIwNyUyMEglMjAxJTIweiUyMG0lMjAxMiUyQzAlMjBoJTIwMiUyMFYlMjA3JTIwSCUyMDEzJTIweiUyME0lMjAxJTJDMTUlMjBoJTIwNSUyMHYlMjAxJTIwSCUyMDElMjB6JTIwbSUyMDklMkMwJTIwaCUyMDUlMjB2JTIwMSUyMGglMjAtNSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTZweDtoZWlnaHQ6MTZweDtiYWNrZ3JvdW5kLXNpemU6MTZweCAxNnB4fS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjphY3RpdmU6YWZ0ZXIsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfZnVsbHNjcmVlbjpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjIxNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDEyJTJDOSUyMGglMjA0JTIwdiUyMDclMjBoJTIwLTQlMjB6JTIwbSUyMC0zJTJDMyUyMGglMjA1JTIwdiUyMDQlMjBIJTIwOSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTAlMkMxNSUyMGglMjA1JTIwdiUyMC01JTIwaCUyMC0yJTIwdiUyMDMlMjBoJTIwLTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzI4MjgyOCUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDAlMkM5JTIwaCUyMDQlMjB2JTIwNyUyMEglMjAwJTIweiUyMG0lMjAyJTJDMyUyMGglMjA1JTIwdiUyMDQlMjBIJTIwMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMSUyQzEwJTIwdiUyMDUlMjBIJTIwNiUyMFYlMjAxMyUyMEglMjAzJTIwdiUyMC0zJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyODI4MjglMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAwJTJDMCUyMEglMjA0JTIwViUyMDclMjBIJTIwMCUyMHolMjBtJTIwOSUyQzAlMjBoJTIwNSUyMFYlMjA0JTIwSCUyMDklMjB6JTIwbSUyMDMlMkMwJTIwaCUyMDQlMjB2JTIwNyUyMGglMjAtNCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTUlMkM2JTIwViUyMDElMjBoJTIwLTUlMjB2JTIwMiUyMGglMjAzJTIwdiUyMDMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzI4MjgyOCUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDIlMkMwJTIwSCUyMDclMjBWJTIwNCUyMEglMjAyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA2JTJDMSUyMEglMjAxJTIwViUyMDYlMjBIJTIwMyUyMFYlMjAzJTIwaCUyMDMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzI4MjgyOCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfS5kZy1idWlsZGluZy1jYWxsb3V0X19ib2R5e3Bvc2l0aW9uOnJlbGF0aXZlfS5kZy1idWlsZGluZy1jYWxsb3V0X19saXN0e21hcmdpbi1ib3R0b206OHB4O3BhZGRpbmctbGVmdDoyNHB4O2NvbG9yOiNmZmU2YWE7bGlzdC1zdHlsZTpub25lfS5kZy1idWlsZGluZy1jYWxsb3V0X19saXN0LWl0ZW17cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWJvdHRvbTo0cHg7Zm9udC1zaXplOjEycHh9LmRnLWJ1aWxkaW5nLWNhbGxvdXRfX2xpc3QtaXRlbTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjVweDtsZWZ0Oi0yMXB4O2NvbnRlbnQ6Jyc7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjYlMjIlMjBoZWlnaHQlM0QlMjI2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMyUyQy0wLjAwMiUyMEMlMjA0LjY1NCUyQy0wLjAwMiUyMDUuOTk0JTJDMS4zNDIlMjA1Ljk5NCUyQzMlMjA1Ljk5NCUyQzQuNjU4JTIwNC42NTUlMkM2LjAwMiUyMDMlMkM2LjAwMiUyMDEuMzQ1JTJDNi4wMDIlMjAwLjAwNSUyQzQuNjU4JTIwMC4wMDUlMkMzJTIwMC4wMDUlMkMxLjM0MiUyMDEuMzQ2JTJDLTAuMDAyJTIwMyUyQy0wLjAwMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYWFhJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjZweDtoZWlnaHQ6NnB4O2JhY2tncm91bmQtc2l6ZTo2cHggNnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzc3ttYXJnaW4tYm90dG9tOjEwcHg7Zm9udC1zaXplOjE2cHh9LmRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlKy5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzc3ttYXJnaW4tdG9wOi02cHh9LmRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWhlYWRlcntwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tYm90dG9tOjRweDtwYWRkaW5nLWxlZnQ6MjRweH0uZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtaGVhZGVyOmZpcnN0LWNoaWxkOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NXB4O2xlZnQ6MXB4O2NvbnRlbnQ6Jyd9LmRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWRyaWxsZG93bntwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tYm90dG9tOjRweDtwYWRkaW5nLWxlZnQ6MjRweDtjb2xvcjojYWFhO2ZvbnQtc2l6ZToxMnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcy1kcmlsbGRvd246Zmlyc3QtY2hpbGQ6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDoycHg7bGVmdDoxcHg7Y29udGVudDonJ30uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2V7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWJvdHRvbToxMHB4O3BhZGRpbmctbGVmdDoyNHB4O2ZvbnQtc2l6ZToxNnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzcysuZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2V7bWFyZ2luLXRvcDotNnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjRweDtsZWZ0OjJweDtjb250ZW50OicnfS5kZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZV90eXBlX3N0cmVldDpiZWZvcmV7dG9wOjRweH0uZGctbWFwLWdlb2NsaWNrZXJfX3NpZ2h0LWRlc2NyaXB0aW9ue292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOi41ZW0gMCAwIDI0cHg7bWF4LWhlaWdodDozLjZlbX1hLmRnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbmt7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWxlZnQ6MjRweDtib3JkZXItYm90dG9tOjFweCBkb3R0ZWQ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9YS5kZy1tYXAtZ2VvY2xpY2tlcl9fc2hvdy1tb3JlLXNpZ2h0cy1saW5rOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDo0cHg7bWFyZ2luLWxlZnQ6NXB4O3dpZHRoOjZweDtoZWlnaHQ6MTBweDtjb250ZW50OicnO2ZvbnQtd2VpZ2h0OjcwMH0uZGctbWFwLWdlb2NsaWNrZXJfX2NsYW1wZWQtbGluZXtkaXNwbGF5OmJsb2NrO3doaXRlLXNwYWNlOm5vd3JhcH0uZGctbWFwLWdlb2NsaWNrZXJfX2NsYW1wZWQtbGluZV9sYXN0e292ZXJmbG93OmhpZGRlbjt3aWR0aDoxMDAlO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmRnLW1hcC1nZW9jbGlja2VyX19wcmVsb2FkZXItd3JhcHBlcntkaXNwbGF5OnRhYmxlLWNlbGw7dmVydGljYWwtYWxpZ246bWlkZGxlO3RleHQtYWxpZ246Y2VudGVyfS5kZy1tYXAtZ2VvY2xpY2tlcl9fZHJpbGxkb3due21hcmdpbi1ib3R0b206MTBweH0uZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtZHJpbGxkb3duOmZpcnN0LWNoaWxkOmJlZm9yZSwuZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtaGVhZGVyOmZpcnN0LWNoaWxkOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyOSUyMiUyMGhlaWdodCUzRCUyMjExJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNC45NTglMkMxMSUyMEMlMjA0Ljk1OCUyQzkuMDM2JTIwNi43NTYlMkM2Ljc1MSUyMDguNzE5JTJDNi43NTElMjA4Ljg4NSUyQzYuMjIzJTIwOSUyQzUuNjU2JTIwOSUyQzUuMDYzJTIwOSUyQzIuMjY3JTIwNi45ODUlMkMwJTIwNC41JTJDMCUyMDIuMDE1JTJDMCUyMDAlMkMyLjI2NyUyMDAlMkM1LjA2MyUyMDAlMkM1LjY1NiUyMDAuMTE0JTJDNi4yMjIlMjAwLjI4JTJDNi43NTElMjAyLjI0MyUyQzYuNzUxJTIwNC4wMTglMkM5LjAxMiUyMDQuMDE4JTJDMTElMjBoJTIwMC45NCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTBhMGEwJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6OXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZTo5cHggMTFweH0uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2U6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI4JTIyJTIwaGVpZ2h0JTNEJTIyMTIlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAzLjU4MiUyQzglMjBjJTIwMC4yMTElMkMwJTIwMC43OTglMkMwLjAzNSUyMDElMkMwJTIwdiUyMDQlMjBsJTIwLTIlMkMtMSUyMFYlMjA4JTIwYyUyMDAuMzcyJTJDMC4wNjYlMjAwLjg2MSUyQzAlMjAxJTJDMCUyMHolMjBNJTIwMC40NCUyQzUuMzg0JTIwQyUyMDAuMTYzJTJDNC44NjYlMjAwJTJDNC4yNzYlMjAwJTJDMy42NDYlMjAwJTJDMS42MzMlMjAxLjYwNCUyQzAuMDAyJTIwMy41ODIlMkMwLjAwMiUyMGMlMjAxLjk3OCUyQzAlMjAzLjU4MiUyQzEuNjMxJTIwMy41ODIlMkMzLjY0NCUyMDAlMkMwLjY0NyUyMC0wLjE2OSUyQzEuMjU0JTIwLTAuNDYxJTJDMS43ODElMjBMJTIwNi42NDElMkM1LjQ5NSUyMDYuNjE4JTJDNS41NjclMjBDJTIwNS45NTQlMkM2LjU0OSUyMDQuODQ0JTJDNy4xOTIlMjAzLjU4NCUyQzcuMTkyJTIwMi4yNSUyQzcuMTkyJTIwMS4wODQlMkM2LjQ2NyUyMDAuNDQlMkM1LjM4NCUyMHolMjBNJTIwMi42MTMlMkMxLjI3NiUyMGMlMjAtMC41NDklMkMwJTIwLTAuOTk1JTJDMC40NTMlMjAtMC45OTUlMkMxLjAxMyUyMDAlMkMwLjU1OSUyMDAuNDQ2JTJDMS4wMTMlMjAwLjk5NSUyQzEuMDEzJTIwMC41NTElMkMwJTIwMC45OTYlMkMtMC40NTQlMjAwLjk5NiUyQy0xLjAxMyUyMDAlMkMtMC41NiUyMC0wLjQ0NSUyQy0xLjAxMyUyMC0wLjk5NiUyQy0xLjAxMyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTBhMGEwJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6OHB4O2hlaWdodDoxMnB4O2JhY2tncm91bmQtc2l6ZTo4cHggMTJweH0uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9zdHJlZXQ6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOC44JTJDMCUyMEglMjAzLjE5OSUyMEwlMjAwJTJDMTIlMjBIJTIwMTIlMjBMJTIwOC44JTJDMCUyMHolMjBNJTIwNyUyQzEyJTIwSCUyMDUlMjBWJTIwOSUyMGglMjAyJTIwdiUyMDMlMjB6JTIwTSUyMDclMkM4JTIwSCUyMDUlMjBWJTIwNiUyMEglMjA3JTIwViUyMDglMjB6JTIwTSUyMDclMkM1JTIwSCUyMDUlMjBWJTIwMyUyMEglMjA3JTIwViUyMDUlMjB6JTIwTSUyMDclMkMyJTIwSCUyMDUlMjBWJTIwMCUyMGglMjAyJTIwdiUyMDIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEycHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZC1zaXplOjEycHggMTJweH0uZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9zaWdodDpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjglMjIlMjBoZWlnaHQlM0QlMjIxMiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDclMkMwJTIwSCUyMDIuNTQ3JTIwQyUyMDAuNTQ3JTJDMCUyMDAlMkMwLjgyOCUyMDAlMkMyLjUlMjAwJTJDMy43MzQlMjAwLjUlMkM1JTIwMiUyQzUlMjAzLjM1OSUyQzUlMjA0JTJDMy44NDQlMjA0JTJDMyUyMDQlMkMyLjI4MSUyMDIuODU5JTJDMiUyMDIlMkMyJTIwMiUyQzIuNzY2JTIwMi4yMzQlMkMzJTIwMyUyQzMlMjAzJTJDMy42OSUyMDIuNDglMkM0JTIwMiUyQzQlMjAxLjIzNCUyQzQlMjAxJTJDMy4zMjklMjAxJTJDMi41JTIwMSUyQzEuNjkzJTIwMS4zNzUlMkMxJTIwMi41JTJDMSUyMDQuMzkxJTJDMSUyMDUlMkMxLjY1NiUyMDUlMkMzJTIwNSUyQzQuNiUyMDQuMzM4JTJDNS4xMTklMjAzJTJDNiUyMHYlMjA0JTIwSCUyMDIlMjB2JTIwMiUyMEglMjA4JTIwViUyMDElMjBMJTIwNyUyQzAlMjB6JTIwTSUyMDQlMkMxMCUyMFYlMjA2JTIwbCUyMDElMkMxJTIwdiUyMDMlMjBIJTIwNCUyMHolMjBtJTIwMiUyQzAlMjBWJTIwNiUyMGwlMjAxJTJDMSUyMHYlMjAzJTIwSCUyMDYlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2FhYSUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDo4cHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZC1zaXplOjhweCAxMnB4fS5kZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZV90eXBlX3NldHRsZW1lbnQ6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOSUyQzklMjBDJTIwOC4yMzUlMkM5JTIwNy43NjIlMkM5LjUyMiUyMDcuMjU5JTJDMTAuMDIyJTIwNy43OTUlMkMxMC4zOCUyMDguMDUxJTJDMTEuMDUlMjA3Ljg3OSUyQzEyJTIwSCUyMDEyJTIwQyUyMDEyJTJDMTAuNDYlMjAxMC41MzUlMkM5JTIwOSUyQzklMjB6JTIwbSUyMC0yLjg2OCUyQzEuMjQ4JTIwYyUyMC0wLjk2NSUyQzAlMjAtMS43NDclMkMwLjc4NCUyMC0xLjc0NyUyQzEuNzUxJTIwaCUyMDMuNDk0JTIwYyUyMDAlMkMtMC45NjclMjAtMC43ODIlMkMtMS43NTElMjAtMS43NDclMkMtMS43NTElMjB6JTIwTSUyMDEwJTJDMSUyMFYlMjAwJTIwSCUyMDclMjBWJTIwMSUyMEglMjA1JTIwViUyMDYlMjBMJTIwNiUyQzclMjBWJTIwMiUyMEglMjA3JTIwViUyMDclMjBMJTIwOCUyQzglMjBWJTIwMiUyMGglMjAxJTIwdiUyMDYlMjBoJTIwMSUyMFYlMjAyJTIwaCUyMDElMjB2JTIwNyUyMGwlMjAxJTJDMC42MDclMjBWJTIwMSUyMEglMjAxMCUyMHolMjBNJTIwNi42NiUyQzkuNTM5JTIwNi43MjElMkM5LjQ3OSUyMEMlMjA2LjkwMyUyQzkuMjk3JTIwNy4xMDQlMkM5LjE0JTIwNy4zMTQlMkM5LjAwNCUyMFYlMjA4LjQxNCUyMEwlMjA2LjEzMSUyQzcuMTg3JTIwMyUyQzglMjB2JTIwNCUyMEglMjAzLjYyJTIwQyUyMDMuNjIlMkMxMC42MTIlMjA0Ljc0NyUyQzkuNDgzJTIwNi4xMzIlMkM5LjQ4MyUyMDYuMzEyJTJDOS40ODIlMjA2LjQ5JTJDOS41MDIlMjA2LjY2JTJDOS41MzklMjB6JTIwTSUyMDIlMkMxMiUyMHolMjBNJTIwMSUyQzIlMjAwJTJDNSUyMHYlMjA3JTIwSCUyMDIlMjBWJTIwNSUyMEwlMjAxJTJDMiUyMHolMjBNJTIwMS4xMTElMkM2Ljk1NSUyMEMlMjAwLjgwNCUyQzYuOTU1JTIwMC41NTYlMkM2LjcwNiUyMDAuNTU2JTJDNi40JTIwYyUyMDAlMkMtMC4zMDclMjAwLjI0OCUyQy0wLjU1NSUyMDAuNTU1JTJDLTAuNTU1JTIwMC4zMDclMkMwJTIwMC41NTQlMkMwLjI0OCUyMDAuNTU0JTJDMC41NTUlMjAwJTJDMC4zMDYlMjAtMC4yNDclMkMwLjU1NSUyMC0wLjU1NCUyQzAuNTU1JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMnB4O2hlaWdodDoxMnB4O2JhY2tncm91bmQtc2l6ZToxMnB4IDEycHh9YS5kZy1tYXAtZ2VvY2xpY2tlcl9fc2hvdy1tb3JlLXNpZ2h0cy1saW5re2NvbG9yOiNmZmU2YWF9Lm5vLXRvdWNoIGEuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluazpob3Zlcntjb2xvcjojOWNkfWEuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluazphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyNiUyMiUyMGhlaWdodCUzRCUyMjEwJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwNiUyMDEwJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzUlMjBWJTIwNS40JTIwTCUyMDEuNCUyQzEwJTIwSCUyMDAlMjBMJTIwMCUyQzguNiUyMDMuNiUyQzUlMjAwJTJDMS40JTIwMCUyQzAlMjAxLjQlMkMwJTIwNiUyQzQuNiUyMFYlMjA1JTIwbCUyMDAlMkMwJTIwMCUyQzAlMjAwJTJDMCUyMDAlMkMwJTIwMCUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2FhYSUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctbWFwLWdlb2NsaWNrZXJfX2RyaWxsZG93bntjb2xvcjojYWFhfS5kZy1wcmVsb2FkZXJ7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luOjAgYXV0bzt3aWR0aDoyMDBweDtoZWlnaHQ6NDRweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmRnLXByZWxvYWRlcl9hbmltYXRpb25fZmFsc2V7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKGh0dHBzOi8vbWFwcy5hcGkuMmdpcy5ydS8yLjAvaW1nL0RHUHJlbG9hZGVyX19wcmVsb2FkZXIuZ2lmKTtiYWNrZ3JvdW5kLXNpemU6MTAwcHggMjZweDtiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6c2Nyb2xsO2JhY2tncm91bmQtcG9zaXRpb246NTAlIDUwJX0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2xlZnQ6NTAlO21hcmdpbjotMjJweCAwIDAgLTIycHg7d2lkdGg6NDRweDtoZWlnaHQ6NDRweDtvdXRsaW5lOnRyYW5zcGFyZW50IHNvbGlkIDFweDtjb250ZW50OicnOy13ZWJraXQtYW5pbWF0aW9uOmRnLXByZWxvYWRlcl9fb3V0ZXIgNXMgbGluZWFyIGluZmluaXRlO2FuaW1hdGlvbjpkZy1wcmVsb2FkZXJfX291dGVyIDVzIGxpbmVhciBpbmZpbml0ZTtpbWFnZS1yZW5kZXJpbmc6b3B0aW1pemVRdWFsaXR5fS5kZy1wcmVsb2FkZXJfYW5pbWF0aW9uX3RydWUuZGctcHJlbG9hZGVyX3NpemVfc21hbGw6YmVmb3Jle21hcmdpbjotMTJweCAwIDAgLTEycHg7d2lkdGg6MjRweDtoZWlnaHQ6MjRweH0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlLmRnLXByZWxvYWRlcl9zY2hlbWVfcmVndWxhcjpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjQ0JTIyJTIwaGVpZ2h0JTNEJTIyNDQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAzNS42OCUyQzEwLjMyJTIwQyUyMDM4LjM2OCUyQzEzLjQ2NSUyMDQwJTJDMTcuNTM5JTIwNDAlMkMyMiUyMDQwJTJDMzEuOTQxJTIwMzEuOTQxJTJDNDAlMjAyMiUyQzQwJTIwMTIuMDU5JTJDNDAlMjA0JTJDMzEuOTQxJTIwNCUyQzIyJTIwNCUyQzE3LjUzOSUyMDUuNjMyJTJDMTMuNDY1JTIwOC4zMiUyQzEwLjMyJTIwTCUyMDUuNDglMkM3LjQ4JTIwQyUyMDIuMDclMkMxMS4zNTQlMjAwJTJDMTYuNDM0JTIwMCUyQzIyJTIwMCUyQzM0LjE1JTIwOS44NSUyQzQ0JTIwMjIlMkM0NCUyMDM0LjE1JTJDNDQlMjA0NCUyQzM0LjE1JTIwNDQlMkMyMiUyMDQ0JTJDMTYuNDM0JTIwNDEuOTMlMkMxMS4zNTQlMjAzOC41MiUyQzcuNDglMjBsJTIwLTIuODQlMkMyLjg0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwZGE1ZDUlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA5LjI3MSUyQzkuMjcyJTIwQyUyMDEyLjUyOSUyQzYuMDE1JTIwMTcuMDI5JTJDNCUyMDIyJTJDNCUyMDI2Ljk3MSUyQzQlMjAzMS40NzElMkM2LjAxNSUyMDM0LjcyOSUyQzkuMjcyJTIwTCUyMDM3LjU1NyUyQzYuNDQ0JTIwQyUyMDMzLjU3NSUyQzIuNDYyJTIwMjguMDc1JTJDMCUyMDIyJTJDMCUyMDE1LjkyNSUyQzAlMjAxMC40MjUlMkMyLjQ2MiUyMDYuNDQzJTJDNi40NDQlMjBsJTIwMi44MjglMkMyLjgyOCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTZjZDJhJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7YmFja2dyb3VuZC1zaXplOjQ0cHggNDRweH0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlLmRnLXByZWxvYWRlcl9zY2hlbWVfcmVndWxhci5kZy1wcmVsb2FkZXJfc2l6ZV9zbWFsbDpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjI0JTIyJTIwaGVpZ2h0JTNEJTIyMjQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxOC41NjQlMkM3LjQzNSUyMEMlMjAxOS40NjclMkM4LjczJTIwMjAlMkMxMC4zMDIlMjAyMCUyQzEyJTIwMjAlMkMxNi40MTglMjAxNi40MTglMkMyMCUyMDEyJTJDMjAlMjA3LjU4MiUyQzIwJTIwNCUyQzE2LjQxOCUyMDQlMkMxMiUyMDQlMkMxMC4zMDIlMjA0LjUzMyUyQzguNzMlMjA1LjQzNiUyQzcuNDM1JTIwTCUyMDIuNTgxJTJDNC41ODElMjBDJTIwMC45NjklMkM2LjYyMyUyMDAlMkM5LjE5NSUyMDAlMkMxMiUyMDAlMkMxOC42MjclMjA1LjM3MyUyQzI0JTIwMTIlMkMyNCUyMDE4LjYyNyUyQzI0JTIwMjQlMkMxOC42MjclMjAyNCUyQzEyJTIwMjQlMkM5LjE5NSUyMDIzLjAzMSUyQzYuNjIzJTIwMjEuNDE5JTJDNC41ODElMjBsJTIwLTIuODU1JTJDMi44NTQlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzBkYTVkNSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDEyJTJDMCUyMEMlMjA4LjY4NiUyQzAlMjA1LjY4NiUyQzEuMzQzJTIwMy41MTYlMkMzLjUxNSUyMEwlMjA2LjM0MyUyQzYuMzQzJTIwQyUyMDcuNzkxJTJDNC44OTUlMjA5Ljc5MSUyQzQlMjAxMiUyQzQlMjBjJTIwMi4yMDklMkMwJTIwNC4yMDklMkMwLjg5NSUyMDUuNjU3JTJDMi4zNDMlMjBMJTIwMjAuNDg0JTJDMy41MTUlMjBDJTIwMTguMzE0JTJDMS4zNDMlMjAxNS4zMTQlMkMwJTIwMTIlMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhNmNkMmElMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTtiYWNrZ3JvdW5kLXNpemU6MjRweCAyNHB4fS5kZy1wcmVsb2FkZXJfYW5pbWF0aW9uX3RydWU6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTttYXJnaW46LTE2cHggMCAwIC0xNnB4O3dpZHRoOjMycHg7aGVpZ2h0OjMycHg7b3V0bGluZTp0cmFuc3BhcmVudCBzb2xpZCAxcHg7Y29udGVudDonJzstd2Via2l0LWFuaW1hdGlvbjpkZy1wcmVsb2FkZXJfX2lubmVyIDRzIGxpbmVhciBpbmZpbml0ZTthbmltYXRpb246ZGctcHJlbG9hZGVyX19pbm5lciA0cyBsaW5lYXIgaW5maW5pdGU7aW1hZ2UtcmVuZGVyaW5nOm9wdGltaXplUXVhbGl0eX0uZGctcHJlbG9hZGVyX2FuaW1hdGlvbl90cnVlLmRnLXByZWxvYWRlcl9zaXplX3NtYWxsOmFmdGVye21hcmdpbjotNnB4IDAgMCAtNnB4O3dpZHRoOjEycHg7aGVpZ2h0OjEycHh9LmRnLXByZWxvYWRlcl9hbmltYXRpb25fdHJ1ZS5kZy1wcmVsb2FkZXJfc2NoZW1lX3JlZ3VsYXI6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjMyJTIyJTIwaGVpZ2h0JTNEJTIyMzIlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA2LjU4MSUyQzIzLjQxOSUyMEMlMjA0Ljk2OSUyQzIxLjM3NyUyMDQlMkMxOC44MDQlMjA0JTJDMTYlMjA0JTJDOS4zNzMlMjA5LjM3MyUyQzQlMjAxNiUyQzQlMjBjJTIwNi42MjclMkMwJTIwMTIlMkM1LjM3MyUyMDEyJTJDMTIlMjAwJTJDMi44MDQlMjAtMC45NjklMkM1LjM3NyUyMC0yLjU4MSUyQzcuNDE5JTIwbCUyMDIuODQ3JTJDMi44NDclMjBDJTIwMzAuNTk0JTJDMjMuNDg3JTIwMzIlMkMxOS45MDklMjAzMiUyQzE2JTIwMzIlMkM3LjE2MyUyMDI0LjgzNyUyQzAlMjAxNiUyQzAlMjA3LjE2MyUyQzAlMjAwJTJDNy4xNjMlMjAwJTJDMTYlMjBjJTIwMCUyQzMuOTA5JTIwMS40MDYlMkM3LjQ4NyUyMDMuNzM0JTJDMTAuMjY2JTIwbCUyMDIuODQ3JTJDLTIuODQ3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhNmNkMmElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAyNy4zMTQlMkMyNy4zMTQlMjAyNC40ODYlMkMyNC40ODYlMjBDJTIwMjIuMzE0JTJDMjYuNjU3JTIwMTkuMzE0JTJDMjglMjAxNiUyQzI4JTIwMTIuNjg2JTJDMjglMjA5LjY4NiUyQzI2LjY1NyUyMDcuNTE2JTJDMjQuNDg1JTIwTCUyMDQuNjg4JTJDMjcuMzEzJTIwQyUyMDcuNTgyJTJDMzAuMjA5JTIwMTEuNTgyJTJDMzIlMjAxNiUyQzMyJTIwYyUyMDQuNDE4JTJDMCUyMDguNDE4JTJDLTEuNzkxJTIwMTEuMzE0JTJDLTQuNjg2JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMwZGE1ZDUlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTtiYWNrZ3JvdW5kLXNpemU6MzJweCAzMnB4fS5kZy1wcmVsb2FkZXJfYW5pbWF0aW9uX3RydWUuZGctcHJlbG9hZGVyX3NjaGVtZV9yZWd1bGFyLmRnLXByZWxvYWRlcl9zaXplX3NtYWxsOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMy4xNDElMkM2Ljg2JTIwQyUyMDMuMDU5JTJDNi41ODYlMjAzJTJDNi4zMDElMjAzJTJDNiUyMDMlMkM0LjM0MyUyMDQuMzQzJTJDMyUyMDYlMkMzJTIwNy42NTclMkMzJTIwOSUyQzQuMzQzJTIwOSUyQzYlMjA5JTJDNi4zMDElMjA4Ljk0MSUyQzYuNTg2JTIwOC44NTklMkM2Ljg2JTIwbCUyMDIuMjYlMkMyLjI1OSUyMEMlMjAxMS42NzQlMkM4LjIwOSUyMDEyJTJDNy4xNDQlMjAxMiUyQzYlMjAxMiUyQzIuNjg2JTIwOS4zMTQlMkMwJTIwNiUyQzAlMjAyLjY4NiUyQzAlMjAwJTJDMi42ODYlMjAwJTJDNiUyMDAlMkM3LjE0NCUyMDAuMzI2JTJDOC4yMDklMjAwLjg4MSUyQzkuMTE5JTIwTCUyMDMuMTQxJTJDNi44NiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTZjZDJhJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwNiUyQzEyJTIwYyUyMDEuNjU3JTJDMCUyMDMuMTU3JTJDLTAuNjcyJTIwNC4yNDMlMkMtMS43NTclMjBMJTIwOC4xMjIlMkM4LjEyMiUyMEMlMjA3LjU3OCUyQzguNjY0JTIwNi44MjglMkM5JTIwNiUyQzklMjA1LjE3MiUyQzklMjA0LjQyMiUyQzguNjY0JTIwMy44NzklMkM4LjEyMSUyMEwlMjAxLjc1OCUyQzEwLjI0MiUyMEMlMjAyLjg0MyUyQzExLjMyOCUyMDQuMzQzJTJDMTIlMjA2JTJDMTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzBkYTVkNSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO2JhY2tncm91bmQtc2l6ZToxMnB4IDEycHh9QC13ZWJraXQta2V5ZnJhbWVzIGRnLXByZWxvYWRlcl9fb3V0ZXJ7dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIGRnLXByZWxvYWRlcl9fb3V0ZXJ7dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1ALXdlYmtpdC1rZXlmcmFtZXMgZGctcHJlbG9hZGVyX19pbm5lcnt0b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoLTM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgtMzYwZGVnKX19QGtleWZyYW1lcyBkZy1wcmVsb2FkZXJfX2lubmVye3Rvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKC0zNjBkZWcpfX0uZGctcG9wdXBfX2Zvb3Rlci1idXR0b25ze2Rpc3BsYXk6dGFibGU7bWFyZ2luLXRvcDoxMHB4O3dpZHRoOjEwMCV9LmRnLXBvcHVwX19mb290ZXItYnV0dG9uLXdyYXBwZXJ7ZGlzcGxheTp0YWJsZS1jZWxsfS5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbntwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7bWFyZ2luLWxlZnQ6NSU7d2lkdGg6OTUlO2JvcmRlci1yYWRpdXM6MnB4O3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO2ZvbnQ6MTJweC8yNHB4IEFyaWFsLHNhbnMtc2VyaWY7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMXM7dHJhbnNpdGlvbjphbGwgLjFzfS5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbi13cmFwcGVyOmZpcnN0LWNoaWxkIC5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbnttYXJnaW46MDt3aWR0aDoxMDAlfS5uby10b3VjaCAuZGctcG9wdXBfX2Zvb3Rlci1idXR0b246aG92ZXJ7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnM7dHJhbnNpdGlvbjphbGwgLjJzfS5kZy1wb3B1cF9fZm9vdGVyLWljb24tYnV0dG9uOmJlZm9yZXtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW46LTJweCA1cHggMCAwO3dpZHRoOjEycHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2NvbnRlbnQ6Jyc7dmVydGljYWwtYWxpZ246bWlkZGxlfS5kZy1wb3B1cF9fYnV0dG9uX25hbWVfYmFjazpiZWZvcmUsLmRnLXBvcHVwX19idXR0b25fbmFtZV9maXJtLWNhcmQtYmFjazpiZWZvcmUsLmRnLXBvcHVwX19idXR0b25fbmFtZV9maXJtLWxpc3QtYmFjazpiZWZvcmV7d2lkdGg6OXB4O2hlaWdodDo2cHh9LmRnLXBvcHVwX19zaG93LWxlc3MtaG91c2UtbGlua3twb3NpdGlvbjpyZWxhdGl2ZTt0b3A6NnB4O21hcmdpbjowIDE1cHggMTBweDtjb2xvcjojMDA3MGMwO3RleHQtZGVjb3JhdGlvbjpub25lO2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjI0cHh9LmRnLXBvcHVwX19oZWFkZXItbGlua3N7bWFyZ2luOjhweCAxOHB4IDAgMH0uZGctcG9wdXBfX2hlYWRlci10aXRsZV9mb3JfZmlybWNhcmR7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO21heC1oZWlnaHQ6My40ZW19LmRnLXBvcHVwX19oZWFkZXItdGVhc2Vye2Rpc3BsYXk6LXdlYmtpdC1ib3g7aGVpZ2h0OjMuM2VtOy13ZWJraXQtbGluZS1jbGFtcDozOy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbH0uZGctcG9wdXBfX2hlYWRlci10aXRsZXtkaXNwbGF5OmJsb2NrO3doaXRlLXNwYWNlOm5vcm1hbDtmb250OjIycHgvMjRweCAnQXJpYWwgbmFycm93JyxBcmlhbCxzYW5zLXNlcmlmfS5kZy1wb3B1cF9faGVhZGVyLWxpbmt7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6Mi42ZW07dmVydGljYWwtYWxpZ246bWlkZGxlO3doaXRlLXNwYWNlOm5vd3JhcH0uZGctcG9wdXBfX2hlYWRlci1saW5rOmZpcnN0LWNoaWxke21hcmdpbi1sZWZ0OjEuMmVtfS5kZy1wb3B1cF9fcmF0aW5ne2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowIC40ZW0gM3B4IDA7d2lkdGg6NzBweDtoZWlnaHQ6MTRweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmRnLXBvcHVwX19yYXRpbmctc3RhcnN7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTQlMjIlMjBoZWlnaHQlM0QlMjIxNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDYuOTk5JTJDMCUyMDguNzQ4JTJDNC45ODklMjAxMy45OTclMkM0Ljk5MSUyMDkuODMlMkM4LjcwOCUyMDExLjMyNCUyQzE0LjAwMiUyMDYuOTk5JTJDMTAuODcxJTIwMi42NzQlMkMxNC4wMDIlMjA0LjE2OCUyQzguNzA4JTIwMCUyQzQuOTkxJTIwNS4yNDklMkM0Ljk4OSUyMDYuOTk5JTJDMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZjODRiJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7ZmxvYXQ6bGVmdDtoZWlnaHQ6MTAwJX0uZGctcG9wdXBfX2xpbmt7cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgYm90dG9tO2JhY2tncm91bmQtc2l6ZToxMHB4IDFweDtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDt0ZXh0LWRlY29yYXRpb246bm9uZTstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmRnLXBvcHVwX19saW5rX3R5cGVfZmxhbXBfcmV2aWV3c3ttYXJnaW4tbGVmdDouMWVtfS5kZy1wb3B1cF9fbGlua190eXBlX3Bob3RvczpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjJweDtsZWZ0Oi0xOHB4O2Rpc3BsYXk6aW5oZXJpdDtjb250ZW50OicnfS5kZy1wb3B1cF9fbGlua190eXBlX2Jvb2tsZXQ6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEwJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMCUyQzglMjAzJTJDMiUyMFYlMjAyJTIwTCUyMDAlMkMwJTIwViUyMDglMjB6JTIwTSUyMDQlMkMxMCUyMDglMkM4JTIwViUyMDAlMjBMJTIwNCUyQzIlMjB2JTIwOCUyMHolMjBNJTIwOSUyQzAlMjB2JTIwOCUyMGwlMjAzJTJDMiUyMFYlMjAyJTIwTCUyMDklMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3ZGM4MTQlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTJweDtoZWlnaHQ6MTBweDtiYWNrZ3JvdW5kLXNpemU6MTJweCAxMHB4O3Bvc2l0aW9uOmFic29sdXRlO3RvcDoycHg7bGVmdDotMThweDtkaXNwbGF5OmluaGVyaXQ7Y29udGVudDonJ31hLmRnLXBvcHVwX19saW5re2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AscmlnaHQgdG9wLGZyb20ocmdiYSgyNTUsMjMwLDE3MCwuMykpLHRvKHJnYmEoMjU1LDIzMCwxNzAsLjMpKSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LHJnYmEoMjU1LDIzMCwxNzAsLjMpLHJnYmEoMjU1LDIzMCwxNzAsLjMpIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMjU1LDIzMCwxNzAsLjMpLHJnYmEoMjU1LDIzMCwxNzAsLjMpIDEwMCUpO2NvbG9yOiNmZmU2YWF9Lm5vLXRvdWNoIGEuZGctcG9wdXBfX2xpbms6aG92ZXJ7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbShyZ2JhKDE1MywyMDQsMjIxLC4zKSksdG8ocmdiYSgxNTMsMjA0LDIyMSwuMykpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQscmdiYSgxNTMsMjA0LDIyMSwuMykscmdiYSgxNTMsMjA0LDIyMSwuMykgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgxNTMsMjA0LDIyMSwuMykscmdiYSgxNTMsMjA0LDIyMSwuMykgMTAwJSk7Y29sb3I6IzljZH0uZGctcG9wdXBfX2hlYWRlci10aXRsZXtjb2xvcjojZmZjODRifS5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbi13cmFwcGVyIC5kZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbiwuZGctcG9wdXBfX2Zvb3Rlci1idXR0b24td3JhcHBlciAuZGctcG9wdXBfX2Zvb3Rlci1idXR0b246aG92ZXJ7Y29sb3I6I2U2ZTZlNn0uZGctcG9wdXBfX2Zvb3Rlci1idXR0b257YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4yKTstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggcmdiYSgwLDAsMCwuMSk7Ym94LXNoYWRvdzowIDFweCByZ2JhKDAsMCwwLC4xKX0ubm8tdG91Y2ggLmRnLXBvcHVwX19mb290ZXItYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6IzIyMjstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggM3B4IHJnYmEoMCwwLDAsLjUpO2JveC1zaGFkb3c6MCAxcHggM3B4IHJnYmEoMCwwLDAsLjUpfS5kZy1wb3B1cF9fcmF0aW5ne2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjE0JTIyJTIwaGVpZ2h0JTNEJTIyMTQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA3LjAwMiUyQzAlMjA4Ljc1MSUyQzQuOTg5JTIwMTQlMkM0Ljk5MSUyMDkuODMzJTJDOC43MDglMjAxMS4zMjclMkMxNC4wMDIlMjA3LjAwMiUyQzEwLjg3MSUyMDIuNjc3JTJDMTQuMDAyJTIwNC4xNzElMkM4LjcwOCUyMDAuMDAzJTJDNC45OTElMjA1LjI1MiUyQzQuOTg5JTIwNy4wMDIlMkMwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhYWElMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctcG9wdXBfX2xpbmtfdHlwZV9waG90b3M6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEwJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTElMkMxJTIwSCUyMDEwJTIwTCUyMDklMkMwJTIwSCUyMDYlMjBMJTIwNSUyQzElMjBIJTIwMSUyMEwlMjAwJTJDMiUyMHYlMjA3JTIwbCUyMDElMkMxJTIwSCUyMDExJTIwTCUyMDEyJTJDOSUyMFYlMjAyJTIwTCUyMDExJTJDMSUyMHolMjBNJTIwMyUyQzQlMjBIJTIwMiUyMFYlMjAzJTIwaCUyMDElMjB2JTIwMSUyMHolMjBtJTIwNC41MTglMkMzLjk5MiUyMGMlMjAtMS4zODElMkMwJTIwLTIuNSUyQy0xLjExOSUyMC0yLjUlMkMtMi41JTIwMCUyQy0xLjM4JTIwMS4xMTklMkMtMi41JTIwMi41JTJDLTIuNSUyMDEuMzglMkMwJTIwMi41JTJDMS4xMiUyMDIuNSUyQzIuNSUyMDAlMkMxLjM4MSUyMC0xLjEyMSUyQzIuNSUyMC0yLjUlMkMyLjUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzc5YjBiYyUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMnB4O2hlaWdodDoxMHB4O2JhY2tncm91bmQtc2l6ZToxMnB4IDEwcHh9LmRnLXBvcHVwX19idXR0b25fbmFtZV9maXJtLWNhcmQtYmFjazpiZWZvcmUsLmRnLXBvcHVwX19idXR0b25fbmFtZV9maXJtLWxpc3QtYmFjazpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjklMjIlMjBoZWlnaHQlM0QlMjI2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzMlMjA0JTJDNiUyMFYlMjA0JTIwSCUyMDklMjBWJTIwMiUyMEglMjA0JTIwViUyMDAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzlmOWY5ZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpfS5kZy1wb3B1cF9fYnV0dG9uX25hbWVfYmFjazpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjklMjIlMjBoZWlnaHQlM0QlMjI2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzMlMjA0JTJDNiUyMFYlMjA0JTIwSCUyMDklMjBWJTIwMiUyMEglMjA0JTIwViUyMDAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzlmOWY5ZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjlweDtoZWlnaHQ6NnB4O2JhY2tncm91bmQtc2l6ZTo5cHggNnB4fS5kZy1wb3B1cF9fYnV0dG9uX25hbWVfZ290bzpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjIwJTIyJTIwaGVpZ2h0JTNEJTIyNyUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE2LjUlMkMwJTIwQyUyMDE0LjczOCUyQzAlMjAxMy4yOTUlMkMxLjMwNiUyMDEzLjA1MSUyQzMlMjBIJTIwNC45NDklMjBDJTIwNC43MTglMkMxLjg1OCUyMDMuNzElMkMxJTIwMi41JTJDMSUyMDEuMTE5JTJDMSUyMDAlMkMyLjExOSUyMDAlMkMzLjUlMjAwJTJDNC44ODElMjAxLjExOSUyQzYlMjAyLjUlMkM2JTIwMy43MSUyQzYlMjA0LjcxOCUyQzUuMTQyJTIwNC45NDklMkM0JTIwaCUyMDguMTAyJTIwQyUyMDEzLjI5NSUyQzUuNjkzJTIwMTQuNzM5JTJDNyUyMDE2LjUlMkM3JTIwMTguNDMzJTJDNyUyMDIwJTJDNS40MzMlMjAyMCUyQzMuNSUyMDIwJTJDMS41NjYlMjAxOC40MzMlMkMwJTIwMTYuNSUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzlmOWY5ZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjIwcHg7aGVpZ2h0OjdweDtiYWNrZ3JvdW5kLXNpemU6MjBweCA3cHh9LmRnLXBvcHVwX19idXR0b25fbmFtZV9zaG93LWVudHJhbmNlOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTIlMjIlMjBoZWlnaHQlM0QlMjIxMiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDUlMkM5JTIwOSUyQzYlMjA1JTJDMyUyMFYlMjA1JTIwSCUyMDAlMjBWJTIwNyUyMEglMjA1JTIwViUyMDklMjB6JTIwTSUyMDkuNiUyQzAlMjBIJTIwMi40JTIwQyUyMDEuMDc0JTJDMCUyMDAlMkMxLjA3NCUyMDAlMkMyLjQlMjBWJTIwNCUyMEglMjAyJTIwViUyMDMuNiUyMEMlMjAyJTJDMi43MTYlMjAyLjcxNiUyQzIlMjAzLjYlMkMyJTIwSCUyMDguNCUyMEMlMjA5LjI4MyUyQzIlMjAxMCUyQzIuNzE2JTIwMTAlMkMzLjYlMjBWJTIwOC40JTIwQyUyMDEwJTJDOS4yODQlMjA5LjI4MyUyQzEwJTIwOC40JTJDMTAlMjBIJTIwMy42JTIwQyUyMDIuNzE2JTJDMTAlMjAyJTJDOS4yODQlMjAyJTJDOC40JTIwViUyMDglMjBIJTIwMCUyMFYlMjA5LjYlMjBDJTIwMCUyQzEwLjkyNSUyMDEuMDc0JTJDMTIlMjAyLjQlMkMxMiUyMEglMjA5LjYlMjBDJTIwMTAuOTI2JTJDMTIlMjAxMiUyQzEwLjkyNSUyMDEyJTJDOS42JTIwViUyMDIuNCUyMEMlMjAxMiUyQzEuMDc0JTIwMTAuOTI2JTJDMCUyMDkuNiUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctZmlybS1jYXJkX19pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmctbGVmdDoyNHB4fS5kZy1maXJtLWNhcmRfX2ljb246YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDttYXJnaW46YXV0bztiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgNTAlO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtjb250ZW50OicnfS5kZy1maXJtLWNhcmRfX2xpbmt7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206NHB4O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwO3dvcmQtd3JhcDpub3JtYWw7bGluZS1oZWlnaHQ6MTZweH0uZGctZmlybS1jYXJkX19saW5rIGF7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgYm90dG9tO2JhY2tncm91bmQtc2l6ZToxMHB4IDFweDtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDt0ZXh0LWRlY29yYXRpb246bm9uZX0uZGctZmlybS1jYXJkX19hZGRyZXNze21hcmdpbi1ib3R0b206MTBweDtmb250LXNpemU6MTZweH0uZGctZmlybS1jYXJkX19hZGRyZXNzOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NXB4O2xlZnQ6MXB4O2NvbnRlbnQ6Jyd9LmRnLWZpcm0tY2FyZF9fY29tbWVudHtwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tbGVmdDo1cHg7Zm9udC1zaXplOjEycHh9LmRnLWZpcm0tY2FyZF9fcGhvbmV7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206NHB4O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7bGluZS1oZWlnaHQ6MTZweH0uZGctZmlybS1jYXJkX19waG9uZTpiZWZvcmV7dG9wOjNweDtsZWZ0OjFweH0uZGctZmlybS1jYXJkX19zaXRlOmJlZm9yZXt0b3A6M3B4fS5kZy1maXJtLWNhcmRfX2VtYWlsOmJlZm9yZXt0b3A6NXB4fS5kZy1maXJtLWNhcmRfX3J1YnJpY3N7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206NHB4O2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjE2cHh9LmRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0e21hcmdpbjowO3BhZGRpbmc6MDtsaXN0LXN0eWxlOm5vbmV9LmRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0LWl0ZW17ZGlzcGxheTppbmxpbmU7Y3Vyc29yOmRlZmF1bHR9LmRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0LWl0ZW06YmVmb3Jle2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowIDRweDtjb250ZW50OifigKInfS5kZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdC1pdGVtOmZpcnN0LWNoaWxkOmJlZm9yZXttYXJnaW46MDtjb250ZW50OicnfS5kZy1maXJtLWNhcmRfX2Fhe21hcmdpbjowIDAgNHB4O3BhZGRpbmc6MCAwIDAgMjRweDtmb250LXNpemU6MTJweH0uZGctZmlybS1jYXJkX19hYS1saXN0e2Rpc3BsYXk6aW5saW5lO21hcmdpbjowO3BhZGRpbmc6MDtsaXN0LXN0eWxlOm5vbmU7bGluZS1oZWlnaHQ6MTZweH0uZGctZmlybS1jYXJkX19hYS1saXN0LWl0ZW17ZGlzcGxheTppbmxpbmU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O21heC13aWR0aDoxMDAlO2N1cnNvcjpkZWZhdWx0fS5kZy1maXJtLWNhcmRfX2FhLWxpc3QtaXRlbTpiZWZvcmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luOjAgNHB4O2NvbnRlbnQ6J+KAoid9LmRnLWZpcm0tY2FyZF9fYWEtbGlzdC1pdGVtOmZpcnN0LWNoaWxkOmJlZm9yZXttYXJnaW46MDtjb250ZW50OicnfS5kZy1maXJtLWNhcmRfX2FhLWxpc3QtYWRkaXRpb25hbHtkaXNwbGF5OmlubGluZTttYXJnaW46MDtwYWRkaW5nOjA7bGlzdC1zdHlsZTpub25lO2xpbmUtaGVpZ2h0OjE2cHh9LmRnLWZpcm0tY2FyZF9fc2NoZWR1bGV7bWFyZ2luLWJvdHRvbToxMHB4fS5kZy1maXJtLWNhcmRfX2xpbmsgYXtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKHJnYmEoMjU1LDIzMCwxNzAsLjMpKSx0byhyZ2JhKDI1NSwyMzAsMTcwLC4zKSkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCxyZ2JhKDI1NSwyMzAsMTcwLC4zKSxyZ2JhKDI1NSwyMzAsMTcwLC4zKSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byByaWdodCxyZ2JhKDI1NSwyMzAsMTcwLC4zKSxyZ2JhKDI1NSwyMzAsMTcwLC4zKSAxMDAlKTtjb2xvcjojZmZlNmFhfS5uby10b3VjaCAuZGctZmlybS1jYXJkX19saW5rIGE6aG92ZXJ7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbShyZ2JhKDE1MywyMDQsMjIxLC4zKSksdG8ocmdiYSgxNTMsMjA0LDIyMSwuMykpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQscmdiYSgxNTMsMjA0LDIyMSwuMykscmdiYSgxNTMsMjA0LDIyMSwuMykgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgxNTMsMjA0LDIyMSwuMykscmdiYSgxNTMsMjA0LDIyMSwuMykgMTAwJSk7Y29sb3I6IzljZH0uZGctZmlybS1jYXJkX19jb21tZW50LC5kZy1maXJtLWNhcmRfX3J1YnJpY3N7Y29sb3I6I2FhYX0uZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3QtaXRlbTphZnRlcntjb2xvcjojNmU2OTY0fS5kZy1maXJtLWNhcmRfX2FhLWxpc3QtaXRlbTphZnRlcntjb2xvcjojZTZlNmU2fS5kZy1maXJtLWNhcmRfX2FkZHJlc3M6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjI5JTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA0Ljk1OCUyQzExJTIwQyUyMDQuOTU4JTJDOS4wMzYlMjA2Ljc1NiUyQzYuNzUxJTIwOC43MTklMkM2Ljc1MSUyMDguODg1JTJDNi4yMjMlMjA5JTJDNS42NTYlMjA5JTJDNS4wNjMlMjA5JTJDMi4yNjclMjA2Ljk4NSUyQzAlMjA0LjUlMkMwJTIwMi4wMTUlMkMwJTIwMCUyQzIuMjY3JTIwMCUyQzUuMDYzJTIwMCUyQzUuNjU2JTIwMC4xMTQlMkM2LjIyMiUyMDAuMjglMkM2Ljc1MSUyMDIuMjQzJTJDNi43NTElMjA0LjAxOCUyQzkuMDEyJTIwNC4wMTglMkMxMSUyMGglMjAwLjk0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDo5cHg7aGVpZ2h0OjExcHg7YmFja2dyb3VuZC1zaXplOjlweCAxMXB4fS5kZy1maXJtLWNhcmRfX3Bob25lOmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTAlMjIlMjBoZWlnaHQlM0QlMjIxMCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDkuMTgxJTJDOS4wNSUyMEMlMjA4LjY3MyUyQzkuNTU2JTIwOC4wNDclMkM5Ljg3MyUyMDcuMzkxJTJDMTAlMjA2LjE1NiUyQzkuODQxJTIwNS4wMDglMkM5LjQxNyUyMDMuOTk4JTJDOC43ODglMjBMJTIwMS4yOTMlMkM2LjA5MiUyMEMlMjAwLjYzOSUyQzUuMDUzJTIwMC4yMDMlMkMzLjg2NSUyMDAuMDUyJTJDMi41ODklMjAwLjE5JTJDMS45NjQlMjAwLjQ5NCUyQzEuMzY4JTIwMC45ODMlMkMwLjg4MiUyMEwlMjAxLjgwMyUyQzAuMDY1JTIwMy45ODclMkMyLjI0MSUyMFYlMjAyLjc5JTIwTCUyMDMuNDQxJTJDMy4zMzIlMjBjJTIwLTAuNDUyJTJDMC40NTElMjAtMC40NTMlMkMxLjE4MyUyMDAlMkMxLjYzNCUyMEwlMjA1LjA4MiUyQzYuNiUyMGMlMjAwLjQ1MiUyQzAuNDUxJTIwMS4xODclMkMwLjQ1MSUyMDEuNjM5JTJDMCUyMEwlMjA3LjI0NCUyQzYuMDc5JTIwSCUyMDcuODM4JTIwTCUyMDEwJTJDOC4yMzMlMjA5LjE4MSUyQzkuMDUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMHB4O2hlaWdodDoxMHB4O2JhY2tncm91bmQtc2l6ZToxMHB4IDEwcHh9LmRnLWZpcm0tY2FyZF9fc2l0ZTpiZWZvcmV7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjExJTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA1LjUlMkMxMSUyMEMlMjAyLjQ2MyUyQzExJTIwMCUyQzguNTM4JTIwMCUyQzUuNSUyMDAlMkMyLjQ2MiUyMDIuNDYzJTJDMCUyMDUuNSUyQzAlMjA4LjUzNyUyQzAlMjAxMSUyQzIuNDYyJTIwMTElMkM1LjUlMjAxMSUyQzguNTM4JTIwOC41MzclMkMxMSUyMDUuNSUyQzExJTIweiUyMG0lMjAwJTJDLTklMjBDJTIwMy41NjYlMkMyJTIwMiUyQzMuNTY3JTIwMiUyQzUuNSUyMDIlMkM3LjQzMyUyMDMuNTY2JTJDOSUyMDUuNSUyQzklMjA1LjY1NSUyQzklMjA1LjgwNCUyQzguOTc0JTIwNS45NTQlMkM4Ljk1NCUyMEwlMjAzJTJDNiUyMFYlMjA1JTIwTCUyMDUuNTcxJTJDMy4yODYlMjA1Ljk4NCUyQzIuMDQ5JTIwQyUyMDUuODI0JTJDMi4wMjYlMjA1LjY2NiUyQzIlMjA1LjUlMkMyJTIweiUyME0lMjA4Ljk0OSUyQzUlMjBIJTIwNy4zNzUlMjBDJTIwNy4wMjElMkM1LjUwNSUyMDYuNTQ1JTJDNi4wODIlMjA2JTJDNi40OTclMjBWJTIwOC45NSUyMEMlMjA3LjY5MyUyQzguNzA1JTIwOSUyQzcuMjYyJTIwOSUyQzUuNSUyMDklMkM1LjMyOSUyMDguOTc0JTJDNS4xNjUlMjA4Ljk0OSUyQzUlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZToxMXB4IDExcHh9LmRnLWZpcm0tY2FyZF9fZW1haWw6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMSUyMiUyMGhlaWdodCUzRCUyMjclMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxMSUyQzEuNTU1JTIwdiUyMDMuODklMjBDJTIwMTElMkM2LjMwMyUyMDEwLjI0MiUyQzclMjA5LjMwOSUyQzclMjBIJTIwMS42OTIlMjBDJTIwMC43NTglMkM3JTIwMCUyQzYuMzAzJTIwMCUyQzUuNDQ0JTIwViUyMDEuNTU0JTIwTCUyMDUuNSUyQzQuODI2JTIwMTElMkMxLjU1NSUyMHolMjBNJTIwMC4xOTElMkMwJTIwSCUyMDEwLjgwOCUyMEwlMjA1LjUlMkMzLjExMSUyMDAuMTkxJTJDMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYWFhJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjExcHg7aGVpZ2h0OjdweDtiYWNrZ3JvdW5kLXNpemU6MTFweCA3cHh9LmRnLXNjaGVkdWxlX190b2RheXtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tbGVmdDoyNHB4O21heC13aWR0aDo4NCU7YmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXIgYm90dG9tO2JhY2tncm91bmQtc2l6ZToycHggMXB4O2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjE2cHg7Y3Vyc29yOnBvaW50ZXJ9LmRnLXNjaGVkdWxlX190b2RheTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjNweDtsZWZ0Oi0yNHB4O2NvbnRlbnQ6Jyd9LmRnLXNjaGVkdWxlX190b2RheTphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMTVweDtib3R0b206NHB4O2NvbnRlbnQ6Jyd9LmRnLXNjaGVkdWxlX190b2RheS1pbm5lcntvdmVyZmxvdzpoaWRkZW47d2lkdGg6MTAwJTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcH0uZGctc2NoZWR1bGVfd29ya3MtZXZlcnlkYXlfdHJ1ZSAuZGctc2NoZWR1bGVfX3RvZGF5e2JhY2tncm91bmQtaW1hZ2U6bm9uZTtjdXJzb3I6ZGVmYXVsdH0uZGctc2NoZWR1bGVfd29ya3MtZXZlcnlkYXlfdHJ1ZSAuZGctc2NoZWR1bGVfX3RvZGF5OmFmdGVye2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uZGctc2NoZWR1bGVfb3Blbl90cnVlIC5kZy1zY2hlZHVsZV9fdG9kYXk6YmVmb3Jle2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMSUyMiUyMGhlaWdodCUzRCUyMjExJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNS41JTJDMTElMjBDJTIwMi40NjMlMkMxMSUyMDAlMkM4LjUzNyUyMDAlMkM1LjUlMjAwJTJDMi40NjIlMjAyLjQ2MyUyQzAlMjA1LjUlMkMwJTIwOC41MzclMkMwJTIwMTElMkMyLjQ2MiUyMDExJTJDNS41JTIwMTElMkM4LjUzNyUyMDguNTM3JTJDMTElMjA1LjUlMkMxMSUyMHolMjBNJTIwNiUyQzUuMjkzJTIwViUyMDIlMjBIJTIwNSUyMFYlMjA1LjcwNyUyMEwlMjA3LjY0NiUyQzguMzUzJTIwOC4zNTMlMkM3LjY0NiUyMDYlMkM1LjI5MyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNzBiZjAwJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjExcHg7aGVpZ2h0OjExcHg7YmFja2dyb3VuZC1zaXplOjExcHggMTFweH0uZGctc2NoZWR1bGVfX25vd3ttYXJnaW46MnB4IDdweCAwIDM2cHg7Zm9udC1zaXplOjEycHh9LmRnLXNjaGVkdWxlX19zdHJpbmd7cGFkZGluZzozcHggMTZweCAzcHggMjRweDt0ZXh0LWFsaWduOmxlZnQ7Zm9udC1zaXplOjE0cHh9LmRnLXNjaGVkdWxlX19zdHJpbmctdGltZXt3aGl0ZS1zcGFjZTpub3dyYXB9LmRnLXNjaGVkdWxlX190YWJsZXtkaXNwbGF5Om5vbmU7dGV4dC1hbGlnbjpjZW50ZXI7Zm9udC1zaXplOjB9LmRnLXNjaGVkdWxlX190YWJsZS1jZWxsLWdyb3Vwe3doaXRlLXNwYWNlOm5vd3JhcH0uZGctc2NoZWR1bGVfX3Rje2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MnB4IDAgMTVweDt3aWR0aDo0NHB4O3ZlcnRpY2FsLWFsaWduOnRvcDt3aGl0ZS1zcGFjZTpub3JtYWw7Zm9udC1zaXplOjE0cHh9LmRnLXNjaGVkdWxlX190Y19wcmV7d2lkdGg6MTlweH0uZGctc2NoZWR1bGVfX2RheS1uYW1le21hcmdpbjowO2NvbG9yOiM4Yzg3ODI7dGV4dC10cmFuc2Zvcm06Y2FwaXRhbGl6ZX0uZGctc2NoZWR1bGVfX3Rke21hcmdpbjoxMHB4IDAgMH0uZGctc2NoZWR1bGVfc3RhdGVfZXhwYW5kZWQgLmRnLXNjaGVkdWxlX19wb3B1cHtkaXNwbGF5OmJsb2NrO3Zpc2liaWxpdHk6dmlzaWJsZTttYXgtaGVpZ2h0OjEwMDBweDtvcGFjaXR5OjF9LmRnLXNjaGVkdWxlX190YWJsZS1jbG9ja3ttYXJnaW46MTNweCAwIDB9LmRnLXNjaGVkdWxlX190YWJsZS1sdW5jaHttYXJnaW46MzFweCAwIDB9LmRnLXNjaGVkdWxlX190b2RheXtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKHJnYmEoMjMwLDIzMCwyMzAsLjU1KSksY29sb3Itc3RvcCg1MCUscmdiYSgyMzAsMjMwLDIzMCwuNTUpKSxjb2xvci1zdG9wKDUxJSxyZ2JhKDAsMCwwLDApKSx0byhyZ2JhKDAsMCwwLDApKSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LHJnYmEoMjMwLDIzMCwyMzAsLjU1KSxyZ2JhKDIzMCwyMzAsMjMwLC41NSkgNTAlLHJnYmEoMCwwLDAsMCkgNTElLHJnYmEoMCwwLDAsMCkgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgyMzAsMjMwLDIzMCwuNTUpLHJnYmEoMjMwLDIzMCwyMzAsLjU1KSA1MCUscmdiYSgwLDAsMCwwKSA1MSUscmdiYSgwLDAsMCwwKSAxMDAlKX0uZGctc2NoZWR1bGVfX25vd3tjb2xvcjojYWFhfS5kZy1zY2hlZHVsZV9fdGR7Y29sb3I6I2U2ZTZlNn0uZGctc2NoZWR1bGVfX3RjX2FjdGl2ZV90cnVle2JhY2tncm91bmQ6cmdiYSgyNTUsMjU1LDI1NSwuMSl9LmRnLXNjaGVkdWxlX19zdHJpbmctdGltZXtjb2xvcjojZTZlNmU2fS5kZy1zY2hlZHVsZV9fdGFibGUtY2xvY2t7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjExJTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA1LjUlMkMxMSUyMEMlMjAyLjQ2MyUyQzExJTIwMCUyQzguNTM3JTIwMCUyQzUuNSUyMDAlMkMyLjQ2MiUyMDIuNDYzJTJDMCUyMDUuNSUyQzAlMjA4LjUzNyUyQzAlMjAxMSUyQzIuNDYyJTIwMTElMkM1LjUlMjAxMSUyQzguNTM3JTIwOC41MzclMkMxMSUyMDUuNSUyQzExJTIweiUyME0lMjA2JTJDNS4yOTMlMjBWJTIwMiUyMEglMjA1JTIwViUyMDUuNzA3JTIwTCUyMDcuNjQ2JTJDOC4zNTMlMjA4LjM1MyUyQzcuNjQ2JTIwNiUyQzUuMjkzJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhMGEwYTAlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTFweDtoZWlnaHQ6MTFweDtiYWNrZ3JvdW5kLXNpemU6MTFweCAxMXB4fS5kZy1zY2hlZHVsZV9fdGFibGUtbHVuY2h7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjEyJTIyJTIwaGVpZ2h0JTNEJTIyMTElMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA0JTJDNyUyMEglMjA4JTIwQyUyMDguNTglMkM3JTIwOS40NjElMkM2LjA4NCUyMDkuODI2JTJDNC45NzclMjBWJTIwNSUyMEMlMjAxMS4wNDclMkM1JTIwMTIlMkMzLjQ1MyUyMDEyJTJDMi4wMzElMjAxMiUyQzEuNDUzJTIwMTEuNTMxJTJDMSUyMDExLjAxNiUyQzElMjBIJTIwMTAlMjBDJTIwMTAlMkMwLjE4OCUyMDkuNzgxJTJDMCUyMDklMkMwJTIwSCUyMDMlMjBDJTIwMi4yOTclMkMwJTIwMiUyQzAuMTg4JTIwMiUyQzElMjB2JTIwMyUyMGMlMjAwJTJDMS40OSUyMDEuMTM3JTJDMyUyMDIlMkMzJTIweiUyMG0lMjA2JTJDLTUlMjBoJTIwMC41JTIwQyUyMDEwLjg3NSUyQzIlMjAxMSUyQzIuMjE5JTIwMTElMkMyLjUlMjAxMSUyQzMuNjI1JTIwMTAuNTYyJTJDNCUyMDEwJTJDNCUyMFYlMjAyJTIweiUyME0lMjAwJTJDOSUyMGMlMjAwJTJDMC40NDglMjAxLjc5MSUyQzElMjAzJTJDMSUyMDAlMkMwLjQwNSUyMDAuNjQ2JTJDMSUyMDElMkMxJTIwaCUyMDQlMjBjJTIwMC4zNTQlMkMwJTIwMSUyQy0wLjU5NSUyMDElMkMtMSUyMDEuMjA4JTJDMCUyMDMlMkMtMC41NTIlMjAzJTJDLTElMjBWJTIwOCUyMEglMjAwJTIwdiUyMDElMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2FhYTVhMCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEycHg7aGVpZ2h0OjExcHg7YmFja2dyb3VuZC1zaXplOjEycHggMTFweH0uZGctc2NoZWR1bGVfb3Blbl9mYWxzZSAuZGctc2NoZWR1bGVfX3RvZGF5OmJlZm9yZXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTElMjIlMjBoZWlnaHQlM0QlMjIxMSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDUuNSUyQzExJTIwQyUyMDIuNDYzJTJDMTElMjAwJTJDOC41MzclMjAwJTJDNS41JTIwMCUyQzIuNDYyJTIwMi40NjMlMkMwJTIwNS41JTJDMCUyMDguNTM3JTJDMCUyMDExJTJDMi40NjIlMjAxMSUyQzUuNSUyMDExJTJDOC41MzclMjA4LjUzNyUyQzExJTIwNS41JTJDMTElMjB6JTIwTSUyMDYlMkM1LjI5MyUyMFYlMjAyJTIwSCUyMDUlMjBWJTIwNS43MDclMjBMJTIwNy42NDYlMkM4LjM1MyUyMDguMzUzJTJDNy42NDYlMjA2JTJDNS4yOTMlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2EwYTBhMCUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKTt3aWR0aDoxMXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQtc2l6ZToxMXB4IDExcHh9LmRnLXNjaGVkdWxlX190b2RheTphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTAlMjIlMjBoZWlnaHQlM0QlMjI2JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNSUyQzYlMjBIJTIwNC41ODYlMjBMJTIwMCUyQzEuNDE0JTIwViUyMDAlMjBIJTIwMS40MTQlMjBMJTIwNSUyQzMuNTg2JTIwOC41ODYlMkMwJTIwSCUyMDEwJTIwViUyMDEuNDE0JTIwTCUyMDUuNDE0JTJDNiUyMEglMjA1JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNhNWEwOWMlMjIlMjBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTBweDtoZWlnaHQ6NnB4O2JhY2tncm91bmQtc2l6ZToxMHB4IDZweH0uZGctc2NoZWR1bGVfX3RvZGF5X3Nob3duX3RydWU6YWZ0ZXJ7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB3aWR0aCUzRCUyMjEwJTIyJTIwaGVpZ2h0JTNEJTIyNiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDUlMkMwJTIwSCUyMDUuNDE0JTIwTCUyMDEwJTJDNC41ODYlMjBWJTIwNiUyMEglMjA4LjU4NiUyMEwlMjA1JTJDMi40MTQlMjAxLjQxNCUyQzYlMjBIJTIwMCUyMFYlMjA0LjU4NiUyMEwlMjA0LjU4NiUyQzAlMjBIJTIwNSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzYTVhMDljJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEwcHg7aGVpZ2h0OjZweDtiYWNrZ3JvdW5kLXNpemU6MTBweCA2cHh9LmRnLWxpbmssLmRnLWxpbms6aG92ZXJ7YmFja2dyb3VuZC1wb3NpdGlvbjowIDk1JTtiYWNrZ3JvdW5kLXNpemU6MTBweCAxcHg7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXh9LmRnLWxpbmtfdHlwZV9sb2NhbHtiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLHJpZ2h0IHRvcCxmcm9tKCM5Y2QpLGNvbG9yLXN0b3AoNTAlLCM5Y2QpLGNvbG9yLXN0b3AoNTAlLHRyYW5zcGFyZW50KSk7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LCM5Y2QsIzljZCA1MCUsdHJhbnNwYXJlbnQgNTAlKTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byByaWdodCwjOWNkLCM5Y2QgNTAlLHRyYW5zcGFyZW50IDUwJSl9Lm5vLXRvdWNoIC5kZy1saW5rX3R5cGVfbG9jYWw6aG92ZXJ7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IHRvcCxyaWdodCB0b3AsZnJvbSgjOWJjKSxjb2xvci1zdG9wKDUwJSwjOWJjKSxjb2xvci1zdG9wKDUwJSx0cmFuc3BhcmVudCkpO2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwjOWJjLCM5YmMgNTAlLHRyYW5zcGFyZW50IDUwJSk7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIzliYywjOWJjIDUwJSx0cmFuc3BhcmVudCA1MCUpfS5kZy1saW5rLmRnLWxpbmtfdHlwZV9sb2NhbCwuZGctbGluay5kZy1saW5rX3R5cGVfbG9jYWw6aG92ZXJ7YmFja2dyb3VuZC1zaXplOjZweCAxcHh9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV90cmFmZmljOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIyMCUyMiUyMGhlaWdodCUzRCUyMjE0JTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjAlMjAxNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE4JTJDNSUyMEMlMjAxOCUyQzQlMjAxNyUyQzElMjAxNSUyQzElMjBIJTIwMTIlMjAxMCUyMEMlMjA4JTJDMSUyMDclMkM0JTIwNyUyQzUlMjBIJTIwNSUyMHYlMjAyJTIwaCUyMDElMjB2JTIwNCUyMGMlMjAwJTJDMC42JTIwMCUyQzElMjAxJTJDMSUyMHYlMjAyJTIwaCUyMDIlMjB2JTIwLTIlMjBoJTIwNyUyMHYlMjAyJTIwaCUyMDIlMjB2JTIwLTIlMjBjJTIwMSUyQzAlMjAxJTJDLTAuNCUyMDElMkMtMSUyMFYlMjA3JTIwaCUyMDElMjBWJTIwNSUyMEglMjAxOCUyMHolMjBNJTIwMTAlMkMzJTIwaCUyMDIlMjAzJTIwYyUyMDIlMkMwJTIwMiUyQzElMjAyJTJDMyUyMEglMjA4JTIwQyUyMDglMkM0JTIwOCUyQzMlMjAxMCUyQzMlMjB6JTIwTSUyMDklMkMxMCUyMEglMjA4JTIwQyUyMDcuNCUyQzEwJTIwNyUyQzkuNiUyMDclMkM5JTIwNyUyQzguNCUyMDcuNCUyQzglMjA4JTJDOCUyMGglMjAxJTIwYyUyMDAuNiUyQzAlMjAxJTJDMC40JTIwMSUyQzElMjAwJTJDMC42JTIwLTAuNCUyQzElMjAtMSUyQzElMjB6JTIwbSUyMDglMkMwJTIwSCUyMDE2JTIwQyUyMDE1LjQlMkMxMCUyMDE1JTJDOS42JTIwMTUlMkM5JTIwMTUlMkM4LjQlMjAxNS40JTJDOCUyMDE2JTJDOCUyMGglMjAxJTIwYyUyMDAuNiUyQzAlMjAxJTJDMC40JTIwMSUyQzElMjAwJTJDMC42JTIwLTAuNCUyQzElMjAtMSUyQzElMjB6JTIwTSUyMDQlMkM0JTIwSCUyMDYlMjBWJTIwMyUyMEglMjA0JTIwQyUyMDElMkMzJTIwMSUyQzYlMjAxJTJDNyUyMEglMjAwJTIwdiUyMDElMjBoJTIwMSUyMHYlMjA0JTIwSCUyMDMlMjBWJTIwMTElMjBIJTIwNSUyMFYlMjA3JTIwSCUyMDIlMjBDJTIwMiUyQzYlMjAyJTJDNCUyMDQlMkM0JTIweiUyME0lMjAzJTJDOSUyMDQlMkMxMCUyMEglMjAyJTIwViUyMDklMjBoJTIwMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNjE2MTYxJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ2clMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTYlMkM4JTIwaCUyMDElMjBjJTIwMC40JTJDMCUyMDAuNyUyQzAuMiUyMDAuOCUyQzAuNSUyMEMlMjAxNy45JTJDOC40JTIwMTglMkM4LjIlMjAxOCUyQzglMjAxOCUyQzcuNCUyMDE3LjYlMkM3JTIwMTclMkM3JTIwaCUyMC0xJTIwYyUyMC0wLjYlMkMwJTIwLTElMkMwLjQlMjAtMSUyQzElMjAwJTJDMC4yJTIwMC4xJTJDMC40JTIwMC4yJTJDMC41JTIwQyUyMDE1LjMlMkM4LjIlMjAxNS42JTJDOCUyMDE2JTJDOCUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA4JTJDOCUyMEglMjA5JTIwQyUyMDkuNCUyQzglMjA5LjclMkM4LjIlMjA5LjglMkM4LjUlMjA5LjklMkM4LjQlMjAxMCUyQzguMiUyMDEwJTJDOCUyMDEwJTJDNy40JTIwOS42JTJDNyUyMDklMkM3JTIwSCUyMDglMjBDJTIwNy40JTJDNyUyMDclMkM3LjQlMjA3JTJDOCUyMDclMkM4LjIlMjA3LjElMkM4LjQlMjA3LjIlMkM4LjUlMjA3LjMlMkM4LjIlMjA3LjYlMkM4JTIwOCUyQzglMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzMlMjBIJTIwNCUyMEMlMjA0JTJDMyUyMDQlMkMzJTIwNCUyQzMlMjAyJTJDMyUyMDIlMkM1JTIwMiUyQzYlMjBIJTIwMiUyMEMlMjAyLjElMkM1JTIwMi41JTJDNCUyMDQlMkM0JTIwSCUyMDUlMjA2JTIwViUyMDMlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMCUyMDdIMVY4SDB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTUlMkMyJTIwSCUyMDEyJTIwMTAlMjBDJTIwOCUyQzIlMjA4JTJDMyUyMDglMkM1JTIwSCUyMDglMjBDJTIwOCUyQzMuNyUyMDguMyUyQzMlMjAxMCUyQzMlMjBoJTIwMiUyMDMlMjBjJTIwMS43JTJDMCUyMDEuOSUyQzAuNyUyMDIlMkMyJTIwaCUyMDAlMjBDJTIwMTclMkMzJTIwMTclMkMyJTIwMTUlMkMyJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTMlMjA5TDQlMjA5JTIwMyUyMDglMjAyJTIwOCUyMDIlMjA5JTIwMiUyMDklMjAyJTIwOSUyMDMlMjA5eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDclMkMxMSUyMEMlMjA2JTJDMTElMjA2JTJDMTAuNiUyMDYlMkMxMCUyMHYlMjAxJTIwYyUyMDAlMkMwLjYlMjAwJTJDMSUyMDElMkMxJTIwdiUyMC0xJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDE4JTJDMTElMjB2JTIwMSUyMGMlMjAxJTJDMCUyMDElMkMtMC40JTIwMSUyQy0xJTIwdiUyMC0xJTIwYyUyMDAlMkMwLjYlMjAwJTJDMSUyMC0xJTJDMSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xOSUyMDZIMjBWN0gxOXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0zJTIwMTFMMSUyMDExJTIwMSUyMDEyJTIwMyUyMDEyJTIwMyUyMDExJTIwNSUyMDExJTIwNSUyMDclMjA1JTIwNyUyMDUlMjAxMCUyMDMlMjAxMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNiUyMDEzSDE4VjE0SDE2eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTUlMjA2SDZWN0g1eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTklMjAxM0w3JTIwMTMlMjA3JTIwMTQlMjA5JTIwMTQlMjA5JTIwMTIlMjAxNiUyMDEyJTIwMTYlMjAxMSUyMDklMjAxMXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDZyUyMGZpbGwlM0QlMjIlMjM0NDQlMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAyJTJDNiUyMEMlMjAyJTJDNi40JTIwMiUyQzYuNyUyMDIlMkM3JTIwSCUyMDUlMjBWJTIwNiUyMEglMjAyJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTIlMjA5TDIlMjAxMCUyMDQlMjAxMCUyMDMlMjA5eiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDQlMkMzJTIwSCUyMDYlMjBWJTIwMiUyMEglMjA0JTIwQyUyMDElMkMyJTIwMSUyQzUlMjAxJTJDNiUyMEglMjAwJTIwViUyMDclMjBIJTIwMSUyMEMlMjAxJTJDNiUyMDElMkMzJTIwNCUyQzMlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTglMkM0JTIwQyUyMDE4JTJDMyUyMDE3JTJDMCUyMDE1JTJDMCUyMEglMjAxMiUyMDEwJTIwQyUyMDglMkMwJTIwNyUyQzMlMjA3JTJDNCUyMEglMjA2JTIwNSUyMFYlMjA1JTIwSCUyMDclMjBDJTIwNyUyQzQlMjA4JTJDMSUyMDEwJTJDMSUyMGglMjAyJTIwMyUyMGMlMjAyJTJDMCUyMDMlMkMzJTIwMyUyQzQlMjBoJTIwMiUyMFYlMjA0JTIwaCUyMC0yJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDglMkMxMCUyMEglMjA5JTIwQyUyMDkuNiUyQzEwJTIwMTAlMkM5LjYlMjAxMCUyQzklMjAxMCUyQzguOCUyMDkuOSUyQzguNiUyMDkuOCUyQzguNSUyMDkuNyUyQzguOCUyMDkuNCUyQzklMjA5JTJDOSUyMEglMjA4JTIwQyUyMDcuNiUyQzklMjA3LjMlMkM4LjglMjA3LjIlMkM4LjUlMjA3LjElMkM4LjYlMjA3JTJDOC44JTIwNyUyQzklMjBjJTIwMCUyQzAuNiUyMDAuNCUyQzElMjAxJTJDMSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNyUyQzYlMjBDJTIwMTclMkM1LjYlMjAxNyUyQzUuMyUyMDE3JTJDNSUyMEglMjA4JTIwYyUyMDAlMkMwLjMlMjAwJTJDMC42JTIwMCUyQzElMjBoJTIwOSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxNy44JTJDOC41JTIwQyUyMDE3LjclMkM4LjglMjAxNy40JTJDOSUyMDE3JTJDOSUyMEglMjAxNiUyMEMlMjAxNS42JTJDOSUyMDE1LjMlMkM4LjglMjAxNS4yJTJDOC41JTIwMTUuMSUyQzguNiUyMDE1JTJDOC44JTIwMTUlMkM5JTIwYyUyMDAlMkMwLjYlMjAwLjQlMkMxJTIwMSUyQzElMjBoJTIwMSUyMGMlMjAwLjYlMkMwJTIwMSUyQy0wLjQlMjAxJTJDLTElMjAwJTJDLTAuMiUyMC0wLjElMkMtMC40JTIwLTAuMiUyQy0wLjUlMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjIwcHg7aGVpZ2h0OjE0cHg7YmFja2dyb3VuZC1zaXplOjIwcHggMTRweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDttYXJnaW46YXV0bztjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfdHJhZmZpYzphY3RpdmU6YWZ0ZXIsLm5vLXRvdWNoIC5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfdHJhZmZpYzpob3ZlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMjAlMjIlMjBoZWlnaHQlM0QlMjIxNCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDIwJTIwMTQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAxOCUyQzUlMjBDJTIwMTglMkM0JTIwMTclMkMxJTIwMTUlMkMxJTIwSCUyMDEyJTIwMTAlMjBDJTIwOCUyQzElMjA3JTJDNCUyMDclMkM1JTIwSCUyMDUlMjB2JTIwMiUyMGglMjAxJTIwdiUyMDQlMjBjJTIwMCUyQzAuNiUyMDAlMkMxJTIwMSUyQzElMjB2JTIwMiUyMGglMjAyJTIwdiUyMC0yJTIwaCUyMDclMjB2JTIwMiUyMGglMjAyJTIwdiUyMC0yJTIwYyUyMDElMkMwJTIwMSUyQy0wLjQlMjAxJTJDLTElMjBWJTIwNyUyMGglMjAxJTIwViUyMDUlMjBIJTIwMTglMjB6JTIwTSUyMDEwJTJDMyUyMGglMjAyJTIwMyUyMGMlMjAyJTJDMCUyMDIlMkMxJTIwMiUyQzMlMjBIJTIwOCUyMEMlMjA4JTJDNCUyMDglMkMzJTIwMTAlMkMzJTIweiUyME0lMjA5JTJDMTAlMjBIJTIwOCUyMEMlMjA3LjQlMkMxMCUyMDclMkM5LjYlMjA3JTJDOSUyMDclMkM4LjQlMjA3LjQlMkM4JTIwOCUyQzglMjBoJTIwMSUyMGMlMjAwLjYlMkMwJTIwMSUyQzAuNCUyMDElMkMxJTIwMCUyQzAuNiUyMC0wLjQlMkMxJTIwLTElMkMxJTIweiUyMG0lMjA4JTJDMCUyMEglMjAxNiUyMEMlMjAxNS40JTJDMTAlMjAxNSUyQzkuNiUyMDE1JTJDOSUyMDE1JTJDOC40JTIwMTUuNCUyQzglMjAxNiUyQzglMjBoJTIwMSUyMGMlMjAwLjYlMkMwJTIwMSUyQzAuNCUyMDElMkMxJTIwMCUyQzAuNiUyMC0wLjQlMkMxJTIwLTElMkMxJTIweiUyME0lMjA0JTJDNCUyMEglMjA2JTIwViUyMDMlMjBIJTIwNCUyMEMlMjAxJTJDMyUyMDElMkM2JTIwMSUyQzclMjBIJTIwMCUyMHYlMjAxJTIwaCUyMDElMjB2JTIwNCUyMEglMjAzJTIwViUyMDExJTIwSCUyMDUlMjBWJTIwNyUyMEglMjAyJTIwQyUyMDIlMkM2JTIwMiUyQzQlMjA0JTJDNCUyMHolMjBNJTIwMyUyQzklMjA0JTJDMTAlMjBIJTIwMiUyMFYlMjA5JTIwaCUyMDElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzQyNDI0MiUyMiUyMGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NnJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIybSUyMDE2JTJDOCUyMGglMjAxJTIwYyUyMDAuNCUyQzAlMjAwLjclMkMwLjIlMjAwLjglMkMwLjUlMjBDJTIwMTcuOSUyQzguNCUyMDE4JTJDOC4yJTIwMTglMkM4JTIwMTglMkM3LjQlMjAxNy42JTJDNyUyMDE3JTJDNyUyMGglMjAtMSUyMGMlMjAtMC42JTJDMCUyMC0xJTJDMC40JTIwLTElMkMxJTIwMCUyQzAuMiUyMDAuMSUyQzAuNCUyMDAuMiUyQzAuNSUyMEMlMjAxNS4zJTJDOC4yJTIwMTUuNiUyQzglMjAxNiUyQzglMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwOCUyQzglMjBIJTIwOSUyMEMlMjA5LjQlMkM4JTIwOS43JTJDOC4yJTIwOS44JTJDOC41JTIwOS45JTJDOC40JTIwMTAlMkM4LjIlMjAxMCUyQzglMjAxMCUyQzcuNCUyMDkuNiUyQzclMjA5JTJDNyUyMEglMjA4JTIwQyUyMDcuNCUyQzclMjA3JTJDNy40JTIwNyUyQzglMjA3JTJDOC4yJTIwNy4xJTJDOC40JTIwNy4yJTJDOC41JTIwNy4zJTJDOC4yJTIwNy42JTJDOCUyMDglMkM4JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDYlMkMzJTIwSCUyMDQlMjBDJTIwNCUyQzMlMjA0JTJDMyUyMDQlMkMzJTIwMiUyQzMlMjAyJTJDNSUyMDIlMkM2JTIwSCUyMDIlMjBDJTIwMi4xJTJDNSUyMDIuNSUyQzQlMjA0JTJDNCUyMEglMjA1JTIwNiUyMFYlMjAzJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTAlMjA3SDFWOEgweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE1JTJDMiUyMEglMjAxMiUyMDEwJTIwQyUyMDglMkMyJTIwOCUyQzMlMjA4JTJDNSUyMEglMjA4JTIwQyUyMDglMkMzLjclMjA4LjMlMkMzJTIwMTAlMkMzJTIwaCUyMDIlMjAzJTIwYyUyMDEuNyUyQzAlMjAxLjklMkMwLjclMjAyJTJDMiUyMGglMjAwJTIwQyUyMDE3JTJDMyUyMDE3JTJDMiUyMDE1JTJDMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0zJTIwOUw0JTIwOSUyMDMlMjA4JTIwMiUyMDglMjAyJTIwOSUyMDIlMjA5JTIwMiUyMDklMjAzJTIwOXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA3JTJDMTElMjBDJTIwNiUyQzExJTIwNiUyQzEwLjYlMjA2JTJDMTAlMjB2JTIwMSUyMGMlMjAwJTJDMC42JTIwMCUyQzElMjAxJTJDMSUyMHYlMjAtMSUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxOCUyQzExJTIwdiUyMDElMjBjJTIwMSUyQzAlMjAxJTJDLTAuNCUyMDElMkMtMSUyMHYlMjAtMSUyMGMlMjAwJTJDMC42JTIwMCUyQzElMjAtMSUyQzElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTklMjA2SDIwVjdIMTl6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMyUyMDExTDElMjAxMSUyMDElMjAxMiUyMDMlMjAxMiUyMDMlMjAxMSUyMDUlMjAxMSUyMDUlMjA3JTIwNSUyMDclMjA1JTIwMTAlMjAzJTIwMTB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTYlMjAxM0gxOFYxNEgxNnolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk01JTIwNkg2VjdINXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk05JTIwMTNMNyUyMDEzJTIwNyUyMDE0JTIwOSUyMDE0JTIwOSUyMDEyJTIwMTYlMjAxMiUyMDE2JTIwMTElMjA5JTIwMTF6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZyUzRSUwQSUyMCUyMCUyMCUyMCUzQ2clMjBmaWxsJTNEJTIyJTIzMmUyZTJlJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMiUyQzYlMjBDJTIwMiUyQzYuNCUyMDIlMkM2LjclMjAyJTJDNyUyMEglMjA1JTIwViUyMDYlMjBIJTIwMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yJTIwOUwyJTIwMTAlMjA0JTIwMTAlMjAzJTIwOXolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA0JTJDMyUyMEglMjA2JTIwViUyMDIlMjBIJTIwNCUyMEMlMjAxJTJDMiUyMDElMkM1JTIwMSUyQzYlMjBIJTIwMCUyMFYlMjA3JTIwSCUyMDElMjBDJTIwMSUyQzYlMjAxJTJDMyUyMDQlMkMzJTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDE4JTJDNCUyMEMlMjAxOCUyQzMlMjAxNyUyQzAlMjAxNSUyQzAlMjBIJTIwMTIlMjAxMCUyMEMlMjA4JTJDMCUyMDclMkMzJTIwNyUyQzQlMjBIJTIwNiUyMDUlMjBWJTIwNSUyMEglMjA3JTIwQyUyMDclMkM0JTIwOCUyQzElMjAxMCUyQzElMjBoJTIwMiUyMDMlMjBjJTIwMiUyQzAlMjAzJTJDMyUyMDMlMkM0JTIwaCUyMDIlMjBWJTIwNCUyMGglMjAtMiUyMHolMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjA4JTJDMTAlMjBIJTIwOSUyMEMlMjA5LjYlMkMxMCUyMDEwJTJDOS42JTIwMTAlMkM5JTIwMTAlMkM4LjglMjA5LjklMkM4LjYlMjA5LjglMkM4LjUlMjA5LjclMkM4LjglMjA5LjQlMkM5JTIwOSUyQzklMjBIJTIwOCUyMEMlMjA3LjYlMkM5JTIwNy4zJTJDOC44JTIwNy4yJTJDOC41JTIwNy4xJTJDOC42JTIwNyUyQzguOCUyMDclMkM5JTIwYyUyMDAlMkMwLjYlMjAwLjQlMkMxJTIwMSUyQzElMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTclMkM2JTIwQyUyMDE3JTJDNS42JTIwMTclMkM1LjMlMjAxNyUyQzUlMjBIJTIwOCUyMGMlMjAwJTJDMC4zJTIwMCUyQzAuNiUyMDAlMkMxJTIwaCUyMDklMjB6JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMTcuOCUyQzguNSUyMEMlMjAxNy43JTJDOC44JTIwMTcuNCUyQzklMjAxNyUyQzklMjBIJTIwMTYlMjBDJTIwMTUuNiUyQzklMjAxNS4zJTJDOC44JTIwMTUuMiUyQzguNSUyMDE1LjElMkM4LjYlMjAxNSUyQzguOCUyMDE1JTJDOSUyMGMlMjAwJTJDMC42JTIwMC40JTJDMSUyMDElMkMxJTIwaCUyMDElMjBjJTIwMC42JTJDMCUyMDElMkMtMC40JTIwMSUyQy0xJTIwMCUyQy0wLjIlMjAtMC4xJTJDLTAuNCUyMC0wLjIlMkMtMC41JTIweiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3RyYWZmaWM6YWN0aXZlOmFmdGVyLC5kZy1jb250cm9sLXJvdW5kX19pY29uX3N0YXRlX2FjdGl2ZS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfdHJhZmZpYzphZnRlciwubm8tdG91Y2ggLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlLmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV90cmFmZmljOmhvdmVyOmFmdGVye2JhY2tncm91bmQtaW1hZ2U6bm9uZX1hLmRnLXRyYWZmaWMtY29udHJvbHt6LWluZGV4OjA7Y29sb3I6I2YyZjJmMjt0ZXh0LWRlY29yYXRpb246bm9uZTt0ZXh0LXNoYWRvdzowIDFweCAycHggcmdiYSgwLDAsMCwuMyk7Zm9udDo0MDAgMTVweC8zMnB4ICdBcmlhbCBuYXJyb3cnLEFyaWFsLHNhbnMtc2VyaWZ9YS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfZ3JlZW46YWZ0ZXIsYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfcmVkOmFmdGVyLGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3llbGxvdzphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDt6LWluZGV4Oi0xO21hcmdpbjphdXRvO3dpZHRoOjIycHg7aGVpZ2h0OjIycHg7Ym9yZGVyLXJhZGl1czo1MCU7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgMCByZ2JhKDAsMCwwLC4yKSwwIDFweCAwIDAgI2ZmZjtib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgMCByZ2JhKDAsMCwwLC4yKSwwIDFweCAwIDAgI2ZmZn0ubm8tdG91Y2ggYS5kZy10cmFmZmljLWNvbnRyb2w6aG92ZXJ7Y29sb3I6I2YyZjJmMn0ubm8tdG91Y2ggYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfZ3JlZW46aG92ZXI6YWZ0ZXIsLm5vLXRvdWNoIGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3JlZDpob3ZlcjphZnRlciwubm8tdG91Y2ggYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfeWVsbG93OmhvdmVyOmFmdGVye3dpZHRoOjIycHg7aGVpZ2h0OjIycHh9YS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfZ3JlZW46YWZ0ZXJ7YmFja2dyb3VuZDojM2ZjMDNifS5uby10b3VjaCBhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9ncmVlbjpob3ZlcjphZnRlcixhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9ncmVlbjphY3RpdmU6YWZ0ZXJ7YmFja2dyb3VuZDotd2Via2l0LWdyYWRpZW50KGxpbmVhcixsZWZ0IGJvdHRvbSxsZWZ0IHRvcCxmcm9tKCMyYWE3MzEpLHRvKCM1M2UxM2EpKSAjM2VjNDM1O2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQoYm90dG9tLCMyYWE3MzEsIzUzZTEzYSkgIzNlYzQzNTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh0byB0b3AsIzJhYTczMSwjNTNlMTNhKSAjM2VjNDM1fWEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3llbGxvdzphZnRlcntiYWNrZ3JvdW5kOiNmM2IyMjN9Lm5vLXRvdWNoIGEuZGctdHJhZmZpYy1jb250cm9sX2NvbG9yX3llbGxvdzpob3ZlcjphZnRlcixhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl95ZWxsb3c6YWN0aXZlOmFmdGVye2JhY2tncm91bmQ6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCBib3R0b20sbGVmdCB0b3AsZnJvbSgjZWY5MzFiKSx0bygjZjdiZTI2KSkgI2Y0YTgyMDtiYWNrZ3JvdW5kOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGJvdHRvbSwjZWY5MzFiLCNmN2JlMjYpICNmNGE4MjA7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQodG8gdG9wLCNlZjkzMWIsI2Y3YmUyNikgI2Y0YTgyMH1hLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9yZWQ6YWZ0ZXJ7YmFja2dyb3VuZDojZWIyNDBjfS5uby10b3VjaCBhLmRnLXRyYWZmaWMtY29udHJvbF9jb2xvcl9yZWQ6aG92ZXI6YWZ0ZXIsYS5kZy10cmFmZmljLWNvbnRyb2xfY29sb3JfcmVkOmFjdGl2ZTphZnRlcntiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgYm90dG9tLGxlZnQgdG9wLGZyb20oI2MwMWMwYSksdG8oI2Y3MzQxNikpICNkYjI4MTE7YmFja2dyb3VuZDotd2Via2l0LWxpbmVhci1ncmFkaWVudChib3R0b20sI2MwMWMwYSwjZjczNDE2KSAjZGIyODExO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KHRvIHRvcCwjYzAxYzBhLCNmNzM0MTYpICNkYjI4MTF9LmxlYWZsZXQtcnVsZXJNYXJrZXItcGFuZXt6LWluZGV4OjYwMH0uZGctcnVsZXJfX2xhYmVse3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt6LWluZGV4OjIwMDstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmRnLXJ1bGVyX19sYWJlbC1zcGFjZXJ7ZGlzcGxheTpibG9ja30uZGctcnVsZXJfX2xhYmVsLWNvbnRhaW5lcntkaXNwbGF5Om5vbmU7cGFkZGluZzoycHggNHB4O2JvcmRlcjo0cHggc29saWQgI2ZmZjtib3JkZXItcmFkaXVzOjEzcHg7YmFja2dyb3VuZDojMGRhNWQ1O2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveDtjb2xvcjojZmZmO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LXNpemU6MTJweH0uZGctcnVsZXJfX3BvaW50e2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjoycHggNHB4IDAgMDt3aWR0aDoxMHB4O2hlaWdodDoxMHB4O2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6I2ZmZn0uZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5re2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMiUyMiUyMGhlaWdodCUzRCUyMjEyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwNiUyQzAlMjBDJTIwMi42ODclMkMwJTIwMCUyQzIuNjg3JTIwMCUyQzYlMjAwJTJDOS4zMTMlMjAyLjY4NyUyQzEyJTIwNiUyQzEyJTIwOS4zMTMlMkMxMiUyMDEyJTJDOS4zMTMlMjAxMiUyQzYlMjAxMiUyQzIuNjg3JTIwOS4zMTMlMkMwJTIwNiUyQzAlMjB6JTIwTSUyMDkuNDAxJTJDOS4zOTglMjA4LjglMkM5LjYlMjA2JTJDNi44JTIwMy4xOTklMkM5LjYlMjAyLjU5JTJDOS40MTUlMjAyLjM3NSUyQzguNzc0JTIwNS4xOTklMkM2JTIwMi4zOTklMkMzLjE3NSUyMDIuNjIlMkMyLjU5MSUyMDMuMTc1JTJDMi4zNzUlMjA1Ljk0OSUyQzUuMjI1JTIwOC43NzQlMkMyLjM3NSUyMDkuNDE1JTJDMi42MDUlMjA5LjU2NiUyQzMuMTk2JTIwNi44MjQlMkM2JTIwOS42JTJDOC44JTIwOS40MDElMkM5LjM5OCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTIwZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQVxcXCIpO3dpZHRoOjEycHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZC1zaXplOjEycHggMTJweDtkaXNwbGF5Om5vbmU7bWFyZ2luOjFweCAwIDAgNHB4O3ZlcnRpY2FsLWFsaWduOnRvcDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlO3RyYW5zaXRpb246YWxsIC4ycyBlYXNlfS5uby10b3VjaCAuZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5rOmhvdmVyey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfS5kZy1ydWxlcl9fcmVtb3ZlLWxpbmstb3ZlcmxheXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTdweDtyaWdodDotN3B4O2JvdHRvbTotN3B4O3dpZHRoOjQwcHh9Lm5vLXRvdWNoIC5kZy1ydWxlcl9fcmVtb3ZlLWxpbmstb3ZlcmxheXtkaXNwbGF5Om5vbmV9LmRnLWNvbnRyb2wtcm91bmRfX2ljb25fbmFtZV9ydWxlcjphZnRlcntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHdpZHRoJTNEJTIyMTYlMjIlMjBoZWlnaHQlM0QlMjI5JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMTIuOTk5JTJDMCUyMHYlMjA0LjAwMSUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0yJTIwdiUyMDIlMjBoJTIwLTElMjBWJTIwMCUyMGglMjAtMiUyMFYlMjAyJTIwSCUyMDYlMjBWJTIwMCUyMEglMjAzLjk5OCUyMHYlMjA0LjAwMSUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0zJTIwViUyMDglMjBIJTIwMTYlMjBWJTIwMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNjE2MTYxJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJtJTIwMi45OTklMkM0JTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQy0yJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjBtJTIwMyUyQzAlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDMiUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzQ0NCUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTSUyMDAlMkM4JTIwSCUyMDE2JTIwViUyMDklMjBIJTIwMCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzAlMjBIJTIwMyUyMFYlMjAxJTIwSCUyMDAlMjB6JTIwbSUyMDEzJTJDMCUyMGglMjAzJTIwdiUyMDElMjBoJTIwLTMlMjB6JTIwbSUyMC0zJTJDMCUyMGglMjAyJTIwViUyMDElMjBIJTIwMTAlMjB6JTIwTSUyMDclMkMwJTIwSCUyMDklMjBWJTIwMSUyMEglMjA3JTIweiUyME0lMjA0JTJDMCUyMEglMjA2JTIwViUyMDElMjBIJTIwNCUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNDQ0JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBXFxcIik7d2lkdGg6MTZweDtoZWlnaHQ6OXB4O2JhY2tncm91bmQtc2l6ZToxNnB4IDlweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDttYXJnaW46YXV0bztjb250ZW50OicnfS5kZy1jb250cm9sLXJvdW5kX19pY29uX25hbWVfcnVsZXI6YWN0aXZlOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmhvdmVyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxNiUyMiUyMGhlaWdodCUzRCUyMjklMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxMi45OTklMkMwJTIwdiUyMDQuMDAxJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTIlMjB2JTIwMiUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0yJTIwViUyMDIlMjBIJTIwNiUyMFYlMjAwJTIwSCUyMDMuOTk4JTIwdiUyMDQuMDAxJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTMlMjBWJTIwOCUyMEglMjAxNiUyMFYlMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0MjQyNDIlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAyLjk5OSUyQzQlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDLTIlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDMCUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIwbSUyMDMlMkMyJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMmUyZTJlJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzglMjBIJTIwMTYlMjBWJTIwOSUyMEglMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAwJTJDMCUyMEglMjAzJTIwViUyMDElMjBIJTIwMCUyMHolMjBtJTIwMTMlMkMwJTIwaCUyMDMlMjB2JTIwMSUyMGglMjAtMyUyMHolMjBtJTIwLTMlMkMwJTIwaCUyMDIlMjBWJTIwMSUyMEglMjAxMCUyMHolMjBNJTIwNyUyQzAlMjBIJTIwOSUyMFYlMjAxJTIwSCUyMDclMjB6JTIwTSUyMDQlMkMwJTIwSCUyMDYlMjBWJTIwMSUyMEglMjA0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyZTJlMmUlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX0uZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmFjdGl2ZTphZnRlciwuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmFmdGVyLC5uby10b3VjaCAuZGctY29udHJvbC1yb3VuZF9faWNvbl9zdGF0ZV9hY3RpdmUuZGctY29udHJvbC1yb3VuZF9faWNvbl9uYW1lX3J1bGVyOmhvdmVyOmFmdGVye2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxNiUyMiUyMGhlaWdodCUzRCUyMjklMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAxMi45OTklMkMwJTIwdiUyMDQuMDAxJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTIlMjB2JTIwMiUyMGglMjAtMSUyMFYlMjAwJTIwaCUyMC0yJTIwViUyMDIlMjBIJTIwNiUyMFYlMjAwJTIwSCUyMDMuOTk5JTIwdiUyMDQuMDAxJTIwaCUyMC0xJTIwViUyMDAlMjBoJTIwLTMlMjBWJTIwOCUyMEglMjAxNiUyMFYlMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjMyMWE3ZDYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMm0lMjAyLjk5OSUyQzQlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDLTIlMjBoJTIwMSUyMHYlMjAxJTIwaCUyMC0xJTIweiUyMG0lMjAzJTJDMCUyMGglMjAxJTIwdiUyMDElMjBoJTIwLTElMjB6JTIwbSUyMDMlMkMyJTIwaCUyMDElMjB2JTIwMSUyMGglMjAtMSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzMTQ3NTk2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNJTIwMCUyQzglMjBIJTIwMTYlMjBWJTIwOSUyMEglMjAwJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0lMjAwJTJDMCUyMEglMjAzJTIwViUyMDElMjBIJTIwMCUyMHolMjBtJTIwMTMlMkMwJTIwaCUyMDMlMjB2JTIwMSUyMGglMjAtMyUyMHolMjBtJTIwLTMlMkMwJTIwaCUyMDIlMjBWJTIwMSUyMEglMjAxMCUyMHolMjBNJTIwNyUyQzAlMjBIJTIwOSUyMFYlMjAxJTIwSCUyMDclMjB6JTIwTSUyMDQlMkMwJTIwSCUyMDYlMjBWJTIwMSUyMEglMjA0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjMxNDc1OTYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEFcXFwiKX1cIjsgKHJlcXVpcmUoXCJicm93c2VyaWZ5LWNzc1wiKS5jcmVhdGVTdHlsZShjc3MsIHsgXCJocmVmXCI6IFwiZGlzdC9jc3Mvc3R5bGVzLmZ1bGwuZGFyay5jc3NcIiB9LCB7IFwiaW5zZXJ0QXRcIjogXCJib3R0b21cIiB9KSk7IG1vZHVsZS5leHBvcnRzID0gY3NzOyIsImlmICghQXJyYXkucHJvdG90eXBlLm1hcClcbntcbiAgQXJyYXkucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKGZ1biAvKiwgdGhpc0FyZyAqLylcbiAge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgIGlmICh0eXBlb2YgZnVuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB7XG4gICAgICAvLyBOT1RFOiBBYnNvbHV0ZSBjb3JyZWN0bmVzcyB3b3VsZCBkZW1hbmQgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgICAvLyAgICAgICBiZSB1c2VkLiAgQnV0IHRoaXMgbWV0aG9kIGlzIGZhaXJseSBuZXcsIGFuZCBmYWlsdXJlIGlzXG4gICAgICAvLyAgICAgICBwb3NzaWJsZSBvbmx5IGlmIE9iamVjdC5wcm90b3R5cGUgb3IgQXJyYXkucHJvdG90eXBlXG4gICAgICAvLyAgICAgICBoYXMgYSBwcm9wZXJ0eSB8aXwgKHZlcnkgdW5saWtlbHkpLCBzbyB1c2UgYSBsZXNzLWNvcnJlY3RcbiAgICAgIC8vICAgICAgIGJ1dCBtb3JlIHBvcnRhYmxlIGFsdGVybmF0aXZlLlxuICAgICAgaWYgKGkgaW4gdClcbiAgICAgICAgcmVzW2ldID0gZnVuLmNhbGwodGhpc0FyZywgdFtpXSwgaSwgdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cblxuLyogcmVkdWNlIGltcGxlbWludGF0aW9uIGJ5IE1vemlsYSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9SZWR1Y2U/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkFycmF5JTJGUmVkdWNlKi9cbmlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZSkge1xuICBBcnJheS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24oY2FsbGJhY2ssIG9wdF9pbml0aWFsVmFsdWUpe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAobnVsbCA9PT0gdGhpcyB8fCAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMpIHtcbiAgICAgIC8vIEF0IHRoZSBtb21lbnQgYWxsIG1vZGVybiBicm93c2VycywgdGhhdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBoYXZlXG4gICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZS4gRm9yIGluc3RhbmNlLCBJRThcbiAgICAgIC8vIGRvZXMgbm90IHN1cHBvcnQgc3RyaWN0IG1vZGUsIHNvIHRoaXMgY2hlY2sgaXMgYWN0dWFsbHkgdXNlbGVzcy5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2UgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBpbmRleCwgdmFsdWUsXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoID4+PiAwLFxuICAgICAgICBpc1ZhbHVlU2V0ID0gZmFsc2U7XG4gICAgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IG9wdF9pbml0aWFsVmFsdWU7XG4gICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpbmRleCA9IDA7IGxlbmd0aCA+IGluZGV4OyArK2luZGV4KSB7XG4gICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKGlzVmFsdWVTZXQpIHtcbiAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgICAgaXNWYWx1ZVNldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1ZhbHVlU2V0KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4vLyBQcm9kdWN0aW9uIHN0ZXBzIG9mIEVDTUEtMjYyLCBFZGl0aW9uIDUsIDE1LjQuNC4xOFxuLy8gUmVmZXJlbmNlOiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMThcbmlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcblxuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIFQsIGs7XG5cbiAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhpcyBpcyBudWxsIG9yIG5vdCBkZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIHZhciBrVmFsdWUsXG4gICAgICAgIC8vIDEuIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCBwYXNzaW5nIHRoZSB8dGhpc3wgdmFsdWUgYXMgdGhlIGFyZ3VtZW50LlxuICAgICAgICBPID0gT2JqZWN0KHRoaXMpLFxuXG4gICAgICAgIC8vIDIuIExldCBsZW5WYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIHRoZSBhcmd1bWVudCBcImxlbmd0aFwiLlxuICAgICAgICAvLyAzLiBMZXQgbGVuIGJlIFRvVWludDMyKGxlblZhbHVlKS5cbiAgICAgICAgbGVuID0gTy5sZW5ndGggPj4+IDA7IC8vIEhhY2sgdG8gY29udmVydCBPLmxlbmd0aCB0byBhIFVJbnQzMlxuXG4gICAgLy8gNC4gSWYgSXNDYWxsYWJsZShjYWxsYmFjaykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAvLyBTZWU6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuMTFcbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChjYWxsYmFjaykgIT09IFwiW29iamVjdCBGdW5jdGlvbl1cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjYWxsYmFjayArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIC8vIDUuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBUID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICAvLyA2LiBMZXQgayBiZSAwXG4gICAgayA9IDA7XG5cbiAgICAvLyA3LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cbiAgICB3aGlsZSAoayA8IGxlbikge1xuXG4gICAgICAvLyBhLiBMZXQgUGsgYmUgVG9TdHJpbmcoaykuXG4gICAgICAvLyAgIFRoaXMgaXMgaW1wbGljaXQgZm9yIExIUyBvcGVyYW5kcyBvZiB0aGUgaW4gb3BlcmF0b3JcbiAgICAgIC8vIGIuIExldCBrUHJlc2VudCBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEhhc1Byb3BlcnR5IGludGVybmFsIG1ldGhvZCBvZiBPIHdpdGggYXJndW1lbnQgUGsuXG4gICAgICAvLyAgIFRoaXMgc3RlcCBjYW4gYmUgY29tYmluZWQgd2l0aCBjXG4gICAgICAvLyBjLiBJZiBrUHJlc2VudCBpcyB0cnVlLCB0aGVuXG4gICAgICBpZiAoayBpbiBPKSB7XG5cbiAgICAgICAgLy8gaS4gTGV0IGtWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIEdldCBpbnRlcm5hbCBtZXRob2Qgb2YgTyB3aXRoIGFyZ3VtZW50IFBrLlxuICAgICAgICBrVmFsdWUgPSBPW2tdO1xuXG4gICAgICAgIC8vIGlpLiBDYWxsIHRoZSBDYWxsIGludGVybmFsIG1ldGhvZCBvZiBjYWxsYmFjayB3aXRoIFQgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgIC8vIGFyZ3VtZW50IGxpc3QgY29udGFpbmluZyBrVmFsdWUsIGssIGFuZCBPLlxuICAgICAgICBjYWxsYmFjay5jYWxsKFQsIGtWYWx1ZSwgaywgTyk7XG4gICAgICB9XG4gICAgICAvLyBkLiBJbmNyZWFzZSBrIGJ5IDEuXG4gICAgICBrKys7XG4gICAgfVxuICAgIC8vIDguIHJldHVybiB1bmRlZmluZWRcbiAgfTtcbn1cblxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qva2V5c1xuaWYgKCFPYmplY3Qua2V5cykge1xuICBPYmplY3Qua2V5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGhhc0RvbnRFbnVtQnVnID0gISh7dG9TdHJpbmc6IG51bGx9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKSxcbiAgICAgICAgZG9udEVudW1zID0gW1xuICAgICAgICAgICd0b1N0cmluZycsXG4gICAgICAgICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAgICAgICAndmFsdWVPZicsXG4gICAgICAgICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAgICAgICAnaXNQcm90b3R5cGVPZicsXG4gICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICAgICAnY29uc3RydWN0b3InXG4gICAgICAgIF0sXG4gICAgICAgIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmICh0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nIHx8IG9iaiA9PT0gbnVsbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIG5vbi1vYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBwcm9wLCBpO1xuXG4gICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRvbnRFbnVtc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBkb250RW51bXNbaV0pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkb250RW51bXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9KCkpO1xufVxuXG4vLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcbmlmICghQXJyYXkucHJvdG90eXBlLnNvbWUpXG57XG4gIEFycmF5LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24oZnVuIC8qLCB0aGlzQXJnICovKVxuICB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgIGlmICh0eXBlb2YgZnVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMV0gOiB2b2lkIDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB7XG4gICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwXG5pZiAoIUFycmF5LnByb3RvdHlwZS5tYXApXG57XG4gIEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmdW4gLyosIHRoaXNBcmcgKi8pXG4gIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmICh0aGlzID09PSB2b2lkIDAgfHwgdGhpcyA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAge1xuICAgICAgLy8gTk9URTogQWJzb2x1dGUgY29ycmVjdG5lc3Mgd291bGQgZGVtYW5kIE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAgICAgLy8gICAgICAgYmUgdXNlZC4gIEJ1dCB0aGlzIG1ldGhvZCBpcyBmYWlybHkgbmV3LCBhbmQgZmFpbHVyZSBpc1xuICAgICAgLy8gICAgICAgcG9zc2libGUgb25seSBpZiBPYmplY3QucHJvdG90eXBlIG9yIEFycmF5LnByb3RvdHlwZVxuICAgICAgLy8gICAgICAgaGFzIGEgcHJvcGVydHkgfGl8ICh2ZXJ5IHVubGlrZWx5KSwgc28gdXNlIGEgbGVzcy1jb3JyZWN0XG4gICAgICAvLyAgICAgICBidXQgbW9yZSBwb3J0YWJsZSBhbHRlcm5hdGl2ZS5cbiAgICAgIGlmIChpIGluIHQpXG4gICAgICAgIHJlc1tpXSA9IGZ1bi5jYWxsKHRoaXNBcmcsIHRbaV0sIGksIHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbi8vRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXJcbmlmICghQXJyYXkucHJvdG90eXBlLmZpbHRlcilcbntcbiAgQXJyYXkucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZ1biAvKiwgdGhpc0FyZyAqLylcbiAge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuXG4gICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuICAgIGlmICh0eXBlb2YgZnVuICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcblxuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHtcbiAgICAgIGlmIChpIGluIHQpXG4gICAgICB7XG4gICAgICAgIHZhciB2YWwgPSB0W2ldO1xuXG4gICAgICAgIC8vIE5PVEU6IFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhdFxuICAgICAgICAvLyAgICAgICB0aGUgbmV4dCBpbmRleCwgYXMgcHVzaCBjYW4gYmUgYWZmZWN0ZWQgYnlcbiAgICAgICAgLy8gICAgICAgcHJvcGVydGllcyBvbiBPYmplY3QucHJvdG90eXBlIGFuZCBBcnJheS5wcm90b3R5cGUuXG4gICAgICAgIC8vICAgICAgIEJ1dCB0aGF0IG1ldGhvZCdzIG5ldywgYW5kIGNvbGxpc2lvbnMgc2hvdWxkIGJlXG4gICAgICAgIC8vICAgICAgIHJhcmUsIHNvIHVzZSB0aGUgbW9yZS1jb21wYXRpYmxlIGFsdGVybmF0aXZlLlxuICAgICAgICBpZiAoZnVuLmNhbGwodGhpc0FyZywgdmFsLCBpLCB0KSlcbiAgICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbi8vRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXG5pZiAoIUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcIik7XG4gICAgfVxuXG4gICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgIGZOT1AgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb1RoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcblxuICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICByZXR1cm4gZkJvdW5kO1xuICB9O1xufVxuXG4vL0Zyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZj9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGQXJyYXklMkZpbmRleE9mXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIGlmICggdGhpcyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMgPT09IG51bGwgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCAnXCJ0aGlzXCIgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcgKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggPj4+IDA7IC8vIEhhY2sgdG8gY29udmVydCBvYmplY3QubGVuZ3RoIHRvIGEgVUludDMyXG5cbiAgICBmcm9tSW5kZXggPSArZnJvbUluZGV4IHx8IDA7XG5cbiAgICBpZiAoTWF0aC5hYnMoZnJvbUluZGV4KSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGZyb21JbmRleCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgIGZyb21JbmRleCArPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoO2Zyb21JbmRleCA8IGxlbmd0aDsgZnJvbUluZGV4KyspIHtcbiAgICAgIGlmICh0aGlzW2Zyb21JbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZyb21JbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG59XG4iLCJpZiAodHlwZW9mIFByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICB2YXIgZGVmaW5lLCByZXF1aXJlTW9kdWxlLCByZXF1aXJlLCByZXF1aXJlanM7XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWdpc3RyeSA9IHt9LCBzZWVuID0ge307XG5cbiAgICBkZWZpbmUgPSBmdW5jdGlvbihuYW1lLCBkZXBzLCBjYWxsYmFjaykge1xuICAgICAgcmVnaXN0cnlbbmFtZV0gPSB7IGRlcHM6IGRlcHMsIGNhbGxiYWNrOiBjYWxsYmFjayB9O1xuICAgIH07XG5cbiAgICByZXF1aXJlanMgPSByZXF1aXJlID0gcmVxdWlyZU1vZHVsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXF1aXJlanMuX2Vha19zZWVuID0gcmVnaXN0cnk7XG5cbiAgICAgIGlmIChzZWVuW25hbWVdKSB7IHJldHVybiBzZWVuW25hbWVdOyB9XG4gICAgICBzZWVuW25hbWVdID0ge307XG5cbiAgICAgIGlmICghcmVnaXN0cnlbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgbW9kdWxlIFwiICsgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb2QgPSByZWdpc3RyeVtuYW1lXSxcbiAgICAgICAgICBkZXBzID0gbW9kLmRlcHMsXG4gICAgICAgICAgY2FsbGJhY2sgPSBtb2QuY2FsbGJhY2ssXG4gICAgICAgICAgcmVpZmllZCA9IFtdLFxuICAgICAgICAgIGV4cG9ydHM7XG5cbiAgICAgIGZvciAodmFyIGk9MCwgbD1kZXBzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgaWYgKGRlcHNbaV0gPT09ICdleHBvcnRzJykge1xuICAgICAgICAgIHJlaWZpZWQucHVzaChleHBvcnRzID0ge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlaWZpZWQucHVzaChyZXF1aXJlTW9kdWxlKHJlc29sdmUoZGVwc1tpXSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBjYWxsYmFjay5hcHBseSh0aGlzLCByZWlmaWVkKTtcbiAgICAgIHJldHVybiBzZWVuW25hbWVdID0gZXhwb3J0cyB8fCB2YWx1ZTtcblxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZShjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuY2hhckF0KDApICE9PSAnLicpIHsgcmV0dXJuIGNoaWxkOyB9XG4gICAgICAgIHZhciBwYXJ0cyA9IGNoaWxkLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgdmFyIHBhcmVudEJhc2UgPSBuYW1lLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAtMSk7XG5cbiAgICAgICAgZm9yICh2YXIgaT0wLCBsPXBhcnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgaWYgKHBhcnQgPT09ICcuLicpIHsgcGFyZW50QmFzZS5wb3AoKTsgfVxuICAgICAgICAgIGVsc2UgaWYgKHBhcnQgPT09ICcuJykgeyBjb250aW51ZTsgfVxuICAgICAgICAgIGVsc2UgeyBwYXJlbnRCYXNlLnB1c2gocGFydCk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRCYXNlLmpvaW4oXCIvXCIpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbiAgZGVmaW5lKFwicHJvbWlzZS9hbGxcIixcbiAgICBbXCIuL3V0aWxzXCIsXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZGVwZW5kZW5jeTFfXywgX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgLyogZ2xvYmFsIHRvU3RyaW5nICovXG5cbiAgICAgIHZhciBpc0FycmF5ID0gX19kZXBlbmRlbmN5MV9fLmlzQXJyYXk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IF9fZGVwZW5kZW5jeTFfXy5pc0Z1bmN0aW9uO1xuXG4gICAgICAvKipcbiAgICAgICAgUmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgdGhlIGdpdmVuIHByb21pc2VzIGhhdmUgYmVlblxuICAgICAgICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC4gVGhlIHJldHVybiBwcm9taXNlXG4gICAgICAgIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIGFycmF5IHRoYXQgZ2l2ZXMgYWxsIHRoZSB2YWx1ZXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZVxuICAgICAgICBwYXNzZWQgaW4gdGhlIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQuXG5cbiAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlMSA9IFJTVlAucmVzb2x2ZSgxKTtcbiAgICAgICAgdmFyIHByb21pc2UyID0gUlNWUC5yZXNvbHZlKDIpO1xuICAgICAgICB2YXIgcHJvbWlzZTMgPSBSU1ZQLnJlc29sdmUoMyk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gICAgICAgIFJTVlAuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAgICAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgUlNWUC5hbGxgIGFyZSByZWplY3RlZCwgdGhlIGZpcnN0IHByb21pc2VcbiAgICAgICAgdGhhdCBpcyByZWplY3RlZCB3aWxsIGJlIGdpdmVuIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSByZXR1cm5lZCBwcm9taXNlcydzXG4gICAgICAgIHJlamVjdGlvbiBoYW5kbGVyLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICBFeGFtcGxlOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIHByb21pc2UxID0gUlNWUC5yZXNvbHZlKDEpO1xuICAgICAgICB2YXIgcHJvbWlzZTIgPSBSU1ZQLnJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgICAgICAgdmFyIHByb21pc2UzID0gUlNWUC5yZWplY3QobmV3IEVycm9yKFwiM1wiKSk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gICAgICAgIFJTVlAuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAgICAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVucyBiZWNhdXNlIHRoZXJlIGFyZSByZWplY3RlZCBwcm9taXNlcyFcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBlcnJvci5tZXNzYWdlID09PSBcIjJcIlxuICAgICAgICB9KTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgQG1ldGhvZCBhbGxcbiAgICAgICAgQGZvciBSU1ZQXG4gICAgICAgIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzXG4gICAgICAgIEBwYXJhbSB7U3RyaW5nfSBsYWJlbFxuICAgICAgICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gICAgICAgIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICB2YXIgUHJvbWlzZSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KHByb21pc2VzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gYWxsLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciByZXN1bHRzID0gW10sIHJlbWFpbmluZyA9IHByb21pc2VzLmxlbmd0aCxcbiAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICAgICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICByZXNvbHZlQWxsKGluZGV4LCB2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVBbGwoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAocHJvbWlzZSAmJiBpc0Z1bmN0aW9uKHByb21pc2UudGhlbikpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmVyKGkpLCByZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZUFsbChpLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5hbGwgPSBhbGw7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvYXNhcFwiLFxuICAgIFtcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgdmFyIGJyb3dzZXJHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDoge307XG4gICAgICB2YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgICAgdmFyIGxvY2FsID0gd2luZG93O1xuXG4gICAgICAvLyBub2RlXG4gICAgICBmdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbm9kZS5kYXRhID0gKGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvY2FsLnNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHR1cGxlID0gcXVldWVbaV07XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gdHVwbGVbMF0sIGFyZyA9IHR1cGxlWzFdO1xuICAgICAgICAgIGNhbGxiYWNrKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjaGVkdWxlRmx1c2g7XG5cbiAgICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgICAgICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbiAgICAgIH0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcXVldWUucHVzaChbY2FsbGJhY2ssIGFyZ10pO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gSWYgbGVuZ3RoIGlzIDEsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgICAgICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgICAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5hc2FwID0gYXNhcDtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9jb25maWdcIixcbiAgICBbXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIGluc3RydW1lbnQ6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBjb25maWd1cmUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBjb25maWdbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY29uZmlnW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIF9fZXhwb3J0c19fLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZTtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9wb2x5ZmlsbFwiLFxuICAgIFtcIi4vcHJvbWlzZVwiLFwiLi91dGlsc1wiLFwiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2RlcGVuZGVuY3kxX18sIF9fZGVwZW5kZW5jeTJfXywgX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgLypnbG9iYWwgc2VsZiovXG4gICAgICB2YXIgUlNWUFByb21pc2UgPSBfX2RlcGVuZGVuY3kxX18uUHJvbWlzZTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gX19kZXBlbmRlbmN5Ml9fLmlzRnVuY3Rpb247XG5cbiAgICAgIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgICAgICB2YXIgbG9jYWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICAgIGxvY2FsID0gd2luZG93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2FsID0gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlczZQcm9taXNlU3VwcG9ydCA9XG4gICAgICAgICAgXCJQcm9taXNlXCIgaW4gbG9jYWwgJiZcbiAgICAgICAgICAvLyBTb21lIG9mIHRoZXNlIG1ldGhvZHMgYXJlIG1pc3NpbmcgZnJvbVxuICAgICAgICAgIC8vIEZpcmVmb3gvQ2hyb21lIGV4cGVyaW1lbnRhbCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICBcInJlc29sdmVcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgICAgXCJyZWplY3RcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgICAgXCJhbGxcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgICAgXCJyYWNlXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICAgIC8vIE9sZGVyIHZlcnNpb24gb2YgdGhlIHNwZWMgaGFkIGEgcmVzb2x2ZXIgb2JqZWN0XG4gICAgICAgICAgLy8gYXMgdGhlIGFyZyByYXRoZXIgdGhhbiBhIGZ1bmN0aW9uXG4gICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmU7XG4gICAgICAgICAgICBuZXcgbG9jYWwuUHJvbWlzZShmdW5jdGlvbihyKSB7IHJlc29sdmUgPSByOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHJlc29sdmUpO1xuICAgICAgICAgIH0oKSk7XG5cbiAgICAgICAgaWYgKCFlczZQcm9taXNlU3VwcG9ydCkge1xuICAgICAgICAgIGxvY2FsLlByb21pc2UgPSBSU1ZQUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3Byb21pc2VcIixcbiAgICBbXCIuL2NvbmZpZ1wiLFwiLi91dGlsc1wiLFwiLi9hbGxcIixcIi4vcmFjZVwiLFwiLi9yZXNvbHZlXCIsXCIuL3JlamVjdFwiLFwiLi9hc2FwXCIsXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZGVwZW5kZW5jeTFfXywgX19kZXBlbmRlbmN5Ml9fLCBfX2RlcGVuZGVuY3kzX18sIF9fZGVwZW5kZW5jeTRfXywgX19kZXBlbmRlbmN5NV9fLCBfX2RlcGVuZGVuY3k2X18sIF9fZGVwZW5kZW5jeTdfXywgX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgdmFyIGNvbmZpZyA9IF9fZGVwZW5kZW5jeTFfXy5jb25maWc7XG4gICAgICB2YXIgY29uZmlndXJlID0gX19kZXBlbmRlbmN5MV9fLmNvbmZpZ3VyZTtcbiAgICAgIHZhciBvYmplY3RPckZ1bmN0aW9uID0gX19kZXBlbmRlbmN5Ml9fLm9iamVjdE9yRnVuY3Rpb247XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IF9fZGVwZW5kZW5jeTJfXy5pc0Z1bmN0aW9uO1xuICAgICAgdmFyIG5vdyA9IF9fZGVwZW5kZW5jeTJfXy5ub3c7XG4gICAgICB2YXIgYWxsID0gX19kZXBlbmRlbmN5M19fLmFsbDtcbiAgICAgIHZhciByYWNlID0gX19kZXBlbmRlbmN5NF9fLnJhY2U7XG4gICAgICB2YXIgc3RhdGljUmVzb2x2ZSA9IF9fZGVwZW5kZW5jeTVfXy5yZXNvbHZlO1xuICAgICAgdmFyIHN0YXRpY1JlamVjdCA9IF9fZGVwZW5kZW5jeTZfXy5yZWplY3Q7XG4gICAgICB2YXIgYXNhcCA9IF9fZGVwZW5kZW5jeTdfXy5hc2FwO1xuXG4gICAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICAgIGNvbmZpZy5hc3luYyA9IGFzYXA7IC8vIGRlZmF1bHQgYXN5bmMgaXMgYXNhcDtcblxuICAgICAgZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24ocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgICAgaW52b2tlUmVzb2x2ZXIocmVzb2x2ZXIsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VSZXNvbHZlcihyZXNvbHZlciwgcHJvbWlzZSkge1xuICAgICAgICBmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzb2x2ZXIocmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICByZWplY3RQcm9taXNlKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgICAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICAgICAgICB2YWx1ZSwgZXJyb3IsIHN1Y2NlZWRlZCwgZmFpbGVkO1xuXG4gICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ2FsbGJhY2sgJiYgc3VjY2VlZGVkKSB7XG4gICAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFBFTkRJTkcgICA9IHZvaWQgMDtcbiAgICAgIHZhciBTRUFMRUQgICAgPSAwO1xuICAgICAgdmFyIEZVTEZJTExFRCA9IDE7XG4gICAgICB2YXIgUkVKRUNURUQgID0gMjtcblxuICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICAgIHZhciBsZW5ndGggPSBzdWJzY3JpYmVycy5sZW5ndGg7XG5cbiAgICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICAgICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdICA9IG9uUmVqZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwdWJsaXNoKHByb21pc2UsIHNldHRsZWQpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjYWxsYmFjaywgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycywgZGV0YWlsID0gcHJvbWlzZS5fZGV0YWlsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBQcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFByb21pc2UsXG5cbiAgICAgICAgX3N0YXRlOiB1bmRlZmluZWQsXG4gICAgICAgIF9kZXRhaWw6IHVuZGVmaW5lZCxcbiAgICAgICAgX3N1YnNjcmliZXJzOiB1bmRlZmluZWQsXG5cbiAgICAgICAgdGhlbjogZnVuY3Rpb24ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgdGhlblByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihmdW5jdGlvbigpIHt9KTtcblxuICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGNvbmZpZy5hc3luYyhmdW5jdGlvbiBpbnZva2VQcm9taXNlQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKHByb21pc2UuX3N0YXRlLCB0aGVuUHJvbWlzZSwgY2FsbGJhY2tzW3Byb21pc2UuX3N0YXRlIC0gMV0sIHByb21pc2UuX2RldGFpbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlKHRoaXMsIHRoZW5Qcm9taXNlLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoZW5Qcm9taXNlO1xuICAgICAgICB9LFxuXG4gICAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIFByb21pc2UuYWxsID0gYWxsO1xuICAgICAgUHJvbWlzZS5yYWNlID0gcmFjZTtcbiAgICAgIFByb21pc2UucmVzb2x2ZSA9IHN0YXRpY1Jlc29sdmU7XG4gICAgICBQcm9taXNlLnJlamVjdCA9IHN0YXRpY1JlamVjdDtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBudWxsLFxuICAgICAgICByZXNvbHZlZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB0aGVuID0gdmFsdWUudGhlbjtcblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChyZXNvbHZlZCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xuICAgICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IFNFQUxFRDtcbiAgICAgICAgcHJvbWlzZS5fZGV0YWlsID0gdmFsdWU7XG5cbiAgICAgICAgY29uZmlnLmFzeW5jKHB1Ymxpc2hGdWxmaWxsbWVudCwgcHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7IHJldHVybjsgfVxuICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IFNFQUxFRDtcbiAgICAgICAgcHJvbWlzZS5fZGV0YWlsID0gcmVhc29uO1xuXG4gICAgICAgIGNvbmZpZy5hc3luYyhwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHVibGlzaEZ1bGZpbGxtZW50KHByb21pc2UpIHtcbiAgICAgICAgcHVibGlzaChwcm9taXNlLCBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICBwdWJsaXNoKHByb21pc2UsIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQpO1xuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5Qcm9taXNlID0gUHJvbWlzZTtcbiAgICB9KTtcbiAgZGVmaW5lKFwicHJvbWlzZS9yYWNlXCIsXG4gICAgW1wiLi91dGlsc1wiLFwiZXhwb3J0c1wiXSxcbiAgICBmdW5jdGlvbihfX2RlcGVuZGVuY3kxX18sIF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIC8qIGdsb2JhbCB0b1N0cmluZyAqL1xuICAgICAgdmFyIGlzQXJyYXkgPSBfX2RlcGVuZGVuY3kxX18uaXNBcnJheTtcblxuICAgICAgLyoqXG4gICAgICAgIGBSU1ZQLnJhY2VgIGFsbG93cyB5b3UgdG8gd2F0Y2ggYSBzZXJpZXMgb2YgcHJvbWlzZXMgYW5kIGFjdCBhcyBzb29uIGFzIHRoZVxuICAgICAgICBmaXJzdCBwcm9taXNlIGdpdmVuIHRvIHRoZSBgcHJvbWlzZXNgIGFyZ3VtZW50IGZ1bGZpbGxzIG9yIHJlamVjdHMuXG5cbiAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBwcm9taXNlMSA9IG5ldyBSU1ZQLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXNvbHZlKFwicHJvbWlzZSAxXCIpO1xuICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwcm9taXNlMiA9IG5ldyBSU1ZQLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXNvbHZlKFwicHJvbWlzZSAyXCIpO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFJTVlAucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgIC8vIHJlc3VsdCA9PT0gXCJwcm9taXNlIDJcIiBiZWNhdXNlIGl0IHdhcyByZXNvbHZlZCBiZWZvcmUgcHJvbWlzZTFcbiAgICAgICAgICAvLyB3YXMgcmVzb2x2ZWQuXG4gICAgICAgIH0pO1xuICAgICAgICBgYGBcblxuICAgICAgICBgUlNWUC5yYWNlYCBpcyBkZXRlcm1pbmlzdGljIGluIHRoYXQgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpcnN0IGNvbXBsZXRlZFxuICAgICAgICBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZSBgcHJvbWlzZXNgXG4gICAgICAgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBjb21wbGV0ZWQgcHJvbWlzZSBoYXMgYmVjb21lXG4gICAgICAgIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkIHByb21pc2VcbiAgICAgICAgd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgcHJvbWlzZTEgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmVzb2x2ZShcInByb21pc2UgMVwiKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvbWlzZTIgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInByb21pc2UgMlwiKSk7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgUlNWUC5yYWNlKFtwcm9taXNlMSwgcHJvbWlzZTJdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09IFwicHJvbWlzZTJcIiBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgICAgICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIEBtZXRob2QgcmFjZVxuICAgICAgICBAZm9yIFJTVlBcbiAgICAgICAgQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gb2JzZXJ2ZVxuICAgICAgICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBkZXNjcmliaW5nIHRoZSBwcm9taXNlIHJldHVybmVkLlxuICAgICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICAgIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IGJlY29tZXMgZnVsZmlsbGVkIHdpdGggdGhlIHZhbHVlIHRoZSBmaXJzdFxuICAgICAgICBjb21wbGV0ZWQgcHJvbWlzZXMgaXMgcmVzb2x2ZWQgd2l0aCBpZiB0aGUgZmlyc3QgY29tcGxldGVkIHByb21pc2Ugd2FzXG4gICAgICAgIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgd2l0aCB0aGUgcmVhc29uIHRoYXQgdGhlIGZpcnN0IGNvbXBsZXRlZCBwcm9taXNlXG4gICAgICAgIHdhcyByZWplY3RlZCB3aXRoLlxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJhY2UocHJvbWlzZXMpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIFByb21pc2UgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNBcnJheShwcm9taXNlcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciByZXN1bHRzID0gW10sIHByb21pc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChwcm9taXNlICYmIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIF9fZXhwb3J0c19fLnJhY2UgPSByYWNlO1xuICAgIH0pO1xuICBkZWZpbmUoXCJwcm9taXNlL3JlamVjdFwiLFxuICAgIFtcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgLyoqXG4gICAgICAgIGBSU1ZQLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWRcbiAgICAgICAgYHJlYXNvbmAuIGBSU1ZQLnJlamVjdGAgaXMgZXNzZW50aWFsbHkgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICAgICAgICB9KTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgdmFyIHByb21pc2UgPSBSU1ZQLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICAgICAgICB9KTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgQG1ldGhvZCByZWplY3RcbiAgICAgICAgQGZvciBSU1ZQXG4gICAgICAgIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gICAgICAgIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGlkZW50aWZ5aW5nIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICAgIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuXG4gICAgICAgIGByZWFzb25gLlxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIFByb21pc2UgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBfX2V4cG9ydHNfXy5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvcmVzb2x2ZVwiLFxuICAgIFtcImV4cG9ydHNcIl0sXG4gICAgZnVuY3Rpb24oX19leHBvcnRzX18pIHtcbiAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gdGhpcykge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBQcm9taXNlID0gdGhpcztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgX19leHBvcnRzX18ucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gIGRlZmluZShcInByb21pc2UvdXRpbHNcIixcbiAgICBbXCJleHBvcnRzXCJdLFxuICAgIGZ1bmN0aW9uKF9fZXhwb3J0c19fKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih4KSB8fCAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNBcnJheSh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgIH1cblxuICAgICAgLy8gRGF0ZS5ub3cgaXMgbm90IGF2YWlsYWJsZSBpbiBicm93c2VycyA8IElFOVxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9ub3cjQ29tcGF0aWJpbGl0eVxuICAgICAgdmFyIG5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG5cblxuICAgICAgX19leHBvcnRzX18ub2JqZWN0T3JGdW5jdGlvbiA9IG9iamVjdE9yRnVuY3Rpb247XG4gICAgICBfX2V4cG9ydHNfXy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICAgIF9fZXhwb3J0c19fLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgICAgX19leHBvcnRzX18ubm93ID0gbm93O1xuICAgIH0pO1xuICByZXF1aXJlTW9kdWxlKCdwcm9taXNlL3BvbHlmaWxsJykucG9seWZpbGwoKTtcbiAgfSgpKTtcbn1cbiIsInJlcXVpcmUoJ2xlYWZsZXQnKTtcbnJlcXVpcmUoJ2h0bWw1c2hpdicpO1xuXG4vLyBERyBpbmhlcml0YW5jZVxudmFyIG9sZERHID0gd2luZG93LkRHO1xuREcgPSBuZXcgKFxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBEZ0FwaSA9IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgRGdBcGlDb3JlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgRGdBcGlDb3JlLnByb3RvdHlwZSA9IEw7XG4gICAgICAgIERnQXBpLnByb3RvdHlwZSA9IG5ldyBEZ0FwaUNvcmUoKTtcblxuICAgICAgICByZXR1cm4gRGdBcGk7XG4gICAgfSkoKVxuKSgpO1xuXG5mb3IgKHZhciBwcm9wIGluIG9sZERHKSB7XG4gICAgaWYgKG9sZERHLmhhc093blByb3BlcnR5KHByb3ApICYmIHR5cGVvZiBER1twcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgREdbcHJvcF0gPSBvbGRER1twcm9wXTtcbiAgICB9XG59XG5cbndpbmRvdy5fX2RnQXBpX18gPSB3aW5kb3cuX19kZ0FwaV9fIHx8IHt9O1xuREcudmVyc2lvbiA9IHdpbmRvdy5fX2RnQXBpX18udmVyc2lvbjtcbkRHLkljb24uRGVmYXVsdC5pbWFnZVBhdGggID0gJy4uL2ltZy92ZW5kb3JzL2xlYWZsZXQnO1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5pdGVkID0gZmFsc2U7XG5cbiAgICAvLyBBbmFseXRpY3MgaW5pdGVkIG9uY2VcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWluaXRlZCkge1xuICAgICAgICAgICAgLyplc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgICAgICAgKGZ1bmN0aW9uKGkscyxvLGcscixhLG0pe2lbJ0dvb2dsZUFuYWx5dGljc09iamVjdCddPXI7aVtyXT1pW3JdfHxmdW5jdGlvbigpe1xuICAgICAgICAgICAgKGlbcl0ucT1pW3JdLnF8fFtdKS5wdXNoKGFyZ3VtZW50cyl9LGlbcl0ubD0xKm5ldyBEYXRlKCk7YT1zLmNyZWF0ZUVsZW1lbnQobyksXG4gICAgICAgICAgICBtPXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobylbMF07YS5hc3luYz0xO2Euc3JjPWc7bS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLG0pXG4gICAgICAgICAgICB9KSh3aW5kb3csZG9jdW1lbnQsJ3NjcmlwdCcsREcuY29uZmlnLnByb3RvY29sK0RHLmNvbmZpZy5nb29nbGVBbmFseXRpY3MsJ2dhJyk7XG4gICAgICAgICAgICAvKmVzbGludC1lbmFibGUgKi9cblxuICAgICAgICAgICAgaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgZ2EoJ2NyZWF0ZScsIERHLmNvbmZpZy5nYUNvZGUsICdub25lJywge25hbWU6ICdtYXBzYXBpMmdpcyd9KTtcbiAgICAgICAgZ2EoJ21hcHNhcGkyZ2lzLnNlbmQnLCAncGFnZXZpZXcnKTtcbiAgICAgICAgLyplc2xpbnQtZW5hYmxlICovXG5cbiAgICAgICAgdmFyIG5ld0ltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBuZXdJbWcuc3JjID0gREcuY29uZmlnLnByb3RvY29sICsgREcuY29uZmlnLmFuYWx5dGljcyArICc/JyArXG4gICAgICAgICAgICAnc3I9JyArIHdpbmRvdy5zY3JlZW4ud2lkdGggKyAneCcgKyB3aW5kb3cuc2NyZWVuLmhlaWdodCArICcmJyArXG4gICAgICAgICAgICAndj0nICsgREcudmVyc2lvbjtcbiAgICB9O1xufSkoKSk7XG5cbi8vIEltcHJvdmUgSUhhbmRsZXJcbkRHLk1hcC5pbmNsdWRlKHtcbiAgICBhZGRIYW5kbGVyOiBmdW5jdGlvbiAobmFtZSwgSGFuZGxlckNsYXNzKSB7XG4gICAgICAgIGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNbbmFtZV0sXG4gICAgICAgICAgICBwYXJhbSA9IChvcHRpb25zID09PSBPYmplY3Qob3B0aW9ucykpID8gb3B0aW9ucyA6IG51bGwsXG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpc1tuYW1lXSA9IG5ldyBIYW5kbGVyQ2xhc3ModGhpcywgcGFyYW0pO1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuZW5hYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxuLy8gQXBwbHkgY2xhc3MgdG8gbWFwIGNvbnRhaW5lciBmb3IgZGV0ZWN0IHdoZW4gd2UgZG9udCBuZWVkIGhvdmVyIGVmZmVjdHNcbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFERy5Ccm93c2VyLnRvdWNoKSB7XG4gICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbm8tdG91Y2gnKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBERztcbiIsInZhciBoYW5kbGVycyA9IHdpbmRvdy5fX2RnQXBpX18uY2FsbGJhY2tzIHx8IFtdLFxuICAgIGNoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXJzKSB7XG4gICAgY2hhaW4gPSBjaGFpbi50aGVuKGhhbmRsZXJzWzBdLCBoYW5kbGVyc1sxXSk7XG59KTtcblxuREcudGhlbiA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXR1cm4gY2hhaW4udGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuLy8gSUU4IHRocm93IGVycm9yIGlmIGBjaGFpbi5jYXRjaGBcbi8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiwgbm8tY29uc29sZSAqL1xuY2hhaW5bJ2NhdGNoJ10oZnVuY3Rpb24gKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbn0pO1xuLyogZXNsaW50LWVuYWJsZSBkb3Qtbm90YXRpb24sIG5vLWNvbnNvbGUgKi9cbiIsIkRHLnBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW5zKSB7XG4gICAgdmFyIGNvdW50LFxuICAgICAgICBqc1JlZyA9IG5ldyBSZWdFeHAoLy5qcyQvaSksXG4gICAgICAgIGNzc1JlZyA9IG5ldyBSZWdFeHAoLy5jc3MkL2kpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGluZyAoKSB7XG4gICAgICAgICAgICBjb3VudC0tO1xuXG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcHBlbmRKUyAobGluaykge1xuICAgICAgICAgICAgdmFyIGpzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBqcy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9qYXZhc2NyaXB0Jyk7XG4gICAgICAgICAgICBqcy5zZXRBdHRyaWJ1dGUoJ3NyYycsIGxpbmspO1xuICAgICAgICAgICAganMub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNoZWNrTG9hZGluZygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGpzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkaW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gbG9hZC9lcnJvciBmb3IgSUVcbiAgICAgICAgICAgIGpzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoanMucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fCBqcy5yZWFkeVN0YXRlID09PSAnbG9hZGVkJykge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0xvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGpzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZENTUyAobGluaykge1xuICAgICAgICAgICAgdmFyIGNzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgICAgIGNzcy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBjc3Muc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgICAgICBjc3Muc2V0QXR0cmlidXRlKCdocmVmJywgbGluayk7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGNzcyk7XG5cbiAgICAgICAgICAgIGNoZWNrTG9hZGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNKcyAodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNSZWcudGVzdCh1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNDc3MgKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIGNzc1JlZy50ZXN0KHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhcHBlbmRBc3NldCAoYXNzZXQpIHtcbiAgICAgICAgICAgIGlmIChpc0pzKGFzc2V0KSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZEpTKGFzc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDc3MoYXNzZXQpKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kQ1NTKGFzc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChERy5VdGlsLmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgICAgIGNvdW50ID0gcGx1Z2lucy5sZW5ndGg7XG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAgICAgICAgIGFwcGVuZEFzc2V0KHBsdWdpbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGx1Z2lucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgICAgIGFwcGVuZEFzc2V0KHBsdWdpbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuIiwiREcuYWpheCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgd2luID0gd2luZG93LFxuICAgICAgICBkb2MgPSBkb2N1bWVudCxcblxuICAgICAgICBydXJsID0gL14oW1xcdy4rLV0rOik/KD86XFwvXFwvKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxuICAgICAgICB0d29IdW5kbyA9IC9eMjBcXGQkLyxcblxuICAgICAgICAvLyBEb2N1bWVudCBsb2NhdGlvblxuICAgICAgICBhamF4TG9jUGFydHMsXG4gICAgICAgIGFqYXhMb2NhdGlvbixcblxuICAgICAgICBieVRhZyA9ICdnZXRFbGVtZW50c0J5VGFnTmFtZScsXG4gICAgICAgIHJlYWR5U3RhdGUgPSAncmVhZHlTdGF0ZScsXG4gICAgICAgIGNvbnRlbnRUeXBlID0gJ0NvbnRlbnQtVHlwZScsXG4gICAgICAgIHJlcXVlc3RlZFdpdGggPSAnWC1SZXF1ZXN0ZWQtV2l0aCcsXG4gICAgICAgIGhlYWQgPSBkb2NbYnlUYWddKCdoZWFkJylbMF0sXG4gICAgICAgIHVuaXFpZCA9IDAsXG4gICAgICAgIGNhbGxiYWNrUHJlZml4ID0gJ2xfZGdfYWpheF9jYWxsYmFja18nICsgKCtuZXcgRGF0ZSgpKSxcbiAgICAgICAgbGFzdFZhbHVlLCAvLyBkYXRhIHN0b3JlZCBieSB0aGUgbW9zdCByZWNlbnQgSlNPTlAgY2FsbGJhY2tcbiAgICAgICAgeG1sSHR0cFJlcXVlc3QgPSAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgICB4RG9tYWluUmVxdWVzdCA9ICdYRG9tYWluUmVxdWVzdCcsXG4gICAgICAgIG5vb3AgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICByZXF1ZXN0ZWRXaXRoOiB4bWxIdHRwUmVxdWVzdCxcbiAgICAgICAgICAgIGFjY2VwdDoge1xuICAgICAgICAgICAgICAgICcqJzogICd0ZXh0L2phdmFzY3JpcHQsIHRleHQvaHRtbCwgYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCwgKi8qJyxcbiAgICAgICAgICAgICAgICB4bWw6ICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCcsXG4gICAgICAgICAgICAgICAgaHRtbDogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAgICAgdGV4dDogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgICAgIGpzb246ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgICAgIGpzOiAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCB0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qZ2xvYmFsIFhEb21haW5SZXF1ZXN0OmZhbHNlLCBBY3RpdmVYT2JqZWN0OmZhbHNlICovXG4gICAgICAgIHhociA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBpcyBpdCB4LWRvbWFpblxuICAgICAgICAgICAgaWYgKG8uY3Jvc3NEb21haW4gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gd2luW3htbEh0dHBSZXF1ZXN0XSA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoeGhyICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5beG1sSHR0cFJlcXVlc3RdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2xvYmFsU2V0dXBPcHRpb25zID0ge1xuICAgICAgICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmdcbiAgICAvLyBhIGZpZWxkIGZyb20gd2luZG93LmxvY2F0aW9uIGlmIGRvY3VtZW50LmRvbWFpbiBoYXMgYmVlbiBzZXRcbiAgICB0cnkge1xuICAgICAgICBhamF4TG9jYXRpb24gPSBsb2NhdGlvbi5ocmVmO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBocmVmIGF0dHJpYnV0ZSBvZiBhbiBBIGVsZW1lbnRcbiAgICAgICAgLy8gc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cbiAgICAgICAgYWpheExvY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBhamF4TG9jYXRpb24uaHJlZiA9ICcnO1xuICAgICAgICBhamF4TG9jYXRpb24gPSBhamF4TG9jYXRpb24uaHJlZjtcbiAgICB9XG5cbiAgICAvLyBTZWdtZW50IGxvY2F0aW9uIGludG8gcGFydHNcbiAgICBhamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkpIHx8IFtdO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVhZHlTdGF0ZSAociwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHVzZSBfYWJvcnRlZCB0byBtaXRpZ2F0ZSBhZ2FpbnN0IElFIGVyciBjMDBjMDIzZlxuICAgICAgICAgICAgLy8gKGNhbid0IHJlYWQgcHJvcHMgb24gYWJvcnRlZCByZXF1ZXN0IG9iamVjdHMpXG4gICAgICAgICAgICBpZiAoci5fYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihyLnJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIucmVxdWVzdCAmJiByLnJlcXVlc3RbcmVhZHlTdGF0ZV0gPT09IDQpIHtcbiAgICAgICAgICAgICAgICByLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbm9vcDtcbiAgICAgICAgICAgICAgICBpZiAodHdvSHVuZG8udGVzdChyLnJlcXVlc3Quc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHIucmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioci5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVycyAoaHR0cCwgbykge1xuICAgICAgICB2YXIgaGVhZGVycyA9IG8uaGVhZGVycyB8fCB7fSxcbiAgICAgICAgICAgIGg7XG5cbiAgICAgICAgaGVhZGVycy5BY2NlcHQgPSBoZWFkZXJzLkFjY2VwdCB8fCBkZWZhdWx0SGVhZGVycy5hY2NlcHRbby5kYXRhVHlwZV0gfHwgZGVmYXVsdEhlYWRlcnMuYWNjZXB0WycqJ107XG5cbiAgICAgICAgLy8gYnJlYWtzIGNyb3NzLW9yaWdpbiByZXF1ZXN0cyB3aXRoIGxlZ2FjeSBicm93c2Vyc1xuICAgICAgICBpZiAoIW8uY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbcmVxdWVzdGVkV2l0aF0pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbcmVxdWVzdGVkV2l0aF0gPSBkZWZhdWx0SGVhZGVycy5yZXF1ZXN0ZWRXaXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGVhZGVyc1tjb250ZW50VHlwZV0pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbY29udGVudFR5cGVdID0gby5jb250ZW50VHlwZSB8fCBkZWZhdWx0SGVhZGVycy5jb250ZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGggaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoaCkgJiYgJ3NldFJlcXVlc3RIZWFkZXInIGluIGh0dHApIHtcbiAgICAgICAgICAgICAgICBodHRwLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDcmVkZW50aWFscyAoaHR0cCwgbykge1xuICAgICAgICBpZiAodHlwZW9mIG8ud2l0aENyZWRlbnRpYWxzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaHR0cC53aXRoQ3JlZGVudGlhbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBodHRwLndpdGhDcmVkZW50aWFscyA9ICEhby53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmFsQ2FsbGJhY2sgKGRhdGEpIHtcbiAgICAgICAgbGFzdFZhbHVlID0gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cmxhcHBlbmQgKHVybCwgcykge1xuICAgICAgICByZXR1cm4gdXJsICsgKC9cXD8vLnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyBzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUpzb25wIChvLCBmbiwgZXJyLCB1cmwpIHtcbiAgICAgICAgdmFyIHJlcUlkID0gdW5pcWlkKyssXG4gICAgICAgICAgICBjYmtleSA9IG8uanNvbnBDYWxsYmFjayB8fCAnY2FsbGJhY2snLCAvLyB0aGUgJ2NhbGxiYWNrJyBrZXlcbiAgICAgICAgICAgIGNidmFsID0gby5qc29ucENhbGxiYWNrTmFtZSB8fCBjYWxsYmFja1ByZWZpeCxcbiAgICAgICAgICAgIGNicmVnID0gbmV3IFJlZ0V4cCgnKChefFxcXFw/fCYpJyArIGNia2V5ICsgJyk9KFteJl0rKScpLFxuICAgICAgICAgICAgbWF0Y2ggPSB1cmwubWF0Y2goY2JyZWcpLFxuICAgICAgICAgICAgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgICAgbG9hZGVkID0gMCxcbiAgICAgICAgICAgIGlzSUUxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRSAxMC4wJykgIT09IC0xO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzNdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShjYnJlZywgJyQxPScgKyBjYnZhbCk7IC8vIHdpbGRjYXJkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYnZhbCA9IG1hdGNoWzNdOyAvLyBwcm92aWRlZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGNia2V5ICsgJz0nICsgY2J2YWwpOyAvLyBubyBjYWxsYmFjayBkZXRhaWxzLCBhZGQgJ2VtXG4gICAgICAgIH1cblxuICAgICAgICB3aW5bY2J2YWxdID0gZ2VuZXJhbENhbGxiYWNrO1xuXG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzSUUxMCkge1xuICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGZvciBJRSBkdWUgdG8gb3V0LW9mLW9yZGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSgpLCBiaW5kaW5nIHNjcmlwdFxuICAgICAgICAgICAgLy8gZXhlY3V0aW9uIHRvIGFuIGV2ZW50IGxpc3RlbmVyIGdpdmVzIHVzIGNvbnRyb2wgb3ZlciB3aGVuIHRoZSBzY3JpcHRcbiAgICAgICAgICAgIC8vIGlzIGV4ZWN1dGVkLiBTZWUgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBoYWNrIGlzIHVzZWQgaW4gSUUxMCBqc29ucCBjYWxsYmFjayBhcmUgbmV2ZXIgY2FsbGVkXG4gICAgICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZCA9ICdfcmVxdWVzdF8nICsgcmVxSWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgZXJyKHt9LCAnUmVxdWVzdCB1bmtub3duIGVycm9yJywge30pO1xuICAgICAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgbG9hZGVkID0gMTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoKHNjcmlwdFtyZWFkeVN0YXRlXSAmJiBzY3JpcHRbcmVhZHlTdGF0ZV0gIT09ICdjb21wbGV0ZScgJiYgc2NyaXB0W3JlYWR5U3RhdGVdICE9PSAnbG9hZGVkJykgfHwgbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdXNlciBjYWxsYmFjayB3aXRoIHRoZSBsYXN0IHZhbHVlIHN0b3JlZCBhbmQgY2xlYW4gdXAgdmFsdWVzIGFuZCBzY3JpcHRzLlxuICAgICAgICAgICAgZm4obGFzdFZhbHVlKTtcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIGxvYWRlZCA9IDE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIHRoZSBzY3JpcHQgdG8gdGhlIERPTSBoZWFkXG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICAgICAgICAvLyBFbmFibGUgSlNPTlAgdGltZW91dFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlcnIoe30sICdSZXF1ZXN0IGlzIGFib3J0ZWQ6IHRpbWVvdXQnLCB7fSk7XG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlcXVlc3QgKGZuLCBlcnIpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBtZXRob2QgPSAoby50eXBlIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgdXJsID0gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbyA6IG8udXJsLFxuICAgICAgICAgICAgLy8gY29udmVydCBub24tc3RyaW5nIG9iamVjdHMgdG8gcXVlcnktc3RyaW5nIGZvcm0gdW5sZXNzIG8ucHJvY2Vzc0RhdGEgaXMgZmFsc2VcbiAgICAgICAgICAgIGRhdGEgPSAoby5wcm9jZXNzRGF0YSAhPT0gZmFsc2UgJiYgby5kYXRhICYmIHR5cGVvZiBvLmRhdGEgIT09ICdzdHJpbmcnKSA/IEFqYXgudG9RdWVyeVN0cmluZyhvLmRhdGEpIDogKG8uZGF0YSB8fCBudWxsKSxcbiAgICAgICAgICAgIGh0dHAsXG4gICAgICAgICAgICBzZW5kV2FpdCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGlmIHdlJ3JlIHdvcmtpbmcgb24gYSBHRVQgcmVxdWVzdCBhbmQgd2UgaGF2ZSBkYXRhIHRoZW4gd2Ugc2hvdWxkIGFwcGVuZFxuICAgICAgICAvLyBxdWVyeSBzdHJpbmcgdG8gZW5kIG9mIFVSTCBhbmQgbm90IHBvc3QgZGF0YVxuICAgICAgICBpZiAoKG8udHlwZSA9PT0gJ2pzb25wJyB8fCBtZXRob2QgPT09ICdHRVQnKSAmJiBkYXRhKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmxhcHBlbmQodXJsLCBkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG8udHlwZSA9PT0gJ2pzb25wJykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUpzb25wKG8sIGZuLCBlcnIsIHVybCk7XG4gICAgICAgIH1cblxuICAgICAgICBodHRwID0geGhyKG8pO1xuICAgICAgICBodHRwLm9wZW4obWV0aG9kLCB1cmwsIG8uYXN5bmMgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlKTtcblxuICAgICAgICBzZXRIZWFkZXJzKGh0dHAsIG8pO1xuICAgICAgICBzZXRDcmVkZW50aWFscyhodHRwLCBvKTtcblxuICAgICAgICBpZiAod2luW3hEb21haW5SZXF1ZXN0XSAmJiBodHRwIGluc3RhbmNlb2Ygd2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICAgICAgaHR0cC5vbmxvYWQgPSBmbjtcbiAgICAgICAgICAgIGh0dHAub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgaHR0cC5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIGh0dHAub25lcnJvciA9IGVycjtcbiAgICAgICAgICAgIHNlbmRXYWl0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlUmVhZHlTdGF0ZSh0aGlzLCBmbiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VuZFdhaXQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGh0dHAuc2VuZChkYXRhKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodHRwLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0dHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRQYXJhbXMgKHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkKSB7XG4gICAgICAgIHZhciBuYW1lLCBpLCB2LFxuICAgICAgICAgICAgcmJyYWNrZXQgPSAvXFxbXFxdJC87XG5cbiAgICAgICAgaWYgKERHLlV0aWwuaXNBcnJheShvYmopKSB7XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuICAgICAgICAgICAgZm9yIChpID0gMDsgb2JqICYmIGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgICAgICAgICAgICBhZGQocHJlZml4LCB2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyAnWycgKyAodHlwZW9mIHYgPT09ICdvYmplY3QnID8gaSA6ICcnKSArICddJywgdiwgdHJhZGl0aW9uYWwsIGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9iaiAmJiBvYmoudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArICdbJyArIG5hbWUgKyAnXScsIG9ialtuYW1lXSwgdHJhZGl0aW9uYWwsIGFkZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuICAgICAgICAgICAgYWRkKHByZWZpeCwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFR5cGUgKHVybCkge1xuICAgICAgICB2YXIgbSA9IHVybC5tYXRjaCgvXFwuKGpzb258anNvbnB8aHRtbHx4bWwpKFxcP3wkKS8pO1xuICAgICAgICByZXR1cm4gbSA/IG1bMV0gOiAnanMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ3Jvc3NEb21haW4gKHVybCkge1xuICAgICAgICB2YXIgcGFydHMgPSBydXJsLmV4ZWModXJsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICByZXR1cm4gISEocGFydHMgJiZcbiAgICAgICAgICAgICAgICAocGFydHNbMV0gIT09IGFqYXhMb2NQYXJ0c1sxXSB8fCBwYXJ0c1syXSAhPT0gYWpheExvY1BhcnRzWzJdIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXJ0c1szXSB8fCAocGFydHNbMV0gPT09ICdodHRwOicgPyAnODAnIDogJzQ0MycpKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIChhamF4TG9jUGFydHNbM10gfHwgKGFqYXhMb2NQYXJ0c1sxXSA9PT0gJ2h0dHA6JyA/ICc4MCcgOiAnNDQzJykpKVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb1JlcXVlc3QgKG8pIHtcblxuICAgICAgICBpZiAoISgnY3Jvc3NEb21haW4nIGluIG8pKSB7XG4gICAgICAgICAgICBvLmNyb3NzRG9tYWluID0gaXNDcm9zc0RvbWFpbihvLnVybCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHt9O1xuICAgICAgICBzZWxmLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzZWxmLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2Fib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlamVjdCgnYWJvcnRlZCcpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2VsZi51cmwgPSBvLnVybDtcbiAgICAgICAgICAgIHNlbGYudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMgPSBvO1xuXG4gICAgICAgICAgICBzZWxmLl9hYm9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLl9lcnJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzID0ge307XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gby50eXBlID09PSAnanNvbnAnID8gby50eXBlIDogKG8uZGF0YVR5cGUgfHwgc2V0VHlwZShzZWxmLnVybCkpO1xuXG4gICAgICAgICAgICBpZiAoby50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9LCBvLnRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wbGV0ZSAocmVzcCkge1xuICAgICAgICAgICAgICAgIGlmIChvLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2VycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc3VjY2VzcyAocmVzcCkge1xuICAgICAgICAgICAgICAgIHJlc3AgPSAodHlwZSAhPT0gJ2pzb25wJykgPyBzZWxmLnJlcXVlc3QgOiByZXNwO1xuICAgICAgICAgICAgICAgIC8vIHVzZSBnbG9iYWwgZGF0YSBmaWx0ZXIgb24gcmVzcG9uc2UgdGV4dFxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZFJlc3BvbnNlID0gZ2xvYmFsU2V0dXBPcHRpb25zLmRhdGFGaWx0ZXIocmVzcC5yZXNwb25zZVRleHQsIHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICByID0gZmlsdGVyZWRSZXNwb25zZTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3AucmVzcG9uc2VUZXh0ID0gcjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IGFzc2lnbiB0aGlzIGluIElFPD04LCBqdXN0IGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1ldmFsICovXG4gICAgICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gd2luLkpTT04gPyB3aW4uSlNPTi5wYXJzZShyKSA6IGV2YWwoJygnICsgciArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihyZXNwLCAnQ291bGQgbm90IHBhcnNlIEpTT04gaW4gcmVzcG9uc2UnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2pzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gZXZhbCgnKCcgKyByICsgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSByO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gcmVzcC5yZXNwb25zZVhNTCAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLmVycm9yQ29kZSAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IucmVhc29uID8gbnVsbCA6IHJlc3AucmVzcG9uc2VYTUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1ldmFsICovXG4gICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlKHJlc3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBlcnJvciAocmVzcCwgbXNnLCB0KSB7XG4gICAgICAgICAgICAgICAgcmVzcCA9IHNlbGYucmVxdWVzdDtcbiAgICAgICAgICAgICAgICBzZWxmLl9yZXNwb25zZUFyZ3MucmVzcCA9IHJlc3A7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLm1zZyA9IG1zZztcbiAgICAgICAgICAgICAgICBzZWxmLl9yZXNwb25zZUFyZ3MudCA9IHQ7XG4gICAgICAgICAgICAgICAgc2VsZi5fZXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlKHJlc3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnJlcXVlc3QgPSBnZXRSZXF1ZXN0LmNhbGwoc2VsZiwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBBamF4ICh1cmwsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHVybCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXJsO1xuICAgICAgICAgICAgdXJsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnVybCA9IHVybCB8fCBvcHRpb25zLnVybDtcblxuICAgICAgICB2YXIgcmVxdWVzdFByb21pc2UgPSBkb1JlcXVlc3Qob3B0aW9ucyksXG4gICAgICAgICAgICByZXN1bHRQcm9taXNlID0gcmVxdWVzdFByb21pc2UucHJvbWlzZTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzIHx8IG9wdGlvbnMuZXJyb3IgfHwgb3B0aW9ucy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmVzdWx0UHJvbWlzZS50aGVuKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRQcm9taXNlLmFib3J0ID0gcmVxdWVzdFByb21pc2UuYWJvcnQ7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgfVxuXG4gICAgQWpheC5zZXR1cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsU2V0dXBPcHRpb25zW2tdID0gb3B0aW9uc1trXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBamF4LnRvUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiAobywgdHJhZCkge1xuICAgICAgICB2YXIgcHJlZml4LCBpLFxuICAgICAgICAgICAgdHJhZGl0aW9uYWwgPSB0cmFkIHx8IGZhbHNlLFxuICAgICAgICAgICAgcyA9IFtdLFxuICAgICAgICAgICAgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50LFxuICAgICAgICAgICAgYWRkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmMoa2V5KSArICc9JyArIGVuYyh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgICAgIGlmIChERy5VdGlsLmlzQXJyYXkobykpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IG8gJiYgaSA8IG8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhZGQob1tpXS5uYW1lLCBvW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAgICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgICAgICAgIGZvciAocHJlZml4IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCwgb1twcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGFjZXMgc2hvdWxkIGJlICsgYWNjb3JkaW5nIHRvIHNwZWNcbiAgICAgICAgcmV0dXJuIHMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xuICAgIH07XG5cbiAgICB2YXIgdGVzdHhociA9IHdpblt4bWxIdHRwUmVxdWVzdF0gPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG51bGw7XG5cbiAgICBBamF4LmNvcnNTdXBwb3J0ID0gISghKHRlc3R4aHIgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gdGVzdHhocikgJiYgIXdpblt4RG9tYWluUmVxdWVzdF0pICYmXG4gICAgICAgIC8vIGNvcnMgbm90IGF2YWlsYWJsZSBpbiBJRSBhbmQgd2l0aCBjeXJpbGxpYyBkb21haW5cbiAgICAgICAgIShERy5Ccm93c2VyLmllICYmIGRvY3VtZW50LmxvY2F0aW9uLmhvc3QudG9Mb3dlckNhc2UoKS5zZWFyY2goL1vQsC3Rj10vKSAhPSAtMSk7XG5cbiAgICByZXR1cm4gQWpheDtcbn0pKCk7XG4iLCJERy5Xa3QgPSB7fTtcblxuREcuV2t0LnRvR2VvSlNPTiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKERHLlV0aWwuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gZGF0YVswXTtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gZGF0YS5zcGxpdCgnOycpO1xuICAgIGRhdGEgPSBwYXJ0cy5wb3AoKTtcblxuICAgIHZhciBpID0gMCxcbiAgICAgICAgc3JpZCA9IChwYXJ0cy5zaGlmdCgpIHx8ICcnKS5zcGxpdCgnPScpLnBvcCgpO1xuXG4gICAgZnVuY3Rpb24gJChyZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkYXRhLnN1YnN0cmluZyhpKS5tYXRjaChyZSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcnMob2JqKSB7XG4gICAgICAgIGlmIChvYmogJiYgc3JpZC5tYXRjaCgvXFxkKy8pKSB7XG4gICAgICAgICAgICBvYmouY3JzID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICduYW1lJyxcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjonICsgc3JpZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdoaXRlKCkgeyAkKC9eXFxzKi8pOyB9XG5cbiAgICBmdW5jdGlvbiBtdWx0aWNvb3JkcygpIHtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgdmFyIGRlcHRoID0gMCwgcmluZ3MgPSBbXSwgc3RhY2sgPSBbcmluZ3NdLFxuICAgICAgICAgICAgcG9pbnRlciA9IHJpbmdzLCBlbGVtO1xuICAgICAgICB3aGlsZSAoZWxlbSA9XG4gICAgICAgICAgICAkKC9eKFxcKCkvKSB8fFxuICAgICAgICAgICAgJCgvXihcXCkpLykgfHxcbiAgICAgICAgICAgICQoL14oXFwsKS8pIHx8XG4gICAgICAgICAgICAkKC9eWy0rXT8oWzAtOV0qXFwuWzAtOV0rfFswLTldKykvKSkge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT09ICcoJykge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbSA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50ZXIucHVzaChwYXJzZUZsb2F0KGVsZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGRlcHRoICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmluZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29vcmRzKCkge1xuICAgICAgICB2YXIgbGlzdCA9IFtdLCBpdGVtLCBwdDtcbiAgICAgICAgd2hpbGUgKHB0ID1cbiAgICAgICAgICAgICQoL15bLStdPyhbMC05XSpcXC5bMC05XSt8WzAtOV0rKS8pIHx8XG4gICAgICAgICAgICAkKC9eKFxcLCkvKSkge1xuICAgICAgICAgICAgaWYgKHB0ID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaXRlbSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLnB1c2gocGFyc2VGbG9hdChwdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0Lmxlbmd0aCA/IGxpc3QgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50KCkge1xuICAgICAgICBpZiAoISQoL14ocG9pbnQpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmICghJCgvXihcXCgpLykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGMgPSBjb29yZHMoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjWzBdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwb2ludCgpIHtcbiAgICAgICAgaWYgKCEkKC9eKG11bHRpcG9pbnQpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHZhciBjID0gbXVsdGljb29yZHMoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdNdWx0aVBvaW50JyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlsaW5lc3RyaW5nKCkge1xuICAgICAgICBpZiAoISQoL14obXVsdGlsaW5lc3RyaW5nKS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICB2YXIgYyA9IG11bHRpY29vcmRzKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZXN0cmluZygpIHtcbiAgICAgICAgaWYgKCEkKC9eKGxpbmVzdHJpbmcpL2kpKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmICghJCgvXihcXCgpLykpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGMgPSBjb29yZHMoKTtcbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uKCkge1xuICAgICAgICBpZiAoISQoL14ocG9seWdvbikvaSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBtdWx0aWNvb3JkcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwb2x5Z29uKCkge1xuICAgICAgICBpZiAoISQoL14obXVsdGlwb2x5Z29uKS9pKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgICAgICBjb29yZGluYXRlczogbXVsdGljb29yZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlb21ldHJ5Y29sbGVjdGlvbigpIHtcbiAgICAgICAgdmFyIGdlb21ldHJpZXMgPSBbXSwgZ2VvbWV0cnk7XG5cbiAgICAgICAgaWYgKCEkKC9eKGdlb21ldHJ5Y29sbGVjdGlvbikvaSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgd2hpdGUoKTtcblxuICAgICAgICBpZiAoISQoL14oXFwoKS8pKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHdoaWxlIChnZW9tZXRyeSA9IHJvb3QoKSkge1xuICAgICAgICAgICAgZ2VvbWV0cmllcy5wdXNoKGdlb21ldHJ5KTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAkKC9eKFxcLCkvKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkKC9eKFxcKSkvKSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb290KCkge1xuICAgICAgICByZXR1cm4gcG9pbnQoKSB8fFxuICAgICAgICAgICAgbGluZXN0cmluZygpIHx8XG4gICAgICAgICAgICBwb2x5Z29uKCkgfHxcbiAgICAgICAgICAgIG11bHRpcG9pbnQoKSB8fFxuICAgICAgICAgICAgbXVsdGlsaW5lc3RyaW5nKCkgfHxcbiAgICAgICAgICAgIG11bHRpcG9seWdvbigpIHx8XG4gICAgICAgICAgICBnZW9tZXRyeWNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JzKHJvb3QoKSk7XG59O1xuXG5ERy5Xa3QuZ2VvSnNvbkxheWVyID0gZnVuY3Rpb24gKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gREcuZ2VvSnNvbihERy5Xa3QudG9HZW9KU09OKGRhdGEpLCBvcHRzKTtcbn07XG5cbkRHLldrdC5fY29vcmRzVG9MYXRMbmdzID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIGlmIChERy5VdGlsLmlzQXJyYXkoY29vcmRzKSAmJiAhREcuVXRpbC5pc0FycmF5KGNvb3Jkc1swXSkpIHtcbiAgICAgICAgcmV0dXJuIFtERy5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nKGNvb3JkcyldO1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZHMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIERHLldrdC5fY29vcmRzVG9MYXRMbmdzKGVsKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYXJyLCBjb29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5jb25jYXQoY29vcmQpO1xuICAgICAgICB9KTtcbn07XG5cbkRHLldrdC50b0xhdExuZ3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghREcuVXRpbC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgY29vcmRzID0gREcuV2t0LnRvR2VvSlNPTihlbCkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgcmV0dXJuIERHLldrdC5fY29vcmRzVG9MYXRMbmdzKGNvb3Jkcyk7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGNvb3JkKSB7XG4gICAgICAgIHJldHVybiBhcnIuY29uY2F0KGNvb3JkKTtcbiAgICB9KTtcbn07XG5cbkRHLldrdC50b1BvaW50cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIERHLldrdC50b0dlb0pTT04oZGF0YSkuY29vcmRpbmF0ZXM7XG59O1xuXG5ERy5Xa3QucG9pbnRzVG9MYXRMbmdPbk1hcCA9IGZ1bmN0aW9uICh3a3QsIG1hcCkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gcGFyc2VQb2ludHMocG9pbnRzKSB7XG4gICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShwb2ludHMpICYmIEFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSkgP1xuICAgICAgICAgICAgcG9pbnRzLm1hcChwYXJzZVBvaW50cykgOlxuICAgICAgICAgICAgbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocG9pbnRzKTtcbiAgICB9KShERy5Xa3QudG9Qb2ludHMod2t0KSk7XG59O1xuIiwiREcuUHJvamVjdERldGVjdG9yID0gREcuSGFuZGxlci5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXApIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9vc21WaWV3cG9ydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9sb2FkUHJvamVjdExpc3QoKTtcbiAgICB9LFxuXG4gICAgYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3ZlJywgdGhpcy5fcHJvamVjdFdhdGNoLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignbW92ZScsIHRoaXMuX3Byb2plY3RXYXRjaCwgdGhpcyk7XG4gICAgfSxcblxuICAgIGdldFByb2plY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcm9qZWN0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIHJldHVybiBERy5VdGlsLmV4dGVuZCh7fSwgdGhpcy5fcHJvamVjdCk7XG4gICAgfSxcblxuICAgIGdldFByb2plY3RzTGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvamVjdExpc3Quc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIGlzUHJvamVjdEhlcmU6IGZ1bmN0aW9uIChjb29yZHMsIHByb2plY3QsIGNoZWNrTWV0aG9kKSB7XG4gICAgICAgIGlmICghY29vcmRzKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgICAgaWYgKCEoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nKSAmJiAhKGNvb3JkcyBpbnN0YW5jZW9mIERHLkxhdExuZ0JvdW5kcykpIHtcbiAgICAgICAgICAgIGNvb3JkcyA9IERHLmxhdExuZyhjb29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29vcmRzID0gKGNvb3JkcyBpbnN0YW5jZW9mIERHLkxhdExuZ0JvdW5kcykgP1xuICAgICAgICAgICAgREcubGF0TG5nQm91bmRzKGNvb3Jkcy5nZXRTb3V0aFdlc3QoKS53cmFwKCksIGNvb3Jkcy5nZXROb3J0aEVhc3QoKS53cmFwKCkpIDogY29vcmRzLndyYXAoKTtcblxuICAgICAgICBjaGVja01ldGhvZCA9IGNoZWNrTWV0aG9kIHx8ICgoY29vcmRzIGluc3RhbmNlb2YgREcuTGF0TG5nQm91bmRzKSA/ICAnaW50ZXJzZWN0cycgOiAnY29udGFpbnMnKTtcblxuICAgICAgICB2YXIgbWV0aG9kID0gY2hlY2tNZXRob2QgPT0gJ2ludGVyc2VjdHMnID8gdGhpcy5fdGVzdFByb2plY3RJbnRlcnNlY3RzIDogdGhpcy5fdGVzdFByb2plY3RDb250YWlucztcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLmJpbmQodGhpcywgY29vcmRzKTtcblxuICAgICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZChwcm9qZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0TGlzdC5maWx0ZXIobWV0aG9kKVswXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHJvamVjdFdhdGNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vc21WaWV3cG9ydCA9PT0gKHRoaXMuX3Byb2plY3QgJiYgdGhpcy5fY2VudGVySW5Qcm9qZWN0KHRoaXMuX3Byb2plY3QsICdjb250YWlucycpKSkge1xuICAgICAgICAgICAgdGhpcy5fb3NtVmlld3BvcnQgPSAhdGhpcy5fb3NtVmlld3BvcnQ7XG4gICAgICAgICAgICB0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sLl91cGRhdGUobnVsbCwgdGhpcy5fb3NtVmlld3BvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2plY3QgJiYgdGhpcy5fem9vbUluUHJvamVjdCh0aGlzLl9wcm9qZWN0KSAmJiB0aGlzLl9jZW50ZXJJblByb2plY3QodGhpcy5fcHJvamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NlYXJjaFByb2plY3QoKTtcblxuICAgICAgICBpZiAodGhpcy5fcHJvamVjdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29zbVZpZXdwb3J0ID09PSAodGhpcy5fcHJvamVjdCAmJiB0aGlzLl9jZW50ZXJJblByb2plY3QodGhpcy5fcHJvamVjdCwgJ2NvbnRhaW5zJykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3NtVmlld3BvcnQgPSAhdGhpcy5fb3NtVmlld3BvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sLl91cGRhdGUobnVsbCwgdGhpcy5fb3NtVmlld3BvcnQsIHRoaXMuX3Byb2plY3QuY291bnRyeV9jb2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2hlY2tQcm9qZWN0RGF0YTogZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2sgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9qZWN0ICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC5ib3VuZHMgJiZcbiAgICAgICAgICAgICAgICBjaGVjayhwcm9qZWN0LmNvZGUpICYmXG4gICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC5kb21haW4pICYmXG4gICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC5jb3VudHJ5X2NvZGUpICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC56b29tX2xldmVsICYmXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKHByb2plY3Quem9vbV9sZXZlbC5taW4pICYmXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrKHByb2plY3Quem9vbV9sZXZlbC5tYXgpICYmXG4gICAgICAgICAgICAgICAgcHJvamVjdC50aW1lX3pvbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hlY2socHJvamVjdC50aW1lX3pvbmUub2Zmc2V0KTtcbiAgICB9LFxuXG4gICAgX2xvYWRQcm9qZWN0TGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBERy5mYWxsYmFja1Byb2plY3RzTGlzdCA9IERHLmZhbGxiYWNrUHJvamVjdHNMaXN0IHx8IFtdO1xuXG4gICAgICAgIGlmICghREcucHJvamVjdHNMaXN0KSB7XG4gICAgICAgICAgICBERy5wcm9qZWN0c0xpc3QgPSBERy5mYWxsYmFja1Byb2plY3RzTGlzdDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgREcuZmFsbGJhY2tQcm9qZWN0c0xpc3Q7XG5cbiAgICAgICAgdGhpcy5fcHJvamVjdExpc3QgPSBERy5wcm9qZWN0c0xpc3RcbiAgICAgICAgICAgIC5maWx0ZXIodGhpcy5fY2hlY2tQcm9qZWN0RGF0YSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmQgPSBERy5Xa3QudG9HZW9KU09OKHByb2plY3QuYm91bmRzKTtcbiAgICAgICAgICAgICAgICB2YXIgbGF0TG5nQm91bmRzID0gREcuZ2VvSlNPTihib3VuZCkuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRQb3MgPSBwcm9qZWN0LmRlZmF1bHRfcG9zID8gREcubGF0TG5nKHByb2plY3QuZGVmYXVsdF9wb3MubGF0LCBwcm9qZWN0LmRlZmF1bHRfcG9zLmxvbikgOiBudWxsO1xuXG5cbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcHJvamVjdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcHJvamVjdC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICBtaW5ab29tOiBwcm9qZWN0Lnpvb21fbGV2ZWwubWluLFxuICAgICAgICAgICAgICAgICAgICBtYXhab29tOiBwcm9qZWN0Lnpvb21fbGV2ZWwubWF4LFxuICAgICAgICAgICAgICAgICAgICB0aW1lT2Zmc2V0OiBwcm9qZWN0LnRpbWVfem9uZS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBib3VuZCxcbiAgICAgICAgICAgICAgICAgICAgbGF0TG5nQm91bmRzOiBsYXRMbmdCb3VuZHMsXG4gICAgICAgICAgICAgICAgICAgIHRyYWZmaWM6ICEhcHJvamVjdC5mbGFncy50cmFmZmljLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6ICEhcHJvamVjdC5mbGFncy5wdWJsaWNfdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICByb2FkczogISFwcm9qZWN0LmZsYWdzLnJvYWRfbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgY291bnRyeV9jb2RlOiBwcm9qZWN0LmNvdW50cnlfY29kZSxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBwcm9qZWN0LmRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBvczogZGVmYXVsdFBvc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfc2VhcmNoUHJvamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyDQktC90LDRh9Cw0LvQtSDQvtGC0YHQtdC40LLQsNC10Lwg0YDQtdCz0LjQvtC90Ysg0L/QviDQt9GD0LzRg1xuICAgICAgICB2YXIgZmlsdGVyZWRCeVpvb20gPSB0aGlzLl9wcm9qZWN0TGlzdC5maWx0ZXIodGhpcy5fem9vbUluUHJvamVjdCwgdGhpcyk7XG5cbiAgICAgICAgLy8g0J3QsNGF0L7QtNC40Lwg0L/RgNC+0LXQutGCINCyINCz0YDQsNC90LjRhtGLINC60L7RgtC+0YDQvtCz0L4g0L/QvtC/0LDQtNCw0LXRgiDRhtC10L3RgtGAINC60LDRgNGC0YtcbiAgICAgICAgdmFyIGZvdW5kUHJvamVjdHMgPSBmaWx0ZXJlZEJ5Wm9vbS5maWx0ZXIodGhpcy5fY2VudGVySW5Qcm9qZWN0LCB0aGlzKTtcblxuICAgICAgICAvLyDQldGB0LvQuCDRgtCw0LrQvtC5INC/0YDQvtC10LrRgiDQvdC1INC90LDQudC00LXQvSwg0YLQviDQuNGJ0LXQvCDQv9GA0L7QtdC60YLRiyDQsdCw0YPQvdC0INCx0L7QutGB0Ysg0LrQvtGC0L7RgNGL0YUg0L/QtdGA0LXRgdC10LrQsNGO0YLRgdGPINGBINGN0LrRgNCw0L3QvtC8XG4gICAgICAgIGlmIChmb3VuZFByb2plY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIG1hcEJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgIGZvdW5kUHJvamVjdHMgPSBmaWx0ZXJlZEJ5Wm9vbS5maWx0ZXIoREcuYmluZCh0aGlzLl90ZXN0UHJvamVjdEludGVyc2VjdHMsIHRoaXMsIG1hcEJvdW5kcykpO1xuXG4gICAgICAgICAgICBpZiAoZm91bmRQcm9qZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcENlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmVhcmVhc3RQcm9qZWN0ID0gZm91bmRQcm9qZWN0c1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGZvdW5kUHJvamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9qZWN0ID0gZm91bmRQcm9qZWN0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9qZWN0LmRlZmF1bHRQb3MgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcENlbnRlci5kaXN0YW5jZVRvKG5lYXJlYXN0UHJvamVjdC5kZWZhdWx0UG9zKSA+XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBDZW50ZXIuZGlzdGFuY2VUbyhjdXJyZW50UHJvamVjdC5kZWZhdWx0UG9zKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lYXJlYXN0UHJvamVjdCA9IGN1cnJlbnRQcm9qZWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvdW5kUHJvamVjdHMgPSBbbmVhcmVhc3RQcm9qZWN0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdQcm9qZWN0ID0gZm91bmRQcm9qZWN0c1swXSB8fCBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9wcm9qZWN0ID09PSBuZXdQcm9qZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2plY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3QgPSBudWxsO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fbWFwLmZpcmUoJ3Byb2plY3RsZWF2ZScpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3UHJvamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvamVjdCA9IG5ld1Byb2plY3Q7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tYXAuZmlyZSgncHJvamVjdGNoYW5nZScsIHtnZXRQcm9qZWN0OiBzZWxmLmdldFByb2plY3QuYmluZChzZWxmKX0pO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Rlc3RQcm9qZWN0SW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcywgcHJvamVjdCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdC5sYXRMbmdCb3VuZHMuaW50ZXJzZWN0cyhib3VuZHMpO1xuICAgIH0sXG5cbiAgICBfdGVzdFByb2plY3RDb250YWluczogZnVuY3Rpb24gKGxhdGxuZywgcHJvamVjdCkge1xuICAgICAgICByZXR1cm4gREcuUG9seVV0aWwuaW5zaWRlKFtsYXRsbmcubG5nLCBsYXRsbmcubGF0XSwgcHJvamVjdC5ib3VuZCk7XG4gICAgfSxcblxuICAgIF9jZW50ZXJJblByb2plY3Q6IGZ1bmN0aW9uIChwcm9qZWN0LCBjaGVja01ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1Byb2plY3RIZXJlKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgcHJvamVjdCwgY2hlY2tNZXRob2QpO1xuICAgIH0sXG5cbiAgICBfem9vbUluUHJvamVjdDogZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9tYXAuZ2V0Wm9vbSgpID49IHByb2plY3QubWluWm9vbSk7XG4gICAgfVxufSk7XG5cbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIHByb2plY3REZXRlY3RvcjogdHJ1ZVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdwcm9qZWN0RGV0ZWN0b3InLCBERy5Qcm9qZWN0RGV0ZWN0b3IpO1xuIiwiLypcbiAqIFV0aWxpdHkgZnVuY3Rpb25zXG4gKi9cblxuREcuTWV0cmljID0gZnVuY3Rpb24gKCkge307XG5cbi8qXG4gKiBERy5NZXRyaWMuU2VnbWVudHMgY2xhc3MgY2FuIGNhbGN1bGF0ZSB0b3RhbCBwdXNoZWQgc2VnbWVudHMgbGVuZ3RoIGFuZCB1c2VkIHRvIHNob3J0Y3V0XG4gKiAnZ2V0IFNvbWV0aGluZyBieSBwcm92aWRlZCBMZW5ndGgnIGNhbGN1bGF0aW9ucyAoc2VnbWVudCdzIEluZGV4LCBzZWdtZW50J3MgTGVuZ3RoLCBldGMuLi4pXG4gKi9cbkRHLk1ldHJpYy5TZWdtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5ERy5NZXRyaWMuU2VnbWVudHMucHJvdG90eXBlID0ge1xuICAgIHB1c2g6IGZ1bmN0aW9uIChsZW4pIHtcbiAgICAgICAgdGhpc1t0aGlzLmxlbmd0aF0gPSB0aGlzLmxlbmd0aCA+IDAgPyB0aGlzW3RoaXMubGVuZ3RoIC0gMV0gKyBsZW4gOiBsZW47XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIH0sXG5cbiAgICBnZXRSZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IG5ldyBERy5NZXRyaWMuU2VnbWVudHMoKTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgaWYgKGkgPCAwKSB7IHJldHVybiBzZWdtZW50czsgfVxuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2godGhpc1tpICsgMV0gLSB0aGlzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWdtZW50cy5wdXNoKHRoaXNbMF0pO1xuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24gKGxlbikge1xuICAgICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgICAgICBpZiAoaSA8IDApIHsgcmV0dXJuIGk7IH1cblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA8PSBsZW4pIHsgYnJlYWs7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICB9LFxuXG4gICAgZ2V0U2VnUmF0aW86IGZ1bmN0aW9uIChsZW4pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmdldEluZGV4KGxlbik7XG4gICAgICAgIHZhciBzdWIgPSBpID4gMCA/IHRoaXNbaSAtIDFdIDogMDtcblxuICAgICAgICByZXR1cm4gKGxlbiAtIHN1YikgLyAodGhpc1tpXSAtIHN1Yik7XG4gICAgfSxcblxuICAgIGdldFNlZ0xlbmd0aDogZnVuY3Rpb24gKGxlbikge1xuICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXgobGVuKTtcbiAgICAgICAgdmFyIHN1YiA9IGkgPiAwID8gdGhpc1tpIC0gMV0gOiAwO1xuXG4gICAgICAgIHJldHVybiBsZW4gLSBzdWI7XG4gICAgfVxufTtcbiIsIi8qXG4gKiBERy5WZXJ0ZXhUcmFuc2Zvcm0gaXMgYSBjbGFzc2ljIDJEIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiBjbGFzc1xuICpcbiAqIFByb3RvdHlwZSBtZXRob2RzIGNhbiBzY2FsZS9yb3RhdGUvdHJhbnNsYXRlIHZlcnRpY2VzXG4gKlxuICogU3RhdGljIG1ldGhvZHMgZG8gdGhlIHNhbWUgYnV0IHJldHVybiBzaW1wbGUgYXJyYXkgaW5zdGFuY2VzIHdpdGggYXR0YWNoZWRcbiAqIC5jbG9uZSgpIG1ldGhvZCB3aGljaCBjYW4gcmVjb25zdHJ1Y3QgZnVsbCBERy5WZXJ0ZXhUcmFuc2Zvcm0gb2JqZWN0XG4gKi9cblxuREcuVmVydGV4VHJhbnNmb3JtID0gREcuQ2xhc3MuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAodmVydGljZXMpIHtcbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSB2ZXJ0aWNlcztcblxuICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FuZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmVydGljZXMgPSB0aGlzLl92ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHZlcnRleCkgeyByZXR1cm4gdmVydGV4LmNsb25lKCk7IH0pO1xuICAgICAgICB0aGlzLnZlcnRpY2VzLmNsb25lID0gREcuVmVydGV4VHJhbnNmb3JtLmNsb25lO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHZlcnRleCkgeyByZXR1cm4gdmVydGV4LmNsb25lKCk7IH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTY2FsZTogZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgfSxcblxuICAgIHNldEFuZ2xlOiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgdGhpcy5fYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldEFuZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmdsZTtcbiAgICB9LFxuXG4gICAgc2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICB0aGlzLl90cmFucyA9IHRyYW5zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zO1xuICAgIH0sXG5cbiAgICBzZXRNYXRyaXg6IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRyaXg7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgaSA9IHYubGVuZ3RoO1xuXG4gICAgICAgIHNjYWxlID0gc2NhbGUgfHwgdGhpcy5fc2NhbGUgfHwgMTtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdltpXS54ICo9IHNjYWxlO1xuICAgICAgICAgICAgdltpXS55ICo9IHNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IHRoaXMuX3NjYWxlIHx8IDE7ICAgICAgLy8gIEFsc28gc2FmZWd1YXJkIGFnYWluc3QgemVybyBzY2FsZVxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSgxIC8gc2NhbGUpO1xuICAgIH0sXG5cbiAgICByb3RhdGU6IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gYW5nbGUgPyBhbmdsZS5jb3MgOiAodGhpcy5fYW5nbGUgPyB0aGlzLl9hbmdsZS5jb3MgOiAxKTtcbiAgICAgICAgdmFyIHNpbiA9IGFuZ2xlID8gYW5nbGUuc2luIDogKHRoaXMuX2FuZ2xlID8gdGhpcy5fYW5nbGUuc2luIDogMCk7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgdmFyIGkgPSB2Lmxlbmd0aDtcbiAgICAgICAgdmFyIHgsIHk7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgeCA9IHZbaV0ueDtcbiAgICAgICAgICAgIHkgPSB2W2ldLnk7XG4gICAgICAgICAgICB2W2ldLnggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICAgICAgICAgIHZbaV0ueSA9IHggKiBzaW4gKyB5ICogY29zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuUm90YXRlOiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgdmFyIGNvcyA9IGFuZ2xlID8gYW5nbGUuY29zIDogKHRoaXMuX2FuZ2xlID8gdGhpcy5fYW5nbGUuY29zIDogMSk7XG4gICAgICAgIHZhciBzaW4gPSBhbmdsZSA/IGFuZ2xlLnNpbiA6ICh0aGlzLl9hbmdsZSA/IHRoaXMuX2FuZ2xlLnNpbiA6IDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZSh7Y29zOiBjb3MsIHNpbjogLXNpbn0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICh0cmFucykge1xuICAgICAgICB2YXIgZHggPSB0cmFucyA/IHRyYW5zLnggOiAodGhpcy5fdHJhbnMgPyB0aGlzLl90cmFucy54IDogMCk7XG4gICAgICAgIHZhciBkeSA9IHRyYW5zID8gdHJhbnMueSA6ICh0aGlzLl90cmFucyA/IHRoaXMuX3RyYW5zLnkgOiAwKTtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgaSA9IHYubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHZbaV0ueCArPSBkeDtcbiAgICAgICAgICAgIHZbaV0ueSArPSBkeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1blRyYW5zbGF0ZTogZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgIHZhciBkeCA9IHRyYW5zID8gdHJhbnMueCA6ICh0aGlzLl90cmFucyA/IHRoaXMuX3RyYW5zLnggOiAwKTtcbiAgICAgICAgdmFyIGR5ID0gdHJhbnMgPyB0cmFucy55IDogKHRoaXMuX3RyYW5zID8gdGhpcy5fdHJhbnMueSA6IDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh7eDogLWR4LCB5OiAtZHl9KTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIHZhciBhLCBiLCBjLCBkLCBkeCwgZHk7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgdmFyIGkgPSB2Lmxlbmd0aDtcbiAgICAgICAgdmFyIHgsIHk7XG5cbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgYSA9IG1hdHJpeFswXTsgYiA9IG1hdHJpeFsxXTsgZHggPSBtYXRyaXhbMl07XG4gICAgICAgICAgICBjID0gbWF0cml4WzNdOyBkID0gbWF0cml4WzRdOyBkeSA9IG1hdHJpeFs1XTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9tYXRyaXgpIHtcbiAgICAgICAgICAgIGEgPSB0aGlzLl9tYXRyaXhbMF07IGIgPSB0aGlzLl9tYXRyaXhbMV07IGR4ID0gdGhpcy5fbWF0cml4WzJdO1xuICAgICAgICAgICAgYyA9IHRoaXMuX21hdHJpeFszXTsgZCA9IHRoaXMuX21hdHJpeFs0XTsgZHkgPSB0aGlzLl9tYXRyaXhbNV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhID0gMTsgYiA9IDA7IGR4ID0gMDtcbiAgICAgICAgICAgIGMgPSAwOyBkID0gMTsgZHkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgeCA9IHZbaV0ueDtcbiAgICAgICAgICAgIHkgPSB2W2ldLnk7XG4gICAgICAgICAgICB2W2ldLnggPSB4ICogYSArIHkgKiBiICsgZHg7XG4gICAgICAgICAgICB2W2ldLnkgPSB4ICogYyArIHkgKiBkICsgZHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKHZ0LCBzY2FsZSkge1xuICAgICAgICAgICAgdmFyIHYgPSB2dC52ZXJ0aWNlcztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gdltpXS54ICogc2NhbGU7XG4gICAgICAgICAgICAgICAgeSA9IHZbaV0ueSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBERy5Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2xvbmUgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uY2xvbmU7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5TY2FsZTogZnVuY3Rpb24gKHZ0LCBzY2FsZSkge1xuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCAxOyAgICAgICAgIC8vICBBbHNvIHNhZmVndWFyZCBhZ2FpbnN0IHplcm8gc2NhbGVcbiAgICAgICAgICAgIHJldHVybiBERy5WZXJ0ZXhUcmFuc2Zvcm0uc2NhbGUodnQsIDEgLyBzY2FsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbiAodnQsIGFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgY29zID0gYW5nbGUgPyBhbmdsZS5jb3MgOiAxO1xuICAgICAgICAgICAgdmFyIHNpbiA9IGFuZ2xlID8gYW5nbGUuc2luIDogMDtcbiAgICAgICAgICAgIHZhciB2ID0gdnQudmVydGljZXM7XG4gICAgICAgICAgICB2YXIgeCwgeSwgcngsIHJ5O1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByeCA9IHZbaV0ueDtcbiAgICAgICAgICAgICAgICByeSA9IHZbaV0ueTtcbiAgICAgICAgICAgICAgICB4ID0gcnggKiBjb3MgLSByeSAqIHNpbjtcbiAgICAgICAgICAgICAgICB5ID0gcnggKiBzaW4gKyByeSAqIGNvcztcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgREcuUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNsb25lID0gREcuVmVydGV4VHJhbnNmb3JtLmNsb25lO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuUm90YXRlOiBmdW5jdGlvbiAodnQsIGFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgY29zID0gYW5nbGUgPyBhbmdsZS5jb3MgOiAxO1xuICAgICAgICAgICAgdmFyIHNpbiA9IGFuZ2xlID8gYW5nbGUuc2luIDogMDtcblxuICAgICAgICAgICAgcmV0dXJuIERHLlZlcnRleFRyYW5zZm9ybS5yb3RhdGUodnQsIHtjb3M6IGNvcywgc2luOiAtc2lufSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAodnQsIHRyYW5zKSB7XG4gICAgICAgICAgICB2YXIgZHggPSB0cmFucyA/IHRyYW5zLnggOiAwO1xuICAgICAgICAgICAgdmFyIGR5ID0gdHJhbnMgPyB0cmFucy55IDogMDtcbiAgICAgICAgICAgIHZhciB2ID0gdnQudmVydGljZXM7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHZbaV0ueCArIGR4O1xuICAgICAgICAgICAgICAgIHkgPSB2W2ldLnkgKyBkeTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgREcuUG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmNsb25lID0gREcuVmVydGV4VHJhbnNmb3JtLmNsb25lO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHVuVHJhbnNsYXRlOiBmdW5jdGlvbiAodnQsIHRyYW5zKSB7XG4gICAgICAgICAgICB2YXIgZHggPSB0cmFucyA/IHRyYW5zLnggOiAwO1xuICAgICAgICAgICAgdmFyIGR5ID0gdHJhbnMgPyB0cmFucy55IDogMDtcblxuICAgICAgICAgICAgcmV0dXJuIERHLlZlcnRleFRyYW5zZm9ybS50cmFuc2xhdGUodnQsIHt4OiAtZHgsIHk6IC1keX0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyAgJ3RoaXMnIGlzIGFuIGFycmF5XG4gICAgICAgICAgICByZXR1cm4gbmV3IERHLlZlcnRleFRyYW5zZm9ybSh0aGlzKS5zYXZlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiAodmVjMSwgdmVjMikge1xuICAgICAgICAgICAgdmFyIGR4LCBkeTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ZWMxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vICAndmVjMScgYW5kICd2ZWMyJyBhcmUgYWJzb2x1dGUgY29vcmRpbmF0ZXMgb2YgdmVjdG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2ZWMxICogdmVjMSArIHZlYzIgKiB2ZWMyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSB2ZWN0b3Igb2JqZWN0c1xuICAgICAgICAgICAgICAgIGR4ID0gdmVjMi54IC0gdmVjMS54O1xuICAgICAgICAgICAgICAgIGR5ID0gdmVjMi55IC0gdmVjMS55O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNjYWxlZDogZnVuY3Rpb24gKHZlYzEsIHZlYzIsIHNjYWxlKSB7XG4gICAgICAgICAgICB2YXIgZHgsIGR5O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZlYzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZiB2ZWN0b3JcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERHLlBvaW50KHZlYzEgKiBzY2FsZSwgdmVjMiAqIHNjYWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSB2ZWN0b3Igb2JqZWN0c1xuICAgICAgICAgICAgICAgIGR4ID0gKHZlYzIueCAtIHZlYzEueCkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBkeSA9ICh2ZWMyLnkgLSB2ZWMxLnkpICogc2NhbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBERy5Qb2ludCh2ZWMxLnggKyBkeCwgdmVjMS55ICsgZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFuZ2xlOiBmdW5jdGlvbiAodmVjMSwgdmVjMiwgb3JpZ2luKSB7XG4gICAgICAgICAgICB2YXIgbCwgc3AsIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZlYzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZiB2ZWN0b3JcbiAgICAgICAgICAgICAgICBsID0gTWF0aC5zcXJ0KHZlYzEgKiB2ZWMxICsgdmVjMiAqIHZlYzIpO1xuICAgICAgICAgICAgICAgIGlmIChsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvczogdmVjMSAvIGwsIHNpbjogdmVjMiAvIGx9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29zOiAxLCBzaW46IDB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICd2ZWMxJyBhbmQgJ3ZlYzInIGFyZSB2ZWN0b3Igb2JqZWN0c1xuICAgICAgICAgICAgICAgIHgxID0gdmVjMS54OyB5MSA9IHZlYzEueTtcbiAgICAgICAgICAgICAgICB4MiA9IHZlYzIueDsgeTIgPSB2ZWMyLnk7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICB4MSAtPSBvcmlnaW4ueDsgeTEgLT0gb3JpZ2luLnk7XG4gICAgICAgICAgICAgICAgICAgIHgyIC09IG9yaWdpbi54OyB5MiAtPSBvcmlnaW4ueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3AgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpICogTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb3M6ICh4MSAqIHgyICsgeTEgKiB5MikgLyBzcCxcbiAgICAgICAgICAgICAgICAgICAgc2luOiAoeDEgKiB5MiAtIHgyICogeTEpIC8gc3BcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFuZ2xlc1N1bTogZnVuY3Rpb24gKGFuZ2xlMSwgYW5nbGUyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvczogYW5nbGUxLmNvcyAqIGFuZ2xlMi5jb3MgLSBhbmdsZTEuc2luICogYW5nbGUyLnNpbixcbiAgICAgICAgICAgICAgICBzaW46IGFuZ2xlMS5zaW4gKiBhbmdsZTIuY29zICsgYW5nbGUxLmNvcyAqIGFuZ2xlMi5zaW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QW5nbGVzRGlmOiBmdW5jdGlvbiAoYW5nbGUxLCBhbmdsZTIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29zOiBhbmdsZTEuY29zICogYW5nbGUyLmNvcyArIGFuZ2xlMS5zaW4gKiBhbmdsZTIuc2luLFxuICAgICAgICAgICAgICAgIHNpbjogYW5nbGUxLnNpbiAqIGFuZ2xlMi5jb3MgLSBhbmdsZTEuY29zICogYW5nbGUyLnNpblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiLypcbiAqIERHLkFycm93UGF0aFRyYW5zZm9ybSBjbGFzcyBpcyBhIGNvcmUgb2YgYXJyb3cncyBib2R5IGNhbGN1bGF0aW9uc1xuICpcbiAqIEdlbmVyYWwgaWRlYXMgYXJlOlxuICogICAgICBXZSBjb25zdHJ1Y3QgYXJyb3cgYm9keSB3aXRoIHN0cm9rZSBwb2ludHMgbWFraW5nIGFyY3Mgb24gb3V0ZXIgcGF0aCB0dXJuc1xuICogICAgICBQcm9jZXNzaW5nIGlzIGRvbmUgc2VnbWVudCBieSBzZWdtZW50IGFyb3VuZCB7MCwgMH0gdmlydHVhbCBwb2ludFxuICogICAgICAgICAgYW5kIHJlc3VsdGluZyAncGF0aCcgZmluYWxseSByb3RhdGVkIHRvIGl0J3Mgb3JpZ2luYWwgbWFwJ3MgYW5nbGUgKC5mdWxsQW5nbGUpXG4gKiAgICAgIFN1YnNldCBvZiB0aGlzIHZlcnRpY2VzIGxhdGVseSB1c2VkIGluIC5zdWJQYXRoKCkgY2FsY3VsYXRpb25zIHdoaWNoIGNhbiBiZSB1c2VkXG4gKiAgICAgICAgICBpbiBhbmltYXRpb25zIGZvciBleC5cbiAqXG4gKiAgRmluYWwgdHJhbnNsYXRpb24gKHNlZSBERy5FbnRyYW5jZS5BcnJvdykgbW92ZXMgYXJyb3cgb2JqZWN0cyB0byB0aGVpciBvcmlnaW5hbCBwb3NpdGlvbnNcbiAqL1xuXG5ERy5BcnJvd1BhdGhUcmFuc2Zvcm0gPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyAgJ3BhdGgub2Zmc2V0JyBpcyBpbml0aWFsIHBvaW50cyBvZmZzZXQgKC14IC8gK3gpIHRvIGNvbXBlbnNhdGUgYXJyb3cgdGlwIGxlbmd0aFxuXG4gICAgICAgIC8vICBTa2lwIHN1cGVyIGluaXRpYWxpemF0aW9uIGFzIHdlIG5lZWQgb25seSBzdWJzZXQgb2YgREcuVmVydGV4VHJhbnNmb3JtIHBvd2VyXG4gICAgICAgIHRoaXMuX2xlbmd0aHMgPSBuZXcgREcuTWV0cmljLlNlZ21lbnRzKCk7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gW1tdLCBbXV07XG4gICAgICAgIHRoaXMuX2RyYXdpbmdzID0gW1tdLCBbXV07XG4gICAgICAgIC8vICB0aGlzLl9hcmNzID0gW107ICAgIC8vICBpbml0aWFsaXplZCBpbiBfc2V0UGF0aCgpXG5cbiAgICAgICAgdGhpcy5fc2V0UGF0aChwYXRoKTtcbiAgICAgICAgdGhpcy5zdWJQYXRoKDEpO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YlBhdGgoMSk7XG4gICAgfSxcblxuICAgIHNhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7ICAgIC8vICBOb09wXG4gICAgfSxcblxuICAgIC8vICBNZXRob2QgY29uc3RydWN0cyBuZXcgcGF0aCBwb2ludHMgd2l0aCBzb21lIGRpc3BsYWNlbWVudCBmcm9tIG9yaWdpbmFsICdwYXRoJ1xuICAgIC8vICBPdXRlciBjb3JuZXJzIHdpbGwgYmUgc21vb3RoZWQgYnkgYXJjcyAoY3ViaWMgQsOpemllciBjdXJ2ZXMpXG4gICAgX3NldFBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBERy5BcnJvd1BhdGhUcmFuc2Zvcm0udHJhbnNmb3JtO1xuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLl92ZXJ0aWNlcztcbiAgICAgICAgdmFyIGRyYXdpbmdzID0gdGhpcy5fZHJhd2luZ3M7XG4gICAgICAgIHZhciBQb2ludCA9IERHLlBvaW50O1xuICAgICAgICB2YXIgd2lkdGggPSBwYXRoLndpZHRoO1xuICAgICAgICB2YXIgYXJjcyA9IFtbXSwgW10sIFtdXTtcbiAgICAgICAgdmFyIGxlbmd0aHMgPSBbXTtcblxuICAgICAgICB2YXIgaSwgeCxcbiAgICAgICAgICAgIGF4LCBieCwgY3gsXG4gICAgICAgICAgICBhbmdsZXMsIGFuZ2xlO1xuXG4gICAgICAgIHZlcnRpY2VzLnB1c2gocGF0aC52ZXJ0aWNlcyk7ICAgLy8gIGV4cGVjdCAucG9wKCkgaW4gZmluYWwgdHJhbnNmb3JtXG4gICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IERHLlBvaW50KHBhdGgub2Zmc2V0LCArd2lkdGgpKTtcbiAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgREcuUG9pbnQocGF0aC5vZmZzZXQsIC13aWR0aCkpO1xuICAgICAgICBhbmdsZXMgPSBERy5BcnJvd1BhdGhUcmFuc2Zvcm0uZ2V0QW5nbGVzKHBhdGgpO1xuXG4gICAgICAgIGN4ID0gLXBhdGgub2Zmc2V0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYW5nbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4ID0gcGF0aC52ZXJ0aWNlc1tpICsgMV0ueDtcbiAgICAgICAgICAgIGF4ID0gd2lkdGggKiBhbmdsZXNbaV0uY290O1xuXG4gICAgICAgICAgICAvLyAgaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNjaXJjbGVzX2N1YmljXG4gICAgICAgICAgICAvLyAgYWN0dWFsIGVxdWF0aW9uIGlzICg0LzMgKiB0YW4ozrEvNCkgKiByYWRpdXMpXG4gICAgICAgICAgICBieCA9IGFuZ2xlc1tpXS50YW4gKiB3aWR0aCAqIDggLyAzO1xuXG4gICAgICAgICAgICAvLyAgTmV4dCBjb2RlIGNhbiBiZSBjb21iaW5lZCBieSAtLysgaW52ZXJzaW9uIGJ1dCBmb3Igc2ltcGxpY2l0eSBpdCBpcyBsZWZ0IGFzIGlzXG4gICAgICAgICAgICBpZiAoYXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMF0ucHVzaChuZXcgUG9pbnQoeCArIGF4LCAgICAgICt3aWR0aCkpO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdzWzBdLnB1c2goJ0wnKTtcblxuICAgICAgICAgICAgICAgIGFyY3NbMl0ucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBhcmNzWzFdLnB1c2godmVydGljZXNbMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludCh4ICsgYXgsICAgICAgLXdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgUG9pbnQoeCArIGF4IC0gYngsIC13aWR0aCkpO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKHZlcnRpY2VzLCBhbmdsZXNbaV0sIHt4OiB4LCB5OiAwfSk7XG5cbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludCgwIC0gYXggKyBieCwgLXdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXNbMV0ucHVzaChuZXcgUG9pbnQoMCAtIGF4LCAgICAgIC13aWR0aCkpO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdzWzFdLnB1c2goJ0wnLCAnQycpO1xuXG4gICAgICAgICAgICAgICAgbGVuZ3Rocy5wdXNoKE1hdGguYWJzKHggKyBheCkgLSBjeCk7IGN4ID0gK2F4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludCh4IC0gYXgsICAgICAgLXdpZHRoKSk7XG4gICAgICAgICAgICAgICAgZHJhd2luZ3NbMV0ucHVzaCgnTCcpO1xuXG4gICAgICAgICAgICAgICAgYXJjc1syXS5wdXNoKDApO1xuICAgICAgICAgICAgICAgIGFyY3NbMF0ucHVzaCh2ZXJ0aWNlc1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IFBvaW50KHggLSBheCwgICAgICArd2lkdGgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1swXS5wdXNoKG5ldyBQb2ludCh4IC0gYXggKyBieCwgK3dpZHRoKSk7XG5cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0odmVydGljZXMsIGFuZ2xlc1tpXSwge3g6IHgsIHk6IDB9KTtcblxuICAgICAgICAgICAgICAgIHZlcnRpY2VzWzBdLnB1c2gobmV3IFBvaW50KDAgKyBheCAtIGJ4LCArd2lkdGgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1swXS5wdXNoKG5ldyBQb2ludCgwICsgYXgsICAgICAgK3dpZHRoKSk7XG4gICAgICAgICAgICAgICAgZHJhd2luZ3NbMF0ucHVzaCgnTCcsICdDJyk7XG5cbiAgICAgICAgICAgICAgICBsZW5ndGhzLnB1c2goTWF0aC5hYnMoeCAtIGF4KSAtIGN4KTsgY3ggPSAtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAgRmluYWwgc2VnbWVudHMgYW5kIHRhaWwgYXJjXG4gICAgICAgIGF4ID0gcGF0aC52ZXJ0aWNlc1tpICsgMV0ueDtcbiAgICAgICAgYnggPSB3aWR0aCAqIDQgLyAzOyAvLyB0YW4oUEkvNCkgPSAxXG5cbiAgICAgICAgdmVydGljZXNbMF0ucHVzaChuZXcgUG9pbnQoYXgsICt3aWR0aCkpO1xuICAgICAgICB2ZXJ0aWNlc1sxXS5wdXNoKG5ldyBQb2ludChheCwgLXdpZHRoKSk7XG5cbiAgICAgICAgdmVydGljZXNbMF0ucHVzaChuZXcgUG9pbnQoYXggLSBieCwgK3dpZHRoKSk7XG4gICAgICAgIHZlcnRpY2VzWzFdLnB1c2gobmV3IFBvaW50KGF4IC0gYngsIC13aWR0aCkpO1xuXG4gICAgICAgIGRyYXdpbmdzWzBdLnB1c2goJ0wnKTtcbiAgICAgICAgZHJhd2luZ3NbMV0ucHVzaCgnTCcpO1xuXG4gICAgICAgIGxlbmd0aHMucHVzaChNYXRoLmFicyhheCkgLSBjeCk7XG5cbiAgICAgICAgLy8gIFJldmVyc2UgcmlnaHQgcGF0aFxuICAgICAgICB2ZXJ0aWNlc1sxXS5yZXZlcnNlKCk7XG4gICAgICAgIGRyYXdpbmdzWzFdLnJldmVyc2UoKTtcblxuICAgICAgICAvLyAgTW92ZSB2ZXJ0aWNlcyBpbnRvIG9yaWdpbmFsIHBvc2l0aW9uIChiZWZvcmUgbGFzdCB0cmFuc2xhdGlvbilcbiAgICAgICAgYW5nbGUgPSBERy5WZXJ0ZXhUcmFuc2Zvcm0uZ2V0QW5nbGVzU3VtKGFuZ2xlcy5mdWxsQW5nbGUsIHBhdGguZ2V0QW5nbGUoKSk7XG4gICAgICAgIHRyYW5zZm9ybSh2ZXJ0aWNlcywgYW5nbGUsIHZlcnRpY2VzLnBvcCgpWzBdKTsgIC8vICBwYXRoLnZlcnRpY2VzWzBdXG5cbiAgICAgICAgLy8gIFdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgYXJjJ3MgaW5kZXhlcyBidXQgdG9vIG1hbnkgdmFyaWFibGVzIGFscmVhZHkgdG91Y2hlZCwgcmV1c2Ugc29tZSBvZiB0aGVtXG4gICAgICAgIGF4ID0gdmVydGljZXNbMF0ubGVuZ3RoO1xuICAgICAgICBieCA9IHZlcnRpY2VzWzFdLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fYXJjcyA9IGFyY3NbMl0ubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBjeCA9IGFyY3NbaV0uc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREcuQXJjQmV6aWVyKHZlcnRpY2VzWzFdLnNsaWNlKGJ4IC0gY3ggLSA0LCBieCAtIGN4KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREcuQXJjQmV6aWVyKHZlcnRpY2VzWzBdLnNsaWNlKGN4LCBjeCArIDQpLnJldmVyc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnJldmVyc2UoKTtcblxuICAgICAgICB0aGlzLl9sZW5ndGhzLnB1c2gobGVuZ3Rocy5wb3AoKSk7XG4gICAgICAgIGxlbmd0aHMucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGwsIGkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aHMucHVzaCh0aGlzLl9hcmNzW2ldLmdldExlbmd0aCgpKS5wdXNoKGwpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyAgU2hvcnRjdXQgYm9yZGVyIGNhc2VzICgwJS1sZW5ndGggc3ViLXBhdGggYW5kIGZ1bGwtcGF0aClcbiAgICAgICAgdGhpc1swXSA9IHtcbiAgICAgICAgICAgIHZlcnRpY2VzOiBbdmVydGljZXNbMF1bYXggLSAyXSwgdmVydGljZXNbMF1bYXggLSAxXSwgdmVydGljZXNbMV1bMF0sIHZlcnRpY2VzWzFdWzFdXSxcbiAgICAgICAgICAgIGRyYXdpbmdzOiBbJ00nLCAnQyddXG4gICAgICAgIH07XG4gICAgICAgIHRoaXNbMV0gPSB7XG4gICAgICAgICAgICB2ZXJ0aWNlczogdmVydGljZXNbMF0uY29uY2F0KHZlcnRpY2VzWzFdKSxcbiAgICAgICAgICAgIGRyYXdpbmdzOiBbJ00nXS5jb25jYXQoZHJhd2luZ3NbMF0sICdDJywgZHJhd2luZ3NbMV0pXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9zZXRBbmdsZUFuZERpc3BsYWNlbWVudDogZnVuY3Rpb24gKHZMLCB2UikgeyAvLyBVc2VkIGluIERHLkFycm93VGlwVHJhbnNmb3JtLnN1YlNoYXBlKClcbiAgICAgICAgdGhpcy5hbmdsZSA9IERHLlZlcnRleFRyYW5zZm9ybS5nZXRBbmdsZSh7eDogdkwueCAtIHZSLngsIHk6IHZMLnkgLSB2Ui55fSwge3g6IDAsIHk6IDF9KTtcbiAgICAgICAgdGhpcy5kaXNwbCA9IHZSLmNsb25lKCk7XG4gICAgfSxcblxuICAgIHN1YlBhdGg6IGZ1bmN0aW9uIChwYXRoUmF0aW8pIHtcbiAgICAgICAgcGF0aFJhdGlvID0gcGF0aFJhdGlvID4gMSA/IDEgOiBwYXRoUmF0aW87XG5cbiAgICAgICAgLy8gIFNob3J0Y3V0IGJvcmRlciBjYXNlcyAoMCUtbGVuZ3RoIHN1Yi1wYXRoIGFuZCBmdWxsLXBhdGgpXG4gICAgICAgIGlmIChwYXRoUmF0aW8gPT09IDAgfHwgcGF0aFJhdGlvID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gdGhpc1twYXRoUmF0aW9dLnZlcnRpY2VzLm1hcChmdW5jdGlvbiAodmVydGV4KSB7IHJldHVybiB2ZXJ0ZXguY2xvbmUoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLmRyYXdpbmdzID0gdGhpc1twYXRoUmF0aW9dLmRyYXdpbmdzO1xuICAgICAgICAgICAgdGhpcy5fc2V0QW5nbGVBbmREaXNwbGFjZW1lbnQodGhpcy52ZXJ0aWNlc1swXSwgdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldFNjYWxlZCA9IERHLlZlcnRleFRyYW5zZm9ybS5nZXRTY2FsZWQ7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuX3ZlcnRpY2VzO1xuICAgICAgICB2YXIgZHJhd2luZ3MgPSB0aGlzLl9kcmF3aW5ncztcbiAgICAgICAgdmFyIGxlbmd0aHMgPSB0aGlzLl9sZW5ndGhzO1xuICAgICAgICB2YXIgbGVuID0gbGVuZ3Rocy5nZXRMZW5ndGgoKSAqIHBhdGhSYXRpbztcbiAgICAgICAgdmFyIHNlZ0luZGV4ID0gbGVuZ3Rocy5nZXRJbmRleChsZW4pO1xuICAgICAgICB2YXIgc2VnUmF0aW8gPSBsZW5ndGhzLmdldFNlZ1JhdGlvKGxlbik7XG4gICAgICAgIHZhciB2ZXJ0ZXhJbmRleExlZnQgPSB2ZXJ0aWNlc1swXS5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgdmVydGV4SW5kZXhSaWdodCA9IDE7XG4gICAgICAgIHZhciBkcmF3aW5nSW5kZXhMZWZ0ID0gZHJhd2luZ3NbMF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGRyYXdpbmdJbmRleFJpZ2h0ID0gMDtcbiAgICAgICAgdmFyIHZlcnRleExlZnQsIHZlcnRleFJpZ2h0O1xuICAgICAgICB2YXIgYXJjID0gMCwgYWVkID0gMDtcblxuICAgICAgICB3aGlsZSAoYWVkKysgPCBzZWdJbmRleCkge1xuICAgICAgICAgICAgaWYgKGFlZCAlIDIgPT0gMSkge1xuICAgICAgICAgICAgICAgIHZlcnRleEluZGV4TGVmdC0tO1xuICAgICAgICAgICAgICAgIGRyYXdpbmdJbmRleExlZnQtLTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhJbmRleFJpZ2h0Kys7XG4gICAgICAgICAgICAgICAgZHJhd2luZ0luZGV4UmlnaHQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYXdpbmdzWzBdW2RyYXdpbmdJbmRleExlZnRdID09PSAnQycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4SW5kZXhMZWZ0IC09IDM7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdpbmdJbmRleExlZnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhJbmRleFJpZ2h0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdpbmdJbmRleFJpZ2h0ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyYysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ0luZGV4ICUgMiA9PSAxKSB7XG4gICAgICAgICAgICAvLyAgT25lIHBhdGggZW5kcyB3aXRoIGFuIGFyY1xuICAgICAgICAgICAgYXJjID0gdGhpcy5fYXJjc1thcmNdO1xuICAgICAgICAgICAgaWYgKGRyYXdpbmdzWzBdW2RyYXdpbmdJbmRleExlZnRdID09PSAnQycpIHtcbiAgICAgICAgICAgICAgICBhcmMgPSBhcmMuZ2V0Q3VydmVCZWZvcmUoYXJjLmdldFRieUwobGVuZ3Rocy5nZXRTZWdMZW5ndGgobGVuKSkpO1xuICAgICAgICAgICAgICAgIHZlcnRleExlZnQgPSBhcmMucG9pbnRzWzNdO1xuICAgICAgICAgICAgICAgIHZlcnRleFJpZ2h0ID0gdmVydGljZXNbMV1bdmVydGV4SW5kZXhSaWdodF07XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IGFyYy5wb2ludHMuc2xpY2UoMSkucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodmVydGljZXNbMF0uc2xpY2UodmVydGV4SW5kZXhMZWZ0KSwgdmVydGljZXNbMV0uc2xpY2UoMCwgdmVydGV4SW5kZXhSaWdodCArIDEpKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2ZXJ0ZXgpIHsgcmV0dXJuIHZlcnRleC5jbG9uZSgpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdpbmdzID0gWydNJ10uY29uY2F0KGRyYXdpbmdzWzBdLnNsaWNlKGRyYXdpbmdJbmRleExlZnQpLCAnQycsIGRyYXdpbmdzWzFdLnNsaWNlKDAsIGRyYXdpbmdJbmRleFJpZ2h0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyYyA9IGFyYy5nZXRDdXJ2ZUJlZm9yZShhcmMuZ2V0VGJ5TChsZW5ndGhzLmdldFNlZ0xlbmd0aChsZW4pKSk7XG4gICAgICAgICAgICAgICAgdmVydGV4TGVmdCA9IHZlcnRpY2VzWzBdW3ZlcnRleEluZGV4TGVmdF07XG4gICAgICAgICAgICAgICAgdmVydGV4UmlnaHQgPSBhcmMucG9pbnRzWzNdO1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlc1swXS5zbGljZSh2ZXJ0ZXhJbmRleExlZnQpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodmVydGljZXNbMV0uc2xpY2UoMCwgdmVydGV4SW5kZXhSaWdodCArIDEpLCBhcmMucG9pbnRzLnNsaWNlKDEpKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2ZXJ0ZXgpIHsgcmV0dXJuIHZlcnRleC5jbG9uZSgpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdpbmdzID0gWydNJ10uY29uY2F0KGRyYXdpbmdzWzBdLnNsaWNlKGRyYXdpbmdJbmRleExlZnQgKyAxKSwgJ0MnLCBkcmF3aW5nc1sxXS5zbGljZSgwLCBkcmF3aW5nSW5kZXhSaWdodCArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICBCb3RoIHBhdGhzIGVuZCB3aXRoIGxpbmVzXG4gICAgICAgICAgICB2ZXJ0ZXhMZWZ0ID0gZ2V0U2NhbGVkKHZlcnRpY2VzWzBdW3ZlcnRleEluZGV4TGVmdF0sIHZlcnRpY2VzWzBdW3ZlcnRleEluZGV4TGVmdCAtIDFdLCBzZWdSYXRpbyk7XG4gICAgICAgICAgICB2ZXJ0ZXhSaWdodCA9IGdldFNjYWxlZCh2ZXJ0aWNlc1sxXVt2ZXJ0ZXhJbmRleFJpZ2h0XSwgdmVydGljZXNbMV1bdmVydGV4SW5kZXhSaWdodCArIDFdLCBzZWdSYXRpbyk7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzID0gW3ZlcnRleExlZnRdXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh2ZXJ0aWNlc1swXS5zbGljZSh2ZXJ0ZXhJbmRleExlZnQpLCB2ZXJ0aWNlc1sxXS5zbGljZSgwLCB2ZXJ0ZXhJbmRleFJpZ2h0ICsgMSksIHZlcnRleFJpZ2h0KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHZlcnRleCkgeyByZXR1cm4gdmVydGV4LmNsb25lKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5kcmF3aW5ncyA9IFsnTSddLmNvbmNhdChkcmF3aW5nc1swXS5zbGljZShkcmF3aW5nSW5kZXhMZWZ0KSwgJ0MnLCBkcmF3aW5nc1sxXS5zbGljZSgwLCBkcmF3aW5nSW5kZXhSaWdodCArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldEFuZ2xlQW5kRGlzcGxhY2VtZW50KHZlcnRleExlZnQsIHZlcnRleFJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgZ2V0QW5nbGVzOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgdmFyIGdldEFuZ2xlID0gREcuVmVydGV4VHJhbnNmb3JtLmdldEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGZ1bGxBbmdsZSA9IHtjb3M6IDEsIHNpbjogMH07XG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBwYXRoLnZlcnRpY2VzO1xuICAgICAgICAgICAgdmFyIGFuZ2xlcyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgYWJzU2luLCBhbmdsZSxcbiAgICAgICAgICAgICAgICBjb3MsIHNpbiwgY290LCB0ZW1wLCBzaWduO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdmVydGljZXMubGVuZ3RoIC0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBnZXRBbmdsZSh2ZXJ0aWNlc1tpIC0gMV0sIHZlcnRpY2VzW2kgKyAxXSwgdmVydGljZXNbaV0pO1xuXG4gICAgICAgICAgICAgICAgYWJzU2luID0gTWF0aC5hYnMoYW5nbGUuc2luKTtcbiAgICAgICAgICAgICAgICBpZiAoYWJzU2luIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIEV4Y2x1ZGUgMTgwwrAgYW5nbGUgZnJvbSB2ZXJ0aWNlcyBhcnJheVxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5zcGxpY2UodmVydGljZXMubGVuZ3RoIC0gaSAtIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICBUaGlzIGlzIGhhbGYg4oiizrEgY290YW5nZW50LCBzaWduIGRlc2NyaWJlcyBhbmdsZSBkaXJlY3Rpb24gYW5kIHVzZWQgdG8gc2hvcnRjdXQgc3Ryb2tlIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyAgJy0xJyAtIHJpZ2h0IGFuZ2xlIGlzIGlubmVyIGFuZ2xlLCAnMScgLSBsZWZ0IGFuZ2xlIGlzIGlubmVyIGFuZ2xlIChpZiBzZWVuIGZyb20gWzAsIDBdIHRvIFstMSwgMF0pXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlLmNvdCA9ICgxICsgYW5nbGUuY29zKSAvIGFuZ2xlLnNpbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyAgV2UgbmVlZCB0byByb3RhdGUgbmV4dCBzZWdtZW50IHRvIFstMSwgMF0gYXhpcywgc28gd2UgbmVlZCBjb21wbGVtZW50YXJ5IGFuZ2xlIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlLmNvcyA9IC1hbmdsZS5jb3M7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIENvbXBsaW1lbnRhcnkgYW5nbGUgYWxzbyB1c2VkIHRvIGNhbGN1bGF0ZSBpdCdzIHF1YXRlcm5hcnkg4oiizrIgdGFuZ2VudFxuICAgICAgICAgICAgICAgICAgICAvLyAg4oiizrIgdGFuZ2VudCB1c2VkIGluIGFwcHJveGltYXRpb24gb2Ygb3V0ZXIgYXJjIHNlZ21lbnQgYnkgQsOpemllciBjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICBjb3QgPSAoMSArIGFuZ2xlLmNvcykgLyBhbmdsZS5zaW47XG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSBjb3QgPCAwID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gc2lnbiAqIE1hdGguc3FydCg0ICogY290ICogY290ICsgNCk7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlLnRhbiA9IC0wLjUgKiAoY290ICsgY290IC0gdGVtcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYW5nbGVzLnB1c2goYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvcyA9IGZ1bGxBbmdsZS5jb3MgKiBhbmdsZS5jb3MgLSBmdWxsQW5nbGUuc2luICogYW5nbGUuc2luO1xuICAgICAgICAgICAgICAgICAgICBzaW4gPSBmdWxsQW5nbGUuc2luICogYW5nbGUuY29zICsgZnVsbEFuZ2xlLmNvcyAqIGFuZ2xlLnNpbjtcblxuICAgICAgICAgICAgICAgICAgICBmdWxsQW5nbGUgPSB7Y29zOiBjb3MsIHNpbjogc2lufTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICBVc2VkIGluIGZpbmFsIHN0cm9rZSBwb2ludHMgdHJhbnNsYXRpb25cbiAgICAgICAgICAgIGFuZ2xlcy5mdWxsQW5nbGUgPSAge2NvczogZnVsbEFuZ2xlLmNvcywgc2luOiAtZnVsbEFuZ2xlLnNpbn07XG4gICAgICAgICAgICByZXR1cm4gYW5nbGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vICBUT0RPIC0gaWYgbGVuZ3RoIG9mICdsYXRsbmdzJyBhcnJheSBpcyBsZXNzIHRoYW4gMiBvciBpdCBpcyB1bmRlZmluZWQgbmV4dCBmdW5jdGlvbiBwcm9kdWNlcyBleGNlcHRpb25cbiAgICAgICAgLy8gIGNoZWNrIHRoaXMgY29uZGl0aW9uIGluIG91dGVyIHJvdXRpbmVzPyFcbiAgICAgICAgZ2V0VHJhbnNsYXRlZFBhdGg6IGZ1bmN0aW9uIChtYXAsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gbmV3IERHLlZlcnRleFRyYW5zZm9ybShbXSk7XG4gICAgICAgICAgICB2YXIgaSA9IGxhdGxuZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciB2ID0gbWFwLnByb2plY3QobGF0bG5nc1tpXSk7XG4gICAgICAgICAgICB2YXIgZHggPSB2LngsIGR5ID0gdi55O1xuXG4gICAgICAgICAgICBwYXRoLnZlcnRpY2VzLnB1c2gobmV3IERHLlBvaW50KDAsIDApKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICB2ID0gbWFwLnByb2plY3QobGF0bG5nc1tpXSk7XG4gICAgICAgICAgICAgICAgcGF0aC52ZXJ0aWNlcy5wdXNoKG5ldyBERy5Qb2ludCh2LnggLSBkeCwgdi55IC0gZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoXG4gICAgICAgICAgICAgICAgLnNldEFuZ2xlKERHLlZlcnRleFRyYW5zZm9ybS5nZXRBbmdsZSgtcGF0aC52ZXJ0aWNlc1sxXS54LCAtcGF0aC52ZXJ0aWNlc1sxXS55KSlcbiAgICAgICAgICAgICAgICAudW5Sb3RhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChyaW5ncywgYW5nbGUsIHZlY3Rvcikge1xuICAgICAgICAgICAgdmFyIGkgPSByaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29zID0gYW5nbGUuY29zO1xuICAgICAgICAgICAgdmFyIHNpbiA9IGFuZ2xlLnNpbjtcbiAgICAgICAgICAgIHZhciBkeCA9IHZlY3Rvci54O1xuICAgICAgICAgICAgdmFyIGR5ID0gdmVjdG9yLnk7XG4gICAgICAgICAgICB2YXIgcmluZywgeCwgeSwgajtcblxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIHJpbmcgPSByaW5nc1tpXTtcbiAgICAgICAgICAgICAgICBqID0gcmluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gcmluZ1tqXS54IC0gZHg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSByaW5nW2pdLnkgLSBkeTtcbiAgICAgICAgICAgICAgICAgICAgcmluZ1tqXS54ID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgICAgICAgICAgICAgICAgIHJpbmdbal0ueSA9IHggKiBzaW4gKyB5ICogY29zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiLypcbiAqIERHLkFycm93VGlwVHJhbnNmb3JtIGNsYXNzIGlzIGEgY29yZSBvZiBhcnJvdydzIHRpcCBjYWxjdWxhdGlvbnNcbiAqXG4gKiAuc3ViU2hhcGUoKSByb3V0aW5lICdib3VuZCcgYXJyb3cncyB0aXAgdG8gdGhlIGVuZGluZyBwb2ludHMgb2YgLnN1YlBhdGgoKVxuICogY2FsY3VsYXRlZCBzZXBhcmF0ZWx5IGluIERHLkFycm93UGF0aFRyYW5zZm9ybVxuICpcbiAqICBGaW5hbCB0cmFuc2xhdGlvbiAoc2VlIERHLkVudHJhbmNlLkFycm93KSBtb3ZlcyBhcnJvdyBvYmplY3RzIHRvIHRoZWlyIG9yaWdpbmFsIHBvc2l0aW9uc1xuICovXG5cbkRHLkFycm93VGlwVHJhbnNmb3JtID0gREcuVmVydGV4VHJhbnNmb3JtLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHBhdGgsIHNoYXBlKSB7XG4gICAgICAgIHRoaXMuZHJhd2luZ3MgPSBzaGFwZS5kcmF3aW5nczsgLy8gIHN0YXRpYyBtYXBwaW5nXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gc2hhcGUudmVydGljZXM7XG5cbiAgICAgICAgdGhpcy5fc2V0U2hhcGUocGF0aCwgc2hhcGUpO1xuICAgIH0sXG5cbiAgICBfc2V0U2hhcGU6IGZ1bmN0aW9uIChwYXRoLCBzaGFwZSkge1xuICAgICAgICB2YXIgc3AgPSBzaGFwZS52ZXJ0aWNlc1swXTtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5hYnMoc3AueSk7XG4gICAgICAgIHZhciBwbCA9IHBhdGgudmVydGljZXNbMV0ueDsgICAgLy8gIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIHZhciBsZW5ndGggPSBzcC54OyAgICAgICAgICAgICAgLy8gIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIHZhciBvZmZzZXQgPSBwbCAtIGxlbmd0aCArIHdpZHRoICsgd2lkdGg7XG5cbiAgICAgICAgcGF0aC53aWR0aCA9IHdpZHRoO1xuICAgICAgICBwYXRoLm9mZnNldCA9IGxlbmd0aCArIChvZmZzZXQgPiAwID8gb2Zmc2V0IDogMCk7XG4gICAgICAgIGlmIChwYXRoLnZlcnRpY2VzLmxlbmd0aCA8IDMgJiYgbGVuZ3RoID4gLTEwKSB7XG4gICAgICAgICAgICBwYXRoLm9mZnNldCArPSAyLjU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92ZXJ0aWNlcyA9IHRoaXMubG9hZCgpLnVuVHJhbnNsYXRlKHNwKS52ZXJ0aWNlcztcbiAgICB9LFxuXG4gICAgc3ViU2hhcGU6IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5sb2FkKCkudW5Sb3RhdGUodHJhbnNmb3JtLmFuZ2xlKS50cmFuc2xhdGUodHJhbnNmb3JtLmRpc3BsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG4iLCIvKlxuICogREcuQ29tcGxleFBhdGggaXMgYSBzaW1wbGUgdmVjdG9yIGxheWVyIGNsYXNzIHdpdGggZW1wdHkgLmdldEV2ZW50cygpIG9iamVjdCghKVxuICogSXQncyBkcmF3aW5nIGxvZ2ljIGlzIG1haW50YWluZWQgaW4gREcuRW50cmFuY2UuQXJyb3cgY2xhc3NcbiAqXG4gKiBfcHhCb3VuZHMgaXMgYSBwaXhlbCBib3VuZHMgb2YgdGhpcyBkcmF3aW5ncyBhbmQgdGhleSBhcmUgdXNlZCBpbiBMLkNhbnZhc1xuICovXG5cbkRHLkNvbXBsZXhQYXRoID0gREcuUGF0aC5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZmlsbDogdHJ1ZSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgIGludGVyYWN0aXZlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2VtcHR5ID0gW107XG5cbiAgICAgICAgdGhpcy5fcHhFbXB0eSA9IERHLmJvdW5kcyhcbiAgICAgICAgICAgIERHLnBvaW50KDAsIDApLCBERy5wb2ludCgwLCAwKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9weEJvdW5kcyA9IHRoaXMuX3B4RW1wdHk7XG5cbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSBbdGhpcy5fZW1wdHldO1xuICAgICAgICB0aGlzLl9kcmF3aW5ncyA9IFt0aGlzLl9lbXB0eV07XG4gICAgfSxcblxuICAgIGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgem9vbSwgd2VpZ2h0O1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMudmlzaWJpbGl0eS5pc1Nob3duICYmIG9wdHMudHJhbnNmb3JtW3pvb21dKSB7XG4gICAgICAgICAgICAvLyAgTmV4dCBudW1iZXJzIHdhcyBlbXBpcmljYWxseSBzZWxlY3RlZCBpbiBvcmRlciB0byBwcm92aWRlIHZpc3VhbCBjb21wbGlhbmNlXG4gICAgICAgICAgICAvLyAgdG8gdGhlIG9yaWdpbmFsIGFycm93J3MgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIHdlaWdodCA9IDIuMiAtICgoMTkgLSB6b29tKSAqIDAuMik7XG4gICAgICAgICAgICBpZiAob3B0cy53ZWlnaHQgIT09IHdlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoe3dlaWdodDogK3dlaWdodC50b0ZpeGVkKDIpfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3ZlcnRpY2VzWzBdID0gb3B0cy50cmFuc2Zvcm1bem9vbV0udmVydGljZXM7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nc1swXSA9IG9wdHMudHJhbnNmb3JtW3pvb21dLmRyYXdpbmdzO1xuXG4gICAgICAgICAgICB0aGlzLl9weEJvdW5kcyA9IG9wdHMudHJhbnNmb3JtW3pvb21dLl9weEJvdW5kcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRpY2VzWzBdID0gdGhpcy5fZW1wdHk7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nc1swXSA9IHRoaXMuX2VtcHR5O1xuXG4gICAgICAgICAgICB0aGlzLl9weEJvdW5kcyA9IHRoaXMuX3B4RW1wdHk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHsgIC8vICB1c2VkIGluIENhbnZhcyByZW5kZXJlclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ29tcGxleFBhdGgodGhpcyk7XG4gICAgfVxufSk7XG4iLCIvKlxuICogQWN0dWFsIHBhaW50aW5nIG1ldGhvZHMgdGhhdCBjYW4gZHJhdyBjb21wbGV4IG9iamVjdHMgd2l0aCBjdXJ2ZXNcbiAqXG4gKiBQb2ludCBjb29yZGluYXRlcyBtdXN0IGJlIHByb3ZpZGVkIGluIGxheWVyLl92ZXJ0aWNlcyBvYmplY3RcbiAqIEFuZCB0eXBlcyBvZiBsaW5lIG11c3QgYmUgcHJvdmlkZWQgaW4gbGF5ZXIuX2RyYXdpbmdzIG9iamVjdFxuICovXG5cbkRHLmV4dGVuZChMLkNhbnZhcy5wcm90b3R5cGUsIHtcbiAgICBfdXBkYXRlQ29tcGxleFBhdGg6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG4gICAgICAgIHZhciBpLCBqLCBrLCBkLCB4LCB5LCBfeCwgX3ksICR4LCAkeSwgcG9pbnRzO1xuICAgICAgICB2YXIgZHJhd2luZ3MgPSBsYXllci5fZHJhd2luZ3M7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGxheWVyLl92ZXJ0aWNlcztcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICB0aGlzLl9kcmF3bkxheWVyc1tsYXllci5fbGVhZmxldF9pZF0gPSBsYXllcjtcblxuICAgICAgICAvLyAgVE9ETzogRG8gd2UgbmVlZCB0byBkbyBhICdiZWdpblBhdGgoKScgYW5kIHBvc3NpYmxlICdjbG9zZVBhdGgoKScgcGVyIHJpbmc/IVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHMgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHggPSB5ID0gMDtcbiAgICAgICAgICAgIGogPSBrID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGQgPSBkcmF3aW5nc1tpXVtrKytdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfeCA9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3kgPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICR4ID0gcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAkeSA9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oX3gsIF95LCAkeCwgJHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfeCA9IHggKyBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF95ID0geSArIHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHggPSB4ICsgcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAkeSA9IHkgKyBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4ICsgcG9pbnRzW2pdLng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0geSArIHBvaW50c1tqXS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oX3gsIF95LCAkeCwgJHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfeCA9IHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3kgPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal0ueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKF94LCBfeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF94ID0geCArIHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3kgPSB5ICsgcG9pbnRzW2pdLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0geCArIHBvaW50c1tqXS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHkgKyBwb2ludHNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKF94LCBfeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcbiAgICB9XG59KTtcblxuXG5ERy5leHRlbmQoTC5TVkcucHJvdG90eXBlLCB7XG4gICAgX3VwZGF0ZUNvbXBsZXhQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuICAgICAgICB0aGlzLl9zZXRQYXRoKGxheWVyLCBMLlNWRy5jb21wbGV4UG9pbnRzVG9QYXRoKGxheWVyLl92ZXJ0aWNlcywgbGF5ZXIuX2RyYXdpbmdzLCBjbG9zZWQpKTtcbiAgICB9XG59KTtcblxuXG5ERy5leHRlbmQoTC5TVkcsIHtcbiAgICBjb21wbGV4UG9pbnRzVG9QYXRoOiBmdW5jdGlvbiAodmVydGljZXMsIGRyYXdpbmdzLCBjbG9zZWQpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICB2YXIgc3ZnID0gREcuQnJvd3Nlci5zdmc7XG4gICAgICAgIHZhciBpLCBqLCBrLCBuLCBkLCBwb2ludHM7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHMgPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgICAgLy8gIFNwZWVkdXAgaG90IHBhdGggYnkgcmVtb3ZpbmcgaWYvdGVybmFyeSBjb25kaXRpb24gY2hlY2tzIGJ1dCBkdXBsaWNhdGluZyBsb29wc1xuICAgICAgICAgICAgaWYgKHN2Zykge1xuICAgICAgICAgICAgICAgIGogPSBrID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGRyYXdpbmdzW2ldW2srK107XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzogICBuID0gMzsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOiAgIG4gPSAyOyBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogICAgbiA9IDE7ICAvLyAgJ00nLCAnbScsICdMJywgJ2wnLCAuLi5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gZDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHBvaW50c1tqXS54LnRvRml4ZWQoNCkgKyAnLCcgKyBwb2ludHNbal0ueS50b0ZpeGVkKDQpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAgdm1sIGluIElFOCBjYW4gc3VwcG9ydCBvbmx5IGludGVnZXIgdmFsdWVzIGluICdwYXRoJywgc29ycnkgYWJvdXQgbG9zcyBvZiBwcmVjaXNpb25cbiAgICAgICAgICAgICAgICBqID0gayA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBkcmF3aW5nc1tpXVtrKytdO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOiAgIGQgPSAnbSc7IG4gPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOiAgIGQgPSAndCc7IG4gPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOiAgIGQgPSAnbCc7IG4gPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOiAgIGQgPSAncic7IG4gPSAxOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOiAgIGQgPSAnYyc7IG4gPSAzOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOiAgIGQgPSAndic7IG4gPSAzOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBWTUwgc3BlYyBoYXMgJ3FiJyBjb21tYW5kIGluICd2JyBhdHRyaWJ1dGUgc3RyaW5nIGJ1dCBubyAncmVsYXRpdmVUbycgY29tcGxpbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBTbyB3ZSdsbCBlbXVsYXRlIEN1YmljIELDqXppZXIgY3VydmUgYnkgYXBwbHlpbmcgUXVhZHJhdGljIHZhcmlhbnQgaW4gYm90aCBjYXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUT0RPOiBCb3RoIGNvbnRyb2wgcG9pbnRzIHdpbGwgdXNlIHRoZSBzYW1lIHZhbHVlIGJ1dCB0aGlzIGlzIG5vdCB0cnVlIHNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdDJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tqXS54LnRvRml4ZWQoMCkgKyAnLCcgKyBwb2ludHNbal0ueS50b0ZpeGVkKDApICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2pdLngudG9GaXhlZCgwKSArICcsJyArIHBvaW50c1tqXS55LnRvRml4ZWQoMCkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaiArIDFdLngudG9GaXhlZCgwKSArICcsJyArIHBvaW50c1tqICsgMV0ueS50b0ZpeGVkKDApICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ2MnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2pdLngudG9GaXhlZCgwKSArICcsJyArIHBvaW50c1tqXS55LnRvRml4ZWQoMCkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbal0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2pdLnkudG9GaXhlZCgwKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1tqICsgMV0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2ogKyAxXS55LnRvRml4ZWQoMCkgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogICAgbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IGQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBwb2ludHNbal0ueC50b0ZpeGVkKDApICsgJywnICsgcG9pbnRzW2pdLnkudG9GaXhlZCgwKSArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyICs9IGNsb3NlZCA/IChzdmcgPyAneicgOiAneCcpIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVkcgY29tcGxhaW5zIGFib3V0IGVtcHR5IHBhdGggc3RyaW5nc1xuICAgICAgICByZXR1cm4gc3RyIHx8ICdtMCwwJztcbiAgICB9XG59KTtcbiIsIi8qXG4gKiBER0JlemllckN1cnZlcyBpcyBhIGNvbGxlY3Rpb24gb2YgdGhyZWUgY2xhc3NlczpcbiAqIE9yaWdpbmFsIERHLkJlemllciBjbGFzcyBwcm92aWRlcyBiYXNpYyBtYXRoIGZvciBDdWJpYyBhbmQgUXVhZHJhdGljIELDqXppZXIgY3VydmVzXG4gKiBERy5UaW1lQmV6aWVyIHVzZWQgaW4gYW5pbWF0aW9uIGVmZmVjdHMgaXQgY2FuIHJldHVybiAnRGlzdGFuY2UnIChZKSBieSBUaW1lIChYKSB2YWx1ZVxuICogREcuQXJjQmV6aWVyIGNhbiByZXR1cm4gJ3QnIHZhbHVlIGJ5IGN1cnZlJ3Mgc2VnbWVudCBsZW5ndGhcbiAqIEFjdHVhbCBjYWxjdWxhdGlvbnMgY2FuIGJlIHZlcnkgaGFyZCAoaW4gbWF0aCB0ZXJtcykgc28gd2UgdXNlIExVVCdzIHRvIG9wdGltaXplIHRoZW1cbiAqXG4gKiBPcmlnaW5hbCBpZGVhcyBjb21lIGZyb20gdGhpcyBzb3VyY2U6ICAgaHR0cHM6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby9cbiAqL1xuXG5ERy5CZXppZXIgPSBERy5DbGFzcy5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgY3VydmUgb2JqZWN0IGJ5IHByb3ZpZGVkIGNvbnRyb2wgcG9pbnRzXG4gICAgICogQHBhcmFtIHtBcnJheTxERy5Qb2ludD59IGNvb3JkcyBDdXJ2ZSdzIGNvbnRyb2wgcG9pbnRzIGluIERHLlBvaW50IGZvcm1hdCAodXAgdG8gZm91ciBjb250cm9sIHBvaW50cyBzdXBwb3J0ZWQpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2xvbmVdIENsb25lIG9yaWdpbmFsIHBvaW50cyBvciBub3QgKERlZmF1bHQpXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGNvb3JkcywgY2xvbmUpIHtcbiAgICAgICAgaWYgKGNsb25lKSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IGNvb3Jkcy5tYXAoZnVuY3Rpb24gKGNvb3JkKSB7IHJldHVybiBjb29yZC5jbG9uZSgpOyB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gY29vcmRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHBvaW50cyA9IHRoaXMuX2dldERlcml2YXRpdmVzKCk7XG4gICAgICAgIHRoaXMub3JkZXIgPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLl9sdXQgPSBbXTtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBtdCwgbXQyLCB0MjtcbiAgICAgICAgdmFyIGEsIGIsIGMsIGQ7XG5cbiAgICAgICAgaWYgKHQgPT09IDApIHsgcmV0dXJuIHBbMF07IH1cbiAgICAgICAgaWYgKHQgPT09IDEpIHsgcmV0dXJuIHBbdGhpcy5vcmRlcl07IH1cblxuICAgICAgICBtdCA9IDEgLSB0O1xuICAgICAgICBtdDIgPSBtdCAqIG10O1xuICAgICAgICB0MiA9IHQgKiB0O1xuXG4gICAgICAgIGlmICh0aGlzLm9yZGVyID4gMikge1xuICAgICAgICAgICAgYSA9IG10MiAqIG10O1xuICAgICAgICAgICAgYiA9IG10MiAqIHQgKiAzO1xuICAgICAgICAgICAgYyA9IG10ICogdDIgKiAzO1xuICAgICAgICAgICAgZCA9IHQgKiB0MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBbcFswXSwgcFsxXSwgcFsyXSwge3g6IDAsIHk6IDB9XTtcbiAgICAgICAgICAgIGEgPSBtdDI7XG4gICAgICAgICAgICBiID0gbXQgKiB0ICogMjtcbiAgICAgICAgICAgIGMgPSB0MjtcbiAgICAgICAgICAgIGQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIGEgKiBwWzBdLnggKyBiICogcFsxXS54ICsgYyAqIHBbMl0ueCArIGQgKiBwWzNdLngsXG4gICAgICAgICAgICBhICogcFswXS55ICsgYiAqIHBbMV0ueSArIGMgKiBwWzJdLnkgKyBkICogcFszXS55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGRlcml2YXRpdmU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5kcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbXQgPSAxIC0gdDtcbiAgICAgICAgdmFyIGEsIGIsIGM7XG5cbiAgICAgICAgaWYgKHRoaXMub3JkZXIgPiAyKSB7XG4gICAgICAgICAgICBhID0gbXQgKiBtdDtcbiAgICAgICAgICAgIGIgPSBtdCAqIHQgKiAyO1xuICAgICAgICAgICAgYyA9IHQgKiB0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IFtwWzBdLCBwWzFdLCB7eDogMCwgeTogMH1dO1xuICAgICAgICAgICAgYSA9IG10OyBiID0gdDsgYyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgYSAqIHBbMF0ueCArIGIgKiBwWzFdLnggKyBjICogcFsyXS54LFxuICAgICAgICAgICAgYSAqIHBbMF0ueSArIGIgKiBwWzFdLnkgKyBjICogcFsyXS55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgdmFyIHdfaSA9IERHLkJlemllci5XRUlHSFQ7XG4gICAgICAgIHZhciB4X2kgPSBERy5CZXppZXIuQUJTQ0lTU0E7XG4gICAgICAgIHZhciB6ID0gMC41O1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIGQsIGwsIHQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4X2kubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHQgPSB6ICogeF9pW2ldICsgejtcbiAgICAgICAgICAgIGQgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgICAgICAgICBsID0gZC54ICogZC54ICsgZC55ICogZC55O1xuICAgICAgICAgICAgc3VtICs9IHdfaVtpXSAqIE1hdGguc3FydChsKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuXG4gICAgICAgIHJldHVybiB6ICogc3VtO1xuICAgIH0sXG5cbiAgICBnZXRDdXJ2ZUJlZm9yZTogZnVuY3Rpb24gKHopIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIHoyLCB6MywgbXosIG16MiwgbXozO1xuICAgICAgICB2YXIgYiQzLCBiJDQsIGMkNDtcbiAgICAgICAgdmFyIGN1cnZlO1xuXG4gICAgICAgIGlmICh6ID09PSAxKSB7IHJldHVybiB0aGlzLmNsb25lKCk7IH1cblxuICAgICAgICBjdXJ2ZSA9IFtdO1xuICAgICAgICB6MiA9IHogKiB6O1xuICAgICAgICBteiA9IHogLSAxO1xuICAgICAgICBtejIgPSBteiAqIG16O1xuXG4gICAgICAgIGN1cnZlWzBdID0gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgcFswXS54LFxuICAgICAgICAgICAgcFswXS55XG4gICAgICAgICk7XG5cbiAgICAgICAgY3VydmVbMV0gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICB6ICogcFsxXS54IC0gbXogKiBwWzBdLngsXG4gICAgICAgICAgICB6ICogcFsxXS55IC0gbXogKiBwWzBdLnlcbiAgICAgICAgKTtcblxuICAgICAgICBiJDMgPSB6ICogbXogKiAyO1xuICAgICAgICBjdXJ2ZVsyXSA9IG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIHoyICogcFsyXS54IC0gYiQzICogcFsxXS54ICsgbXoyICogcFswXS54LFxuICAgICAgICAgICAgejIgKiBwWzJdLnkgLSBiJDMgKiBwWzFdLnkgKyBtejIgKiBwWzBdLnlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5vcmRlciA+IDIpIHtcbiAgICAgICAgICAgIHozID0gejIgKiB6O1xuICAgICAgICAgICAgbXozID0gbXoyICogbXo7XG4gICAgICAgICAgICBiJDQgPSB6MiAqIG16ICogMztcbiAgICAgICAgICAgIGMkNCA9IHogKiBtejIgKiAzO1xuICAgICAgICAgICAgY3VydmVbM10gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICAgICAgejMgKiBwWzNdLnggLSBiJDQgKiBwWzJdLnggKyBjJDQgKiBwWzFdLnggLSBtejMgKiBwWzBdLngsXG4gICAgICAgICAgICAgICAgejMgKiBwWzNdLnkgLSBiJDQgKiBwWzJdLnkgKyBjJDQgKiBwWzFdLnkgLSBtejMgKiBwWzBdLnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERHLkJlemllcihjdXJ2ZSk7XG4gICAgfSxcblxuICAgIGdldEN1cnZlQWZ0ZXI6IGZ1bmN0aW9uICh6KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBuID0gdGhpcy5vcmRlcjtcbiAgICAgICAgdmFyIHoyLCB6MywgbXosIG16MiwgbXozO1xuICAgICAgICB2YXIgYiQzLCBiJDQsIGMkNDtcbiAgICAgICAgdmFyIGN1cnZlO1xuXG4gICAgICAgIGlmICh6ID09PSAxKSB7IHJldHVybiB0aGlzLmNsb25lKCk7IH1cblxuICAgICAgICBjdXJ2ZSA9IFtdO1xuICAgICAgICB6MiA9IHogKiB6O1xuICAgICAgICBteiA9IHogLSAxO1xuICAgICAgICBtejIgPSBteiAqIG16O1xuXG4gICAgICAgIGN1cnZlW25dID0gbmV3IERHLlBvaW50KFxuICAgICAgICAgICAgcFtuXS54LFxuICAgICAgICAgICAgcFtuXS55XG4gICAgICAgICk7XG5cbiAgICAgICAgY3VydmVbLS1uXSA9IG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIHogKiBwW24gKyAxXS54IC0gbXogKiBwW25dLngsXG4gICAgICAgICAgICB6ICogcFtuICsgMV0ueSAtIG16ICogcFtuXS55XG4gICAgICAgICk7XG5cbiAgICAgICAgYiQzID0geiAqIG16ICogMjtcbiAgICAgICAgY3VydmVbLS1uXSA9IG5ldyBERy5Qb2ludChcbiAgICAgICAgICAgIHoyICogcFtuICsgMl0ueCAtIGIkMyAqIHBbbiArIDFdLnggKyBtejIgKiBwW25dLngsXG4gICAgICAgICAgICB6MiAqIHBbbiArIDJdLnkgLSBiJDMgKiBwW24gKyAxXS55ICsgbXoyICogcFtuXS55XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMub3JkZXIgPiAyKSB7XG4gICAgICAgICAgICB6MyA9IHoyICogejtcbiAgICAgICAgICAgIG16MyA9IG16MiAqIG16O1xuICAgICAgICAgICAgYiQ0ID0gejIgKiBteiAqIDM7XG4gICAgICAgICAgICBjJDQgPSB6ICogbXoyICogMztcbiAgICAgICAgICAgIGN1cnZlWy0tbl0gPSBuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICAgICAgejMgKiBwW24gKyAzXS54IC0gYiQ0ICogcFtuICsgMl0ueCArIGMkNCAqIHBbbiArIDFdLnggLSBtejMgKiBwW25dLngsXG4gICAgICAgICAgICAgICAgejMgKiBwW24gKyAzXS55IC0gYiQ0ICogcFtuICsgMl0ueSArIGMkNCAqIHBbbiArIDFdLnkgLSBtejMgKiBwW25dLnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERHLkJlemllcihjdXJ2ZSk7XG4gICAgfSxcblxuICAgIF9nZXREZXJpdmF0aXZlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgZCwgYywgaiwgbGlzdDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoZCA9IHAubGVuZ3RoLCBjID0gZCAtIDE7IGQgPiAxOyBkLS0sIGMtLSkge1xuICAgICAgICAgICAgbGlzdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGM7IGorKykge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChuZXcgREcuUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIGMgKiAocFtqICsgMV0ueCAtIHBbal0ueCksXG4gICAgICAgICAgICAgICAgICAgIGMgKiAocFtqICsgMV0ueSAtIHBbal0ueSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxpc3QpO1xuICAgICAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRMVVQ6IGZ1bmN0aW9uIChzdGVwcykge1xuICAgICAgICBzdGVwcyA9IHN0ZXBzIHx8IDEyNTtcblxuICAgICAgICBpZiAodGhpcy5fbHV0Lmxlbmd0aCAhPT0gc3RlcHMgKyAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmRlciA+IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRMVVQzKHN0ZXBzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0TFVUMihzdGVwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbHV0O1xuICAgIH0sXG5cbiAgICBfc2V0TFVUMjogZnVuY3Rpb24gKHN0ZXBzKSB7XG4gICAgICAgIHZhciBsdXQgPSB0aGlzLl9sdXQgPSBbXTtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIHQsIG10O1xuICAgICAgICB2YXIgYSwgYiwgYztcblxuICAgICAgICBsdXQucHVzaCh7eDogcFswXS54LCB5OiBwWzBdLnksIGw6IDB9KTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDE7IHMgPCBzdGVwczsgcysrKSB7XG4gICAgICAgICAgICB0ID0gcyAvIHN0ZXBzO1xuICAgICAgICAgICAgbXQgPSAxIC0gdDtcbiAgICAgICAgICAgIGEgPSBtdCAqIG10O1xuICAgICAgICAgICAgYiA9IG10ICogdCAqIDI7XG4gICAgICAgICAgICBjID0gdCAqIHQ7XG4gICAgICAgICAgICBsdXQucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogYSAqIHBbMF0ueCArIGIgKiBwWzFdLnggKyBjICogcFsyXS54LFxuICAgICAgICAgICAgICAgIHk6IGEgKiBwWzBdLnkgKyBiICogcFsxXS55ICsgYyAqIHBbMl0ueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbHV0LnB1c2goe3g6IHBbMl0ueCwgeTogcFsyXS55LCBsOiAwfSk7XG4gICAgfSxcblxuICAgIF9zZXRMVVQzOiBmdW5jdGlvbiAoc3RlcHMpIHtcbiAgICAgICAgdmFyIGx1dCA9IHRoaXMuX2x1dCA9IFtdO1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgdCwgdDIsIG10LCBtdDI7XG4gICAgICAgIHZhciBhLCBiLCBjLCBkO1xuXG4gICAgICAgIGx1dC5wdXNoKHt4OiBwWzBdLngsIHk6IHBbMF0ueSwgbDogMH0pO1xuICAgICAgICBmb3IgKHZhciBzID0gMTsgcyA8IHN0ZXBzOyBzKyspIHtcbiAgICAgICAgICAgIHQgPSBzIC8gc3RlcHM7XG4gICAgICAgICAgICBtdCA9IDEgLSB0O1xuICAgICAgICAgICAgbXQyID0gbXQgKiBtdDtcbiAgICAgICAgICAgIHQyID0gdCAqIHQ7XG4gICAgICAgICAgICBhID0gbXQyICogbXQ7XG4gICAgICAgICAgICBiID0gbXQyICogdCAqIDM7XG4gICAgICAgICAgICBjID0gbXQgKiB0MiAqIDM7XG4gICAgICAgICAgICBkID0gdCAqIHQyO1xuICAgICAgICAgICAgbHV0LnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IGEgKiBwWzBdLnggKyBiICogcFsxXS54ICsgYyAqIHBbMl0ueCArIGQgKiBwWzNdLngsXG4gICAgICAgICAgICAgICAgeTogYSAqIHBbMF0ueSArIGIgKiBwWzFdLnkgKyBjICogcFsyXS55ICsgZCAqIHBbM10ueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbHV0LnB1c2goe3g6IHBbM10ueCwgeTogcFszXS55LCBsOiAwfSk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgREcuQmV6aWVyKHRoaXMucG9pbnRzLCB0cnVlKTtcbiAgICB9XG59KTtcblxuREcuYmV6aWVyID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIGlmICh0eXBlb2YgY29vcmRzID09PSAnbnVtYmVyJyB8fCBjb29yZHMgaW5zdGFuY2VvZiBERy5Qb2ludCkge1xuICAgICAgICBjb29yZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29vcmRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA8IDcpIHtcbiAgICAgICAgICAgIGNvb3JkcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgREcuUG9pbnQoY29vcmRzWzBdLCBjb29yZHNbMV0pLFxuICAgICAgICAgICAgICAgIG5ldyBERy5Qb2ludChjb29yZHNbMl0sIGNvb3Jkc1szXSksXG4gICAgICAgICAgICAgICAgbmV3IERHLlBvaW50KGNvb3Jkc1s0XSwgY29vcmRzWzVdKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvb3JkcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgREcuUG9pbnQoY29vcmRzWzBdLCBjb29yZHNbMV0pLFxuICAgICAgICAgICAgICAgIG5ldyBERy5Qb2ludChjb29yZHNbMl0sIGNvb3Jkc1szXSksXG4gICAgICAgICAgICAgICAgbmV3IERHLlBvaW50KGNvb3Jkc1s0XSwgY29vcmRzWzVdKSxcbiAgICAgICAgICAgICAgICBuZXcgREcuUG9pbnQoY29vcmRzWzZdLCBjb29yZHNbN10pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgREcuQmV6aWVyKGNvb3Jkcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBERy5CZXppZXIoY29vcmRzLCB0cnVlKTtcbiAgICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbkRHLkJlemllci5XRUlHSFQgPSBbXG4gICAgMC4zNjI2ODM3ODMzNzgzNjIwLFxuICAgIDAuMzYyNjgzNzgzMzc4MzYyMCxcbiAgICAwLjMxMzcwNjY0NTg3Nzg4NzMsXG4gICAgMC4zMTM3MDY2NDU4Nzc4ODczLFxuICAgIDAuMjIyMzgxMDM0NDUzMzc0NSxcbiAgICAwLjIyMjM4MTAzNDQ1MzM3NDUsXG4gICAgMC4xMDEyMjg1MzYyOTAzNzYzLFxuICAgIDAuMTAxMjI4NTM2MjkwMzc2M1xuXTtcbkRHLkJlemllci5BQlNDSVNTQSA9IFtcbiAgIC0wLjE4MzQzNDY0MjQ5NTY0OTgsXG4gICAgMC4xODM0MzQ2NDI0OTU2NDk4LFxuICAgLTAuNTI1NTMyNDA5OTE2MzI5MCxcbiAgICAwLjUyNTUzMjQwOTkxNjMyOTAsXG4gICAtMC43OTY2NjY0Nzc0MTM2MjY3LFxuICAgIDAuNzk2NjY2NDc3NDEzNjI2NyxcbiAgIC0wLjk2MDI4OTg1NjQ5NzUzNjMsXG4gICAgMC45NjAyODk4NTY0OTc1MzYzXG5dO1xuLyogZXNsaW50LWVuYWJsZSBpbmRlbnQgKi9cblxuXG4vLyAgVGhpcyBjdXJ2ZSBpcyBtb25vdG9uaWNhbGx5IG9yZGVyZWQgYnkgJ1gnIGNvb3JkaW5hdGUgYW5kIGhhcyBQWzBdID0gezAsIDB9IGFuZCBQWzNdID0gezEsIDF9XG4vLyAgV2UgY2FuIHV0aWxpemUgdGhpcyBmYWN0cyB0byBzaG9ydGN1dCBjYWxjdWxhdGlvbnNcbkRHLlRpbWVCZXppZXIgPSBERy5CZXppZXIuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoY29udHJvbFBvaW50MSwgY29udHJvbFBvaW50MiwgY2xvbmUpIHtcbiAgICAgICAgREcuQmV6aWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgW0RHLlRpbWVCZXppZXIuU1RBUlQsIGNvbnRyb2xQb2ludDEsIGNvbnRyb2xQb2ludDIsIERHLlRpbWVCZXppZXIuRU5EXSxcbiAgICAgICAgICAgIGNsb25lXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldFlieVg6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBsdXQgPSB0aGlzLmdldExVVCgpO1xuICAgICAgICB2YXIgbWF4ID0gbHV0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICB2YXIgbWlkO1xuXG4gICAgICAgIGlmICh4IDw9IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgaWYgKHggPj0gMSkgeyByZXR1cm4gMTsgfVxuXG4gICAgICAgIC8vICAnWCcgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHNvIHdlIGNhbiBkbyBhIHNpbXBsZSBiaW5hcnkgc2VhcmNoIChMVVQpXG4gICAgICAgIC8vICBhbmQgdGhlbiBmaW5lLXR1bmUgdGhlIHJlc3VsdCBieSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBhc3N1bWluZyAnWScgaXMgbm90IGNoYW5nZWQgc28gcmFkaWNhbGx5XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBtaWQgPSBtaW4gKyAobWF4IC0gbWluID4+IDEpO1xuICAgICAgICAgICAgaWYgKHggPCBsdXRbbWlkXS54KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4IC0gbWluIDwgMikgeyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIHggPSAoeCAtIGx1dFttaW5dLngpIC8gKGx1dFttYXhdLnggLSBsdXRbbWluXS54KTtcblxuICAgICAgICByZXR1cm4gKGx1dFttaW5dLnkgKyAobHV0W21heF0ueSAtIGx1dFttaW5dLnkpICogeCk7XG4gICAgfSxcblxuICAgIGdldExVVDogZnVuY3Rpb24gKHN0ZXBzKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciB0LCB0MiwgbXQ7XG4gICAgICAgIHZhciBiLCBjLCBkO1xuICAgICAgICB2YXIgbHV0O1xuXG4gICAgICAgIHN0ZXBzID0gc3RlcHMgfHwgMjQwO1xuICAgICAgICBpZiAodGhpcy5fbHV0Lmxlbmd0aCA9PT0gc3RlcHMgKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbHV0ID0gbHV0ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBsdXQucHVzaCh7eDogMCwgeTogMH0pO1xuICAgICAgICBmb3IgKHZhciBzID0gMTsgcyA8IHN0ZXBzOyBzKyspIHtcbiAgICAgICAgICAgIHQgPSBzIC8gc3RlcHM7XG4gICAgICAgICAgICBtdCA9IDEgLSB0O1xuICAgICAgICAgICAgdDIgPSB0ICogdDtcbiAgICAgICAgICAgIC8vICBXZSBkb24ndCBuZWVkICdhJyBjb2VmZmljaWVudCBiZWNhdXNlIHBbMF0gaXMgezAsIDB9XG4gICAgICAgICAgICBiID0gbXQgKiBtdCAqIHQgKiAzO1xuICAgICAgICAgICAgYyA9IG10ICogdDIgKiAzO1xuICAgICAgICAgICAgZCA9IHQgKiB0MjtcbiAgICAgICAgICAgIGx1dC5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBiICogcFsxXS54ICsgYyAqIHBbMl0ueCArIGQsXG4gICAgICAgICAgICAgICAgeTogYiAqIHBbMV0ueSArIGMgKiBwWzJdLnkgKyBkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsdXQucHVzaCh7eDogMSwgeTogMX0pO1xuXG4gICAgICAgIHJldHVybiBsdXQ7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgREcuVGltZUJlemllcih0aGlzLnBvaW50cywgdHJ1ZSk7XG4gICAgfVxufSk7XG5cbkRHLlRpbWVCZXppZXIuU1RBUlQgPSBERy5wb2ludCgwLCAwKTtcbkRHLlRpbWVCZXppZXIuRU5EID0gREcucG9pbnQoMSwgMSk7XG5cblxuLy8gIFRoaXMgaXMgY3ViaWMgQmV6aWVyIGRlc2NyaWJpbmcgY2lyY3VsYXIgYXJjXG5ERy5BcmNCZXppZXIgPSBERy5CZXppZXIuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoY29vcmRzLCBjbG9uZSkge1xuICAgICAgICBERy5CZXppZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBjb29yZHMsIGNsb25lKTtcbiAgICAgICAgdGhpcy5nZXRMVVQoKTtcbiAgICAgICAgdGhpcy5fc2V0THV0TGVuZ3RocygpO1xuICAgIH0sXG5cbiAgICBnZXRUYnlMOiBmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgbHV0ID0gdGhpcy5nZXRMVVQoKTtcbiAgICAgICAgdmFyIG1heCA9IGx1dC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgdmFyIG1pZDtcbiAgICAgICAgdmFyIHgsIHk7XG5cbiAgICAgICAgaWYgKGwgPD0gMCkgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAobCA+PSBsdXRbbWF4XS5sKSB7IHJldHVybiAxOyB9XG5cbiAgICAgICAgLy8gICdMJyBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgc28gd2UgY2FuIGRvIGEgYmluYXJ5IHNlYXJjaCAoTFVUKVxuICAgICAgICAvLyAgYW5kIHRoZW4gZmluZS10dW5lIHRoZSByZXN1bHQgYnkgbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIG1pZCA9IG1pbiArIChtYXggLSBtaW4gPj4gMSk7XG4gICAgICAgICAgICBpZiAobCA8IGx1dFttaWRdLmwpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbiA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXggLSBtaW4gPCAyKSB7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgbCA9IChsIC0gbHV0W21pbl0ubCkgLyAobHV0W21heF0ubCAtIGx1dFttaW5dLmwpO1xuXG4gICAgICAgIHggPSAobHV0W21pbl0ueCArIChsdXRbbWF4XS54IC0gbHV0W21pbl0ueCkgKiBsKTtcbiAgICAgICAgeSA9IChsdXRbbWluXS55ICsgKGx1dFttYXhdLnkgLSBsdXRbbWluXS55KSAqIGwpO1xuXG4gICAgICAgIC8vICBCVVQgdGhpcyBpcyBhIHBhcnQgb2Ygc3RvcnksIHdlIG5lZWQgYSBwcm9qZWN0aW9uIG9mIHRoaXMgcG9pbnQgdG8gdGhlIGFjdHVhbCBjdXJ2ZSBhbmQgaXQncyByZXZlcnNlICd0JyB2YWxcbiAgICAgICAgdmFyIHAsIGR4LCBkeSwgdDtcbiAgICAgICAgdmFyIGV0ID0gbWF4IC8gbHV0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGR0ID0gbWluIC8gbHV0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHMgPSAxIC8gbHV0Lmxlbmd0aCAvIDEwOyAgICAvLyAgVE9ET1xuICAgICAgICB2YXIgZCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbiAgICAgICAgZm9yICh0ID0gZHQ7IGR0IDwgZXQ7IGR0ICs9IHMpIHtcbiAgICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50KGR0KTtcbiAgICAgICAgICAgIGR4ID0gcC54IC0geDsgZHkgPSBwLnkgLSB5O1xuICAgICAgICAgICAgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICBpZiAobCA8IGQpIHtcbiAgICAgICAgICAgICAgICBkID0gbDtcbiAgICAgICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICB9LFxuXG4gICAgX3NldEx1dExlbmd0aHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGx1dCA9IHRoaXMuX2x1dDtcbiAgICAgICAgdmFyIGR4LCBkeTtcblxuICAgICAgICBsdXRbMF0ubCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkeCA9IGx1dFtpXS54IC0gbHV0W2kgLSAxXS54O1xuICAgICAgICAgICAgZHkgPSBsdXRbaV0ueSAtIGx1dFtpIC0gMV0ueTtcbiAgICAgICAgICAgIGx1dFtpXS5sID0gbHV0W2kgLSAxXS5sICsgTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2x1dFt0aGlzLl9sdXQubGVuZ3RoIC0gMV0ubDtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBERy5BcmNCZXppZXIodGhpcy5wb2ludHMsIHRydWUpO1xuICAgIH1cbn0pO1xuIiwiLypcbiAqIERHLkFuaW1hdGlvbiBwcm92aWRlcyB0aWNrIChzdGVwKSBsb2dpYyByZXR1cm5pbmcgcHJvZ3Jlc3Npb24gdmFsdWVzXG4gKiBjYWxjdWxhdGVkIG92ZXIgcHJvdmlkZWQgb3IgY3VzdG9tIELDqXppZXIgY3VydmVzXG4gKiBPcmlnaW5hbCBpbnB1dCBjYW4gYmUgYXJyYXkgb2JqZWN0IGJ0dy4uLlxuICovXG5cbkRHLkFuaW1hdGlvbiA9IERHLkV2ZW50ZWQuZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIC8vIGFuaW1hdGlvbjogeyAgICAvLyAgT3IgYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICAvLyAgICAgZnVuY3Rpb246IERHLkFuaW1hdGlvbi5FQVNFLFxuICAgICAgICAvLyAgICAgZHVyYXRpb246IDIwMDAsXG4gICAgICAgIC8vICAgICBmcmFtZXM6IG51bGxcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vb2Zmc2V0OiAwXG4gICAgICAgIC8vcmVwZWF0OiAwXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fYW5pbUlEID0gLTE7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmUoKTtcblxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cbiAgICAgICAgLy8gIERhdGUubm93KCksIGJ1dC4uLiBJRTkrXG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGUoKTtcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgICAgICAgdGhpcy5fcnVuKHRoaXMuX2R1cmF0aW9ucy5nZXRMZW5ndGgoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3ByZXBhcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gREcuVXRpbC5pc0FycmF5KHRoaXMub3B0aW9ucy5hbmltYXRpb24pID8gdGhpcy5vcHRpb25zLmFuaW1hdGlvbiA6IFt0aGlzLm9wdGlvbnMuYW5pbWF0aW9uXTtcblxuICAgICAgICB0aGlzLl9kdXJhdGlvbnMgPSBuZXcgREcuTWV0cmljLlNlZ21lbnRzKCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChhbmltYXRpb24uZHVyYXRpb24pO1xuICAgICAgICB9LCB0aGlzLl9kdXJhdGlvbnMpO1xuICAgIH0sXG5cbiAgICBfYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hbmltSUQgPSBERy5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3J1bigpO1xuICAgIH0sXG5cbiAgICBfcnVuOiBmdW5jdGlvbiAoZWxhcHNlZCkge1xuICAgICAgICB2YXIgZWwsIGluZGV4LCBwcm9ncmVzcztcbiAgICAgICAgLy8gIFBvc3NpYmxlIHNraXAgemVybyBkZWx0YSB0aW1lIGJ1dCB3aG8gY2FyZXM/IVxuICAgICAgICBlbGFwc2VkID0gZWxhcHNlZCA/IGVsYXBzZWQgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3N0YXJ0VGltZTtcblxuICAgICAgICBpZiAoZWxhcHNlZCA8IHRoaXMuX2R1cmF0aW9ucy5nZXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9kdXJhdGlvbnMuZ2V0SW5kZXgoZWxhcHNlZCk7XG4gICAgICAgICAgICBlbCA9IHRoaXMuX2R1cmF0aW9ucy5nZXRTZWdSYXRpbyhlbGFwc2VkKTtcbiAgICAgICAgICAgIHByb2dyZXNzID0gdGhpcy5fYW5pbWF0aW9uW2luZGV4XVsnZnVuY3Rpb24nXS5nZXRZYnlYKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAodGhpcy5fZ2V0RnJhbWVWYWx1ZXMoaW5kZXgsIHByb2dyZXNzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuX2R1cmF0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdGhpcy5fc3RlcCh0aGlzLl9nZXRGcmFtZVZhbHVlcyhpbmRleCwgMSkpO1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc3RlcDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0aGlzLmZpcmUoJ3N0ZXAnLCBvYmopO1xuICAgIH0sXG5cbiAgICBfY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgREcuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlEKTtcblxuICAgICAgICB0aGlzLl9kdXJhdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmlyZSgnZW5kJyk7XG4gICAgfSxcblxuICAgIF9nZXRGcmFtZVZhbHVlczogZnVuY3Rpb24gKGluZGV4LCBwcm9ncmVzcykge1xuICAgICAgICB2YXIgZnJhbWVzID0gdGhpcy5fYW5pbWF0aW9uW2luZGV4XS5mcmFtZXM7XG4gICAgICAgIHZhciBvYmogPSB7cHJvZ3Jlc3M6IHByb2dyZXNzfTtcbiAgICAgICAgdmFyIGZyLCB0bztcblxuICAgICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lc1trZXldLnByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gZnJhbWVzW2tleV0ucHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyID0gZnJhbWVzW2tleV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBmcmFtZXNba2V5XS50bztcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBmciArICh0byAtIGZyKSAqIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn0pO1xuXG5ERy5hbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQW5pbWF0aW9uKG9wdGlvbnMpO1xufTtcblxuREcuQW5pbWF0aW9uLkxJTkVBUiAgICAgICAgID0gbmV3IERHLlRpbWVCZXppZXIoREcucG9pbnQoMC4wMCwgMC4wKSwgREcucG9pbnQoMS4wMCwgMS4wKSk7XG5ERy5BbmltYXRpb24uRUFTRSAgICAgICAgICAgPSBuZXcgREcuVGltZUJlemllcihERy5wb2ludCgwLjI1LCAwLjEpLCBERy5wb2ludCgwLjI1LCAxLjApKTtcbkRHLkFuaW1hdGlvbi5FQVNFX0lOICAgICAgICA9IG5ldyBERy5UaW1lQmV6aWVyKERHLnBvaW50KDAuNDIsIDAuMCksIERHLnBvaW50KDEuMDAsIDEuMCkpO1xuREcuQW5pbWF0aW9uLkVBU0VfSU5fT1VUICAgID0gbmV3IERHLlRpbWVCZXppZXIoREcucG9pbnQoMC40MiwgMC4wKSwgREcucG9pbnQoMC41OCwgMS4wKSk7XG5ERy5BbmltYXRpb24uRUFTRV9PVVQgICAgICAgPSBuZXcgREcuVGltZUJlemllcihERy5wb2ludCgwLjAwLCAwLjApLCBERy5wb2ludCgwLjU4LCAxLjApKTtcbiIsIi8qXG4gKiBERy5FbnRyYW5jZSBpcyBhIG1haW4gY2xhc3MgdGhhdCBob3N0cyBhY3R1YWwgYXJyb3cgbGF5ZXJzXG4gKiBJdCBvcmNoZXN0cmF0ZXMgYW5pbWF0aW9uIGFuZCBwcm92aWRlcyB1c2VyIHNwYWNlIG1ldGhvZHMgbGlrZSAuc2hvdygpIGFuZCAuaGlkZSgpXG4gKi9cblxuREcuRW50cmFuY2UgPSBERy5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdmVjdG9yczogW10sXG5cbiAgICAgICAgZmlsbENvbG9yOiAnIzAwODVhMCcsXG4gICAgICAgIHN0cm9rZUNvbG9yOiAnI2ZmZicsXG5cbiAgICAgICAgZW5hYmxlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG5cbiAgICAgICAgYXV0b0Nsb3NlOiB0cnVlXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIERHLkxheWVyR3JvdXAucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcblxuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9XG4gICAgICAgICAgICBuZXcgREcuTGF0TG5nQm91bmRzKCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbnMgPSB7XG4gICAgICAgICAgICBib3VuY2U6IERHLmFuaW1hdGlvbihERy5FbnRyYW5jZS5CT1VOQ0VfQU5JTUFUSU9OKSxcbiAgICAgICAgICAgIHBhdGg6IERHLmFuaW1hdGlvbihERy5FbnRyYW5jZS5QQVRIX0FOSU1BVElPTilcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9pbml0QXJyb3dzKCk7XG5cbiAgICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBERy5MYXllckdyb3VwLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgREcuTGF5ZXJHcm91cC5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgIH0sXG5cbiAgICBnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICBldmVudHNbJ2xheWVyYWRkJ10gPSB0aGlzLl9yZW1vdmVFbnRyYW5jZTsgIC8vICBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBldmVudHNbJ3pvb21lbmQnXSA9IHRoaXMuX2FuaW1hdGU7ICAgICAgICAgIC8vICBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24gKGZpdEJvdW5kcykge1xuICAgICAgICBpZiAodGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZml0Qm91bmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXRCb3VuZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChhcnJvdykge1xuICAgICAgICAgICAgICAgICAgICBhcnJvdy5zZXRWaXNpYmlsaXR5KHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ2VudHJhbmNlc2hvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xheWVycyAmJiB0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAoYXJyb3cpIHtcbiAgICAgICAgICAgICAgICBhcnJvdy5zZXRWaXNpYmlsaXR5KGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ2VudHJhbmNlaGlkZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGlzU2hvd246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd247XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xuICAgIH0sXG5cbiAgICBzZXRGaWxsQ29sb3I6IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAoYXJyb3cpIHtcbiAgICAgICAgICAgIGFycm93LnNldFN0eWxlKHtmaWxsQ29sb3I6IGNvbG9yfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzZXRTdHJva2VDb2xvcjogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChhcnJvdykge1xuICAgICAgICAgICAgYXJyb3cuc2V0U3R5bGUoe2NvbG9yOiBjb2xvcn0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2luaXRBcnJvd3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB7XG4gICAgICAgICAgICBjb2xvcjogdGhpcy5vcHRpb25zLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgZmlsbENvbG9yOiB0aGlzLm9wdGlvbnMuZmlsbENvbG9yLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy52ZWN0b3JzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2ZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREcuV2t0LnRvTGF0TG5ncyh2ZWN0b3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBERy5VdGlsLmNyZWF0ZShiYXNlKSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gREcubGF0TG5nQm91bmRzKGxhdGxuZ3MpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzLmV4dGVuZChib3VuZHMpO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sYXRsbmdzID0gbGF0bG5ncztcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvdW5kcyA9IGJvdW5kcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF0bG5ncy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbnMucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9ucy5ib3VuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRpc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGF5ZXIoREcuZW50cmFuY2UuYXJyb3cob3B0aW9ucykpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuXG4gICAgX2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnMuYm91bmNlLnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25zLnBhdGguc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAgQ3VycmVudCBsb2dpYyBvZiBuZXh0IGZvdXIgbWV0aG9kcyBleHRyYWN0ZWQgZnJvbSBvcmlnaW5hbCBhcnJvdydzIGltcGxlbWVudGF0aW9uXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXAsIGZpdFpvb20sXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXG4gICAgICAgIGlmICghbWFwLmdldEJvdW5kcygpLmNvbnRhaW5zKGJvdW5kcykgfHwgIXRoaXMuX2lzQWxsb3dlZFpvb20oKSkge1xuICAgICAgICAgICAgZml0Wm9vbSA9IHRoaXMuX2dldEZpdFpvb20oKTtcbiAgICAgICAgICAgIGlmICghbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkpIHtcbiAgICAgICAgICAgICAgICBtYXAub25jZSgnbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldFpvb20odGhpcy5fZ2V0Rml0Wm9vbSgpKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcC5zZXRWaWV3KGJvdW5kcy5nZXRDZW50ZXIoKSwgZml0Wm9vbSwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZ2V0Rml0Wm9vbTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkubWF4Wm9vbSB8fCBERy5FbnRyYW5jZS5TSE9XX0ZST01fWk9PTTtcbiAgICB9LFxuXG4gICAgX2lzQWxsb3dlZFpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXRab29tKCkgPj0gREcuRW50cmFuY2UuU0hPV19GUk9NX1pPT007XG4gICAgfSxcblxuICAgIF9yZW1vdmVFbnRyYW5jZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUubGF5ZXIgaW5zdGFuY2VvZiBERy5Qb3B1cCB8fFxuICAgICAgICAgICAgKGUubGF5ZXIgaW5zdGFuY2VvZiBERy5FbnRyYW5jZSAmJiBlLmxheWVyICE9PSB0aGlzKSkge1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLmVudHJhbmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkVudHJhbmNlKG9wdGlvbnMpO1xufTtcblxuREcuRW50cmFuY2UuU0hPV19GUk9NX1pPT00gPSAxNjtcbkRHLkVudHJhbmNlLlBBVEhfQU5JTUFUSU9OID0ge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9JTl9PVVQsXG4gICAgICAgICdkdXJhdGlvbic6IDc1MFxuICAgIH1cbn07XG5ERy5FbnRyYW5jZS5CT1VOQ0VfQU5JTUFUSU9OID0ge1xuICAgIGFuaW1hdGlvbjogW1xuICAgICAgICB7J2Z1bmN0aW9uJzogREcuQW5pbWF0aW9uLkVBU0VfSU5fT1VULCAnZHVyYXRpb24nOiAyNTAsICdmcmFtZXMnOiB7J2Rpc3RhbmNlJzogeydmcm9tJzogMCwgJ3RvJzogMC42fX19LFxuICAgICAgICB7J2Z1bmN0aW9uJzogREcuQW5pbWF0aW9uLkVBU0VfSU4sICdkdXJhdGlvbic6IDEzNSwgJ2ZyYW1lcyc6IHsnZGlzdGFuY2UnOiB7J2Zyb20nOiAwLjYsICd0byc6IDB9fX0sXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9PVVQsICdkdXJhdGlvbic6IDEzNSwgJ2ZyYW1lcyc6IHsnZGlzdGFuY2UnOiB7J2Zyb20nOiAwLCAndG8nOiAwLjE2fX19LFxuICAgICAgICB7J2Z1bmN0aW9uJzogREcuQW5pbWF0aW9uLkVBU0VfSU4sICdkdXJhdGlvbic6IDkwLCAnZnJhbWVzJzogeydkaXN0YW5jZSc6IHsnZnJvbSc6IDAuMTYsICd0byc6IDB9fX0sXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9PVVQsICdkdXJhdGlvbic6IDkwLCAnZnJhbWVzJzogeydkaXN0YW5jZSc6IHsnZnJvbSc6IDAsICd0byc6IDAuMDZ9fX0sXG4gICAgICAgIHsnZnVuY3Rpb24nOiBERy5BbmltYXRpb24uRUFTRV9JTiwgJ2R1cmF0aW9uJzogNTAsICdmcmFtZXMnOiB7J2Rpc3RhbmNlJzogeydmcm9tJzogMC4wNiwgJ3RvJzogMH19fVxuICAgIF1cbn07XG4iLCIvKlxuICogREcuRW50cmFuY2UuQXJyb3cgY2xhc3MgaG9zdHMgdHdvIGxheWVycywgb25lIGZvciBhcnJvdyBib2R5IChwYXRoKSBhbmQgb25lIGZvciBhcnJvdyB0aXBcbiAqIEl0IG92ZXJyaWRlcyBwcm9qZWN0aW9uIGV2ZW50cyBmcm9tIGhvc3RlZCBsYXllcnMgdG8gbWluaW1pemUgdG90YWwgb3ZlcmhlYWRcbiAqIEFjdHVhbCBjYWxjdWxhdGlvbnMgcHJvZHVjZWQgaW4gREcuQXJyb3dQYXRoVHJhbnNmb3JtIGFuZCBERy5BcnJvd1RpcFRyYW5zZm9ybSBjbGFzc2VzXG4gKi9cblxuREcuRW50cmFuY2UuQXJyb3cgPSBERy5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBERy5MYXllckdyb3VwLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcyk7XG5cbiAgICAgICAgREcuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDE7XG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eSA9IHtcbiAgICAgICAgICAgIGlzU2hvd246IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID1cbiAgICAgICAgICAgIG9wdGlvbnMubGF0bG5nc1tvcHRpb25zLmxhdGxuZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuX3NoYXBlID1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zaGFwZSB8fFxuICAgICAgICAgICAgREcuRW50cmFuY2UuQXJyb3cuU0hBUEU7XG5cbiAgICAgICAgdGhpcy5fYXB0ID0ge307IC8vIERHLkFycm93UGF0aFRyYW5zZm9ybSBvYmplY3RzIGJ5IHpvb20gbGV2ZWxzXG4gICAgICAgIHRoaXMuX2F0dCA9IHt9OyAvLyBERy5BcnJvd1RpcFRyYW5zZm9ybSBvYmplY3RzIGJ5IHpvb20gbGV2ZWxzXG4gICAgfSxcblxuICAgIGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAvLyAgdGhpcy5fbWFwIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQsIHNvIHdlIGNhbiBmcmVlbHkgYWRkTGF5ZXIocylcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgLy8gIFRPRE86IENoZWNrIENhbnZhcyBwcm9jZXNzaW5nIG9yZGVyXG4gICAgICAgIC8vICBBZGRpdGlvbmFsIGxvZ2ljIHRvIERJU0FCTEUgYW5pbWF0aW9uIG9uIENhbnZhcyBmb3Igbm93IVxuICAgICAgICBpZiAob3B0cy5hbmltYXRpb24gJiYgIW1hcC5vcHRpb25zLnByZWZlckNhbnZhcyAmJiAhREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgb3B0cy5hbmltYXRpb24ub24oJ3N0ZXAnLCB0aGlzLl9hbmltYXRpb24sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cy5hbmltYXRpb24gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5hZGRMYXllcihuZXcgREcuQ29tcGxleFBhdGgoe1xuICAgICAgICAgICAgbGluZUNhcDogJ2J1dHQnLFxuICAgICAgICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IG9wdHMuZmlsbENvbG9yLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IG9wdHMuaW50ZXJhY3RpdmUsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLl92aXNpYmlsaXR5LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9hcHRcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRoaXMuYWRkTGF5ZXIobmV3IERHLkNvbXBsZXhQYXRoKHtcbiAgICAgICAgICAgIGxpbmVKb2luOiAnbWl0ZXInLFxuICAgICAgICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IG9wdHMuZmlsbENvbG9yLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IG9wdHMuaW50ZXJhY3RpdmUsXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiB0aGlzLl92aXNpYmlsaXR5LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9hdHRcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHpvb21lbmQ6IHRoaXMuX3Byb2plY3QsXG4gICAgICAgICAgICBtb3ZlZW5kOiB0aGlzLl91cGRhdGUsXG4gICAgICAgICAgICB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNldFZpc2liaWxpdHk6IGZ1bmN0aW9uIChpc1Nob3duKSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmlsaXR5LmlzU2hvd24gIT09IGlzU2hvd24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2liaWxpdHkuaXNTaG93biA9IGlzU2hvd247XG4gICAgICAgICAgICBpZiAoaXNTaG93bikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib3VuZHM7XG4gICAgfSxcblxuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCB8fCB0aGlzLl9tYXBUb0FkZDtcbiAgICAgICAgdmFyIHpvb20gPSBtYXAgPyBtYXAuZ2V0Wm9vbSgpIDogMDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5fc2hhcGUudmVydGljZXNbem9vbV07XG4gICAgICAgIHZhciBkcmF3aW5ncyA9IHRoaXMuX3NoYXBlLmRyYXdpbmdzW3pvb21dO1xuICAgICAgICB2YXIgbGF0bG5ncyA9IHRoaXMub3B0aW9ucy5sYXRsbmdzO1xuICAgICAgICB2YXIgc2hhcGUsIHBhdGgsIGxhc3RQb2ludCwgcHJldlBvaW50O1xuXG4gICAgICAgIGlmICh6b29tICYmIHZlcnRpY2VzICYmIGRyYXdpbmdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dFt6b29tXSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBERy5BcnJvd1BhdGhUcmFuc2Zvcm0uZ2V0VHJhbnNsYXRlZFBhdGgobWFwLCBsYXRsbmdzKTtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHt2ZXJ0aWNlczogdmVydGljZXMsIGRyYXdpbmdzOiBkcmF3aW5nc307XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0W3pvb21dID0gbmV3IERHLkFycm93VGlwVHJhbnNmb3JtKHBhdGgsIHNoYXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHRbem9vbV0gPSBuZXcgREcuQXJyb3dQYXRoVHJhbnNmb3JtKHBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0UG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX3Bvc2l0aW9uKTtcbiAgICAgICAgICAgIHByZXZQb2ludCA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nc1tsYXRsbmdzLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXB0W3pvb21dLl9weEJvdW5kcykge1xuICAgICAgICAgICAgICAgIC8vICBPbmUtdGltZSBhY3Rpb24gcGVyICd2aWV3cmVzZXQnIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gIENhY2hpbmcgX3B4Qm91bmRzIGZvciB1c2luZyB3aXRoIENhbnZhcyByZW5kZXJlclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEJvdW5kcyhsYXN0UG9pbnQsIHByZXZQb2ludCwgdGhpcy5fYXB0W3pvb21dLCB0aGlzLl9hdHRbem9vbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIC8vICBBcnJvdyBwb3NpdGlvbiByZWNhbGN1bGF0ZWQgZm9yIEJvdW5jZSBhbmltYXRpb24gZWZmZWN0XG4gICAgICAgICAgICAgICAgbGFzdFBvaW50ID0gREcuVmVydGV4VHJhbnNmb3JtLmdldFNjYWxlZChsYXN0UG9pbnQsIHByZXZQb2ludCwgdGhpcy5fZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgTWFpbiBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIC8vICBHZXQgcGFydCBvZiB0aGUgYXJyb3cgcGF0aCBhbmQgbW92ZSAoYm91bmQpIGFycm93IHRpcCB0byBpdFxuICAgICAgICAgICAgdGhpcy5fYXB0W3pvb21dLnN1YlBhdGgodGhpcy5fcHJvZ3Jlc3MpLnRyYW5zbGF0ZShsYXN0UG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5fYXR0W3pvb21dLnN1YlNoYXBlKHRoaXMuX2FwdFt6b29tXSkudHJhbnNsYXRlKGxhc3RQb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FuaW1hdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZGlzdGFuY2UgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IGUuZGlzdGFuY2U7ICAgIC8vICBib3VuY2UgYW5pbWF0aW9uIGVmZmVjdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSBlLnByb2dyZXNzOyAgICAvLyAgcGF0aCBhbmltYXRpb24gZWZmZWN0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Zpc2liaWxpdHkuaXNTaG93bikge1xuICAgICAgICAgICAgLy8gIFRPRE86IEFkZGl0aW9uYWwgbG9naWMgZm9yIGFuaW1hdGlvbiBvbiBDYW52YXNcbiAgICAgICAgICAgIC8vIHRoaXMucHJvamVjdGlvbigpLmludm9rZSgncmVkcmF3Jyk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3QoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbigpLmludm9rZSgnX3Byb2plY3QnKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmludm9rZSgnX3VwZGF0ZScpO1xuICAgIH0sXG5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRCb3VuZHMoKTtcblxuICAgICAgICB0aGlzLl9wcm9qZWN0KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfcmVzZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gIENhbnZhcyByZW5kZXJlciBzcGVjaWZpY1xuICAgICAgICB2YXIgejtcblxuICAgICAgICBmb3IgKHogaW4gdGhpcy5fYXB0KSB7XG4gICAgICAgICAgICB0aGlzLl9hcHRbel0uX3B4Qm91bmRzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoeiBpbiB0aGlzLl9hdHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dFt6XS5fcHhCb3VuZHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRCb3VuZHM6IGZ1bmN0aW9uIChwbCwgcHAsIGFwdCwgYXR0KSB7XG4gICAgICAgIHZhciBfYXB0ID0gYXB0LnN1YlBhdGgoMSkudHJhbnNsYXRlKHBsKS52ZXJ0aWNlcyxcbiAgICAgICAgICAgIF9hdHQgPSBhdHQuc3ViU2hhcGUoYXB0KS50cmFuc2xhdGUocGwpLnZlcnRpY2VzO1xuXG4vKlxuICAgICAgICAvLyAgVE9ETzogQWRkaXRpb25hbCBsb2dpYyBmb3IgYW5pbWF0aW9uIG9uIENhbnZhc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBwbCA9IERHLlZlcnRleFRyYW5zZm9ybS5nZXRTY2FsZWQocGwsIHBwLCAxKTtcbiAgICAgICAgICAgIF9hcHQgPSBfYXB0LmNvbmNhdChhcHQuc3ViUGF0aCgxKS50cmFuc2xhdGUocGwpLnZlcnRpY2VzKTtcbiAgICAgICAgICAgIF9hdHQgPSBfYXR0LmNvbmNhdChhdHQuc3ViU2hhcGUoYXB0KS50cmFuc2xhdGUocGwpLnZlcnRpY2VzKTtcbiAgICAgICAgfVxuKi9cbiAgICAgICAgYXB0Ll9weEJvdW5kcyA9IG5ldyBERy5Cb3VuZHMoX2FwdCk7XG4gICAgICAgIGF0dC5fcHhCb3VuZHMgPSBuZXcgREcuQm91bmRzKF9hdHQpO1xuICAgIH1cbn0pO1xuXG5ERy5lbnRyYW5jZS5hcnJvdyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBERy5FbnRyYW5jZS5BcnJvdyhvcHRpb25zKTtcbn07XG4iLCIvKlxuICogUHJlZGVmaW5lZCBhcnJvdyB0aXBzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5ERy5FbnRyYW5jZS5BcnJvdy5TSEFQRSA9IHtcbiAgICB2ZXJ0aWNlczoge1xuICAgICAgICAxNjogW1xuICAgICAgICAgICAgWyAtNi41MDAwLCAgLTEuODAwMF0sXG4gICAgICAgICAgICBbIC02LjA1MjIsICAtMS44MDAwXSxcbiAgICAgICAgICAgIFsgLTcuMDk3NSwgIC01LjI1MzddLFxuICAgICAgICAgICAgWyAtNi42NjE5LCAgLTYuMjU2NV0sIFsgLTYuNTk4MCwgIC02LjM1NTBdLCBbIC02LjE3NTcsICAtNi4xNDcwXSxcbiAgICAgICAgICAgIFsgIDAuODM3MSwgIC0wLjM1NTJdLFxuICAgICAgICAgICAgWyAgMC45Mjc1LCAgLTAuMTc2NF0sIFsgIDAuOTI3NSwgICAwLjE3NjRdLCBbICAwLjgzNzEsICAgMC4zNTUyXSxcbiAgICAgICAgICAgIFsgLTYuMTc1NywgICA2LjE0NzBdLFxuICAgICAgICAgICAgWyAtNi41OTgwLCAgIDYuMzU1MF0sIFsgLTYuNjYxOSwgICA2LjI1NjVdLCBbIC03LjA5NzUsICAgNS4yNTM3XSxcbiAgICAgICAgICAgIFsgLTYuMDUyMiwgICAxLjgwMDBdLFxuICAgICAgICAgICAgWyAtNi41MDAwLCAgIDEuODAwMF1cbiAgICAgICAgXSxcbiAgICAgICAgMTc6IFtcbiAgICAgICAgICAgIFsgLTkuMDAwMCwgIC0yLjQwMDBdLFxuICAgICAgICAgICAgWyAtNy44ODkwLCAgLTIuNDAwMF0sXG4gICAgICAgICAgICBbIC05LjkyNDUsICAtNy4yNTQ4XSxcbiAgICAgICAgICAgIFsgLTkuMzM2MywgIC04LjY0MDRdLCBbIC05LjM0NDgsICAtOC42NDQ4XSwgWyAtOC44NzE3LCAgLTguMzUwOF0sXG4gICAgICAgICAgICBbICAxLjAyODUsICAtMC4zNTUyXSxcbiAgICAgICAgICAgIFsgIDEuMTE5MCwgIC0wLjE3NjRdLCBbICAxLjExOTAsICAgMC4xNzY0XSwgWyAgMS4wMjg1LCAgIDAuMzU1Ml0sXG4gICAgICAgICAgICBbIC04Ljg3MTcsICAgOC4zNTA4XSxcbiAgICAgICAgICAgIFsgLTkuMzQ0OCwgICA4LjY0NDhdLCBbIC05LjMzNjMsICAgOC42NDA0XSwgWyAtOS45MjQ1LCAgIDcuMjU0OF0sXG4gICAgICAgICAgICBbIC03Ljg4OTAsICAgMi40MDAwXSxcbiAgICAgICAgICAgIFsgLTkuMDAwMCwgICAyLjQwMDBdXG4gICAgICAgIF0sXG4gICAgICAgIDE4OiBbXG4gICAgICAgICAgICBbLTExLjUwMDAsICAtMy4wMDAwXSxcbiAgICAgICAgICAgIFstMTAuMDc5NSwgIC0zLjAwMDBdLFxuICAgICAgICAgICAgWy0xMi40OTA5LCAgLTkuMzE3M10sXG4gICAgICAgICAgICBbLTExLjg0MDIsIC0xMC43NjU0XSwgWy0xMS41OTg2LCAtMTAuNzA3M10sIFstMTAuOTM4MCwgLTEwLjIyNThdLFxuICAgICAgICAgICAgWyAgMS4xNDk3LCAgLTAuMzU1Ml0sXG4gICAgICAgICAgICBbICAxLjI0MDIsICAtMC4xNzY0XSwgWyAgMS4yNDAyLCAgIDAuMTc2NF0sIFsgIDEuMTQ5NywgICAwLjM1NTJdLFxuICAgICAgICAgICAgWy0xMC45MzgwLCAgMTAuMjI1OF0sXG4gICAgICAgICAgICBbLTExLjU5ODYsICAxMC43MDczXSwgWy0xMS44NDAyLCAgMTAuNzY1NF0sIFstMTIuNDkwOSwgICA5LjMxNzNdLFxuICAgICAgICAgICAgWy0xMC4wNzk1LCAgIDMuMDAwMF0sXG4gICAgICAgICAgICBbLTExLjUwMDAsICAgMy4wMDAwXVxuICAgICAgICBdLFxuICAgICAgICAxOTogW1xuICAgICAgICAgICAgWy0xMy4wMDAwLCAgLTMuNjAwMF0sXG4gICAgICAgICAgICBbLTExLjY2MDAsICAtMy42MDAwXSxcbiAgICAgICAgICAgIFstMTQuMTY5NiwgLTEwLjgzNTFdLFxuICAgICAgICAgICAgWy0xMy41MTg5LCAtMTIuMjgzMl0sIFstMTMuMjc3MywgLTEyLjIyNTFdLCBbLTEyLjYxNjcsIC0xMS43NDM2XSxcbiAgICAgICAgICAgIFsgIDEuMzA2MSwgIC0wLjM1NTJdLFxuICAgICAgICAgICAgWyAgMS4zOTY2LCAgLTAuMTc2NF0sIFsgIDEuMzk2NiwgICAwLjE3NjRdLCBbICAxLjMwNjEsICAgMC4zNTUyXSxcbiAgICAgICAgICAgIFstMTIuNjE2NywgIDExLjc0MzZdLFxuICAgICAgICAgICAgWy0xMy4yNzczLCAgMTIuMjI1MV0sIFstMTMuNTE4OSwgIDEyLjI4MzJdLCBbLTE0LjE2OTYsICAxMC44MzUxXSxcbiAgICAgICAgICAgIFstMTEuNjYwMCwgICAzLjYwMDBdLFxuICAgICAgICAgICAgWy0xMy4wMDAwLCAgIDMuNjAwMF1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgZHJhd2luZ3M6IHtcbiAgICAgICAgMTY6IFsnTScsICdMJywgJ0wnLCAnQycsICdMJywgJ0MnLCAnTCcsICdDJywgJ0wnLCAnTCddLFxuICAgICAgICAxNzogWydNJywgJ0wnLCAnTCcsICdDJywgJ0wnLCAnQycsICdMJywgJ0MnLCAnTCcsICdMJ10sXG4gICAgICAgIDE4OiBbJ00nLCAnTCcsICdMJywgJ0MnLCAnTCcsICdDJywgJ0wnLCAnQycsICdMJywgJ0wnXSxcbiAgICAgICAgMTk6IFsnTScsICdMJywgJ0wnLCAnQycsICdMJywgJ0MnLCAnTCcsICdDJywgJ0wnLCAnTCddXG4gICAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cblxuKGZ1bmN0aW9uICh2ZXJ0aWNlcykge1xuICAgIGZvciAodmFyIGkgaW4gdmVydGljZXMpIHtcbiAgICAgICAgdmVydGljZXNbaV0gPSB2ZXJ0aWNlc1tpXS5tYXAoZnVuY3Rpb24gKHZlcnRleCkgeyByZXR1cm4gREcucG9pbnQodmVydGV4KTsgfSk7XG4gICAgfVxufSkoREcuRW50cmFuY2UuQXJyb3cuU0hBUEUudmVydGljZXMpO1xuIiwiREcuTGFiZWwgPSBERy5MYXllci5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IG5ldyBERy5Qb2ludCgxMiwgMTUpLFxuICAgICAgICBjbGFzc05hbWU6ICdkZy1sYWJlbCcsXG4gICAgICAgIHpJbmRleE9mZnNldDogMFxuICAgIH0sXG5cbiAgICBfdHlwZU9mU3RyaW5nIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCdzJyksXG4gICAgX2RlZmF1bHRaSW5kZXg6IDEwMCxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9hbmltYXRlZCA9IERHLkJyb3dzZXIuYW55M2Q7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbCkge1xuICAgICAgICAgICAgdGhpcy5faW5pdERPTSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgdGhpc1xuICAgICAgICAgICAgLnNldENvbnRlbnQodGhpcy5fY29udGVudClcbiAgICAgICAgICAgIC5fb25WaWV3UmVzZXQoKTtcblxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5vbigndmlld3Jlc2V0JywgdGhpcy5fb25WaWV3UmVzZXQsIHRoaXMpXG4gICAgICAgICAgICAub24oJ3pvb21hbmltJywgdGhpcy5fb25ab29tQW5pbWF0aW9uLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgbWFwXG4gICAgICAgICAgICAub2ZmKCd2aWV3cmVzZXQnLCB0aGlzLl9vblZpZXdSZXNldCwgdGhpcylcbiAgICAgICAgICAgIC5vZmYoJ3pvb21hbmltJywgdGhpcy5fb25ab29tQW5pbWF0aW9uLCB0aGlzKTtcblxuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgREcuVXRpbC5mYWxzZUZuKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCk7IC8vIHdlIG5lZWQgcmVmbG93IGhlcmVcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICBtYXAuZ2V0UGFuZXMoKS5tYXJrZXJQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2VsKTtcbiAgICAgICAgdGhpcy5fZWwgPSBudWxsO1xuICAgIH0sXG5cbiAgICBfaW5pdERPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9lbCA9IERHLkRvbVV0aWwuY3JlYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl9hbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLmdldFBhbmVzKCkubWFya2VyUGFuZSk7XG4gICAgICAgIHRoaXMuX2VsLnN0eWxlLnpJbmRleCA9IHRoaXMuX2RlZmF1bHRaSW5kZXggKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lICsgJ19fY29udGVudCcsIHRoaXMuX2VsKTtcbiAgICAgICAgREcuRG9tRXZlbnRcbiAgICAgICAgICAgIC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9lbClcbiAgICAgICAgICAgIC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgREcuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgLm9uKHRoaXMuX2NvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgREcuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICB9LFxuXG4gICAgX29uVmlld1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpYmxlICYmIHRoaXMuX2xhdGxuZykge1xuICAgICAgICAgICAgREcuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLmFkZCh0aGlzLm9wdGlvbnMub2Zmc2V0KSwgREcuQnJvd3Nlci5pZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uWm9vbUFuaW1hdGlvbjogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICBpZiAodGhpcy5fbGF0bG5nKSB7XG4gICAgICAgICAgICBERy5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5hZGQodGhpcy5vcHRpb25zLm9mZnNldCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldE9mZnNldDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIGlmIChwb2ludCBpbnN0YW5jZW9mIERHLlBvaW50KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub2Zmc2V0ID0gcG9pbnQ7XG4gICAgICAgICAgICB0aGlzLl9vblZpZXdSZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uICh6SW5kZXgpIHtcbiAgICAgICAgaWYgKCFpc05hTigrekluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCA9ICt6SW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsLnN0eWxlLnpJbmRleCA9IHRoaXMuX2RlZmF1bHRaSW5kZXggKyB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbnRlbnQpICE9PSB0aGlzLl90eXBlT2ZTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgIGlmICghKGxhdGxuZyBpbnN0YW5jZW9mIERHLkxhdExuZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGF0bG5nID0gbGF0bG5nO1xuICAgICAgICB0aGlzLl9vblZpZXdSZXNldCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxuREcubGFiZWwgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuTGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG59O1xuIiwiREcuTWFya2VyLmluY2x1ZGUoe1xuXG4gICAgYmluZExhYmVsOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICE9PSBvcHRpb25zLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRPZmZzZXQodGhpcy5vcHRpb25zLm9mZnNldCA9IG9wdGlvbnMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGF0aWMgIT09IG9wdGlvbnMuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5iaW5kTGFiZWwoKS5iaW5kTGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IERHLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBuZXcgREcuUG9pbnQoNSwgNSlcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IERHLmxhYmVsKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB0aGlzLm9uY2UoJ3JlbW92ZScsIHRoaXMuX29uTWFya2VyUmVtb3ZlKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93TGFiZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIHRoaXMuX21vdXNlT3ZlckxhYmVsKVxuICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgdGhpcy5fbW91c2VPdXRMYWJlbClcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9kcmFnU3RhcnRMYWJlbClcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnZW5kJywgdGhpcy5fZHJhZ0VuZExhYmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9tYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxaSW5kZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdhZGQnLCB0aGlzLl91cGRhdGVMYWJlbFpJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuYmluZExhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgIC5oaWRlTGFiZWwoKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3JlbW92ZScsIHRoaXMudW5iaW5kTGFiZWwpXG4gICAgICAgICAgICAgICAgLm9mZignbW91c2VvdmVyJywgdGhpcy5fbW91c2VPdmVyTGFiZWwpXG4gICAgICAgICAgICAgICAgLm9mZignbW91c2VvdXQnLCB0aGlzLl9tb3VzZU91dExhYmVsKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuX2RyYWdTdGFydExhYmVsKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9kcmFnRW5kTGFiZWwpXG4gICAgICAgICAgICAgICAgLm9mZignbW92ZScsIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2FkZCcsIHRoaXMuX3VwZGF0ZUxhYmVsWkluZGV4KTtcblxuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfb25NYXJrZXJSZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX2xhYmVsLl9jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5vbmNlKCdhZGQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7IHJldHVybjsgfSAvLyBuZXcgbGFiZWwgYWRkZWQgYWZ0ZXIgcmVtb3ZpbmcgbWFya2VyXG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kTGFiZWwoY29udGVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kTGFiZWwoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWwgPyB0aGlzLl9sYWJlbCA6IG51bGw7XG4gICAgfSxcblxuICAgIF9vcmlnaW5hbFVwZGF0ZVpJbmRleDogREcuTWFya2VyLnByb3RvdHlwZS5fdXBkYXRlWkluZGV4LFxuICAgIF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl96SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3pJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3JpZ2luYWxVcGRhdGVaSW5kZXgob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxaSW5kZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91cGRhdGVMYWJlbFpJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwgJiYgdGhpcy5faWNvbikge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0WkluZGV4T2Zmc2V0KHRoaXMuX2ljb24uc3R5bGUuekluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2hvd0xhYmVsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAub24oJ21vdmUnLCB0aGlzLl91cGRhdGVQb3NpdGlvbilcbiAgICAgICAgICAgICAgICAuX21hcC5hZGRMYXllcih0aGlzLl9sYWJlbC5zZXRQb3NpdGlvbih0aGlzLmdldExhdExuZygpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaGlkZUxhYmVsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3ZlJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlUG9zaXRpb24gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsLnNldFBvc2l0aW9uKHRoaXMuZ2V0TGF0TG5nKCkpO1xuICAgIH0sXG5cbiAgICBfZHJhZ1N0YXJ0TGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGFiZWwuaXNNYXJrZXJEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5oaWRlTGFiZWwoKTtcbiAgICB9LFxuXG4gICAgX2RyYWdFbmRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYWJlbC5pc01hcmtlckRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsLmlzTW91c2VPdmVyTWFya2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMYWJlbCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9tb3VzZU92ZXJMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYWJlbC5pc01vdXNlT3Zlck1hcmtlciA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9sYWJlbC5pc01hcmtlckRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMYWJlbCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9tb3VzZU91dExhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsLmlzTW91c2VPdmVyTWFya2VyID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5oaWRlTGFiZWwoKTtcbiAgICB9XG59KTtcblxuREcuTWFya2VyLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kTGFiZWwodGhpcy5vcHRpb25zLmxhYmVsKTtcbiAgICB9XG59KTtcbiIsIkRHLlBhdGguaW5jbHVkZSh7XG4gICAgYmluZExhYmVsOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmICghdGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gREcubGFiZWwoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm9uKHRoaXMuX2xhYmVsRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldENvbnRlbnQoY29udGVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbC5vcHRpb25zLm9mZnNldCAhPT0gb3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRPZmZzZXQob3B0aW9ucy5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1bmJpbmRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuX2xhYmVsRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbCk7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldExhYmVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbCA/IHRoaXMuX2xhYmVsIDogbnVsbDtcbiAgICB9LFxuXG4gICAgX2xhYmVsRXZlbnRzIDoge1xuICAgICAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX2xhYmVsLnNldFBvc2l0aW9uKGV2ZW50LmxhdGxuZykpO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0UG9zaXRpb24oZXZlbnQubGF0bG5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xhYmVsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5QYXRoLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kTGFiZWwodGhpcy5vcHRpb25zLmxhYmVsKTtcbiAgICB9XG59KTtcbiIsIkRHLkVudHJhbmNlLmluY2x1ZGUoe1xuICAgIGJpbmRMYWJlbDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IERHLmxhYmVsKGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5vbih0aGlzLl9sYWJlbEV2ZW50cywgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwub3B0aW9ucy5vZmZzZXQgIT09IG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuc2V0T2Zmc2V0KG9wdGlvbnMub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5iaW5kTGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm9mZih0aGlzLl9sYWJlbEV2ZW50cywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRMYWJlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWwgPyB0aGlzLl9sYWJlbCA6IG51bGw7XG4gICAgfSxcblxuICAgIF9sYWJlbEV2ZW50cyA6IHtcbiAgICAgICAgbW91c2VvdmVyOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9sYWJlbC5zZXRQb3NpdGlvbihldmVudC5sYXRsbmcpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLnNldFBvc2l0aW9uKGV2ZW50LmxhdGxuZyk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5yZW1vdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5FbnRyYW5jZS5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuYmluZExhYmVsKHRoaXMub3B0aW9ucy5sYWJlbCk7XG4gICAgfVxufSk7XG4iLCJERy5jb25maWdUaGVtZSA9IERHLmNvbmZpZ1RoZW1lIHx8IHt9O1xuXG5ERy5jb25maWdUaGVtZS5iYWxsb29uT3B0aW9ucyA9IHtcbiAgICBvZmZzZXQ6IHtcbiAgICAgICAgeDogMSxcbiAgICAgICAgeTogLTQzXG4gICAgfVxufTtcbiIsInJlcXVpcmUoJy4uLy4uLy4uL3ZlbmRvcnMvYmFyb24nKTtcblxuLy8gMkdJUy1yZWxhdGVkIHBvcHVwIGNvbnRlbnQgd3JhcHBlciBhbmQgb2Zmc2V0XG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBvZmZzZXRYID0gREcuY29uZmlnVGhlbWUuYmFsbG9vbk9wdGlvbnMub2Zmc2V0LngsXG4gICAgICAgIG9mZnNldFkgPSBERy5jb25maWdUaGVtZS5iYWxsb29uT3B0aW9ucy5vZmZzZXQueSxcbiAgICAgICAgb3JpZ2luYWxJbml0aWFsaXplID0gREcuUG9wdXAucHJvdG90eXBlLmluaXRpYWxpemUsXG4gICAgICAgIG9yaWdpbmFsSW5pdExheW91dCA9IERHLlBvcHVwLnByb3RvdHlwZS5faW5pdExheW91dCxcbiAgICAgICAgb3JpZ2luYWxPbkFkZCA9IERHLlBvcHVwLnByb3RvdHlwZS5vbkFkZCxcbiAgICAgICAgb3JpZ2luYWxBZGp1c3RQYW4gPSBERy5Qb3B1cC5wcm90b3R5cGUuX2FkanVzdFBhbixcbiAgICAgICAgZ3JhZiA9IGJhcm9uLm5vQ29uZmxpY3QoKTtcblxuICAgIHZhciBCYXJvbkRvbUhlbHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXNbMF0gPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfTtcbiAgICBCYXJvbkRvbUhlbHBlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzWzBdLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0QXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0uZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzWzBdLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjc3M6IGZ1bmN0aW9uIChzdHlsZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXNbMF0uc3R5bGVbc3R5bGVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBERy5Eb21VdGlsLmdldFN0eWxlKHRoaXNbMF0sIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBERy5Qb3B1cC5wcm90b3R5cGUub3B0aW9ucy5vZmZzZXQgPSBERy5wb2ludChvZmZzZXRYLCBvZmZzZXRZKTtcblxuICAgIERHLlBvcHVwLm1lcmdlT3B0aW9ucyh7XG4gICAgICAgIGJvcmRlcjogMTYsXG4gICAgICAgIG1hcENvbnRyb2xzV2lkdGg6IDYwXG4gICAgfSk7XG5cbiAgICBERy5Qb3B1cC5pbmNsdWRlKHtcbiAgICAgICAgX2hlYWRlckNvbnRlbnQ6IG51bGwsXG4gICAgICAgIF9mb290ZXJDb250ZW50OiBudWxsLFxuXG4gICAgICAgIC8vYmFyb24gZWxlbWVudHMgcmVmZXJlbmNlc1xuICAgICAgICBfc2Nyb2xsZXI6IG51bGwsXG4gICAgICAgIF9zY3JvbGxlckJhcjogbnVsbCxcbiAgICAgICAgX2JhcldyYXBwZXI6IG51bGwsXG4gICAgICAgIF9iYXJvbjogbnVsbCxcbiAgICAgICAgX2lzQmFyb25FeGlzdDogZmFsc2UsXG5cbiAgICAgICAgX3BvcHVwU2hvd0NsYXNzOiAnbGVhZmxldC1wb3B1cF9zaG93X3RydWUnLFxuICAgICAgICBfcG9wdXBIaWRlQ2xhc3M6ICdsZWFmbGV0LXBvcHVwX3Nob3dfZmFsc2UnLFxuXG4gICAgICAgIF9wb3B1cFRpcENsYXNzOiAnbGVhZmxldC1wb3B1cC10aXAtY29udGFpbmVyJyxcbiAgICAgICAgX3RpcFNWR1BhdGg6ICdNMCAwYzEyLjY0MyAwIDI4IDcuMTE1IDI4IDQ0aDJjMC0zNi44ODUgMTUuMzU4LTQ0IDI4LTQ0aC01OHonLFxuXG4gICAgICAgIF9pc0F1dG9QYW5QYWRkaW5nVXNlckRlZmluZWQ6IGZhbHNlLFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHsgLy8gKE9iamVjdCwgT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2lzQXV0b1BhblBhZGRpbmdVc2VyRGVmaW5lZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYXV0b1BhblBhZGRpbmcnKTtcbiAgICAgICAgICAgIG9yaWdpbmFsSW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMsIHNvdXJjZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHsgLy8gKE1hcClcbiAgICAgICAgICAgIG1hcC5vbih7XG4gICAgICAgICAgICAgICAgZW50cmFuY2VzaG93OiB0aGlzLl9jbG9zZVBvcHVwLFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogdGhpcy5yZXNpemVcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgb3JpZ2luYWxPbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlT3BlbmluZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7IC8vIChNYXApXG4gICAgICAgICAgICB0aGlzLl9hbmltYXRlQ2xvc2luZygpO1xuICAgICAgICAgICAgbWFwLm9mZih7XG4gICAgICAgICAgICAgICAgZW50cmFuY2VzaG93OiB0aGlzLl9jbG9zZVBvcHVwLFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogdGhpcy5yZXNpemVcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoREcuRG9tVXRpbC5UUkFOU0lUSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKEwuRG9tVXRpbC5yZW1vdmUsIEwuRG9tVXRpbCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkgeyAvLyAoRE9NRWxlbWVudCB8IE9iamVjdCB8IEhUTUwpIC0+IFBvcHVwXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzTm9kZShjb250ZW50KSAmJiB0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaXRlbSArICdDb250ZW50J10gPSBjb250ZW50W2l0ZW1dO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEhlYWRlckNvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7IC8vIChIVE1MKSAtPiBQb3B1cFxuICAgICAgICAgICAgdGhpcy5faGVhZGVyQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRGb290ZXJDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkgeyAvLyAoSFRNTCkgLT4gUG9wdXBcbiAgICAgICAgICAgIHRoaXMuX2Zvb3RlckNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29udGVudDogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBIVE1MXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9keUNvbnRlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SGVhZGVyQ29udGVudDogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBIVE1MXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyQ29udGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRGb290ZXJDb250ZW50OiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IEhUTUxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb290ZXJDb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IFBvcHVwXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9wb3B1cFN0cnVjdHVyZSkuZm9yRWFjaCh0aGlzLl9jbGVhckVsZW1lbnQsIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyB0aGluayBhYm91dCBtb3ZlIHRoaXMgc2V0IHRvIGFub3RoZXIgcHVibGljIG1ldGhvZFxuICAgICAgICAgICAgdGhpcy5faXNCYXJvbkV4aXN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckhlYWRlcjogZnVuY3Rpb24gKCkgeyAvLyAoKSAtPiBQb3B1cFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyRWxlbWVudCgnaGVhZGVyJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJGb290ZXI6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gUG9wdXBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGVhckVsZW1lbnQoJ2Zvb3RlcicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkgeyAvLyAoU3RyaW5nKSAtPiBET01FbGVtZW50XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudE5vZGUucXVlcnlTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYW5pbWF0ZU9wZW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW5uZXJDb250YWluZXIsIHRoaXMuX3BvcHVwU2hvd0NsYXNzKTtcbiAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5faW5uZXJDb250YWluZXIsIHRoaXMuX3BvcHVwSGlkZUNsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYW5pbWF0ZUNsb3Npbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW5uZXJDb250YWluZXIsIHRoaXMuX3BvcHVwSGlkZUNsYXNzKTtcbiAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5faW5uZXJDb250YWluZXIsIHRoaXMuX3BvcHVwU2hvd0NsYXNzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzTm9kZTogZnVuY3Rpb24gKG8pIHsgLy8gKE9iamVjdCkgLT4gQm9vbGVhblxuICAgICAgICAgICAgcmV0dXJuIChvLm5vZGVOYW1lID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoREcuQnJvd3Nlci5tb2JpbGUgJiYgdGhpcy5fbWFwLmdlb2NsaWNrZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgfHwgdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICBXZSBuZWVkIHRvIHNpZ25hbCBnZW9jbGlja2VyIHRoYXQgcG9wdXAgd2FzIG9wZW4gYmVmb3JlICdjbGljaycgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gIEJ1dCBieSB0aW1lIGl0IHdpbGwgZ2V0IGl0J3MgZXZlbnQgdGhlIHBvcHVwIHdpbGwgYmUgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gIFNlZSAnREdHZW9jbGlja2VyJyBmb3IgJ19tYXBFdmVudHNMaXN0ZW5lcnMnIGFuZCAnX3NpbmdsZUNsaWNrJyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLmdlb2NsaWNrZXIucG9wdXBXYXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAuY2xvc2VQb3B1cCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3JpZ2luYWxJbml0TGF5b3V0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1wb3B1cC1pbm5lciAnICsgdGhpcy5fcG9wdXBIaWRlQ2xhc3MsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnRzIG1vdXNlIGV2ZW50cyBmcm9tIGxlYWtpbmcgdGhyb3VnaCBjbG9zZSBidXR0b25cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vMmdpcy9tYXBzYXBpL3B1bGwvMTUzL1xuICAgICAgICAgICAgREcuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5faW5uZXJDb250YWluZXIpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGV0YWNoRWwodGhpcy5fY2xvc2VCdXR0b24pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGV0YWNoRWwodGhpcy5fd3JhcHBlcikpO1xuXG4gICAgICAgICAgICB2YXIgdGlwID0gdGhpcy5fZGV0YWNoRWwodGhpcy5fdGlwQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKERHLkJyb3dzZXIuc3ZnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBERy5TVkcuY3JlYXRlKCdwYXRoJyk7XG4gICAgICAgICAgICAgICAgdmFyIHN2Z0NsYXNzID0gdGhpcy5fcG9wdXBUaXBDbGFzcyArICcgJyArIHRoaXMuX3BvcHVwVGlwQ2xhc3MgKyAnX3N2Zyc7XG5cbiAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMuX3RpcFNWR1BhdGgpO1xuXG4gICAgICAgICAgICAgICAgdGlwID0gREcuU1ZHLmNyZWF0ZSgnc3ZnJyk7XG4gICAgICAgICAgICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBzdmdDbGFzcyk7XG5cbiAgICAgICAgICAgICAgICB0aXAuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgICAgICAgICAgREcuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24ocGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGlwLCB0aGlzLl9wb3B1cFRpcENsYXNzICsgJ19pbWFnZScpO1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRpcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRpcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyRWxlbWVudDogZnVuY3Rpb24gKGVsZW0pIHsgLy8gKERPTUVsZW1lbnQpIC0+IFBvcHVwXG4gICAgICAgICAgICB0aGlzWydfJyArIGVsZW0gKyAnQ29udGVudCddID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RldGFjaEVsKHRoaXMuX3BvcHVwU3RydWN0dXJlW2VsZW1dKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wb3B1cFN0cnVjdHVyZVtlbGVtXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Jhcm9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFyb24udXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsZWQgPSB0aGlzLl91cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmICghc2Nyb2xsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNCYXJvbkV4aXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGVyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9zY3JvbGxlciwgJ2RnLXNjcm9sbGVyJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zY3JvbGxlciwgJ2RnLXNjcm9sbGVyX2hpZGRlbl90cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2Nyb2xsZXIsICdkZy1zY3JvbGxlcicpO1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5vZmYodGhpcy5fc2Nyb2xsZXIsICdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc0Jhcm9uRXhpc3QpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Njcm9sbGVyLCAnZGctc2Nyb2xsZXJfaGlkZGVuX3RydWUnKTtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3Njcm9sbGVyLCAnZGctc2Nyb2xsZXInKTtcblxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9pc0Jhcm9uRXhpc3QgPyB0aGlzLl9zY3JvbGxlci5zY3JvbGxUb3AgOiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsZXIuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbm5lckhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQgLSB0aGlzLm9wdGlvbnMuYm9yZGVyICogMiAtIHRoaXMuX2dldERlbHRhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsZXJXcmFwcGVyLnN0eWxlLmhlaWdodCA9IGlubmVySGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0NvbnRlbnRIZWlnaHRFbm91Z2goKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRCYXJvblNjcm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdEJhcm9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2FkanVzdFBhbigpO1xuICAgICAgICAgICAgdGhpcy5fYmluZEFkanVzdFBhbk9uVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5wcm9wZXJ0eU5hbWUgPT09ICdtYXgtaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KG9yaWdpbmFsQWRqdXN0UGFuLmJpbmQodGhpcyksIDEpOyAvL0pTQVBJLTM0MDkgZml4IHNhZmFyaSBnbGljaFxuICAgICAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5vZmYodGhpcy5fd3JhcHBlciwgREcuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fYWRqdXN0UGFuKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgbGF5ZXJQb3MgPSBuZXcgTC5Qb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuICAgICAgICAgICAgICAgIGxheWVyUG9zLl9hZGQoTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXV0b1BhblBhZGRpbmcgPSBbb3B0aW9ucy5hdXRvUGFuUGFkZGluZ1swXSwgb3B0aW9ucy5hdXRvUGFuUGFkZGluZ1sxXV07XG5cbiAgICAgICAgICAgIC8vIGlmIHdpZHRoIG9mIG1hcCBpcyBtb3JlIHRoZW4gd2lkdGggb2YgcG9wdXAgYW5kIGNvbnRyb2xzXG4gICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBhdXRvUGFuUGFkZGluZyB0byB3aWR0aCBjb250cm9sc1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLl9pc0F1dG9QYW5QYWRkaW5nVXNlckRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIub2Zmc2V0V2lkdGggPj0gb3B0aW9ucy5tYXhXaWR0aCArIG9wdGlvbnMubWFwQ29udHJvbHNXaWR0aCAqIDJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5QYWRkaW5nWzBdID0gb3B0aW9ucy5tYXBDb250cm9sc1dpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gTC5wb2ludChhdXRvUGFuUGFkZGluZyksXG4gICAgICAgICAgICAgICAgcGFkZGluZ1RMID0gTC5wb2ludChvcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nQlIgPSBMLnBvaW50KG9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBzaXplID0gbWFwLmdldFNpemUoKSxcbiAgICAgICAgICAgICAgICBkeCA9IDAsXG4gICAgICAgICAgICAgICAgZHkgPSAwO1xuXG4gICAgICAgICAgICBpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XG4gICAgICAgICAgICAgICAgZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XG4gICAgICAgICAgICAgICAgZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXG4gICAgICAgICAgICAgICAgZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXG4gICAgICAgICAgICAgICAgZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgICAgICAgLmZpcmUoJ2F1dG9wYW5zdGFydCcpXG4gICAgICAgICAgICAgICAgICAgIC5wYW5CeShbZHgsIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2JpbmRBZGp1c3RQYW5PblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChERy5Eb21VdGlsLlRSQU5TSVRJT04pIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudC5vbih0aGlzLl93cmFwcGVyLCBERy5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9hZGp1c3RQYW4sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGp1c3RQYW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaXNDb250ZW50SGVpZ2h0RW5vdWdoOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IEJvb2xlYW5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMubWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb3B1cEhlaWdodCA9IHRoaXMuX3BvcHVwU3RydWN0dXJlLmJvZHkgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwU3RydWN0dXJlLmJvZHkub2Zmc2V0SGVpZ2h0ICsgdGhpcy5fZ2V0RGVsdGEoKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudE5vZGUub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICBwb3B1cEhlaWdodCArPSBvcHRpb25zLmJvcmRlciAqIDI7XG5cbiAgICAgICAgICAgIHJldHVybiBwb3B1cEhlaWdodCA8PSBvcHRpb25zLm1heEhlaWdodDtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEJhcm9uU2Nyb2xsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50Tm9kZSA9IHRoaXMuX3BvcHVwU3RydWN0dXJlLmJvZHkucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxlcldyYXBwZXIgPSB0aGlzLl9zY3JvbGxlcldyYXBwZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLXNjcm9sbGVyX193cmFwcGVyJywgY29udGVudE5vZGUpLFxuICAgICAgICAgICAgICAgIHNjcm9sbGVyID0gdGhpcy5fc2Nyb2xsZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLXNjcm9sbGVyJywgc2Nyb2xsZXJXcmFwcGVyKSxcbiAgICAgICAgICAgICAgICBiYXJXcmFwcGVyID0gdGhpcy5fYmFyV3JhcHBlciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctc2Nyb2xsZXJfX2Jhci13cmFwcGVyJywgc2Nyb2xsZXIpLFxuICAgICAgICAgICAgICAgIGlubmVySGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCAtIHRoaXMub3B0aW9ucy5ib3JkZXIgKiAyO1xuXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxlckJhciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctc2Nyb2xsZXJfX2JhcicsIGJhcldyYXBwZXIpO1xuICAgICAgICAgICAgc2Nyb2xsZXIuYXBwZW5kQ2hpbGQodGhpcy5fZGV0YWNoRWwodGhpcy5fcG9wdXBTdHJ1Y3R1cmUuYm9keSkpO1xuXG4gICAgICAgICAgICBpbm5lckhlaWdodCAtPSB0aGlzLl9nZXREZWx0YSgpO1xuICAgICAgICAgICAgc2Nyb2xsZXJXcmFwcGVyLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDE4LCBpbm5lckhlaWdodCkgKyAncHgnO1xuICAgICAgICAgICAgc2Nyb2xsZXJXcmFwcGVyLnN0eWxlLndpZHRoID0gY29udGVudE5vZGUub2Zmc2V0V2lkdGggKyA1ICsgJ3B4JzsgLy9UT0RPXG5cbiAgICAgICAgICAgIHRoaXMuX2lzQmFyb25FeGlzdCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaEV2ZW50cygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vblNjcm9sbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnc2Nyb2xsJywge29yaWdpbmFsRXZlbnQ6IGV9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX21vdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnY2xpY2snLCB7b3JpZ2luYWxFdmVudDogZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9vblN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5fbW92ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcblxuICAgICAgICAgICAgdGhpcy5fc3RhcnRQb2ludCA9IG5ldyBERy5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlVG91Y2hFdmVudHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVUb3VjaEV2ZW50cyh0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5fb25DbGljayhlKTtcblxuICAgICAgICAgICAgdGhpcy5fbW92aW5nID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxuICAgICAgICAgICAgICAgIG5ld1BvaW50ID0gREcucG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSksXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5hYnMobmV3UG9pbnQuc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCkueSk7XG5cbiAgICAgICAgICAgIGlmICghb2Zmc2V0IHx8IG9mZnNldCA8IDEwKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICB0aGlzLl9tb3ZpbmcgPSB0aGlzLl9tb3ZlZCA9IHRydWU7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEJhcm9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX3Njcm9sbGVyV3JhcHBlcjtcbiAgICAgICAgICAgIHRoaXMuX2Jhcm9uID0gZ3JhZih7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXI6ICcuZGctc2Nyb2xsZXInLFxuICAgICAgICAgICAgICAgIGJhcjogJy5kZy1zY3JvbGxlcl9fYmFyJyxcbiAgICAgICAgICAgICAgICB0cmFjazogJy5kZy1zY3JvbGxlcl9fYmFyLXdyYXBwZXInLFxuICAgICAgICAgICAgICAgICQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHt9LnRvU3RyaW5nLmNhbGwoc2VsZWN0b3IpID09PSAnW29iamVjdCBTdHJpbmddJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogc2VsZWN0b3I7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCYXJvbkRvbUhlbHBlcihub2RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBmdW5jdGlvbiAoZWxlbSwgZXZlbnQsIGZ1bmMsIG1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBERy5Eb21FdmVudFttb2RlIHx8ICdvbiddKGVsZW0sIHR5cGUsIGZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdEhlYWRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUuaGVhZGVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2hlYWRlcicsICdkZy1wb3B1cF9faGVhZGVyJywgdGhpcy5fY29udGVudE5vZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0Rm9vdGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZS5mb290ZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZm9vdGVyJywgJ2RnLXBvcHVwX19mb290ZXInLCB0aGlzLl9jb250ZW50Tm9kZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luaXRCb2R5Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZS53cmFwcGVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1wb3B1cF9fY29udGFpbmVyLXdyYXBwZXInLCB0aGlzLl9jb250ZW50Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFN0cnVjdHVyZS5ib2R5ID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1wb3B1cF9fY29udGFpbmVyJywgdGhpcy5fcG9wdXBTdHJ1Y3R1cmUud3JhcHBlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgaWYgKCFERy5Ccm93c2VyLmllbHQ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaEV2ZW50cyh0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJOb2RlKHRoaXMuX2NvbnRlbnROb2RlKTtcbiAgICAgICAgICAgIHRoaXMuX2lzQmFyb25FeGlzdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBpbml0IHBvcHVwIGNvbnRlbnQgZG9tIHN0cnVjdHVyZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWRlckNvbnRlbnQpIHsgdGhpcy5faW5pdEhlYWRlcigpOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9keUNvbnRlbnQpIHsgdGhpcy5faW5pdEJvZHlDb250YWluZXIoKTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2Zvb3RlckNvbnRlbnQpIHsgdGhpcy5faW5pdEZvb3RlcigpOyB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvcHVwU3RydWN0dXJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgICAgICBERy5Eb21FdmVudC5vbih0aGlzLl93cmFwcGVyLCAnY2xpY2snLCBERy5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fc3dpdGNoRXZlbnRzKCk7XG5cbiAgICAgICAgICAgIGlmIChERy5Ccm93c2VyLmllbHQ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLl9wb3B1cFN0cnVjdHVyZS5mb290ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgKz0gJyBpZTgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFERy5Ccm93c2VyLmllbHQ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0RGVsdGE6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gTnVtYmVyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAwLFxuICAgICAgICAgICAgICAgIHBvcHVwID0gdGhpcy5fcG9wdXBTdHJ1Y3R1cmU7XG5cbiAgICAgICAgICAgIGlmIChwb3B1cC5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSArPSBwb3B1cC5oZWFkZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcHVwLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIGRlbHRhICs9IHBvcHVwLmZvb3Rlci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkZWx0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5fY29udGVudE5vZGUsIC8vIGxlYWZsZXQtcG9wdXAtY29udGVudFxuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyLCAvLyBsZWFmbGV0LXBvcHVwLWNvbnRlbnQtd3JhcHBlclxuICAgICAgICAgICAgICAgIHN0eWxlID0gY29udGVudC5zdHlsZSxcbiAgICAgICAgICAgICAgICB3cmFwcGVyU3R5bGUgPSB3cmFwcGVyLnN0eWxlLFxuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIHNjcm9sbGVkQ2xhc3MgPSAnbGVhZmxldC1wb3B1cC1zY3JvbGxlZCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHN0eWxlLm1hcmdpbiA9IG9wdHMuYm9yZGVyICsgJ3B4JztcblxuICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250ZW50LCBzY3JvbGxlZENsYXNzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ29udGVudEhlaWdodEVub3VnaCgpKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLm1heEhlaWdodCA9IGNvbnRlbnQub2Zmc2V0SGVpZ2h0ICsgb3B0cy5ib3JkZXIgKiAyICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLm1heEhlaWdodCA9IG9wdHMubWF4SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKGNvbnRlbnQsIHNjcm9sbGVkQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG9wdHMuYXV0b1BhblBhZGRpbmdbMF0gKiAyO1xuXG4gICAgICAgICAgICBpZiAob3B0cy5zcHJhd2xpbmcpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IG9wdHMubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWluKHdpZHRoLCB0aGlzLl9tYXAuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCAtIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBvcHRzLm1pbldpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlLndpZHRoID0gJyc7XG5cbiAgICAgICAgICAgICAgICBzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG4gICAgICAgICAgICAgICAgd2lkdGggPSB3cmFwcGVyLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSAnJztcblxuICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMuX21hcC5fY29udGFpbmVyLm9mZnNldFdpZHRoIC0gYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgod2lkdGgsIG9wdHMubWluV2lkdGgpLCBvcHRzLm1heFdpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJXaWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlUG9wdXBTdHJ1Y3R1cmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3BvcHVwU3RydWN0dXJlKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0Q29udGVudCh0aGlzWydfJyArIGl0ZW0gKyAnQ29udGVudCddLCB0aGlzLl9wb3B1cFN0cnVjdHVyZVtpdGVtXSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luc2VydENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50LCBub2RlKSB7IC8vIChTdHJpbmcgfCBET01FbGVtZW50LCBET01FbGVtZW50KVxuICAgICAgICAgICAgaWYgKCFjb250ZW50IHx8ICFub2RlKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICBjb250ZW50ID0gKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSA/IGNvbnRlbnQodGhpcy5fc291cmNlIHx8IHRoaXMpIDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFyTm9kZTogZnVuY3Rpb24gKG5vZGUpIHsgLy8gKERPTUVsZW1lbnQpXG4gICAgICAgICAgICB3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RldGFjaEVsOiBmdW5jdGlvbiAoZWxlbSkgeyAvLyAoRE9NRWxlbWVudCkgLT4gRE9NRWxlbWVudFxuICAgICAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zd2l0Y2hFdmVudHM6IGZ1bmN0aW9uIChvbikgeyAvLyAoQm9vbGVhbilcbiAgICAgICAgICAgIHZhciBzd2l0Y2hlciA9IG9uID8gJ29mZicgOiAnb24nO1xuXG4gICAgICAgICAgICBpZiAoIURHLkJyb3dzZXIudG91Y2gpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudFtzd2l0Y2hlcl0odGhpcy5fY29udGVudE5vZGUsICdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBERy5Eb21FdmVudFtzd2l0Y2hlcl0odGhpcy5fY29udGVudE5vZGUsICd0b3VjaHN0YXJ0IG1vdXNlZG93biBtb3VzZW1vdmUnLCB0aGlzLl9vblN0YXJ0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQmFyb25FeGlzdCkge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50W3N3aXRjaGVyXSh0aGlzLl9zY3JvbGxlciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfdG9nZ2xlVG91Y2hFdmVudHM6IGZ1bmN0aW9uIChvbikge1xuICAgICAgICAgICAgdmFyIHN3aXRjaGVyID0gb24gPyAnb2ZmJyA6ICdvbic7XG5cbiAgICAgICAgICAgIERHLkRvbUV2ZW50XG4gICAgICAgICAgICAgICAgW3N3aXRjaGVyXSh0aGlzLl9jb250ZW50Tm9kZSwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcylcbiAgICAgICAgICAgICAgICBbc3dpdGNoZXJdKHRoaXMuX2NvbnRlbnROb2RlLCAndG91Y2hlbmQnLCB0aGlzLl9vbkVuZCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufSgpKTtcblxuXG5ERy5NYXAuaW5jbHVkZSh7XG4gICAgX21hcmtlckNsYXNzOiAnZGctY3VzdG9taXphdGlvbl9fbWFya2VyX3R5cGVfbXVzaHJvb20nLFxuICAgIF9tYXJrZXJTaG93Q2xhc3M6ICdkZy1jdXN0b21pemF0aW9uX19tYXJrZXJfYXBwZWFyJyxcbiAgICBfbWFya2VySGlkZUNsYXNzOiAnZGctY3VzdG9taXphdGlvbl9fbWFya2VyX2Rpc2FwcGVhcicsXG4gICAgX2RnSGlkZUNsYXNzOiAnZGctcG9wdXBfaGlkZGVuX3RydWUnLFxuICAgIG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHsgLy8gKFBvcHVwKSBvciAoU3RyaW5nIHx8IEhUTUxFbGVtZW50LCBMYXRMbmdbLCBPYmplY3RdKVxuICAgICAgICBpZiAoIShwb3B1cCBpbnN0YW5jZW9mIEwuUG9wdXApKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHBvcHVwO1xuXG4gICAgICAgICAgICBwb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMpLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF0bG5nKSB7XG4gICAgICAgICAgICBwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0xheWVyKHBvcHVwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQb3B1cCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSBwb3B1cDtcblxuICAgICAgICBpZiAocG9wdXAuX3NvdXJjZSAmJiBwb3B1cC5fc291cmNlLl9pY29uKSB7XG4gICAgICAgICAgICBpZiAocG9wdXAuX3NvdXJjZS5faWNvbi5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9tYXJrZXJDbGFzcykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9tYXJrZXJTaG93Q2xhc3MpO1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MocG9wdXAuX3NvdXJjZS5faWNvbiwgdGhpcy5fbWFya2VySGlkZUNsYXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9kZ0hpZGVDbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHVwLl9zb3VyY2UuX3NoYWRvdykge1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHBvcHVwLl9zb3VyY2UuX3NoYWRvdywgdGhpcy5fZGdIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmFkZExheWVyKHBvcHVwKTtcbiAgICB9LFxuXG4gICAgY2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7ICAvLyAoUG9wdXApIC0+IFBvcHVwXG4gICAgICAgIGlmICghcG9wdXAgfHwgcG9wdXAgPT09IHRoaXMuX3BvcHVwKSB7XG4gICAgICAgICAgICBwb3B1cCA9IHRoaXMuX3BvcHVwO1xuICAgICAgICAgICAgdGhpcy5fcG9wdXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3B1cCkge1xuICAgICAgICAgICAgaWYgKHBvcHVwLl9zb3VyY2UgJiYgcG9wdXAuX3NvdXJjZS5faWNvbikge1xuICAgICAgICAgICAgICAgIGlmIChwb3B1cC5fc291cmNlLl9pY29uLmNsYXNzTmFtZS5pbmRleE9mKHRoaXMuX21hcmtlckNsYXNzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9tYXJrZXJIaWRlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHBvcHVwLl9zb3VyY2UuX2ljb24sIHRoaXMuX21hcmtlclNob3dDbGFzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhwb3B1cC5fc291cmNlLl9pY29uLCB0aGlzLl9kZ0hpZGVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3B1cC5fc291cmNlLl9zaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3MocG9wdXAuX3NvdXJjZS5fc2hhZG93LCB0aGlzLl9kZ0hpZGVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxheWVyKHBvcHVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuIiwiREcuRGljdGlvbmFyeSA9IHt9O1xuXG5ERy5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICBpZiAobiAlIDEwID09PSAxICYmIG4gJSAxMDAgIT09IDExKSB7IC8vIDEsIDIxXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTApICUgMSA9PT0gMCkgJiYgKG4gJSAxMDAgPCAxMiB8fCBuICUgMTAwID4gMTQpKSB7IC8vIDIsIDNcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChuICUgMTAgPT09IDApIHx8IChuICUgMTAgPj0gNSAmJiBuICUgMTAgPD0gOSAmJiAobiAlIDEwKSAlIDEgPT09IDApIHx8IChuICUgMTAwID49IDExICYmIChuICUgMTAwKSA8PSAxNCAmJiAobiAlIDEwMCkgJSAxID09PSAwKSkgeyAvLyAxMywgMTdcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuREcuRGljdGlvbmFyeS5lbiA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgaWYgKG4gPT09IDEpIHsgLy8gMVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTsgLy8wLCAyLCAzLCA0IC4uXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5ERy5EaWN0aW9uYXJ5Lml0ID0ge1xuICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICBpZiAobiA9PT0gMSkgeyAvLyAxXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxOyAvLzAsIDIsIDMsIDQgLi5cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkRHLkRpY3Rpb25hcnkuY3MgPSB7XG4gICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgIHJldHVybiAobiA9PT0gMSkgPyAwIDogKG4gPj0gMiAmJiBuIDw9IDQpID8gMSA6IDI7XG4gICAgfVxufTtcblxuREcuRGljdGlvbmFyeS5lcyA9IHtcbiAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgcmV0dXJuIChuID49IDIpID8gMSA6IDA7XG4gICAgfVxufTtcbiIsIkRHLkxvY2FsZSA9IHtcbiAgICB0OiBmdW5jdGlvbiAobXNnLCBhcmd1bWVudCkgeyAvLyAoU3RyaW5nLCBOdW1iZXIpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgbGFuZyA9IHRoaXMuX21hcC5nZXRMYW5nKCksXG4gICAgICAgICAgICBtc2dJc3NldCA9IGZhbHNlLFxuICAgICAgICAgICAgZGljdGlvbmFyeU1zZyxcbiAgICAgICAgICAgIGV4cDtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuRGljdGlvbmFyeVtsYW5nXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxhbmcgPSBERy5jb25maWcuZGVmYXVsdExhbmc7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0TGFuZyhsYW5nKTtcbiAgICAgICAgfVxuICAgICAgICBkaWN0aW9uYXJ5TXNnID0gdGhpcy5jb25zdHJ1Y3Rvci5EaWN0aW9uYXJ5W2xhbmddW21zZ107XG4gICAgICAgIG1zZ0lzc2V0ID0gdHlwZW9mIGRpY3Rpb25hcnlNc2cgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAoIW1zZ0lzc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG1zZ0lzc2V0ID8gZGljdGlvbmFyeU1zZyA6IG1zZztcblxuICAgICAgICBpZiAoYXJndW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUludChhcmd1bWVudCwgMTApO1xuICAgICAgICAgICAgYXJndW1lbnQgPSBpc05hTihhcmd1bWVudCkgPyAwIDogYXJndW1lbnQ7XG4gICAgICAgICAgICBleHAgPSB0aGlzLmNvbnN0cnVjdG9yLkRpY3Rpb25hcnlbbGFuZ10ucGx1cmFsUnVsZXMoYXJndW1lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZGljdGlvbmFyeU1zZ1tleHBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gREcuVXRpbC50ZW1wbGF0ZShyZXN1bHQsIHtuOiBhcmd1bWVudH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0IDogbXNnO1xuICAgIH1cbn07XG5cbkRHLk1hcC5pbmNsdWRlKHtcbiAgICBzZXRMYW5nOiBmdW5jdGlvbiAobGFuZykgeyAvLyAoU3RyaW5nKVxuICAgICAgICBpZiAobGFuZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobGFuZykgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY3VycmVudExhbmcgPSBsYW5nO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdsYW5nY2hhbmdlJywgeydsYW5nJzogbGFuZ30pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldExhbmc6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gU3RyaW5nXG4gICAgICAgIC8vIElmIHRoZSBsYW5ndWFnZSBoYXNuJ3QgYmVlbiBzZXQgYmVmb3JlLCBzZXQgaXQgdG8gcGFnZSBsYW5ndWFnZSBvclxuICAgICAgICAvLyBkZWZhdWx0IGxhbmd1YWdlIGZyb20gY29uZmlnXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmN1cnJlbnRMYW5nKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZhciBsYW5nID0gcm9vdC5sYW5nIHx8IChyb290LmdldEF0dHJpYnV0ZU5TICYmIHJvb3QuZ2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICdsYW5nJykpIHx8IERHLmNvbmZpZy5kZWZhdWx0TGFuZztcblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmN1cnJlbnRMYW5nID0gbGFuZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY3VycmVudExhbmc7XG4gICAgfVxufSk7XG4iLCJERy5Sb3VuZENvbnRyb2wgPSBERy5Db250cm9sLmV4dGVuZCh7XG4gICAgaW5jbHVkZXM6IERHLk1peGluLkV2ZW50cyxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ2RlZmF1bHQnXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIHZhciBjb250cm9sQ2xhc3MgPSB0aGlzLl9jb250cm9sQ0xhc3MgPSAnZGctY29udHJvbC1yb3VuZCcsXG4gICAgICAgICAgICBjb250cm9sSWNvbkNsYXNzID0gdGhpcy5fY29udHJvbEljb25DTGFzcyA9IHRoaXMuX2NvbnRyb2xDTGFzcyArICdfX2ljb24nLFxuICAgICAgICAgICAgY29udGFpbmVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICcnKTtcblxuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgY29udHJvbENsYXNzKTtcblxuICAgICAgICB2YXIgbGluayA9IHRoaXMuX2xpbmsgPSBERy5Eb21VdGlsLmNyZWF0ZShcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgIGNvbnRyb2xJY29uQ2xhc3MgKyAnICcgKyBjb250cm9sSWNvbkNsYXNzICsgJ19uYW1lXycgKyB0aGlzLm9wdGlvbnMuaWNvbkNsYXNzLFxuICAgICAgICAgICAgY29udGFpbmVyXG4gICAgICAgICk7XG5cbiAgICAgICAgbGluay5ocmVmID0gJyMnO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclRyYW5zbGF0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuXG4gICAgICAgIERHLkRvbUV2ZW50XG4gICAgICAgICAgICAub24oY29udGFpbmVyLCAnY2xpY2snLCB0aGlzLl90b2dnbGVDb250cm9sLCB0aGlzKVxuICAgICAgICAgICAgLm9uKGNvbnRhaW5lciwgJ2RibGNsaWNrJywgREcuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgLm9uKGxpbmssICdtb3VzZWRvd24nLCBERy5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xuXG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KCdhZGQnKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZpcmVFdmVudCgncmVtb3ZlJyk7XG4gICAgICAgIERHLkRvbUV2ZW50Lm9mZih0aGlzLl9saW5rLCAnY2xpY2snLCB0aGlzLl90b2dnbGVDb250cm9sKTtcbiAgICB9LFxuXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xpbmsgfHwgIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIERHLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCB0aGlzLl9jb250cm9sQ0xhc3MgKyAnX3N0YXRlXycgKyB0aGlzLl9zdGF0ZSk7XG4gICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2xpbmssIHRoaXMuX2NvbnRyb2xJY29uQ0xhc3MgKyAnX3N0YXRlXycgKyB0aGlzLl9zdGF0ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICAgICAgREcuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsIHRoaXMuX2NvbnRyb2xDTGFzcyArICdfc3RhdGVfJyArIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbGluaywgdGhpcy5fY29udHJvbEljb25DTGFzcyArICdfc3RhdGVfJyArIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlQ29udHJvbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgREcuRG9tRXZlbnQuc3RvcChlKTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoJ2NsaWNrJyk7XG4gICAgfVxufSk7XG5cbkRHLlJvdW5kQ29udHJvbC5pbmNsdWRlKERHLkxvY2FsZSk7XG5cbkRHLnJvdW5kQ29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBERy5Sb3VuZENvbnRyb2wob3B0aW9ucyk7XG59O1xuIiwiREcuY29uZmlnVGhlbWUgPSBERy5jb25maWdUaGVtZSB8fCB7fTtcblxuREcuY29uZmlnVGhlbWUubWFya2Vyc0RhdGEgPSB7XG4gICAgaWNvblNpemU6IFsyMiwgMzRdLFxuICAgIGNsYXNzTmFtZTogJ2RnLWN1c3RvbWl6YXRpb25fX21hcmtlciBkZy1jdXN0b21pemF0aW9uX19tYXJrZXJfdHlwZV9tdXNocm9vbScsXG4gICAgaWNvbkFuY2hvcjogWzEwLCAzMl1cbn07XG4iLCIvLyBGaXggYSBsb3Qgb2YgYnVncyB3aXRoIHBpbmNoLXpvb21pbmdcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vMmdpcy9tYXBzYXBpL2lzc3Vlcy8zMjdcbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIGJvdW5jZUF0Wm9vbUxpbWl0czogZmFsc2Vcbn0pO1xuXG4vL0luamVjdCBvYnNlcnZpbmcgbG9jYWxpemF0aW9uIGNoYW5nZVxudmFyIGNvbnRyb2xBZGRUbyA9IERHLkNvbnRyb2wucHJvdG90eXBlLmFkZFRvO1xuXG5ERy5Db250cm9sLmluY2x1ZGUoe1xuICAgIGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIG1hcC5vbignbGFuZ2NoYW5nZScsIHRoaXMuX3JlbmRlclRyYW5zbGF0aW9uLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY29udHJvbEFkZFRvLmNhbGwodGhpcywgbWFwKTtcbiAgICB9LFxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCkge31cbn0pO1xuXG4vLyBBZGQgc29tZSBicm93c2VyIGRldGVjdGlvblxuREcuQnJvd3Nlci5zYWZhcmk1MSA9IERHLkJyb3dzZXIuc2FmYXJpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVmVyc2lvbi81LjEnKSAhPT0gLTE7XG5cbi8vIEFwcGxpZXMgMkdJUyBkaXZJY29uIHRvIG1hcmtlclxuREcuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb24gPSBERy5kaXZJY29uKERHLmNvbmZpZ1RoZW1lLm1hcmtlcnNEYXRhKTtcblxuLy8gc3VwcG9ydCBvbGQgb3B0aW9uIGNsaWNrYWJsZVxudmFyIHV0aWxTZXRPcHRpb25zID0gREcuVXRpbC5zZXRPcHRpb25zO1xuXG5ERy5zZXRPcHRpb25zID0gTC5zZXRPcHRpb25zID0gREcuVXRpbC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmNsaWNrYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5pbnRlcmFjdGl2ZSA9IG9wdGlvbnMuY2xpY2thYmxlO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlsU2V0T3B0aW9ucy5jYWxsKHRoaXMsIG9iaiwgb3B0aW9ucyk7XG59O1xuXG5ERy5MYXllci5tZXJnZU9wdGlvbnMoe1xuICAgIG5vbkJ1YmJsaW5nRXZlbnRzOiBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdjb250ZXh0bWVudSddXG59KTtcbiIsInZhciBpbml0TWFwID0gREcuTWFwLnByb3RvdHlwZS5pbml0aWFsaXplLFxuICAgIHBhbkJ5ID0gREcuTWFwLnByb3RvdHlwZS5wYW5CeSxcbiAgICBnZXRCb3VuZHNab29tID0gREcuTWFwLnByb3RvdHlwZS5nZXRCb3VuZHNab29tLFxuICAgIHNldE1heFpvb20gPSBERy5NYXAucHJvdG90eXBlLnNldE1heFpvb207XG5cbi8vIFJlc3RyaWN0IHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIDJnaXMgcHJvamVjdHMsIGluIGNhc2UgaWYgZGdUaWxlTGF5ZXIgaXMgb25seSBvbmVcbkRHLk1hcC5pbmNsdWRlKHtcblxuICAgIC8vIG51bWJlciBvZiB0aWxlTGF5ZXJzIHdpdGhvdXQgMmdpcyBsYXllcnNcbiAgICBfdGlsZUxheWVyc051bWJlcjogMCxcblxuICAgIF9tYXBNYXhab29tQ2FjaGU6IG51bGwsXG5cbiAgICAvL1RPRE8gdHJ5IHJlZmFjdG9yIGl0IGFmdGVyIHVwIG9uIG5ldyBsZWFmbGV0ICg+IDAuNylcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IHdoZWVsUHhQZXJab29tTGV2ZWwgdmFsdWUgdG8gYXZvaWQgem9vbWluZyB0b28gZmFzdFxuICAgICAgICAvLyBvbiBtb3VzZSB3aGVlbCByb3RhdGlvblxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tLzJnaXMvbWFwc2FwaS9pc3N1ZXMvMzQzXG4gICAgICAgIG9wdGlvbnMgPSBERy5leHRlbmQoe3doZWVsUHhQZXJab29tTGV2ZWw6IDEwMDAwfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaW5pdE1hcC5jYWxsKHRoaXMsIGlkLCBvcHRpb25zKTtcblxuICAgICAgICAvLyAgUHJvamVjdCBtdXN0IGJlIGNoZWNrZWQgYWZ0ZXIgQmFzZUxheWVyIGluaXQgd2hpY2ggb2NjdXJzIGluIEluaXRIb29rIChzZWUgb3JpZyBtZXRob2QgZGVmaW5pdGlvbilcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jZW50ZXIgJiYgdGhpcy5vcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3KERHLmxhdExuZyh0aGlzLm9wdGlvbnMuY2VudGVyKSwgdGhpcy5vcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcmVzdHJpY3Rab29tKGNlbnRlciwgem9vbSk7XG5cbiAgICAgICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XG4gICAgICAgIGNlbnRlciA9IHRoaXMuX2xpbWl0Q2VudGVyKERHLmxhdExuZyhjZW50ZXIpLCB6b29tLCB0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5hbmltYXRlID0gdGhpcy5fdGVzdEFuaW1hdGlvbihjZW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9sb2FkZWQgJiYgIW9wdGlvbnMucmVzZXQgJiYgb3B0aW9ucyAhPT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnpvb20gPSBERy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy56b29tKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhbiA9IERHLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb25cbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLnBhbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSBhbmltYXRpbmcgcGFuIG9yIHpvb21cbiAgICAgICAgICAgIHZhciBhbmltYXRlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XG4gICAgICAgICAgICB0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5QW5pbWF0ZWRQYW4oY2VudGVyLCBvcHRpb25zLnBhbik7XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XG4gICAgICAgIHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWFwID0gcGFuQnkuY2FsbCh0aGlzLCBvZmZzZXQsIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB6b29tID0gdGhpcy5fcmVzdHJpY3Rab29tKHRoaXMuZ2V0Q2VudGVyKCkpO1xuICAgICAgICBpZiAodGhpcy5nZXRab29tKCkgPiB6b29tKSB7XG4gICAgICAgICAgICB0aGlzLnNldFpvb20oem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHNab29tOiBmdW5jdGlvbiAoYm91bmRzLCBpbnNpZGUsIHBhZGRpbmcpIHtcbiAgICAgICAgYm91bmRzID0gREcubGF0TG5nQm91bmRzKGJvdW5kcyk7XG4gICAgICAgIHRoaXMuX3Jlc3RyaWN0Wm9vbShib3VuZHMpO1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzWm9vbS5jYWxsKHRoaXMsIGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKTtcbiAgICB9LFxuXG4gICAgZ2V0VGlsZUxheWVyc051bWJlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZUxheWVyc051bWJlcjtcbiAgICB9LFxuXG4gICAgc2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcbiAgICAgICAgdGhpcy5fbWFwTWF4Wm9vbUNhY2hlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHNldE1heFpvb20uY2FsbCh0aGlzLCB6b29tKTtcbiAgICB9LFxuXG4gICAgX3Rlc3RBbmltYXRpb246IGZ1bmN0aW9uIChjb29yZHMpIHsvL2lmIHdlIGp1bXAgdG8gb3RoZXIgcHJvamVjdCAtIGRpc2FibGUgYW5pbWF0aW9uXG4gICAgICAgIGlmICh0aGlzLnByb2plY3REZXRlY3Rvci5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0RnJvbSA9IHRoaXMucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0VG8gPSB0aGlzLnByb2plY3REZXRlY3Rvci5pc1Byb2plY3RIZXJlKGNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmIChwcm9qZWN0RnJvbSAmJiBwcm9qZWN0VG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdEZyb20uY29kZSA9PT0gcHJvamVjdFRvLmNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVRpbGVMYXllcnM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghKGUubGF5ZXIgaW5zdGFuY2VvZiBERy5UaWxlTGF5ZXIpIHx8IGUubGF5ZXIuX2lzRGcpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2xheWVyYWRkJykge1xuICAgICAgICAgICAgdGhpcy5fdGlsZUxheWVyc051bWJlcisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGlsZUxheWVyc051bWJlci0tO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXROZXdCb3VuZHM6IGZ1bmN0aW9uIChjb29yZHMsIHpvb20pIHtcbiAgICAgICAgaWYgKGNvb3JkcyBpbnN0YW5jZW9mIERHLkxhdExuZ0JvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMucHJvamVjdChjb29yZHMsIHpvb20pO1xuICAgICAgICB2YXIgc2NyZWVuU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpO1xuXG4gICAgICAgIHZhciBzdyA9IHRoaXMudW5wcm9qZWN0KHBvaW50LnN1YnRyYWN0KHNjcmVlblNpemUpLCB6b29tKTtcbiAgICAgICAgdmFyIG5lID0gdGhpcy51bnByb2plY3QocG9pbnQuYWRkKHNjcmVlblNpemUpLCB6b29tKTtcblxuICAgICAgICByZXR1cm4gREcubGF0TG5nQm91bmRzKHN3LCBuZSk7XG4gICAgfSxcblxuICAgIF9yZXN0cmljdFpvb206IGZ1bmN0aW9uIChjb29yZHMsIHpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuX2xheWVycyAmJlxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0RGV0ZWN0b3IuZW5hYmxlZCgpICYmXG4gICAgICAgICAgICAodGhpcy5fdGlsZUxheWVyc051bWJlciA9PT0gMCkpIHtcblxuICAgICAgICAgICAgdmFyIG1hcE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaXNNYXBNYXhab29tID0gISFtYXBPcHRpb25zLm1heFpvb20sXG4gICAgICAgICAgICAgICAgZGdUaWxlTGF5ZXIgPSB0aGlzLmJhc2VMYXllcixcbiAgICAgICAgICAgICAgICBib3VuZHMgPSB0aGlzLl9nZXROZXdCb3VuZHMoY29vcmRzLCB6b29tKSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0ID0gdGhpcy5wcm9qZWN0RGV0ZWN0b3IuaXNQcm9qZWN0SGVyZShib3VuZHMpO1xuXG4gICAgICAgICAgICBpZiAoaXNNYXBNYXhab29tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXBNYXhab29tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIERHLkJyb3dzZXIucmV0aW5hICYmIG1hcE9wdGlvbnMubWF4Wm9vbSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcE9wdGlvbnMubWF4Wm9vbS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwTWF4Wm9vbUNhY2hlID0gbWFwT3B0aW9ucy5tYXhab29tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBPcHRpb25zLm1heFpvb20gPSAodGhpcy5fbWFwTWF4Wm9vbUNhY2hlICYmIHByb2plY3QpID8gdGhpcy5fbWFwTWF4Wm9vbUNhY2hlIDogIERHLmNvbmZpZy5wcm9qZWN0TGVhdmVNYXhab29tO1xuICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcE1heFpvb21DYWNoZSA9IG1hcE9wdGlvbnMubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwT3B0aW9ucy5tYXhab29tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGdUaWxlTGF5ZXIub3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgREcuQnJvd3Nlci5yZXRpbmEgJiYgcHJvamVjdC5tYXhab29tID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGdUaWxlTGF5ZXIub3B0aW9ucy5tYXhab29tID0gcHJvamVjdC5tYXhab29tIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRnVGlsZUxheWVyLm9wdGlvbnMubWF4Wm9vbSA9IHByb2plY3QubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRnVGlsZUxheWVyLm9wdGlvbnMubWF4Wm9vbSA9IERHLmNvbmZpZy5wcm9qZWN0TGVhdmVNYXhab29tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRnVGlsZUxheWVyLm9wdGlvbnMubWF4TmF0aXZlWm9vbSA9IGRnVGlsZUxheWVyLm9wdGlvbnMubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGdUaWxlTGF5ZXIub3B0aW9ucy5tYXhab29tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vbignbGF5ZXJhZGQgbGF5ZXJyZW1vdmUnLCB0aGlzLl91cGRhdGVUaWxlTGF5ZXJzKTtcbn0pO1xuXG4vLyBTZXQgY3NzIHByb3BlcnR5IHRvdWNoLWFjdGlvbiB0byBhdXRvIGlmIGRyYWdnaW5nIGlzIGZhbHNlLlxuLy8gTmVlZCBmb3Igc2Nyb2xsaW5nIHBhZ2UgaW4gbW9iaWxlIHVzaW5nIG91ciBtYXAgZG9tIGVsZW1lbnQuXG4vLyB0b2RvOiBJIG1hZGUgaXNzdWUgaW4gbGVhZmxldCBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy80NDE1XG5ERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhZ2dpbmcgPT0gZmFsc2UgJiYgdGhpcy5vcHRpb25zLnRhcCA9PSBmYWxzZSkge1xuICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2RnLWRyYWdnaW5nLWZhbHNlJyk7XG4gICAgfVxufSk7XG4iLCJERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnJvclVybCA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVFBQUFBRUFBUU1BQUFCbXZEb2xBQUFBQTFCTVZFWDI4dDVSMGs1VUFBQUFIMGxFUVZSNFh1M0FBUWtBQUFEQ01QdW5Oc2RoV3h3QUFBQUFBQUFBd0FFaEFBQUJnMlVQNUFBQUFBQkpSVTVFcmtKZ2dnPT0nO1xuICAgIHZhciBlcnJvclJ1VXJsID0gREcuY29uZmlnLnByb3RvY29sICsgREcuY29uZmlnLmJhc2VVcmwgKyAnL2ltZy9ub21hcF9ydS5wbmcnO1xuXG4gICAgdmFyIEJhc2VMYXllciA9IERHLlRpbGVMYXllci5leHRlbmQoe1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RnID0gdHJ1ZTtcbiAgICAgICAgICAgIERHLlRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VGlsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWxlcztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHRpbGVVcmwgPSBERy5jb25maWcucHJvdG9jb2wgKyAoREcuQnJvd3Nlci5yZXRpbmEgPyBERy5jb25maWcucmV0aW5hVGlsZVNlcnZlciA6IERHLmNvbmZpZy50aWxlU2VydmVyKTtcblxuICAgIHRoaXMuYmFzZUxheWVyID0gbmV3IEJhc2VMYXllcih0aWxlVXJsLCB7XG4gICAgICAgIHN1YmRvbWFpbnM6ICcwMTIzJyxcbiAgICAgICAgZXJyb3JUaWxlVXJsOiB0aGlzLmdldExhbmcoKSA9PT0gJ3J1JyA/IGVycm9yUnVVcmwgOiBlcnJvclVybCxcbiAgICAgICAgZGV0ZWN0UmV0aW5hOiBERy5jb25maWcuZGV0ZWN0UmV0aW5hLFxuICAgICAgICBtYXhab29tOiAxOSxcbiAgICAgICAgbWF4TmF0aXZlWm9vbTogMTksXG4gICAgICAgIHpJbmRleDogMFxuICAgIH0pLmFkZFRvKHRoaXMpO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlRXJyb3JUaWxlVXJsICgpIHtcbiAgICAgICAgdmFyIGxhbmcgPSB0aGlzLmdldExhbmcoKTtcbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLnByb2plY3REZXRlY3RvciAmJiB0aGlzLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCk7XG5cbiAgICAgICAgaWYgKGxhbmcgPT09ICdydScgJiYgIXByb2plY3QpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsID0gZXJyb3JSdVVybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZUxheWVyLm9wdGlvbnMuZXJyb3JUaWxlVXJsID0gZXJyb3JVcmw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9uKHtcbiAgICAgICAgbGFuZ2NoYW5nZTogdXBkYXRlRXJyb3JUaWxlVXJsLFxuICAgICAgICBwcm9qZWN0Y2hhbmdlOiB1cGRhdGVFcnJvclRpbGVVcmwsXG4gICAgICAgIHByb2plY3RsZWF2ZTogdXBkYXRlRXJyb3JUaWxlVXJsXG4gICAgfSwgdGhpcyk7XG59KTtcbiIsIkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIHRpbGVzQ2hlY2s6IHRydWVcbn0pO1xuXG5ERy5NYXAuVGlsZXNDaGVjayA9IERHLkhhbmRsZXIuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5fbGF5ZXIgPSBtYXAuYmFzZUxheWVyO1xuXG4gICAgICAgIHRoaXMuX21vdmVTdGFydEV2ZW50Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX21vdmVFbmRFdmVudENvdW50ZXIgPSAwO1xuXG4gICAgICAgIHRoaXMuX2xvYWRpbmdFdmVudENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9sb2FkRXZlbnRDb3VudGVyID0gMDtcbiAgICB9LFxuXG4gICAgYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLm9uKHRoaXMuX21hcEV2ZW50cywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2xheWVyLm9uKHRoaXMuX2xheWVyRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwLm9mZih0aGlzLl9tYXBFdmVudHMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9sYXllci5vZmYodGhpcy5fbGF5ZXJFdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfbWFwRXZlbnRzOiB7XG4gICAgICAgIGxheWVyYWRkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUubGF5ZXIgPT0gdGhpcy5fbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxheWVycmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUubGF5ZXIgPT0gdGhpcy5fbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb3Zlc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BXYWl0aW5nKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX21vdmVTdGFydEV2ZW50Q291bnRlcisrO1xuICAgICAgICAgICAgdGhpcy5faXNXYWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlRW5kRXZlbnRDb3VudGVyKys7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNXYWl0aW5nICYmIHRoaXMuX21vdmVTdGFydEV2ZW50Q291bnRlciAhPT0gdGhpcy5fbW92ZUVuZEV2ZW50Q291bnRlcikgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgdGhpcy5faXNNb3ZlRW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fY2hlY2tXYWl0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2xheWVyRXZlbnRzOiB7XG4gICAgICAgIGxvYWRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdFdmVudENvdW50ZXIrKztcbiAgICAgICAgfSxcblxuICAgICAgICBsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkRXZlbnRDb3VudGVyKys7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNXYWl0aW5nICYmIHRoaXMuX2xvYWRpbmdFdmVudENvdW50ZXIgIT09IHRoaXMuX2xvYWRFdmVudENvdW50ZXIpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrV2FpdGluZygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zdG9wV2FpdGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc1dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNNb3ZlRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzTG9hZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfY2hlY2tXYWl0aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1dhaXRpbmcgJiYgdGhpcy5faXNMb2FkICYmIHRoaXMuX2lzTW92ZUVuZCkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFdhaXRpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0Q291bnRlcnMoKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrVGlsZXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2hlY2tUaWxlczogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFwLmdldFRpbGVMYXllcnNOdW1iZXIoKSAhPT0gMCB8fCAhdGhpcy5fbWFwLl9sb2FkZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICB2YXIgZXJyb3JVcmwgPSB0aGlzLl9sYXllci5vcHRpb25zLmVycm9yVGlsZVVybDtcbiAgICAgICAgdmFyIHRpbGVzID0gdGhpcy5fbGF5ZXIuZ2V0VGlsZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRpbGVzKSB7XG4gICAgICAgICAgICBpZiAodGlsZXNbaV0uY29vcmRzLnogPT09IHpvb20gJiYgdGlsZXNbaV0uZWwuc3JjICE9PSBlcnJvclVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcC56b29tT3V0KCk7XG4gICAgfSxcblxuICAgIF9yZXNldENvdW50ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vdmVTdGFydEV2ZW50Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX21vdmVFbmRFdmVudENvdW50ZXIgPSAwO1xuXG4gICAgICAgIHRoaXMuX2xvYWRpbmdFdmVudENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9sb2FkRXZlbnRDb3VudGVyID0gMDtcbiAgICB9XG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RpbGVzQ2hlY2snLCBERy5NYXAuVGlsZXNDaGVjayk7XG4iLCIvKipcbiAqIFRoaXMgY3VzdG9taXphdGlvbiBmaXhlcyB1bndhbnRlZCBpbmVydGlhIG1vdmVtZW50IGFmdGVyIHN1ZGRlbiBkcmFnIHN0b3BzXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzQwNDguXG4gKiBJZiB0aGlzIFBSIGV2ZXIgZ2V0cyBtZXJnZWQsIHRoaXMgZmlsZSBjYW4gYmUgcmVtb3ZlZC5cbiAqL1xudmFyIG9uRHJhZ0VuZCA9IERHLk1hcC5EcmFnLnByb3RvdHlwZS5fb25EcmFnRW5kO1xuXG5ERy5NYXAuRHJhZy5pbmNsdWRlKHtcbiAgICBfcmVtZW1iZXJUaW1lQW5kUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLl9sYXN0VGltZSA9ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG4gICAgICAgIHRoaXMuX3RpbWVzLnB1c2godGltZSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBkYXRhIHBvaW50cyBvbGRlciB0aGFuIDUwIG1zXG4gICAgICAgIHdoaWxlICh0aW1lIC0gdGhpcy5fdGltZXNbMF0gPiA1MCkge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1lbWJlclRpbWVBbmRQb3NpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAuZmlyZSgnbW92ZScsIGUpXG4gICAgICAgICAgICAuZmlyZSgnZHJhZycsIGUpO1xuICAgIH0sXG5cbiAgICBfb25EcmFnRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhICYmICFERy5Ccm93c2VyLnRvdWNoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1lbWJlclRpbWVBbmRQb3NpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgb25EcmFnRW5kLmNhbGwodGhpcyk7XG4gICAgfVxufSk7XG4iLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9UdXJmanMvdHVyZi1pbnNpZGUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbkRHLlBvbHlVdGlsLmluc2lkZSA9IGZ1bmN0aW9uIChwb2ludCwgcG9seWdvbiwgcG9pbnRSZWR1Y2UpIHtcbiAgICBwb2ludFJlZHVjZSA9IHBvaW50UmVkdWNlIHx8IERHLlBvbHlVdGlsLl9kZWZhdWx0UG9pbnRSZWR1Y2U7XG4gICAgdmFyIHBvbHlzID0gcG9seWdvbi5jb29yZGluYXRlcztcbiAgICB2YXIgcHQgPSBwb2ludFJlZHVjZShwb2ludCk7XG5cbiAgICAvLyBub3JtYWxpemUgdG8gbXVsdGlwb2x5Z29uXG4gICAgaWYgKHBvbHlnb24udHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHBvbHlzID0gW3BvbHlzXTtcbiAgICB9XG5cbiAgICB2YXIgaW5zaWRlUG9seSA9IGZhbHNlO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvbHlzLmxlbmd0aCAmJiAhaW5zaWRlUG9seSkge1xuICAgICAgICAvLyBjaGVjayBpZiBpdCBpcyBpbiB0aGUgb3V0ZXIgcmluZyBmaXJzdFxuICAgICAgICBpZiAodGhpcy5faW5SaW5nKHB0LCBwb2x5c1tpXVswXSwgcG9pbnRSZWR1Y2UpKSB7XG4gICAgICAgICAgICB2YXIgaW5Ib2xlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgayA9IDE7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdGhlIHBvaW50IGluIGFueSBvZiB0aGUgaG9sZXNcbiAgICAgICAgICAgIHdoaWxlIChrIDwgcG9seXNbaV0ubGVuZ3RoICYmICFpbkhvbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5SaW5nKHB0LCBwb2x5c1tpXVtrXSwgcG9pbnRSZWR1Y2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluSG9sZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5Ib2xlKSAge1xuICAgICAgICAgICAgICAgIGluc2lkZVBvbHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGluc2lkZVBvbHk7XG59O1xuXG4vLyBwdCBpcyBbeCx5XSBhbmQgcmluZyBpcyBbW3gseV0sIFt4LHldLC4uXVxuREcuUG9seVV0aWwuX2luUmluZyA9IGZ1bmN0aW9uIChwdCwgcmluZywgcG9pbnRSZWR1Y2UpIHtcbiAgICB2YXIgaXNJbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciBwaSA9IHBvaW50UmVkdWNlKHJpbmdbaV0pO1xuICAgICAgICB2YXIgcGogPSBwb2ludFJlZHVjZShyaW5nW2pdKTtcbiAgICAgICAgdmFyIHhpID0gcGlbMF0sIHlpID0gcGlbMV07XG4gICAgICAgIHZhciB4aiA9IHBqWzBdLCB5aiA9IHBqWzFdO1xuICAgICAgICB2YXIgaW50ZXJzZWN0ID0gKCh5aSA+IHB0WzFdKSAhPT0gKHlqID4gcHRbMV0pKSAmJlxuICAgICAgICAgICAgKHB0WzBdIDwgKHhqIC0geGkpICogKHB0WzFdIC0geWkpIC8gKHlqIC0geWkpICsgeGkpO1xuXG4gICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIGlzSW5zaWRlID0gIWlzSW5zaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc0luc2lkZTtcbn07XG5cbkRHLlBvbHlVdGlsLl9kZWZhdWx0UG9pbnRSZWR1Y2UgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuIiwiREcuQ29udHJvbC5ab29tLmluY2x1ZGUoREcuTG9jYWxlKTtcbkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5ID0ge307XG5cbkRHLkNvbnRyb2wuWm9vbS5pbmNsdWRlKHtcbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB2YXIgem9vbU5hbWUgPSAnZGctem9vbScsXG4gICAgICAgICAgICBidXR0b25UZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwiZGctY29udHJvbC1yb3VuZF9faWNvbiAnICsgem9vbU5hbWUgKyAnX19jb250cm9sICcgKyB6b29tTmFtZSArICdfX2J1dHRvbiAnICsgem9vbU5hbWUgKyAnX19idXR0b25fdHlwZV97dHlwZX1cIj48L2Rpdj4nLFxuICAgICAgICAgICAgY29udGFpbmVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lKTtcblxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgdGhpcy5fem9vbUluQnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKERHLlV0aWwudGVtcGxhdGUoYnV0dG9uVGVtcGxhdGUsIHt0eXBlIDogJ2luJ30pLCB0aGlzLnQoJ3pvb21faW4nKSwgJ2RnLWNvbnRyb2wtcm91bmQgJyArIHpvb21OYW1lICsgJ19faW4nLCBjb250YWluZXIsIHRoaXMuX3pvb21JbiwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oREcuVXRpbC50ZW1wbGF0ZShidXR0b25UZW1wbGF0ZSwge3R5cGUgOiAnb3V0J30pLCB0aGlzLnQoJ3pvb21fb3V0JyksICdkZy1jb250cm9sLXJvdW5kICcgKyB6b29tTmFtZSArICdfX291dCcsIGNvbnRhaW5lciwgdGhpcy5fem9vbU91dCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoKTtcbiAgICAgICAgbWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX29yaWdpbmFsQ3JlYXRlQnV0dG9uOiBERy5Db250cm9sLlpvb20ucHJvdG90eXBlLl9jcmVhdGVCdXR0b24sXG5cbiAgICAvLyBzZXQgYWN0aXZlIHN0YXRlIGNvbnRyb2wgb24gbW9iaWxlIGRldmljZXNcbiAgICBfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLl9vcmlnaW5hbENyZWF0ZUJ1dHRvbi5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICB2YXIgaWNvbiA9IGxpbmsuY2hpbGRyZW5bMF07XG4gICAgICAgIHZhciBsaW5rQWN0aXZlQ2xhc3MgPSAnZGctY29udHJvbC1yb3VuZF9zdGF0ZV9hY3RpdmUnO1xuICAgICAgICB2YXIgaWNvbkFjdGl2ZUNsYXNzID0gJ2RnLWNvbnRyb2wtcm91bmRfX2ljb25fc3RhdGVfYWN0aXZlJztcblxuICAgICAgICBERy5Eb21FdmVudFxuICAgICAgICAgICAgLm9uKGxpbmssICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIERHLkRvbVV0aWwuYWRkQ2xhc3MobGluaywgbGlua0FjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKGljb24sIGljb25BY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKGxpbmssICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBERy5Eb21VdGlsLnJlbW92ZUNsYXNzKGxpbmssIGxpbmtBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgREcuRG9tVXRpbC5yZW1vdmVDbGFzcyhpY29uLCBpY29uQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3pvb21JbkJ1dHRvbiB8fCAhdGhpcy5fem9vbU91dEJ1dHRvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fem9vbUluQnV0dG9uLnRpdGxlID0gdGhpcy50KCd6b29tX2luJyk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24udGl0bGUgPSB0aGlzLnQoJ3pvb21fb3V0Jyk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLlpvb20uRGljdGlvbmFyeS5ydSA9IHtcbiAgICB6b29tX2luIDogJ9Cf0YDQuNCx0LvQuNC30LjRgtGMJyxcbiAgICB6b29tX291dCA6ICfQntGC0LTQsNC70LjRgtGMJ1xufTsiLCJERy5Db250cm9sLlpvb20uRGljdGlvbmFyeS5pdCA9IHtcbiAgICB6b29tX2luIDogJ1pvb20gYXZhbnRpJyxcbiAgICB6b29tX291dCA6ICdab29tIGluZGlldHJvJ1xufTsiLCJERy5Db250cm9sLlpvb20uRGljdGlvbmFyeS5jcyA9IHtcbiAgICB6b29tX2luIDogJ1DFmWlibMOtxb5pdCcsXG4gICAgem9vbV9vdXQgOiAnT2Rkw6FsaXQnXG59OyIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIHpvb21faW4gOiAnWm9vbSBpbicsXG4gICAgem9vbV9vdXQgOiAnWm9vbSBvdXQnXG59OyIsIkRHLkNvbnRyb2wuWm9vbS5EaWN0aW9uYXJ5LmVzID0ge1xuICAgIHpvb21faW4gOiAnQWNlcmNhcicsXG4gICAgem9vbV9vdXQgOiAnQWxlamFyJ1xufTtcbiIsInZhciBkdXN0ID0gcmVxdWlyZSgnZHVzdGpzLWxpbmtlZGluJyk7XG5yZXF1aXJlKCdkdXN0anMtaGVscGVycycpO1xuXG5ERy5kdXN0ID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgLy8gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5LCBzbyB0aGlzIHdvcmtzXG4gICAgZHVzdC5yZW5kZXIobmFtZSwgZGF0YSwgZnVuY3Rpb24gKGVyciwgaHRtbCkge1xuICAgICAgICByZXN1bHQgPSBodG1sO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLmluY2x1ZGUoREcuTG9jYWxlKTtcbkRHLkNvbnRyb2wuQXR0cmlidXRpb24uRGljdGlvbmFyeSA9IHt9O1xuREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5pbmNsdWRlKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYm90dG9tcmlnaHQnXG4gICAgfSxcblxuICAgIF9nZXRMaW5rOiBmdW5jdGlvbiAobGlua1R5cGUpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgIHZhciBkaWN0aW9uYXJ5ID0ge1xuICAgICAgICAgICAgcnU6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly9pbmZvLjJnaXMucnUvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2FwaWxpbms6ICdodHRwOi8vYXBpLjJnaXMucnUvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vaGVscC4yZ2lzLnJ1L2xpY2Vuc2luZy1hZ3JlZW1lbnQvJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXQ6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly8yZ2lzLml0Lz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovLzJnaXMuaXQvP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xpY2Vuc2U6ICdodHRwOi8vMmdpcy5pdC8nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjejoge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovL3ByYWhhLjJnaXMuY3ovP3V0bV9zb3VyY2U9Y29weXJpZ2h0JnV0bV9tZWRpdW09bWFwJnV0bV9jYW1wYWlnbj1wYXJ0bmVycycsXG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2FwaWxpbms6ICdodHRwOi8vcHJhaGEuMmdpcy5jei8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbGljZW5zZTogJ2h0dHA6Ly9sYXcuMmdpcy5jei9saWNlbnNpbmctYWdyZWVtZW50LydcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsOiB7XG4gICAgICAgICAgICAgICAgY29weXJpZ2h0X2xvZ286ICdodHRwOi8vc2FudGlhZ28uMmdpcy5jbC8/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfYXBpbGluazogJ2h0dHA6Ly9zYW50aWFnby4yZ2lzLmNsLz91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9saWNlbnNlOiAnaHR0cDovL2xhdy4yZ2lzLmNsL2xpY2Vuc2luZy1hZ3JlZW1lbnQvJ1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3k6IHtcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbG9nbzogJ2h0dHA6Ly9pbmZvLjJnaXMuY29tLmN5L2xlbWVzb3M/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfYXBpbGluazogJ2h0dHA6Ly9pbmZvLjJnaXMuY29tLmN5L2xlbWVzb3M/dXRtX3NvdXJjZT1jb3B5cmlnaHQmdXRtX21lZGl1bT1tYXAmdXRtX2NhbXBhaWduPXBhcnRuZXJzJyxcbiAgICAgICAgICAgICAgICBjb3B5cmlnaHRfbGljZW5zZTogJ2h0dHA6Ly9sYXcuMmdpcy5jb20uY3kvbGljZW5zaW5nLWFncmVlbWVudC8nXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZToge1xuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9sb2dvOiAnaHR0cDovL2luZm8uMmdpcy5hZS9kdWJhaT91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9hcGlsaW5rOiAnaHR0cDovL2luZm8uMmdpcy5hZS9kdWJhaT91dG1fc291cmNlPWNvcHlyaWdodCZ1dG1fbWVkaXVtPW1hcCZ1dG1fY2FtcGFpZ249cGFydG5lcnMnLFxuICAgICAgICAgICAgICAgIGNvcHlyaWdodF9saWNlbnNlOiAnaHR0cDovL2xhdy4yZ2lzLmFlL2xpY2Vuc2luZy1hZ3JlZW1lbnQvJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuXG4gICAgICAgIHZhciBjb3VudHJ5Q29kZSA9ICh0aGlzLl9jb3VudHJ5Q29kZSBpbiBkaWN0aW9uYXJ5KSA/IHRoaXMuX2NvdW50cnlDb2RlIDogJ3J1JztcblxuICAgICAgICByZXR1cm4gZGljdGlvbmFyeVtjb3VudHJ5Q29kZV1bbGlua1R5cGVdO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBpZiAoIW1hcC5fY29weXJpZ2h0KSB7XG4gICAgICAgICAgICBtYXAuX2NvcHlyaWdodCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBtYXAuYXR0cmlidXRpb25Db250cm9sID0gdGhpcztcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdkZy1hdHRyaWJ1dGlvbicpO1xuICAgICAgICBERy5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xuXG4gICAgICAgIGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcbiAgICAgICAgICAgIGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbiAobGFuZywgb3NtLCBjb3VudHJ5Q29kZSkge1xuICAgICAgICBpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAodHlwZW9mIG9zbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX29zbSA9IG9zbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY291bnRyeUNvZGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3VudHJ5Q29kZSA9IGNvdW50cnlDb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2F0dHJpYnV0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW10sXG4gICAgICAgICAgICBjb3B5cmlnaHQgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5fZmlyc3QpIHtcbiAgICAgICAgICAgIGNvcHlyaWdodCA9IHRoaXMuX2dldEF0dHJpYnV0aW9uSFRNTChsYW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XG4gICAgICAgICAgICBwcmVmaXhBbmRBdHRyaWJzLnB1c2godGhpcy5vcHRpb25zLnByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBjb3B5cmlnaHQgKyBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xuICAgIH0sXG4gICAgX2dldERhdGE6IGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnb3NtJzogdGhpcy5fb3NtLFxuICAgICAgICAgICAgJ3dvcmtfb24nOiB0aGlzLnQoJ3dvcmtfb24nKSxcbiAgICAgICAgICAgICdsYW5nJzogbGFuZyB8fCB0aGlzLl9tYXAuZ2V0TGFuZygpLFxuICAgICAgICAgICAgJ2NvcHlyaWdodF9hcGlsaW5rJzogdGhpcy5fZ2V0TGluaygnY29weXJpZ2h0X2FwaWxpbmsnKSxcbiAgICAgICAgICAgICdjb3B5cmlnaHRfbGljZW5zZSc6IHRoaXMuX2dldExpbmsoJ2NvcHlyaWdodF9saWNlbnNlJyksXG4gICAgICAgICAgICAnY29weXJpZ2h0X2xvZ28nOiB0aGlzLl9nZXRMaW5rKCdjb3B5cmlnaHRfbG9nbycpLFxuICAgICAgICAgICAgJ2xpY2Vuc2VfYWdyZWVtZW50JzogdGhpcy50KCdsaWNlbnNlX2FncmVlbWVudCcpLFxuICAgICAgICAgICAgJ0FQSV8yR0lTJzogdGhpcy50KCdBUElfMkdJUycpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBfZ2V0QXR0cmlidXRpb25IVE1MOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICByZXR1cm4gREcuZHVzdCgnREdBdHRyaWJ1dGlvbi9jb3B5cmlnaHQnLCB0aGlzLl9nZXREYXRhKGxhbmcpKTtcbiAgICB9LFxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKGUubGFuZyk7XG4gICAgfVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9jb3B5cmlnaHQpIHtcbiAgICAgICAgREcuY29udHJvbC5hdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xuICAgIH1cbn0pO1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIGxpY2Vuc2VfYWdyZWVtZW50OiAn0JvQuNGG0LXQvdC30LjQvtC90L3QvtC1INGB0L7Qs9C70LDRiNC10L3QuNC1JyxcbiAgICB3b3JrX29uOiAn0KDQsNCx0L7RgtCw0LXRgiDQvdCwJyxcbiAgICBBUElfMkdJUzogJ0FQSSAy0JPQmNChJ1xufTtcbiIsIkRHLkNvbnRyb2wuQXR0cmlidXRpb24uRGljdGlvbmFyeS5pdCA9IHtcblx0bGljZW5zZV9hZ3JlZW1lbnQgOiAnQWNjb3JkbyBkaSBsaWNlbnphJyxcbiAgICB3b3JrX29uOiAnICcsXG5cdEFQSV8yR0lTOiAnMkdJUyBBUEknXG59O1xuIiwiREcuQ29udHJvbC5BdHRyaWJ1dGlvbi5EaWN0aW9uYXJ5LmNzID0ge1xuXHRsaWNlbnNlX2FncmVlbWVudDogJ0xpY2VuxI1uw60gc21sb3V2YScsXG5cdHdvcmtfb246ICdQcmFjdWplIG5hJyxcbiAgICBBUElfMkdJUzogJ0FQSSAyR0lTJ1xufTtcbiIsIkRHLkNvbnRyb2wuQXR0cmlidXRpb24uRGljdGlvbmFyeS5lbiA9IHtcbiAgICBsaWNlbnNlX2FncmVlbWVudDogJ0xpY2Vuc2UgYWdyZWVtZW50JyxcbiAgICB3b3JrX29uOiAnVXNlcycsXG4gICAgQVBJXzJHSVM6ICcyR0lTIEFQSSdcbn07XG4iLCJERy5Db250cm9sLkF0dHJpYnV0aW9uLkRpY3Rpb25hcnkuZXMgPSB7XG5cdGxpY2Vuc2VfYWdyZWVtZW50IDogJ0FjdWVyZG8gZGUgbGljZW5jaWEnLFxuICAgIHdvcmtfb246ICcgJyxcblx0QVBJXzJHSVM6ICcyR0lTIEFQSSdcbn07XG4iLCJERy5Db250cm9sLkxvY2F0aW9uID0gREcuUm91bmRDb250cm9sLmV4dGVuZCh7XG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgaWNvbkNsYXNzOiAnbG9jYXRlJyxcbiAgICAgICAgcG9zaXRpb246IERHLkJyb3dzZXIubW9iaWxlID8gJ2JvdHRvbXJpZ2h0JyA6ICd0b3BsZWZ0JyxcbiAgICAgICAgZHJhd0NpcmNsZTogdHJ1ZSxcbiAgICAgICAgZm9sbG93OiB0cnVlLCAgLy8gZm9sbG93IHdpdGggem9vbSBhbmQgcGFuIHRoZSB1c2VyJ3MgbG9jYXRpb25cbiAgICAgICAgc3RvcEZvbGxvd2luZ09uRHJhZzogZmFsc2UsIC8vIGlmIGZvbGxvdyBpcyB0cnVlLCBzdG9wIGZvbGxvd2luZyB3aGVuIG1hcCBpcyBkcmFnZ2VkXG4gICAgICAgIG1ldHJpYzogdHJ1ZSxcbiAgICAgICAgb25Mb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoLyplcnIqLykge1xuICAgICAgICAgICAgLy8gdGhpcyBldmVudCBpcyBjYWxsZWQgaW4gY2FzZSBvZiBhbnkgbG9jYXRpb24gZXJyb3JcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbm90IGEgdGltZSBvdXQgZXJyb3IuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlcnIubWVzc2FnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTG9jYXRpb25PdXRzaWRlTWFwQm91bmRzOiBmdW5jdGlvbiAoLypjb250ZXh0Ki8pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZXZlbnQgaXMgcmVwZWF0ZWRseSBjYWxsZWQgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlc1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY29udGV4dC50KCdvdXRzaWRlTWFwQm91bmRzTXNnJykpO1xuICAgICAgICB9LFxuICAgICAgICBsb2NhdGVPcHRpb25zOiB7fVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBERy5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXZlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5fbG9jYXRlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHdhdGNoOiB0cnVlLCAgLy8gaWYgeW91IG92ZXJ3cml0ZSB0aGlzLCB2aXN1YWxpemF0aW9uIGNhbm5vdCBiZSB1cGRhdGVkXG4gICAgICAgICAgICBzZXRWaWV3OiB0cnVlLFxuICAgICAgICAgICAgbWF4aW11bUFnZTogSW5maW5pdHksXG4gICAgICAgICAgICBtYXhab29tOiBJbmZpbml0eVxuICAgICAgICB9O1xuICAgICAgICBERy5leHRlbmQodGhpcy5fbG9jYXRlT3B0aW9ucywgdGhpcy5vcHRpb25zLmxvY2F0ZU9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX3Jlc2V0VmFyaWFibGVzKCk7XG5cbiAgICAgICAgdGhpcy5vbih7XG4gICAgICAgICAgICAnY2xpY2snOiB0aGlzLl9oYW5kbGVMb2NhdGUsXG4gICAgICAgICAgICAnYWRkJzogdGhpcy5faW5pdExvY2F0ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2luaXRMb2NhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXIgPSBuZXcgREcuTGF5ZXJHcm91cCgpO1xuICAgICAgICB0aGlzLl9sYXllci5hZGRUbyh0aGlzLl9tYXApO1xuXG4gICAgICAgIC8vIGV2ZW50IGhvb2tzXG4gICAgICAgIHRoaXMuX21hcC5vbih7XG4gICAgICAgICAgICAnbG9jYXRpb25mb3VuZCc6IHRoaXMuX29uTG9jYXRpb25Gb3VuZCxcbiAgICAgICAgICAgICdsb2NhdGlvbmVycm9yJzogdGhpcy5fb25Mb2NhdGlvbkVycm9yXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfaGFuZGxlTG9jYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUgJiYgKCF0aGlzLl9ldmVudCB8fFxuICAgICAgICAgICAgKHRoaXMuX21hcC5nZXRCb3VuZHMoKS5jb250YWlucyh0aGlzLl9ldmVudC5sYXRsbmcpIHx8XG4gICAgICAgICAgICB0aGlzLl9pc091dHNpZGVNYXBCb3VuZHMoKSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wTG9jYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAubG9jYXRlKHRoaXMuX2xvY2F0ZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvbGxvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Rm9sbG93aW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRXJyb3IoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgncmVxdWVzdGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9vbkxvY2F0aW9uRm91bmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gZG8gYW55dGhpbmcgaWYgdGhlIGxvY2F0aW9uIGhhcyBub3QgY2hhbmdlZFxuICAgICAgICBpZiAodGhpcy5fZXZlbnQgJiZcbiAgICAgICAgICAgICh0aGlzLl9ldmVudC5sYXRsbmcubGF0ID09PSBlLmxhdGxuZy5sYXQgJiZcbiAgICAgICAgICAgICB0aGlzLl9ldmVudC5sYXRsbmcubG5nID09PSBlLmxhdGxuZy5sbmcgJiZcbiAgICAgICAgICAgICB0aGlzLl9ldmVudC5hY2N1cmFjeSA9PT0gZS5hY2N1cmFjeSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudCA9IGU7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb2xsb3cgJiYgdGhpcy5fZm9sbG93aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Zpc3VhbGl6ZUxvY2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9zdGFydEZvbGxvd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9mb2xsb3dpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0b3BGb2xsb3dpbmdPbkRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vbignZHJhZ3N0YXJ0JywgdGhpcy5fc3RvcEZvbGxvd2luZyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3N0b3BGb2xsb3dpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9sbG93aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RvcEZvbGxvd2luZ09uRHJhZykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fc3RvcEZvbGxvd2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzdWFsaXplTG9jYXRpb24oKTtcbiAgICB9LFxuXG4gICAgX2lzT3V0c2lkZU1hcEJvdW5kczogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiZcbiAgICAgICAgICAgICF0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMuY29udGFpbnModGhpcy5fZXZlbnQubGF0bG5nKTtcbiAgICB9LFxuXG4gICAgX3Zpc3VhbGl6ZUxvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudC5hY2N1cmFjeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudC5hY2N1cmFjeSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5fZXZlbnQuYWNjdXJhY3k7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvY2F0ZU9uTmV4dExvY2F0aW9uRm91bmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc091dHNpZGVNYXBCb3VuZHMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkxvY2F0aW9uT3V0c2lkZU1hcEJvdW5kcyh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3KSB7XG4gICAgICAgICAgICAgICAgdmFyIHpvb20gPSB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS5tYXhab29tIHx8IERHLmNvbmZpZy5wcm9qZWN0TGVhdmVNYXhab29tO1xuICAgICAgICAgICAgICAgIHpvb20gPSBNYXRoLm1pbih0aGlzLl9sb2NhdGVPcHRpb25zLm1heFpvb20sIHpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5zZXRWaWV3KHRoaXMuX2V2ZW50LmxhdGxuZywgem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGVPbk5leHRMb2NhdGlvbkZvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaXJjbGUgd2l0aCB0aGUgcmFkaXVzIG9mIHRoZSBsb2NhdGlvbidzIGFjY3VyYWN5XG4gICAgICAgIHZhciBzdHlsZSA9IHtcbiAgICAgICAgICAgIGNsaWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb2xvcjogJyNGRkYnLFxuICAgICAgICAgICAgZmlsbENvbG9yOiAnI0ZGRicsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC40LFxuICAgICAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4zXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhd0NpcmNsZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaXJjbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUgPSBERy5jaXJjbGUodGhpcy5fZXZlbnQubGF0bG5nLCByYWRpdXMsIHN0eWxlKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVG8odGhpcy5fbGF5ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUuc2V0TGF0TG5nKHRoaXMuX2V2ZW50LmxhdGxuZykuc2V0UmFkaXVzKHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFya2VyQ2xhc3MgPSAnZGctbG9jYXRpb25fX3Bpbic7XG5cbiAgICAgICAgbWFya2VyQ2xhc3MgKz0gdGhpcy5fZm9sbG93aW5nID8gKCcgJyArIG1hcmtlckNsYXNzICsgJ3N0YXRlX2ZvbGxvd2luZycpIDogJyc7XG4gICAgICAgIC8vIHNtYWxsIGlubmVyIG1hcmtlclxuICAgICAgICB2YXIgbSA9IHtcbiAgICAgICAgICAgIGljb246IERHLmRpdkljb24oe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogbWFya2VyQ2xhc3MsXG4gICAgICAgICAgICAgICAgaWNvblNpemU6IFsyMCwgMjBdXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghdGhpcy5fbWFya2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXIgPSBERy5tYXJrZXIodGhpcy5fZXZlbnQubGF0bG5nLCBtKVxuICAgICAgICAgICAgICAgIC5iaW5kTGFiZWwodGhpcy50KCd5b3VfYXJlX2hlcmUnKSlcbiAgICAgICAgICAgICAgICAuYWRkVG8odGhpcy5fbGF5ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyLnNldExhdExuZyh0aGlzLl9ldmVudC5sYXRsbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgREcuRG9tRXZlbnQub24odGhpcy5fbWFya2VyLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZUV2ZW50KCdkZ0xvY2F0ZUNsaWNrJyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKCdhY3RpdmUnKTtcbiAgICB9LFxuXG4gICAgX3Jlc2V0VmFyaWFibGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mb2xsb3dpbmcgPSBmYWxzZTtcbiAgICB9LFxuXG5cbiAgICBfc3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYXAuc3RvcExvY2F0ZSgpO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLl9zdG9wRm9sbG93aW5nKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0VmFyaWFibGVzKCk7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgdGhpcy5fbWFya2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jaXJjbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBfb25Mb2NhdGlvbkVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZSB0aW1lIG91dCBlcnJvciBpZiB0aGUgbG9jYXRpb24gaXMgd2F0Y2hlZFxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDMgJiYgdGhpcy5fbG9jYXRlT3B0aW9ucy53YXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcExvY2F0ZSgpO1xuICAgICAgICB0aGlzLl9lcnJvciA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctbGFiZWwgZGctbGFiZWxfbmFtZV9sb2NhdGlvbi1lcnJvcicsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2Vycm9yVGV4dCA9IERHLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnZGctbGFiZWxfX2NvbnRlbnQnLCB0aGlzLl9lcnJvcik7XG4gICAgICAgIHRoaXMuX2Vycm9yVGV4dC5pbm5lckhUTUwgPSB0aGlzLnQoJ2NhbnRfZmluZCcpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLl9jbGVhckVycm9yKCk7XG4gICAgICAgIH0sIDMwMDApO1xuXG4gICAgICAgIC8vc2hvdyBsb2NhdGlvbiBlcnJvclxuICAgICAgICB0aGlzLm9wdGlvbnMub25Mb2NhdGlvbkVycm9yKGVycik7XG4gICAgfSxcblxuICAgIF9jbGVhckVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2Vycm9yKTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JUZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluaykge1xuICAgICAgICAgICAgdGhpcy5fbGluay50aXRsZSA9IHRoaXMudCgnYnV0dG9uX3RpdGxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21hcmtlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyLmJpbmRMYWJlbCh0aGlzLnQoJ3lvdV9hcmVfaGVyZScpKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5jb250cm9sLmxvY2F0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkNvbnRyb2wuTG9jYXRpb24ob3B0aW9ucyk7XG59O1xuXG5ERy5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25Db250cm9sKSB7XG4gICAgICAgIHRoaXMubG9jYXRpb25Db250cm9sID0gREcuY29udHJvbC5sb2NhdGlvbih0aGlzLm9wdGlvbnMubG9jYXRpb25Db250cm9sKTtcbiAgICAgICAgdGhpcy5hZGRDb250cm9sKHRoaXMubG9jYXRpb25Db250cm9sKTtcbiAgICB9XG59KTtcbiIsIkRHLkNvbnRyb2wuTG9jYXRpb24uRGljdGlvbmFyeS5ydSA9IHtcblx0IGNhbnRfZmluZCA6ICfQnNGLINC90LUg0YHQvNC+0LPQu9C4INCS0LDRgSDQvdCw0LnRgtC4Jyxcblx0IHlvdV9hcmVfaGVyZSA6ICfQktGLINC30LTQtdGB0YwnLFxuXHQgYnV0dG9uX3RpdGxlIDogJ9Cd0LDQudGC0Lgg0JLQsNGBINC90LAg0LrQsNGA0YLQtSdcbn07IiwiREcuQ29udHJvbC5Mb2NhdGlvbi5EaWN0aW9uYXJ5Lml0ID0ge1xuXHQgY2FudF9maW5kIDogJ05vbiBzaWFtbyByaXVzY2l0aSBhIGxvY2FsaXp6YXJ0aScsXG5cdCB5b3VfYXJlX2hlcmUgOiAnVm9pIHNpZXRlIHF1aScsXG5cdCBidXR0b25fdGl0bGUgOiAnVHJvdmEgbGEgdHVhIHBvc2l6aW9uZSBzdWxsYSBtYXBwYSdcbn07IiwiREcuQ29udHJvbC5Mb2NhdGlvbi5EaWN0aW9uYXJ5LmNzID0ge1xuXHQgY2FudF9maW5kIDogJ05lcG9kYcWZaWxvIHNlIG7DoW0gdXLEjWl0IFZhxaFpIHBvbG9odScsXG5cdCB5b3VfYXJlX2hlcmUgOiAnSnN0ZSB0YWR5Jyxcblx0IGJ1dHRvbl90aXRsZSA6ICdVcsSNaXQgVmHFoWkgcG9sb2h1IG5hIG1hcMSbJ1xufTsiLCJERy5Db250cm9sLkxvY2F0aW9uLkRpY3Rpb25hcnkuZW4gPSB7XG5cdCBjYW50X2ZpbmQgOiAnV2UgY2FuXFwndCBmaW5kIHlvdScsXG5cdCB5b3VfYXJlX2hlcmUgOiAnWW91IGFyZSBoZXJlJyxcblx0IGJ1dHRvbl90aXRsZSA6ICdTaG93IHlvdXIgbG9jYXRpb24nXG59OyIsIkRHLkNvbnRyb2wuTG9jYXRpb24uRGljdGlvbmFyeS5lcyA9IHtcblx0IGNhbnRfZmluZCA6ICdObyBwdWRpbW9zIGVuY29udHJhcnRlJyxcblx0IHlvdV9hcmVfaGVyZSA6ICdUw7ogZXN0w6FzIGFxdcOtJyxcblx0IGJ1dHRvbl90aXRsZSA6ICdFbmNvbnRyYXJ0ZSBlbiBlbCBtYXBhJ1xufTsiLCIvLyBJbnNwaXJlZCBieSBTaW5kcmUgU29yaHVzIHNjcmVlbmZ1bGxcbi8qZ2xvYmFsIEVsZW1lbnQgKi9cbkRHLlNjcmVlbmZ1bGwgPSBERy5DbGFzcy5leHRlbmQoe1xuICAgIF9hcGlNYXA6IFtcbiAgICAgICAgW1xuICAgICAgICAgICAgJ3JlcXVlc3RGdWxsc2NyZWVuJyxcbiAgICAgICAgICAgICdleGl0RnVsbHNjcmVlbicsXG4gICAgICAgICAgICAnZnVsbHNjcmVlbkVsZW1lbnQnLFxuICAgICAgICAgICAgJ2Z1bGxzY3JlZW5FbmFibGVkJyxcbiAgICAgICAgICAgICdmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAgICAgICAgICdmdWxsc2NyZWVuZXJyb3InXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsXG4gICAgICAgICAgICAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLFxuICAgICAgICAgICAgJ3dlYmtpdEZ1bGxzY3JlZW5FbGVtZW50JyxcbiAgICAgICAgICAgICd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsXG4gICAgICAgICAgICAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsXG4gICAgICAgICAgICAnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ1xuXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXG4gICAgICAgICAgICAnbW96Q2FuY2VsRnVsbFNjcmVlbicsXG4gICAgICAgICAgICAnbW96RnVsbFNjcmVlbkVsZW1lbnQnLFxuICAgICAgICAgICAgJ21vekZ1bGxTY3JlZW5FbmFibGVkJyxcbiAgICAgICAgICAgICdtb3pmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAgICAgICAgICdtb3pmdWxsc2NyZWVuZXJyb3InXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICdtc1JlcXVlc3RGdWxsc2NyZWVuJyxcbiAgICAgICAgICAgICdtc0V4aXRGdWxsc2NyZWVuJyxcbiAgICAgICAgICAgICdtc0Z1bGxzY3JlZW5FbGVtZW50JyxcbiAgICAgICAgICAgICdtc0Z1bGxzY3JlZW5FbmFibGVkJyxcbiAgICAgICAgICAgICdNU0Z1bGxzY3JlZW5DaGFuZ2UnLFxuICAgICAgICAgICAgJ01TRnVsbHNjcmVlbkVycm9yJ1xuICAgICAgICBdXG4gICAgXSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hcGkgPSB0aGlzLl9hcGkoKTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLmFwaS5yZXF1ZXN0RnVsbHNjcmVlbjtcblxuICAgICAgICBlbGVtID0gZWxlbSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGVsZW1bcmVxdWVzdF0oRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCk7XG4gICAgfSxcblxuICAgIGV4aXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnRbdGhpcy5hcGkuZXhpdEZ1bGxzY3JlZW5dKCk7XG4gICAgfSxcblxuICAgIGlzRnVsbHNjcmVlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISFkb2N1bWVudFt0aGlzLmFwaS5mdWxsc2NyZWVuRWxlbWVudF07XG4gICAgfSxcblxuICAgIGlzQXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuYXBpKTtcbiAgICB9LFxuXG4gICAgX2FwaTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXBpID0ge30sXG4gICAgICAgICAgICBhcGlNYXAgPSB0aGlzLl9hcGlNYXA7XG5cbiAgICAgICAgYXBpTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWxbMV0gaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaVthcGlNYXBbMF1baV1dID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYXBpLnJlcXVlc3RGdWxsc2NyZWVuID8gYXBpIDogZmFsc2U7XG4gICAgfVxufSk7XG5cbkRHLnNjcmVlbmZ1bGwgPSBuZXcgREcuU2NyZWVuZnVsbCgpO1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuID0gREcuUm91bmRDb250cm9sLmV4dGVuZCh7XG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ2Z1bGxzY3JlZW4nXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIERHLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faXNGdWxsc2NyZWVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMub24oJ2NsaWNrJywgdGhpcy5fdG9nZ2xlRnVsbHNjcmVlbik7XG4gICAgfSxcblxuICAgIF90b2dnbGVGdWxsc2NyZWVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUodHJ1ZSwgJ3JlcXVlc3QnLCAnb24nLCAncmVxdWVzdGZ1bGxzY3JlZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShmYWxzZSwgJ2V4aXQnLCAnb24nLCAnY2FuY2VsZnVsbHNjcmVlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyVHJhbnNsYXRpb24oKTtcbiAgICAgICAgdGhpcy5fbWFwLmludmFsaWRhdGVTaXplKCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9saW5rLnRpdGxlID0gdGhpcy50KHRoaXMuX2lzRnVsbHNjcmVlbiA/ICd0aXRsZV9taW4nIDogJ3RpdGxlX21heCcpO1xuICAgIH0sXG5cbiAgICBfdG9nZ2xlOiBmdW5jdGlvbiAoaXNFbmFibGVkLCBtZXRob2QsIGxpc3QsIGV2ZW50KSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9tYXAuX2NvbnRhaW5lcjtcblxuICAgICAgICB0aGlzLl9pc0Z1bGxzY3JlZW4gPSBpc0VuYWJsZWQ7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoaXNFbmFibGVkID8gJ2FjdGl2ZScgOiAnJyk7XG5cbiAgICAgICAgREcuc2NyZWVuZnVsbFttZXRob2RdKGNvbnRhaW5lcik7XG4gICAgICAgIERHLkRvbUV2ZW50W2xpc3RdKGRvY3VtZW50LCBERy5zY3JlZW5mdWxsLmFwaS5mdWxsc2NyZWVuY2hhbmdlLCB0aGlzLl9vbkZ1bGxTY3JlZW5TdGF0ZUNoYW5nZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hcC5maXJlKGV2ZW50KTtcbiAgICB9LFxuXG4gICAgX29uRnVsbFNjcmVlblN0YXRlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghREcuc2NyZWVuZnVsbC5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKGZhbHNlLCAnZXhpdCcsICdvbicsICdjYW5jZWxmdWxsc2NyZWVuJyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuREcuY29udHJvbC5mdWxsc2NyZWVuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkNvbnRyb2wuRnVsbHNjcmVlbihvcHRpb25zKTtcbn07XG5cbkRHLk1hcC5tZXJnZU9wdGlvbnMoe1xuICAgIGZ1bGxzY3JlZW5Db250cm9sOiB0cnVlXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZ1bGxzY3JlZW5Db250cm9sKSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbkNvbnRyb2wgPSBERy5jb250cm9sLmZ1bGxzY3JlZW4odGhpcy5vcHRpb25zLmZ1bGxzY3JlZW5Db250cm9sKTtcblxuICAgICAgICBpZiAoREcuc2NyZWVuZnVsbC5pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZENvbnRyb2wodGhpcy5mdWxsc2NyZWVuQ29udHJvbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIkRHLkNvbnRyb2wuRnVsbHNjcmVlbi5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIHRpdGxlX21heCA6ICfQoNCw0LfQstC10YDQvdGD0YLRjCcsXG4gICAgdGl0bGVfbWluIDogJ9CS0L7RgdGB0YLQsNC90L7QstC40YLRjCdcbn07XG4iLCJERy5Db250cm9sLkZ1bGxzY3JlZW4uRGljdGlvbmFyeS5pdCA9IHtcbiAgICB0aXRsZV9tYXggOiAnRXNwYW5kaScsXG4gICAgdGl0bGVfbWluIDogJ1JpcHJpc3RpbmEnXG59O1xuIiwiREcuQ29udHJvbC5GdWxsc2NyZWVuLkRpY3Rpb25hcnkuY3MgPSB7XG4gICAgIHRpdGxlX21heCA6ICdSb3piYWxpdCcsXG4gICAgIHRpdGxlX21pbiA6ICdPYm5vdml0J1xufTtcbiIsIkRHLkNvbnRyb2wuRnVsbHNjcmVlbi5EaWN0aW9uYXJ5LmVuID0ge1xuICAgIHRpdGxlX21heCA6ICdFeHBhbmQnLFxuICAgIHRpdGxlX21pbiA6ICdSZXN0b3JlJ1xufTtcbiIsIkRHLkNvbnRyb2wuRnVsbHNjcmVlbi5EaWN0aW9uYXJ5LmVzID0ge1xuICAgIHRpdGxlX21heCA6ICdNYXhpbWl6YXInLFxuICAgIHRpdGxlX21pbiA6ICdSZXN0YXVyYXInXG59O1xuIiwiREcuTWV0YSA9IHt9O1xuXG5ERy5NZXRhLkxheWVyID0gREcuTGF5ZXIuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdGlsZVNpemU6IDI1NixcblxuICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICBtYXhab29tOiAxOSxcbiAgICAgICAgem9vbU9mZnNldDogMCxcbiAgICAgICAgZXZlbnRCdWJibGluZzogJ3RyYW5zcGFyZW50J1xuICAgICAgICAvLyBtYXhOYXRpdmVab29tOiA8TnVtYmVyPixcbiAgICAgICAgLy8gZGV0ZWN0UmV0aW5hOiA8TnVtYmVyPixcbiAgICAgICAgLy8gem9vbVJldmVyc2U6IDxOdW1iZXI+XG4gICAgICAgIC8vIGF0dHJpYnV0aW9uOiA8U3RyaW5nPixcbiAgICAgICAgLy8gekluZGV4OiA8TnVtYmVyPixcbiAgICAgICAgLy8gYm91bmRzOiA8TGF0TG5nQm91bmRzPlxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIE9iamVjdClcbiAgICAgICAgREcuVGlsZUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91cmw7XG5cbiAgICAgICAgdGhpcy5fY3VycmVudFRpbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbGVEYXRhID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fb3JpZ2luID0gREcuTWV0YS5vcmlnaW4oc291cmNlLCB7XG4gICAgICAgICAgICBkYXRhRmlsdGVyOiB0aGlzLm9wdGlvbnMuZGF0YUZpbHRlclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0T3JpZ2luOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IE9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB0aGlzLl9yZXNldFZpZXcoKTtcbiAgICAgICAgdGhpcy5fYWRkRG9tRXZlbnRzKCk7XG5cbiAgICAgICAgbWFwLm9uKCdydWxlcnN0YXJ0JywgdGhpcy5fcmVtb3ZlRG9tRXZlbnRzLCB0aGlzKTtcbiAgICAgICAgbWFwLm9uKCdydWxlcmVuZCcsIHRoaXMuX2FkZERvbUV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZURvbUV2ZW50cygpO1xuICAgICAgICB0aGlzLl90aWxlWm9vbSA9IG51bGw7XG5cbiAgICAgICAgbWFwLm9mZigncnVsZXJzdGFydCcsIHRoaXMuX3JlbW92ZURvbUV2ZW50cywgdGhpcyk7XG4gICAgICAgIG1hcC5vZmYoJ3J1bGVyZW5kJywgdGhpcy5fYWRkRG9tRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG4gICAgICAgICAgICB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0VmlldyxcbiAgICAgICAgICAgIHpvb206IHRoaXMuX3Jlc2V0VmlldyxcbiAgICAgICAgICAgIG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfYWRkRG9tRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIERHLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5nZXRQYW5lKCd0aWxlUGFuZScpLCB0aGlzLl9kb21FdmVudHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlRG9tRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIERHLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuZ2V0UGFuZSgndGlsZVBhbmUnKSwgdGhpcy5fZG9tRXZlbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUFsbFRpbGVzOiBERy5HcmlkTGF5ZXIucHJvdG90eXBlLl9yZW1vdmVBbGxUaWxlcyxcbiAgICBfZ2V0Wm9vbUZvclVybDogREcuVGlsZUxheWVyLnByb3RvdHlwZS5fZ2V0Wm9vbUZvclVybCxcbiAgICBnZXRUaWxlU2l6ZTogREcuVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlU2l6ZSxcbiAgICBfaXNWYWxpZFRpbGU6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX2lzVmFsaWRUaWxlLFxuICAgIF93cmFwQ29vcmRzOiBERy5HcmlkTGF5ZXIucHJvdG90eXBlLl93cmFwQ29vcmRzLFxuICAgIF9yZXNldFZpZXc6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX3Jlc2V0VmlldyxcbiAgICBfcmVzZXRHcmlkOiBERy5HcmlkTGF5ZXIucHJvdG90eXBlLl9yZXNldEdyaWQsXG4gICAgX2ludmFsaWRhdGVBbGw6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX2ludmFsaWRhdGVBbGwsXG4gICAgX3B4Qm91bmRzVG9UaWxlUmFuZ2U6IERHLkdyaWRMYXllci5wcm90b3R5cGUuX3B4Qm91bmRzVG9UaWxlUmFuZ2UsXG5cbiAgICAvLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvY29tcGFyZS8wNzI2ZjEyYmJmMzNmY2IxOGZlOGJiNTQxZDVlMzIxMmJiMWY1YWIyLi4uYzI2M2YyZDhiMWJkOTYyYjYwNDc0Mzc2Y2M0ODE2YTY4ODA1MjUxMyNkaWZmLWYxZTZiZTY3NTk5YzU5NDczMWZmZjYxOTFjNzEwNDIwTDU3OVxuICAgIF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHRoaXMuX3Jlc2V0VmlldygpO1xuICAgIH0sXG5cbiAgICBfZG9tRXZlbnRzOiB7XG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICAgICAgdmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuICAgICAgICAgICAgICAgIGxheWVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChldmVudCksXG4gICAgICAgICAgICAgICAgdGlsZU9yaWdpblBvaW50ID0gdGhpcy5fbWFwLmdldFBpeGVsT3JpZ2luKCkuYWRkKGxheWVyUG9pbnQpLFxuICAgICAgICAgICAgICAgIHRpbGVDb29yZCA9IHRpbGVPcmlnaW5Qb2ludC51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG4gICAgICAgICAgICAgICAgbW91c2VUaWxlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRpbGVLZXksXG4gICAgICAgICAgICAgICAgaG92ZXJlZE9iamVjdCxcbiAgICAgICAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblxuICAgICAgICAgICAgaWYgKHpvb20gPiAodGhpcy5vcHRpb25zLm1heFpvb20gKyB0aGlzLm9wdGlvbnMuem9vbU9mZnNldCkgfHxcbiAgICAgICAgICAgICAgICB6b29tIDwgKHRoaXMub3B0aW9ucy5taW5ab29tIC0gdGhpcy5vcHRpb25zLnpvb21PZmZzZXQpIHx8XG4gICAgICAgICAgICAgICAgIXRoaXMuX2lzVmFsaWRUaWxlKHRpbGVDb29yZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3dyYXBDb29yZHModGlsZUNvb3JkKTtcblxuICAgICAgICAgICAgdGlsZUNvb3JkLnogPSB0aGlzLl9nZXRab29tRm9yVXJsKCk7XG4gICAgICAgICAgICB0aWxlQ29vcmQua2V5ID0gdGlsZVNpemUueCArICd4JyArIHRpbGVTaXplLnk7XG4gICAgICAgICAgICB0aWxlS2V5ID0gdGhpcy5fb3JpZ2luLmdldFRpbGVLZXkodGlsZUNvb3JkKTtcblxuICAgICAgICAgICAgaWYgKHRpbGVLZXkgIT09IHRoaXMuX2N1cnJlbnRUaWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGUgPSB0aWxlS2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbGVEYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlRGF0YSA9IHRoaXMuX29yaWdpbi5nZXRUaWxlRGF0YSh0aWxlQ29vcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VzZVRpbGVPZmZzZXQgPSBERy5wb2ludCh0aWxlT3JpZ2luUG9pbnQueCAlIHRpbGVTaXplLngsIHRpbGVPcmlnaW5Qb2ludC55ICUgdGlsZVNpemUueSk7XG4gICAgICAgICAgICAgICAgaG92ZXJlZE9iamVjdCA9IHRoaXMuX2dldEhvdmVyZWRPYmplY3QodGlsZUNvb3JkLCBtb3VzZVRpbGVPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvdmVyZWRFbnRpdHkgIT09IGhvdmVyZWRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ21vdXNlb3V0JywgZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRFbnRpdHkgPSBob3ZlcmVkT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdtb3VzZW1vdmUnLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRFbnRpdHkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGUgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnY2xpY2snLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGJsY2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZU1vdXNlRXZlbnQoJ2RibGNsaWNrJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJlTW91c2VFdmVudCgnbW91c2Vkb3duJywgZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVNb3VzZUV2ZW50KCdjb250ZXh0bWVudScsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBtb3VzZUV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9ob3ZlcmVkRW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUodHlwZSwge1xuICAgICAgICAgICAgICAgIG1ldGE6IHRoaXMuX2hvdmVyZWRFbnRpdHksXG4gICAgICAgICAgICAgICAgbGF0bG5nOiB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF0TG5nKG1vdXNlRXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRCdWJibGluZyA9PT0gJ2xheWVyJykge1xuICAgICAgICAgICAgICAgIERHLkRvbUV2ZW50LnN0b3AobW91c2VFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldEhvdmVyZWRPYmplY3Q6IGZ1bmN0aW9uIChjb29yZHMsIG1vdXNlVGlsZU9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2N1cnJlbnRUaWxlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKERHLlBvbHlVdGlsLmluc2lkZShtb3VzZVRpbGVPZmZzZXQsIHRoaXMuX2N1cnJlbnRUaWxlRGF0YVtpXS5nZW9tZXRyeSwgdGhpcy5fcG9pbnRSZWR1Y2VIZWxwZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaWxlRGF0YVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBfcG9pbnRSZWR1Y2VIZWxwZXI6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICAgIH0sXG5cbiAgICBfc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9QcnVuZSwgbm9VcGRhdGUpIHtcbiAgICAgICAgdmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKSxcbiAgICAgICAgICAgIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMuX3RpbGVab29tICE9PSB0aWxlWm9vbTtcblxuICAgICAgICBpZiAoIW5vVXBkYXRlICYmIHRpbGVab29tQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0R3JpZCgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkRHLk1ldGEubGF5ZXIgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBERy5NZXRhLkxheWVyKHNvdXJjZSwgb3B0aW9ucyk7XG59O1xuIiwiREcuTWV0YS5PcmlnaW4gPSBERy5DbGFzcy5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBzdWJkb21haW5zOiAnMDEyMycsXG4gICAgICAgIGRhdGFGaWx0ZXI6IG51bGxcbiAgICB9LFxuXG4gICAgX3VybDogZmFsc2UsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIE9iamVjdClcbiAgICAgICAgdGhpcy5fdXJsID0gdXJsO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0cyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3RpbGVTdG9yYWdlID0ge307XG5cbiAgICAgICAgb3B0aW9ucyA9IERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN1YmRvbWFpbnMgPSBvcHRpb25zLnN1YmRvbWFpbnMuc3BsaXQoJycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFRpbGVEYXRhOiBmdW5jdGlvbiAoY29vcmQpIHsgLy8gKE9iamVjdCkgLT4gT2JqZWN0XG4gICAgICAgIHZhciB0aWxlS2V5ID0gdGhpcy5nZXRUaWxlS2V5KGNvb3JkKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdGlsZVN0b3JhZ2VbdGlsZUtleV0gPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLl9yZXF1ZXN0c1t0aWxlS2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdG9yYWdlW3RpbGVLZXldID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0c1t0aWxlS2V5XSA9IHRoaXMuX3JlcXVlc3REYXRhKGNvb3JkKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRUaWxlRGF0YSh0aWxlS2V5LCBzZWxmLm9wdGlvbnMuZGF0YUZpbHRlciA/IHNlbGYub3B0aW9ucy5kYXRhRmlsdGVyKGRhdGEsIGNvb3JkKSA6IGRhdGEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl9yZXF1ZXN0c1t0aWxlS2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVTdG9yYWdlW3RpbGVLZXldO1xuICAgIH0sXG5cbiAgICBzZXRUaWxlRGF0YTogZnVuY3Rpb24gKGtleSwgZGF0YSkgeyAvLyAoT2JqZWN0L1N0cmluZywgT2JqZWN0KSAtPiBPYmplY3RcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmdldFRpbGVLZXkoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5Lmdlb21ldHJ5LmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBlbnRpdHkuZ2VvbWV0cnkgPSBERy5Xa3QudG9HZW9KU09OKGVudGl0eS5nZW9tZXRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RpbGVTdG9yYWdlW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlU3RvcmFnZVtrZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90aWxlU3RvcmFnZVtrZXldLnB1c2goZW50aXR5KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IE9iamVjdFxuICAgICAgICB0aGlzLl90aWxlU3RvcmFnZSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9yZXF1ZXN0cykuZm9yRWFjaChmdW5jdGlvbiAodGlsZUtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbdGlsZUtleV0uYWJvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RpbGVLZXldLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuX3JlcXVlc3RzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0VVJMOiBmdW5jdGlvbiAodXJsLCBmbHVzaCkgeyAvLyAoU3RyaW5nLCBCb29sZWFuKSAtPiBPYmplY3RcbiAgICAgICAgdGhpcy5fdXJsID0gdXJsO1xuICAgICAgICBpZiAoZmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRUaWxlS2V5OiBmdW5jdGlvbiAoY29vcmQpIHsgLy8gKE9iamVjdCktPiBTdHJpbmdcbiAgICAgICAgcmV0dXJuIFtjb29yZC54LCBjb29yZC55LCBjb29yZC56LCBjb29yZC5rZXldLmpvaW4oJzonKTtcbiAgICB9LFxuXG4gICAgX3JlcXVlc3REYXRhOiBmdW5jdGlvbiAoa2V5KSB7IC8vIChTdHJpbmcpXG4gICAgICAgIGlmICh0aGlzLl91cmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZXJmb3JtUmVxdWVzdChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BlcmZvcm1SZXF1ZXN0OiBmdW5jdGlvbiAoY29vcmRzKSB7IC8vIChPYmplY3QpIC0+IFByb21pc2VcbiAgICAgICAgcmV0dXJuIERHLmFqYXgodGhpcy5fcHJlcGFyZVVSTChjb29yZHMpLCB7XG4gICAgICAgICAgICB0eXBlOiAnZ2V0JyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9wcmVwYXJlVVJMOiBmdW5jdGlvbiAoY29vcmRzKSB7IC8vIChPYmplY3QpIC0+IFN0cmluZ1xuICAgICAgICByZXR1cm4gREcuVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIHtcbiAgICAgICAgICAgIHg6IGNvb3Jkcy54LFxuICAgICAgICAgICAgeTogY29vcmRzLnksXG4gICAgICAgICAgICB6OiBjb29yZHMueixcbiAgICAgICAgICAgIHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0U3ViZG9tYWluOiBERy5UaWxlTGF5ZXIucHJvdG90eXBlLl9nZXRTdWJkb21haW5cblxufSk7XG5cbkRHLk1ldGEub3JpZ2luID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuTWV0YS5PcmlnaW4oc291cmNlLCBvcHRpb25zKTtcbn07XG4iLCJERy5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICBwb2k6ICFERy5Ccm93c2VyLm1vYmlsZVxufSk7XG5cbkRHLlBvaSA9IERHLkhhbmRsZXIuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZGlzYWJsZUxhYmVsOiBmYWxzZVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7IC8vIChPYmplY3QpXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgREcuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB1cmwgPSBERy5jb25maWcucHJvdG9jb2wgKyAoREcuQnJvd3Nlci5yZXRpbmEgPyBERy5jb25maWcucmV0aW5hUG9pTWV0YVNlcnZlciA6IERHLmNvbmZpZy5wb2lNZXRhU2VydmVyKTtcblxuICAgICAgICB0aGlzLl9tZXRhTGF5ZXIgPSBERy5NZXRhLmxheWVyKHVybCwge1xuICAgICAgICAgICAgbWluWm9vbTogREcuY29uZmlnLnBvaUxheWVyTWluWm9vbSxcbiAgICAgICAgICAgIG1heE5hdGl2ZVpvb206IDE5LFxuICAgICAgICAgICAgZGV0ZWN0UmV0aW5hOiBERy5jb25maWcuZGV0ZWN0UmV0aW5hLFxuICAgICAgICAgICAgZXZlbnRCdWJibGluZzogJ2xheWVyJyxcbiAgICAgICAgICAgIGRhdGFGaWx0ZXI6IERHLmJpbmQodGhpcy5fcHJvY2Vzc0RhdGEsIHRoaXMpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fbWV0YUxheWVyKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlciA9IERHLmxhYmVsKCk7XG4gICAgICAgICAgICB0aGlzLl9tZXRhTGF5ZXIub24odGhpcy5fbGF5ZXJFdmVudHNMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9tZXRhTGF5ZXIpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX21ldGFMYXllci5vZmYodGhpcy5fbGF5ZXJFdmVudHNMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xhYmVsSGVscGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsSGVscGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRNZXRhTGF5ZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhTGF5ZXI7XG4gICAgfSxcblxuICAgIF9wcm9jZXNzRGF0YSA6IGZ1bmN0aW9uIChkYXRhLCBjb29yZCkge1xuICAgICAgICB2YXIgdGlsZU9yaWdpblBvaW50ID0gY29vcmQuc2NhbGVCeSh0aGlzLl9tZXRhTGF5ZXIuZ2V0VGlsZVNpemUoKSk7XG4gICAgICAgIHZhciBwb2x5Z29uTG5nTGF0VG9Qb2ludHMgPSBERy5iaW5kKHRoaXMuX3BvbHlnb25MbmdMYXRUb1BvaW50cywgdGhpcywgdGlsZU9yaWdpblBvaW50KTtcblxuICAgICAgICBpZiAoZGF0YS5yZXNwb25zZVRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YS5yZXN1bHQucG9pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGhpbnQ6IGl0ZW0ubGlua3NbMF0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbGlua2VkOiBpdGVtLmxpbmtzWzBdLFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeTogREcuV2t0LnRvR2VvSlNPTihpdGVtLmhvdmVyKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmdlb21ldHJ5LnR5cGUgPT0gJ1BvbHlnb24nIHx8XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZ2VvbWV0cnkudHlwZSA9PSAnTXVsdGlQb2x5Z29uJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdlb0pzb24gPSBpdGVtLmdlb21ldHJ5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGdlb0pzb24udHlwZSA9PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvSnNvbi5jb29yZGluYXRlcyA9IHBvbHlnb25MbmdMYXRUb1BvaW50cyhnZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdlb0pzb24udHlwZSA9PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICBnZW9Kc29uLmNvb3JkaW5hdGVzID0gZ2VvSnNvbi5jb29yZGluYXRlcy5tYXAocG9seWdvbkxuZ0xhdFRvUG9pbnRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfcG9seWdvbkxuZ0xhdFRvUG9pbnRzOiBmdW5jdGlvbiAob3JpZ2luUG9pbnQsIHBvbHlnb24pIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICByZXR1cm4gcG9seWdvbi5tYXAoZnVuY3Rpb24gKGNvbnRvdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250b3VyLm1hcChmdW5jdGlvbiAobG5nTGF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcFxuICAgICAgICAgICAgICAgICAgICAucHJvamVjdChbbG5nTGF0WzFdLCBsbmdMYXRbMF1dKS5yb3VuZCgpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJ0cmFjdChvcmlnaW5Qb2ludCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9sYXllckV2ZW50c0xpc3RlbmVycyA6IHtcbiAgICAgICAgbW91c2VvdmVyOiBmdW5jdGlvbiAoZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCdwb2ludGVyJyk7XG4gICAgICAgICAgICBpZiAoZS5tZXRhLmhpbnQgJiYgZS5tZXRhLmhpbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBvc2l0aW9uKGUubGF0bG5nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q29udGVudChlLm1ldGEuaGludClcbiAgICAgICAgICAgICAgICAgICAgLnNldFpJbmRleE9mZnNldCgzMDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgncG9paG92ZXInLCB7XG4gICAgICAgICAgICAgICAgbGF0bG5nOiBlLmxhdGxuZyxcbiAgICAgICAgICAgICAgICBtZXRhOiBlLm1ldGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCcnKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYWJlbEhlbHBlcik7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZmlyZSgncG9pbGVhdmUnLCB7XG4gICAgICAgICAgICAgICAgbGF0bG5nOiBlLmxhdGxuZyxcbiAgICAgICAgICAgICAgICBtZXRhOiBlLm1ldGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHsgLy8gKE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsSGVscGVyLnNldFBvc2l0aW9uKGUubGF0bG5nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0Q3Vyc29yOiBmdW5jdGlvbiAoY3Vyc29yKSB7IC8vIChTdHJpbmcpXG4gICAgICAgIHRoaXMuX21hcC5nZXRDb250YWluZXIoKS5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgfVxuXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3BvaScsIERHLlBvaSk7XG4iLCJERy5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICBnZW9jbGlja2VyOiBmYWxzZVxufSk7XG5cbkRHLkdlb2NsaWNrZXIgPSBERy5IYW5kbGVyLmV4dGVuZCh7XG4gICAgY2xpY2tDb3VudDogMCxcbiAgICBwZW5kaW5nQ2xpY2s6IDAsXG4gICAgdGltZW91dDogMjUwLCAvLyBzaG91bGQgYmUgZXF1YWwgdG8gJ2RlbGF5JyB2YWx1ZSBpbiBEb3VibGVUYXAgZXZlbnRcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9jb250cm9sbGVyID0gbmV3IERHLkdlb2NsaWNrZXIuQ29udHJvbGxlcihtYXAsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90b2dnbGVFdmVudHModHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAub24oJ3J1bGVyc3RhcnQnLCB0aGlzLl9wYXVzZSwgdGhpcylcbiAgICAgICAgICAgIC5vbigncnVsZXJlbmQnLCB0aGlzLl91bnBhdXNlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRzKCk7XG5cbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAub2ZmKCdydWxlcnN0YXJ0JywgdGhpcy5fcGF1c2UsIHRoaXMpXG4gICAgICAgICAgICAub2ZmKCdydWxlcmVuZCcsIHRoaXMuX3VucGF1c2UsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfY2hlY2tPcGVuUG9wdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKERHLkJyb3dzZXIubW9iaWxlICYmIHRoaXMuX21hcC5fcG9wdXAgJiZcbiAgICAgICAgICAgICh0aGlzLl9tYXAuX3BvcHVwLm9wdGlvbnMuY2xvc2VPbkNsaWNrIHx8XG4gICAgICAgICAgICB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBXYXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRzKCk7XG4gICAgfSxcblxuICAgIF91bnBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlZW5hYmxlIGV2ZW50IGhhbmRsaW5nIG9ubHkgaW4gY2FzZSBnZW9jbGlja2VyIGlzIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudHModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3RvZ2dsZUV2ZW50czogZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgdGhpcy5fbWFwW2ZsYWcgPyAnb24nIDogJ29mZiddKHRoaXMuX21hcEV2ZW50c0xpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9tYXAucG9pKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAucG9pLmdldE1ldGFMYXllcigpW2ZsYWcgPyAnb24nIDogJ29mZiddKCdjbGljaycsIHRoaXMuX29uTWV0YUNsaWNrLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDb250cm9sbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250cm9sbGVyO1xuICAgIH0sXG5cbiAgICBfb25NZXRhQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdDbGljayk7XG4gICAgICAgIHRoaXMucG9wdXBXYXNPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fbWFwRXZlbnRzTGlzdGVuZXJzLmNsaWNrLmNhbGwodGhpcywgZSk7XG4gICAgfSxcblxuICAgIF9tYXBFdmVudHNMaXN0ZW5lcnM6IHtcbiAgICAgICAgbGFuZ2NoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5yZWludm9rZUhhbmRsZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb3B1cGNsb3NlOiBmdW5jdGlvbiAoZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlci5oYW5kbGVQb3B1cENsb3NlKGUucG9wdXApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2luZ2xlQ2xpY2soZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGVuZGluZ0NsaWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwV2FzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRibGNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cFdhc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQ2xpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zaW5nbGVDbGljazogZnVuY3Rpb24gKGUpIHsgLy8gKE9iamVjdClcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdDbGljayk7XG5cbiAgICAgICAgdGhpcy5wZW5kaW5nQ2xpY2sgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChlLm1ldGEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9jaGVja09wZW5Qb3B1cCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX21hcC5jbG9zZVBvcHVwKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICBER1BvcHVwJ3MgJ19jbG9zZScgbWV0aG9kIGlzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIC5wb3B1cFdhc09wZW4gaXMgbW9kaWZpZWRcbiAgICAgICAgICAgIC8vICBJdCBzaWduYWxzIGdlb2NsaWNrZXIgdGhhdCBwb3B1cCB3YXMgb3BlbiBiZWZvcmUgdXNlciBkbyBhICdjbGljaycgb24gbWFwXG4gICAgICAgICAgICAvLyAgTXVsdGlzdGFnZSBiZWhhdmlvciBpcyBuZWVkZWQgYXMgdGhpcyBwcm9jZXNzaW5nIG9jY3VycyBhZnRlciBwb3B1cCB3YXMgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICAgIGlmICghc2VsZi5wb3B1cFdhc09wZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgem9vbSA9IHNlbGYuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fY29udHJvbGxlci5oYW5kbGVDbGljayhlLmxhdGxuZywgem9vbSwgZS5tZXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5jbGlja0NvdW50ID0gMDtcbiAgICAgICAgICAgIHNlbGYucG9wdXBXYXNPcGVuID0gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMudGltZW91dCk7XG4gICAgfVxufSk7XG5cbkRHLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdnZW9jbGlja2VyJywgREcuR2VvY2xpY2tlcik7XG4iLCJERy5HZW9jbGlja2VyLmNsYW1wSGVscGVyID0gZnVuY3Rpb24gKGVsLCBsaW5lQ2xhbXApIHtcbiAgICB2YXIgbWVhc3VyZSwgdGV4dCwgbGluZVdpZHRoLFxuICAgICAgICBsaW5lU3RhcnQsIGxpbmVDb3VudCwgd29yZFN0YXJ0LFxuICAgICAgICBsaW5lLCBsaW5lVGV4dCwgd2FzTmV3TGluZSxcbiAgICAgICAgY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmJpbmQoZG9jdW1lbnQpLFxuICAgICAgICBjdG4gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZS5iaW5kKGRvY3VtZW50KTtcblxuICAgIC8vIG1lYXN1cmVtZW50IGVsZW1lbnQgaXMgbWFkZSBhIGNoaWxkIG9mIHRoZSBjbGFtcGVkIGVsZW1lbnQgdG8gZ2V0IGl0J3Mgc3R5bGVcbiAgICBtZWFzdXJlID0gY2UoJ3NwYW4nKTtcblxuICAgIChmdW5jdGlvbiAocykge1xuICAgICAgICBzLnBvc2l0aW9uID0gJ2Fic29sdXRlJzsgLy8gcHJldmVudCBwYWdlIHJlZmxvd1xuICAgICAgICBzLndoaXRlU3BhY2UgPSAncHJlJzsgLy8gY3Jvc3MtYnJvd3NlciB3aWR0aCByZXN1bHRzXG4gICAgICAgIHMudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyAvLyBwcmV2ZW50IGRyYXdpbmdcbiAgICAgICAgcy5tYXJnaW4gPSAnMCAxOHB4IDhweCAwJztcbiAgICB9KShtZWFzdXJlLnN0eWxlKTtcblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgZWxlbWVudCBiZWxvbmdzIHRvIHRoZSBkb2N1bWVudFxuICAgIGlmICghZWwub3duZXJEb2N1bWVudCB8fCBlbC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlc2V0IHRvIHNhZmUgc3RhcnRpbmcgdmFsdWVzXG4gICAgbGluZVN0YXJ0ID0gd29yZFN0YXJ0ID0gMDtcbiAgICBsaW5lQ291bnQgPSAxO1xuICAgIHdhc05ld0xpbmUgPSBmYWxzZTtcbiAgICBsaW5lV2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICAvLyBnZXQgYWxsIHRoZSB0ZXh0LCByZW1vdmUgYW55IGxpbmUgY2hhbmdlc1xuICAgIHRleHQgPSAoZWwudGV4dENvbnRlbnQgfHwgZWwuaW5uZXJUZXh0KS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICAvLyByZW1vdmUgYWxsIGNvbnRlbnRcbiAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgLy8gYWRkIG1lYXN1cmVtZW50IGVsZW1lbnQgd2l0aGluIHNvIGl0IGluaGVyaXRzIHN0eWxlc1xuICAgIGVsLmFwcGVuZENoaWxkKG1lYXN1cmUpO1xuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9zZWFyY2gtYW5kLWRvbnQtcmVwbGFjZS9cbiAgICB0ZXh0LnJlcGxhY2UoLyB8LS9nLCBmdW5jdGlvbiAobSwgcG9zKSB7XG4gICAgICAgIC8vIGlnbm9yZSBhbnkgZnVydGhlciBwcm9jZXNzaW5nIGlmIHdlIGhhdmUgdG90YWwgbGluZXNcbiAgICAgICAgaWYgKGxpbmVDb3VudCA9PT0gbGluZUNsYW1wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGEgdGV4dCBub2RlIGFuZCBwbGFjZSBpdCBpbiB0aGUgbWVhc3VyZW1lbnQgZWxlbWVudFxuICAgICAgICBtZWFzdXJlLmFwcGVuZENoaWxkKGN0bih0ZXh0LnN1YnN0cihsaW5lU3RhcnQsIHBvcyAtIGxpbmVTdGFydCkpKTtcbiAgICAgICAgLy8gaGF2ZSB3ZSBleGNlZWRlZCBhbGxvd2VkIGxpbmUgd2lkdGg/XG4gICAgICAgIGlmIChsaW5lV2lkdGggPCBtZWFzdXJlLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBpZiAod2FzTmV3TGluZSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSBsb25nIHdvcmQgc28gaXQgZ2V0cyBhIGxpbmUgb2YgaXQncyBvd25cbiAgICAgICAgICAgICAgICBsaW5lVGV4dCA9IHRleHQuc3Vic3RyKGxpbmVTdGFydCwgcG9zICsgMSAtIGxpbmVTdGFydCk7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBsaW5lIHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JhYiB0aGUgdGV4dCB1bnRpbCB0aGlzIHdvcmRcbiAgICAgICAgICAgICAgICBsaW5lVGV4dCA9IHRleHQuc3Vic3RyKGxpbmVTdGFydCwgd29yZFN0YXJ0IC0gbGluZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGxpbmUgc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSB3b3JkU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBsaW5lIGVsZW1lbnRcbiAgICAgICAgICAgIGxpbmUgPSBjZSgnc3BhbicpO1xuICAgICAgICAgICAgLy8gYWRkIHRleHQgdG8gdGhlIGxpbmUgZWxlbWVudFxuICAgICAgICAgICAgbGluZS5hcHBlbmRDaGlsZChjdG4obGluZVRleHQpKTtcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbGluZSBlbGVtZW50IHRvIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgICAgICAgICAgbGluZS5jbGFzc05hbWUgPSAnZGctbWFwLWdlb2NsaWNrZXJfX2NsYW1wZWQtbGluZSc7XG4gICAgICAgICAgICAvLyB5ZXMsIHdlIGNyZWF0ZWQgYSBuZXcgbGluZVxuICAgICAgICAgICAgd2FzTmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICBsaW5lQ291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRpZCBub3QgY3JlYXRlIGEgbmV3IGxpbmVcbiAgICAgICAgICAgIHdhc05ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1lbWJlciBsYXN0IHdvcmQgc3RhcnQgcG9zaXRpb25cbiAgICAgICAgd29yZFN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgLy8gY2xlYXIgbWVhc3VyZW1lbnQgZWxlbWVudFxuICAgICAgICBtZWFzdXJlLnJlbW92ZUNoaWxkKG1lYXN1cmUuZmlyc3RDaGlsZCk7XG4gICAgfSk7XG4gICAgLy8gcmVtb3ZlIHRoZSBtZWFzdXJlbWVudCBlbGVtZW50IGZyb20gdGhlIGNvbnRhaW5lclxuICAgIGVsLnJlbW92ZUNoaWxkKG1lYXN1cmUpO1xuICAgIC8vIGNyZWF0ZSB0aGUgbGFzdCBsaW5lIGVsZW1lbnRcbiAgICBsaW5lID0gY2UoJ3NwYW4nKTtcbiAgICAvLyBnaXZlIHN0eWxlcyByZXF1aXJlZCBmb3IgdGV4dC1vdmVyZmxvdyB0byBraWNrIGluXG4gICAgbGluZS5jbGFzc05hbWUgPSAnZGctbWFwLWdlb2NsaWNrZXJfX2NsYW1wZWQtbGluZSBkZy1tYXAtZ2VvY2xpY2tlcl9fY2xhbXBlZC1saW5lX2xhc3QnO1xuICAgIC8vIGFkZCBhbGwgcmVtYWluaW5nIHRleHQgdG8gdGhlIGxpbmUgZWxlbWVudFxuICAgIGxpbmUuYXBwZW5kQ2hpbGQoY3RuKHRleHQuc3Vic3RyKGxpbmVTdGFydCkpKTtcbiAgICAvLyBhZGQgdGhlIGxpbmUgZWxlbWVudCB0byB0aGUgY29udGFpbmVyXG4gICAgZWwuYXBwZW5kQ2hpbGQobGluZSk7XG59O1xuIiwiREcuR2VvY2xpY2tlci5Qcm92aWRlciA9IHt9O1xuIiwiREcuR2VvY2xpY2tlci5Qcm92aWRlci5DYXRhbG9nQXBpID0gREcuQ2xhc3MuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7IC8vIChPYmplY3QpXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcblxuICAgICAgICB2YXIgYXBpVXJsID0gREcuY29uZmlnLnByb3RvY29sICtcbiAgICAgICAgICAgIERHLmNvbmZpZy53ZWJBcGlTZXJ2ZXIgKyAnLycgK1xuICAgICAgICAgICAgREcuY29uZmlnLndlYkFwaVZlcnNpb24gKyAnLyc7XG5cbiAgICAgICAgdGhpcy5fdXJsR2VvU2VhcmNoID0gYXBpVXJsICsgJ2dlby9zZWFyY2gnO1xuICAgICAgICB0aGlzLl91cmxHZW9HZXQgPSBhcGlVcmwgKyAnZ2VvL2dldCc7XG4gICAgICAgIHRoaXMuX3VybERldGFpbHMgPSBhcGlVcmwgKyAnY2F0YWxvZy9icmFuY2gvZ2V0JztcbiAgICAgICAgdGhpcy5fdXJsRmlybXNJbkhvdXNlID0gYXBpVXJsICsgJ2NhdGFsb2cvYnJhbmNoL2xpc3QnO1xuXG4gICAgICAgIHRoaXMuX2tleSA9IERHLmNvbmZpZy5nZW9jbGlja2VyQ2F0YWxvZ0FwaUtleTtcbiAgICAgICAgdGhpcy5fZ2VvRmllbGRzID0gREcuY29uZmlnLmdlb0FkZGl0aW9uYWxGaWVsZHM7XG4gICAgICAgIHRoaXMuX2Zpcm1JbmZvRmllbGRzID0gREcuY29uZmlnLmZpcm1JbmZvRmllbGRzO1xuICAgIH0sXG5cbiAgICBnZXRMb2NhdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7IC8vIChPYmplY3QpXG4gICAgICAgIC8vIENhbGxiYWNrIHdpbGwgcmVjZWl2ZSBhcnJheSBvZiBmb3VuZCByZXN1bHRzIG9yIHZvaWQgaWYgZXJyb3JzIG9jY3VycmVkIG9yIG5vdGhpbmcgd2FzIGZvdW5kLlxuICAgICAgICB2YXIgem9vbSA9IG9wdGlvbnMuem9vbSxcbiAgICAgICAgICAgIGxhdGxuZyA9IG9wdGlvbnMubGF0bG5nLFxuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdCA9IG9wdGlvbnMuYmVmb3JlUmVxdWVzdCB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIHR5cGVzID0gdGhpcy5nZXRUeXBlc0J5Wm9vbSh6b29tKSxcbiAgICAgICAgICAgIHEgPSBsYXRsbmcubG5nICsgJywnICsgbGF0bG5nLmxhdDtcblxuICAgICAgICBpZiAoIXR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ25vIHR5cGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlZm9yZVJlcXVlc3QoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZW9TZWFyY2gocSwgdHlwZXMsIHpvb20pLnRoZW4oREcuYmluZChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyUmVzcG9uc2UocmVzdWx0LCB0eXBlcyk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgZmlybXNJbkhvdXNlOiBmdW5jdGlvbiAoaG91c2VJZCwgcGFyYW1ldGVycykgeyAvLyAoU3RyaW5nLCBGdW5jdGlvbiwgTnVtYmVyKVxuICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGJ1aWxkaW5nX2lkOiBob3VzZUlkLFxuICAgICAgICAgICAgcGFnZTogcGFyYW1ldGVycy5wYWdlIHx8IDFcbiAgICAgICAgfTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3QocGFyYW1zLCB0aGlzLl91cmxGaXJtc0luSG91c2UpO1xuICAgIH0sXG5cbiAgICBnZXRGaXJtSW5mbzogZnVuY3Rpb24gKGZpcm1JZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2ZpbGlhbCcsXG4gICAgICAgICAgICBpZDogZmlybUlkLFxuICAgICAgICAgICAgZmllbGRzOiB0aGlzLl9maXJtSW5mb0ZpZWxkc1xuICAgICAgICB9LCB0aGlzLl91cmxEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgZ2VvU2VhcmNoOiBmdW5jdGlvbiAocSwgdHlwZXMsIHpvb21sZXZlbCkgeyAvLyAoU3RyaW5nLCBTdHJpbmcsIE51bWJlcilcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICBwb2ludDogcSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVzLFxuICAgICAgICAgICAgem9vbV9sZXZlbDogem9vbWxldmVsLFxuICAgICAgICAgICAgZmllbGRzOiB0aGlzLl9nZW9GaWVsZHNcbiAgICAgICAgfTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3QocGFyYW1zLCB0aGlzLl91cmxHZW9TZWFyY2gpO1xuICAgIH0sXG5cbiAgICBnZW9HZXQ6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZmllbGRzOiB0aGlzLl9nZW9GaWVsZHNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybVJlcXVlc3QocGFyYW1zLCB0aGlzLl91cmxHZW9HZXQpO1xuICAgIH0sXG5cbiAgICBjYW5jZWxMYXN0UmVxdWVzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdFJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VHlwZXNCeVpvb206IGZ1bmN0aW9uICh6b29tKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ3xOdWxsXG4gICAgICAgIHZhciB0eXBlcyA9IHtcbiAgICAgICAgICAgICAgICAnYWRtX2Rpdi5zZXR0bGVtZW50JzogICA4LFxuICAgICAgICAgICAgICAgICdhZG1fZGl2LmNpdHknOiAgICAgICAgIDgsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYuZGl2aXNpb24nOiAgICAgMTEsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYuZGlzdHJpY3QnOiAgICAgMTIsXG4gICAgICAgICAgICAgICAgJ3N0cmVldCc6ICAgICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgJ2J1aWxkaW5nJzogICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAgICAgJ2FkbV9kaXYucGxhY2UnOiAgICAgICAgMTUsXG4gICAgICAgICAgICAgICAgJ3BvaSc6ICAgICAgICAgICAgICAgICAgMTUsXG4gICAgICAgICAgICAgICAgJ2F0dHJhY3Rpb24nOiAgICAgICAgICAgMTdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3RlZFR5cGVzID0gW107XG5cbiAgICAgICAgT2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh6b29tID49IHR5cGVzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFR5cGVzLmpvaW4oJywnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wZXJmb3JtUmVxdWVzdDogZnVuY3Rpb24gKHBhcmFtcywgdXJsKSB7IC8vIChPYmplY3QsIFN0cmluZywgRnVuY3Rpb24sIEZ1bmN0aW9uKVxuICAgICAgICB2YXIgZGF0YSA9IERHLmV4dGVuZCh7a2V5OiB0aGlzLl9rZXl9LCBwYXJhbXMpO1xuICAgICAgICB2YXIgdHlwZSA9ICdnZXQnO1xuXG4gICAgICAgIHRoaXMuY2FuY2VsTGFzdFJlcXVlc3QoKTtcblxuICAgICAgICBpZiAoIURHLmFqYXguY29yc1N1cHBvcnQpIHtcbiAgICAgICAgICAgIHR5cGUgPSBkYXRhLmZvcm1hdCA9ICdqc29ucCc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0UmVxdWVzdCA9IERHLmFqYXgodXJsLCB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuX3RpbWVvdXRNc1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbGFzdFJlcXVlc3Q7XG4gICAgfSxcblxuICAgIF9maWx0ZXJSZXNwb25zZTogZnVuY3Rpb24gKHJlc3BvbnNlLCBhbGxvd2VkVHlwZXMpIHsgLy8gKE9iamVjdCwgQXJyYXkpIC0+IEJvb2xlYW58T2JqZWN0XG4gICAgICAgIHZhciByZXN1bHQgPSB7fSwgaSwgaXRlbSwgZm91bmQsIGRhdGEsIHR5cGU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzTm90Rm91bmQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gcmVzcG9uc2UucmVzdWx0Lml0ZW1zO1xuXG4gICAgICAgIGZvciAoaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSBkYXRhW2ldO1xuXG4gICAgICAgICAgICB0eXBlID0gaXRlbS50eXBlO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3VidHlwZSkge1xuICAgICAgICAgICAgICAgIHR5cGUgKz0gJy4nICsgaXRlbS5zdWJ0eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dlZFR5cGVzICYmIGFsbG93ZWRUeXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRbdHlwZV0gPSBpdGVtO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pc05vdEZvdW5kOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgLy8gKE9iamVjdCkgLT4gQm9vbGVhblxuICAgICAgICByZXR1cm4gIXJlc3BvbnNlIHx8XG4gICAgICAgICAgICAgICAhIXJlc3BvbnNlLm1ldGEgJiYgISFyZXNwb25zZS5tZXRhLmVycm9yIHx8XG4gICAgICAgICAgICAgICAhcmVzcG9uc2UucmVzdWx0IHx8XG4gICAgICAgICAgICAgICAhcmVzcG9uc2UucmVzdWx0Lml0ZW1zIHx8XG4gICAgICAgICAgICAgICAhcmVzcG9uc2UucmVzdWx0Lml0ZW1zLmxlbmd0aDtcbiAgICB9XG5cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyID0ge307XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdCA9IERHLkNsYXNzLmV4dGVuZCh7XG5cbiAgICBpbmNsdWRlczogREcuTG9jYWxlLFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBEaWN0aW9uYXJ5OiB7fVxuICAgIH0sXG5cbiAgICBfZXZlbnRIYW5kbGVyczoge30sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoY29udHJvbGxlciwgdmlldywgbWFwKSB7IC8vIChPYmplY3QsIE9iamVjdCwgT2JqZWN0KVxuICAgICAgICB0aGlzLl9jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5fdmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB9LFxuXG4gICAgaGFuZGxlOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IFByb21pc2VcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBIZWFkZXInLFxuICAgICAgICAgICAgZGF0YTogeyd0aXRsZSc6IHRoaXMudCgnd2VfaGF2ZV9ub3QnKX1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFkZENsaWNrRXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdmlldy5fcG9wdXAub24oJ2NsaWNrJywgdGhpcy5fcnVuRXZlbnRIYW5kbGVycywgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hcC5vbmNlKCdwb3B1cGNsb3NlJywgdGhpcy5fcmVtb3ZlQ2xpY2tFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVDbGlja0V2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3ZpZXcuX3BvcHVwLm9mZignY2xpY2snLCB0aGlzLl9ydW5FdmVudEhhbmRsZXJzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2FkZEV2ZW50SGFuZGxlcjogZnVuY3Rpb24gKGVsLCBoYW5kbGVyKSB7IC8vIChTdHJpbmcsIEZ1bmN0aW9uKVxuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzW2VsXSA9IGhhbmRsZXI7XG4gICAgfSxcblxuICAgIF9ydW5FdmVudEhhbmRsZXJzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldDtcblxuICAgICAgICBmb3IgKHZhciBldmVudENsYXNzIGluIHRoaXMuX2V2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudEhhbmRsZXJzLmhhc093blByb3BlcnR5KGV2ZW50Q2xhc3MpICYmIHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihldmVudENsYXNzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgREcuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzW2V2ZW50Q2xhc3NdLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFyRXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzID0ge307XG4gICAgfSxcblxuICAgIF9nZXREaXJlY3Rpb25zVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gREcuVXRpbC50ZW1wbGF0ZShERy5jb25maWcucHBub3RMaW5rLCB7XG4gICAgICAgICAgICAnZG9tYWluJzogdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkuZG9tYWluLFxuICAgICAgICAgICAgJ3Byb2plY3RDb2RlJzogdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCkuY29kZSxcbiAgICAgICAgICAgICdjZW50ZXInOiB0aGlzLl9tYXAuZ2V0Q2VudGVyKCkubG5nICsgJywnICsgdGhpcy5fbWFwLmdldENlbnRlcigpLmxhdCxcbiAgICAgICAgICAgICd6b29tJzogdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgICduYW1lJzogZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpLFxuICAgICAgICAgICAgJ3JzVHlwZSc6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLnRyYW5zcG9ydCA/ICdidXMnIDogJ2NhcicsXG4gICAgICAgICAgICAncG9pbnQnOiB0aGlzLl9wb3B1cC5fbGF0bG5nLmxuZyArICcsJyArIHRoaXMuX3BvcHVwLl9sYXRsbmcubGF0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0RHJpbGxkb3duOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBhZG1EaXZzID0gW10sXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKG9iamVjdC5hZG1fZGl2KSB7XG4gICAgICAgICAgICBhZG1EaXZzID0gb2JqZWN0LmFkbV9kaXZcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhZG1EaXZzLCBhZG1EaXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkbURpdi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZG1EaXZzLnB1c2goYWRtRGl2Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkbURpdnM7XG4gICAgICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZG1EaXZzLmxlbmd0aCAmJiBvYmplY3QuYWRkcmVzcyAmJiBvYmplY3QuYWRkcmVzcy5wb3N0Y29kZSkge1xuICAgICAgICAgICAgYWRtRGl2cy5wdXNoKG9iamVjdC5hZGRyZXNzLnBvc3Rjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IGFkbURpdnMuam9pbignLCAnKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufSk7XG5cblxuREcuR2VvY2xpY2tlci5IYW5kbGVyLkhhbmRsZXJFeGFtcGxlID0gREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQuZXh0ZW5kKHtcblxuICAgIGhhbmRsZTogZnVuY3Rpb24gKHJlc3VsdHMsIHR5cGUpIHsgLy8gKE9iamVjdCwgU3RyaW5nKSAtPiBQcm9taXNlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdG1wbDogdHlwZSArICc6PGJyLz4nICsgcmVzdWx0c1t0eXBlXS5pZFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5BcGlFcnJvciA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LmV4dGVuZCh7XG4gICAgaGFuZGxlOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IFByb21pc2VcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgIHRtcGw6ICdwb3B1cEhlYWRlcicsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMudCgnYXBpRXJyb3JUaXRsZScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgICAgICB0bXBsOiB0aGlzLnQoJ2FwaUVycm9yQm9keScpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhID0gREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQuZXh0ZW5kKHtcblxuICAgIF9wb2x5bGluZVN0eWxlRGVmYXVsdCA6IHtcbiAgICAgICAgZmlsbENvbG9yOiAnI2ZmOTM4NycsXG4gICAgICAgIGNvbG9yOiAnI2ZmOTM4NycsXG4gICAgICAgIG5vQ2xpcDogdHJ1ZSxcbiAgICAgICAgb3BhY2l0eTogMVxuICAgIH0sXG5cbiAgICBfcG9seWxpbmVTdHlsZXMgOiB7XG4gICAgICAgIDExIDoge1xuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAuMTgsXG4gICAgICAgICAgICB3ZWlnaHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAgMTIgOiB7XG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC4xMixcbiAgICAgICAgICAgIHdlaWdodDogMVxuICAgICAgICB9LFxuICAgICAgICAxMyA6IHtcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjA4LFxuICAgICAgICAgICAgd2VpZ2h0OiAyXG4gICAgICAgIH0sXG4gICAgICAgIDE4IDoge1xuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDAsXG4gICAgICAgICAgICB3ZWlnaHQ6IDNcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uIChyZXN1bHRzLCB0eXBlKSB7IC8vIChPYmplY3QsIFN0cmluZykgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlc3VsdHNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fc3R5bGVzSW5pdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0U3R5bGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgcHJldmlvdXMgZ2VvbWV0cnkgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS8yZ2lzL21hcHNhcGkvaXNzdWVzLzIxM1xuICAgICAgICBpZiAodGhpcy5fZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9nZW9tZXRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3B1cCA9IHRoaXMuX3ZpZXcuZ2V0UG9wdXAoKTtcblxuICAgICAgICB0aGlzLl9nZW9tZXRyeVpvb21TdHlsZSA9IHRoaXMuX2dldFBvbHlTdHlsZU51bSgpO1xuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IERHLldrdC5nZW9Kc29uTGF5ZXIocmVzdWx0c1t0eXBlXS5nZW9tZXRyeS5zZWxlY3Rpb24sIHtcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLl9wb2x5bGluZVN0eWxlc1t0aGlzLl9nZW9tZXRyeVpvb21TdHlsZV0sXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogZmFsc2VcbiAgICAgICAgfSkuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgIC5vbignem9vbWVuZCcsIHRoaXMuX3VwZGF0ZUdlb21ldHJ5LCB0aGlzKVxuICAgICAgICAgICAgLm9uY2UoJ3BvcHVwY2xvc2UnLCB0aGlzLl9jbGVhclBvcHVwLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2ZpbGxDaXR5QXJlYU9iamVjdChyZXN1bHRzLCB0eXBlKSk7XG4gICAgfSxcblxuICAgIF9maWxsQ2l0eUFyZWFPYmplY3Q6IGZ1bmN0aW9uIChyZXN1bHRzLCB0eXBlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy50KCdub25hbWUnKSxcbiAgICAgICAgICAgIGRyaWxsZG93bjogJycsXG4gICAgICAgICAgICBwdXJwb3NlOiB0aGlzLnQodHlwZSksXG4gICAgICAgICAgICB0eXBlOiB0eXBlLnNwbGl0KCcuJykuam9pbignXycpXG4gICAgICAgIH07XG5cbiAgICAgICAgZGF0YS5kcmlsbGRvd24gPSB0aGlzLl9nZXREcmlsbGRvd24ocmVzdWx0c1t0eXBlXSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdHNbdHlwZV0ubmFtZSkge1xuICAgICAgICAgICAgZGF0YS5uYW1lID0gcmVzdWx0c1t0eXBlXS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRtcGw6ICdjaXR5YXJlYScsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgaGVhZGVyOiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICAgICAgdG1wbDogJ3BvcHVwSGVhZGVyJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7J3RpdGxlJzogZGF0YS5uYW1lfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2luaXRTdHlsZXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0eWxlc0luaXRlZCA9IHRydWU7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcG9seWxpbmVTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHpvb20pIHtcbiAgICAgICAgICAgIERHLmV4dGVuZCh0aGlzLl9wb2x5bGluZVN0eWxlc1t6b29tXSwgdGhpcy5fcG9seWxpbmVTdHlsZURlZmF1bHQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2dldFBvbHlTdHlsZU51bTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwWm9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3BvbHlsaW5lU3R5bGVzKS5maWx0ZXIoZnVuY3Rpb24gKHpvb20pIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBab29tIDw9IHpvb207XG4gICAgICAgIH0pWzBdIHx8IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlR2VvbWV0cnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld1N0eWxlID0gdGhpcy5fZ2V0UG9seVN0eWxlTnVtKCk7XG5cbiAgICAgICAgaWYgKG5ld1N0eWxlICYmIG5ld1N0eWxlICE9PSB0aGlzLl9nZW9tZXRyeVpvb21TdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnlab29tU3R5bGUgPSBuZXdTdHlsZTtcbiAgICAgICAgICAgIHRoaXMuX2dlb21ldHJ5LnNldFN0eWxlKHRoaXMuX3BvbHlsaW5lU3R5bGVzW25ld1N0eWxlXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFyUG9wdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX2dlb21ldHJ5KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3pvb21lbmQnLCB0aGlzLl91cGRhdGVHZW9tZXRyeSwgdGhpcyk7XG4gICAgfVxuXG59KTtcbiIsIi8qZ2xvYmFsIEZpcm1DYXJkICovXG5ERy5HZW9jbGlja2VyLkhhbmRsZXIuSG91c2UgPSBERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5leHRlbmQoe1xuXG4gICAgX2Zpcm1zT25QYWdlOiAyMCxcbiAgICBfc2Nyb2xsVGhyb3R0bGVJbnRlcnZhbDogNDAwLFxuICAgIF9zY3JvbGxIZWlnaHRSZXNlcnZlOiA2MCxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgJ3Nob3dCb29rbGV0JzogdHJ1ZSxcbiAgICAgICAgJ3Nob3dQaG90b3MnOiB0cnVlLFxuICAgICAgICAnc2hvd1JvdXRlU2VhcmNoJzogdHJ1ZVxuICAgIH0sXG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIChPYmplY3QpIC0+IFByb21pc2VcbiAgICAgICAgaWYgKCFyZXN1bHRzLmJ1aWxkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXphdGlvbiBzZXR1cFxuICAgICAgICB0aGlzLmZpcm1DYXJkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFnZSA9IDE7XG4gICAgICAgIHRoaXMuX2hvdXNlT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlybUxpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJtTGlzdE9iamVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zpcm1DYXJkT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25TY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNGaXJtbGlzdE9wZW4gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9pZCA9IHJlc3VsdHMuYnVpbGRpbmcuaWQ7XG4gICAgICAgIHRoaXMuX3RvdGFsUGFnZXMgPSAxO1xuICAgICAgICB0aGlzLl9hcGkgPSB0aGlzLl9jb250cm9sbGVyLmdldENhdGFsb2dBcGkoKTtcbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uc1VybCA9IHRoaXMuX2dldERpcmVjdGlvbnNVcmwocmVzdWx0cy5idWlsZGluZy5uYW1lKTtcbiAgICAgICAgdGhpcy5fZmlybUxpc3RMb2FkZXIgPSB0aGlzLl92aWV3LmluaXRMb2FkZXIodHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5faG91c2VPYmplY3QgPSB0aGlzLl9maWxsSG91c2VPYmplY3QocmVzdWx0cy5idWlsZGluZyk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ob3VzZU9iamVjdCk7XG4gICAgfSxcblxuICAgIF9pc1JvdXRlU2VhcmNoQWxsb3dlZDogZnVuY3Rpb24gKCkgeyAvLygpIC0+IEJvb2xlYW5cbiAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLl9jb250cm9sbGVyLmdldE1hcCgpLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCk7XG4gICAgICAgIHJldHVybiBwcm9qZWN0LnRyYW5zcG9ydCB8fCBwcm9qZWN0LnJvYWRzO1xuICAgIH0sXG5cbiAgICBfZmlybUNhcmRTZXR1cDogZnVuY3Rpb24gKCkgeyAvLygpIC0+IE9iamVjdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVuZGVyOiB0aGlzLl92aWV3LnJlbmRlclRlbXBsYXRlLFxuICAgICAgICAgICAgbGFuZzogdGhpcy5fbWFwLmdldExhbmcoKSxcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5fY29udHJvbGxlci5nZXRNYXAoKS5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmRvbWFpbixcbiAgICAgICAgICAgIGFqYXg6IERHLmJpbmQodGhpcy5fYXBpLmdldEZpcm1JbmZvLCB0aGlzLl9hcGkpLFxuICAgICAgICAgICAgdGltZXpvbmVPZmZzZXQ6IHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS50aW1lT2Zmc2V0LFxuICAgICAgICAgICAgbWFwOiB0aGlzLl9tYXAsXG4gICAgICAgICAgICBwb3B1cDogdGhpcy5fcG9wdXAsXG4gICAgICAgICAgICBpc01vYmlsZTogREcuQnJvd3Nlci5tb2JpbGUsXG4gICAgICAgICAgICBzaG93RW50cmFuY2U6IERHLkVudHJhbmNlLFxuICAgICAgICAgICAgZ290b1VybDogdGhpcy5fZGlyZWN0aW9uc1VybCxcbiAgICAgICAgICAgIG9uRmlybVJlYWR5OiBERy5iaW5kKHRoaXMuX29uRmlybVJlYWR5LCB0aGlzKSxcbiAgICAgICAgICAgIG9uVG9nZ2xlOiBERy5iaW5kKHRoaXMuX3BvcHVwLnJlc2l6ZSwgdGhpcy5fcG9wdXApLFxuICAgICAgICAgICAgc2hvd0Jvb2tsZXQ6IHRoaXMub3B0aW9ucy5zaG93Qm9va2xldCxcbiAgICAgICAgICAgIHNob3dQaG90b3M6IHRoaXMub3B0aW9ucy5zaG93UGhvdG9zLFxuICAgICAgICAgICAgc2hvd1JvdXRlU2VhcmNoOiB0aGlzLm9wdGlvbnMuc2hvd1JvdXRlU2VhcmNoICYmIHRoaXMuX2lzUm91dGVTZWFyY2hBbGxvd2VkKCksXG4gICAgICAgICAgICB0OiBERy5iaW5kKHRoaXMudCwgdGhpcylcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gaW5pdCBzaW5nbGUgZmlybSBjYXJkIGluIGNhc2Ugb2YgcG9pXG4gICAgX2ZpbGxGaXJtQ2FyZE9iamVjdDogZnVuY3Rpb24gKGZpcm1JZCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2Zpcm1DYXJkU2V0dXAoKTtcblxuICAgICAgICB0aGlzLmZpcm1DYXJkID0gbmV3IEZpcm1DYXJkKGZpcm1JZCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2luaXRQb3B1cENsb3NlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcm1DYXJkLmdldENvbnRhaW5lcigpO1xuICAgIH0sXG5cbiAgICBfZmlybUxpc3RTZXR1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2Zpcm1DYXJkU2V0dXAoKTtcblxuICAgICAgICBERy5leHRlbmQob3B0aW9ucywge1xuICAgICAgICAgICAgYmFja0J0bjogREcuYmluZCh0aGlzLl9zaG93SG91c2VQb3B1cCwgdGhpcyksXG4gICAgICAgICAgICBvbkZpcm1DbGljazogREcuYmluZCh0aGlzLl9vbkZpcm1MaXN0Q2xpY2ssIHRoaXMpLFxuICAgICAgICAgICAgb25TaG93TGVzczogREcuYmluZCh0aGlzLl9zaG93SG91c2VQb3B1cCwgdGhpcyksXG4gICAgICAgICAgICBwYXN0ZUxvYWRlcjogREcuYmluZCh0aGlzLl9wYXN0ZUxvYWRlciwgdGhpcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcm1DYXJkOiBvcHRpb25zLFxuICAgICAgICAgICAgZmlybWxpc3RJdGVtVG1wbDogJ2Zpcm1saXN0SXRlbScsXG4gICAgICAgICAgICBvbkxpc3RSZWFkeTogREcuYmluZCh0aGlzLl9yZW5kZXJGaXJtTGlzdCwgdGhpcylcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2luaXRTaG9ydEZpcm1MaXN0OiBmdW5jdGlvbiAoZmlybXMpIHsgLy8oT2JqZWN0KSAtPiBET01FbGVtZW50XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fZmlybUxpc3RTZXR1cCgpO1xuXG4gICAgICAgIHRoaXMuX3Nob3J0RmlybUxpc3QgPSBuZXcgRmlybUNhcmQuTGlzdChmaXJtcywgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3J0RmlybUxpc3QucmVuZGVyTGlzdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdEZpcm1MaXN0OiBmdW5jdGlvbiAocmVzKSB7IC8vKE9iamVjdCkgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlcykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHJlcy5yZXN1bHQuaXRlbXMsXG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5fZmlybUxpc3RTZXR1cCgpO1xuXG4gICAgICAgIG9wdGlvbnMuZmlybUNhcmQuYmFja0J0biA9IERHLmJpbmQodGhpcy5fc2hvd0xpc3RQb3B1cCwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fc2hvcnRGaXJtTGlzdC5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcblxuICAgICAgICB0aGlzLl9maXJtTGlzdCA9IG5ldyBGaXJtQ2FyZC5MaXN0KHJlc3VsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0T2JqZWN0ID0gdGhpcy5fZmlsbEZpcm1MaXN0T2JqZWN0KHRoaXMuX2Zpcm1MaXN0LnJlbmRlckxpc3QoKSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAodGhpcy5fZmlybUxpc3RPYmplY3QpO1xuICAgIH0sXG5cbiAgICBfZmlsbEZpcm1MaXN0T2JqZWN0OiBmdW5jdGlvbiAoZmlybUxpc3QpIHsgLy8oRE9NRWxlbWVudCkgLT4gT2JqZWN0XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG1wbDogZmlybUxpc3QsXG4gICAgICAgICAgICBoZWFkZXI6IHRoaXMuX2hlYWRlcixcbiAgICAgICAgICAgIGZvb3RlcjogdGhpcy5fdmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgICAgIHRtcGw6ICdwb3B1cEZvb3RlckJ0bnMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYnRuczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy50KCdiYWNrX2J1dHRvbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0UG9wdXBDbG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RvdGFsUGFnZXMgPiAxICYmIHNlbGYuX2Zpcm1MaXN0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwidGhpc1wiIGhlcmUgaXMgc2VsZi5fZmlybUxpc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50bXBsLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2VsZi5fZmlybUxpc3RMb2FkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX29uRmlybVJlYWR5OiBmdW5jdGlvbiAoZmlybUNvbnRlbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmaXJtQ29udGVudE9iamVjdC5hZnRlclJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJUaXRsZSA9IHNlbGYuX3BvcHVwLl9wb3B1cFN0cnVjdHVyZS5oZWFkZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci5pZWx0OSkge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJUaXRsZS5vZmZzZXRIZWlnaHQgPiA3MikgeyAvL1RPRE86IG1hZ2ljIG51bWJlclxuICAgICAgICAgICAgICAgICAgICBERy5Eb21VdGlsLmFkZENsYXNzKGhlYWRlclRpdGxlLCAnZGctcG9wdXBfX2hlYWRlci10ZWFzZXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFERy5Ccm93c2VyLndlYmtpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgREcuR2VvY2xpY2tlci5jbGFtcEhlbHBlcihoZWFkZXJUaXRsZSwgMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAoZmlybUNvbnRlbnRPYmplY3QpO1xuICAgIH0sXG5cbiAgICBfc2hvd0hvdXNlUG9wdXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9wdXAub2ZmKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAodGhpcy5faG91c2VPYmplY3QpO1xuICAgICAgICB0aGlzLl9zaG9ydEZpcm1MaXN0Ll90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9vbkZpcm1MaXN0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9wdXAub2ZmKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgfSxcblxuICAgIF9wYXN0ZUxvYWRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9hZGVyV3JhcHBlciAgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLW1hcC1nZW9jbGlja2VyX19wcmVsb2FkZXItd3JhcHBlcicpLFxuICAgICAgICAgICAgbG9hZGVyID0gdGhpcy5fdmlldy5pbml0TG9hZGVyKCk7XG5cbiAgICAgICAgbG9hZGVyV3JhcHBlci5pbnNlcnRCZWZvcmUobG9hZGVyLCBsb2FkZXJXcmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICBsb2FkZXJXcmFwcGVyLnN0eWxlLmhlaWdodCA9IHRoaXMuX3BvcHVwLl9jb250ZW50Tm9kZS5vZmZzZXRIZWlnaHQgLSAxICsgJ3B4JzsgLy8gTUFHSUNcbiAgICAgICAgbG9hZGVyV3JhcHBlci5zdHlsZS53aWR0aCA9IHRoaXMuX3BvcHVwLl9jb250ZW50Tm9kZS5vZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuX2NsZWFyQW5kUmVuZGVyUG9wdXAoe3RtcGw6IGxvYWRlcldyYXBwZXJ9KTtcbiAgICB9LFxuXG4gICAgX2luaXRQb3B1cENsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0ZWRQb3B1cENsb3NlKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRyb2xsZXIuZ2V0TWFwKCkub25jZSgncG9wdXBjbG9zZScsIERHLmJpbmQodGhpcy5fb25Qb3B1cENsb3NlLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfc2hvd0xpc3RQb3B1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlybUxpc3QgPSB0aGlzLl9maXJtTGlzdE9iamVjdDtcblxuICAgICAgICB0aGlzLl9wYXN0ZUxvYWRlcigpO1xuXG4gICAgICAgIGlmICghZmlybUxpc3QpIHtcbiAgICAgICAgICAgIGZpcm1MaXN0ID0gdGhpcy5fYXBpLmZpcm1zSW5Ib3VzZSh0aGlzLl9pZCkudGhlbihERy5iaW5kKHRoaXMuX2luaXRGaXJtTGlzdCwgdGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJBbmRSZW5kZXJQb3B1cChmaXJtTGlzdCk7XG4gICAgICAgICAgICB0aGlzLl9maXJtTGlzdC5fdG9nZ2xlRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9vblNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5fb25TY3JvbGwgPSBERy5VdGlsLnRocm90dGxlKHRoaXMuX2hhbmRsZVBvcHVwU2Nyb2xsLCB0aGlzLl9zY3JvbGxUaHJvdHRsZUludGVydmFsLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvcHVwLm9uKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJGaXJtTGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzRmlybWxpc3RPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cC5yZXNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRmlybWxpc3RPcGVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25Qb3B1cENsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2Zpcm1MaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9maXJtTGlzdC5jbGVhckxpc3QoKTtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1MaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwLm9mZignc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Zpcm1JZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZpcm1DYXJkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcm1DYXJkLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5maXJtQ2FyZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlybUxpc3RMb2FkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlID0gMTtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9pbml0U2hvd01vcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLl9wb3B1cC5maW5kRWxlbWVudCgnLmRnLXBvcHVwX19idXR0b25fbmFtZV9hbGwnKTtcblxuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKCdkZy1wb3B1cF9fYnV0dG9uX25hbWVfYWxsJywgREcuYmluZCh0aGlzLl9zaG93TGlzdFBvcHVwLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFyQW5kUmVuZGVyUG9wdXA6IGZ1bmN0aW9uIChwb3B1cE9iamVjdCkge1xuICAgICAgICB0aGlzLl9jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fcG9wdXAuY2xlYXIoJ2hlYWRlcicsICdmb290ZXInKTtcbiAgICAgICAgdGhpcy5fdmlldy5yZW5kZXJQb3B1cChwb3B1cE9iamVjdCk7XG4gICAgfSxcblxuICAgIF9hcHBlbmRGaXJtTGlzdDogZnVuY3Rpb24gKHJlcykgeyAvLyAoT2JqZWN0KVxuICAgICAgICB0aGlzLl9maXJtTGlzdC5hZGRGaXJtcyhyZXMucmVzdWx0Lml0ZW1zKTtcbiAgICAgICAgdGhpcy5fcG9wdXAuX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVQb3B1cFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHNjcm9sbGVyID0gZS5vcmlnaW5hbEV2ZW50LnRhcmdldCB8fCBlLnRhcmdldC5fc2Nyb2xsZXI7XG5cbiAgICAgICAgREcuRG9tRXZlbnQuc3RvcChlKTtcblxuICAgICAgICBpZiAodGhpcy5fdG90YWxQYWdlcyA8PSAxKSB7IHJldHVybjsgfVxuICAgICAgICBpZiAoc2Nyb2xsZXIgJiYgc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IDw9IHNjcm9sbGVyLnNjcm9sbFRvcCArIHNjcm9sbGVyLm9mZnNldEhlaWdodCArIHRoaXMuX3Njcm9sbEhlaWdodFJlc2VydmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBhZ2luZygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oYW5kbGVQYWdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGFnZSsrO1xuXG4gICAgICAgIGlmICh0aGlzLl90b3RhbFBhZ2VzICYmIHRoaXMuX3BhZ2UgPD0gdGhpcy5fdG90YWxQYWdlcykge1xuICAgICAgICAgICAgdGhpcy5fYXBpLmZpcm1zSW5Ib3VzZSh0aGlzLl9pZCwge3BhZ2U6IHRoaXMuX3BhZ2V9KS50aGVuKERHLmJpbmQodGhpcy5fYXBwZW5kRmlybUxpc3QsIHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wYWdlID09PSB0aGlzLl90b3RhbFBhZ2VzKSB7XG4gICAgICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5fZmlybUxpc3RMb2FkZXI7XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXIgJiYgbG9hZGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsb2FkZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wb3B1cC5vZmYoJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLkhvdXNlLmluY2x1ZGUoe1xuICAgIF9nZXRBZGRyZXNzU3RyaW5nOiBmdW5jdGlvbiAoaG91c2UpIHtcbiAgICAgICAgaWYgKCFob3VzZS5hZGRyZXNzIHx8ICFob3VzZS5hZGRyZXNzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob3VzZS5hZGRyZXNzLmNvbXBvbmVudHNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQudHlwZSA9PT0gJ3N0cmVldF9udW1iZXInO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQuc3RyZWV0ICsgJywgJyArIGNvbXBvbmVudC5udW1iZXI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJyAvICcpO1xuICAgIH0sXG5cbiAgICBfZmlsbEJvZHk6IGZ1bmN0aW9uIChob3VzZSkgeyAvLyAvLyAoT2JqZWN0KSAtPiAoRE9NRWxlbWVudClcbiAgICAgICAgdmFyIGRhdGEgPSB7fSxcbiAgICAgICAgICAgIHdyYXBwZXIgPSBERy5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2RnLWJ1aWxkaW5nLWNhbGxvdXRfX2JvZHknKSxcbiAgICAgICAgICAgIGZpbGlhbHMgPSBob3VzZS5saW5rcyAmJiBob3VzZS5saW5rcy5icmFuY2hlcztcblxuICAgICAgICB2YXIgZHJpbGxkb3duID0gdGhpcy5fZ2V0RHJpbGxkb3duKGhvdXNlKTtcblxuICAgICAgICBpZiAoaG91c2UuYnVpbGRpbmdfbmFtZSkge1xuICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogdGhpcy5fZ2V0QWRkcmVzc1N0cmluZyhob3VzZSksXG4gICAgICAgICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHJpbGxkb3duKSB7XG4gICAgICAgICAgICBkYXRhLmFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgZHJpbGxkb3duOiBkcmlsbGRvd25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnB1cnBvc2UgPSBob3VzZS5wdXJwb3NlX25hbWUgK1xuICAgICAgICAgICAgKGhvdXNlLmZsb29ycyA/ICcsICcgKyB0aGlzLnQoJ25fZmxvb3JzJywgaG91c2UuZmxvb3JzLmdyb3VuZF9jb3VudCkgOiAnJyk7XG5cbiAgICAgICAgaWYgKGZpbGlhbHMgJiYgZmlsaWFscy5jb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsUGFnZXMgPSBNYXRoLmNlaWwoaG91c2UubGlua3MuYnJhbmNoZXMuY291bnQgLyB0aGlzLl9maXJtc09uUGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG91c2UubGlua3MgJiYgaG91c2UubGlua3MuYXR0cmFjdGlvbnMgJiYgaG91c2UubGlua3MuYXR0cmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhLmF0dHJhY3Rpb25zID0gaG91c2UubGlua3MuYXR0cmFjdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhdHRyYWN0aW9ucywgYXR0cmFjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyYWN0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmFjdGlvbnMucHVzaChhdHRyYWN0aW9uLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyYWN0aW9ucztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gdGhpcy5fdmlldy5yZW5kZXIoe1xuICAgICAgICAgICAgdG1wbDogJ2hvdXNlJyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZpbGlhbHMgJiYgZmlsaWFscy5pdGVtcykge1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLl9pbml0U2hvcnRGaXJtTGlzdChmaWxpYWxzLml0ZW1zKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9LFxuXG4gICAgX2ZpbGxIZWFkZXI6IGZ1bmN0aW9uIChob3VzZSkgeyAvLyAoT2JqZWN0KSAtPiAoSFRNTFN0cmluZylcbiAgICAgICAgdmFyIGhlYWRlciA9IHt9O1xuXG4gICAgICAgIGlmIChob3VzZS5idWlsZGluZ19uYW1lKSB7XG4gICAgICAgICAgICBoZWFkZXIudGl0bGUgPSBob3VzZS5idWlsZGluZ19uYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKGhvdXNlLmFkZHJlc3MgJiYgaG91c2UuYWRkcmVzcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBoZWFkZXIudGl0bGUgPSB0aGlzLl9nZXRBZGRyZXNzU3RyaW5nKGhvdXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlci50aXRsZSA9IGhvdXNlLnB1cnBvc2VfbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hlYWRlciA9IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgIHRtcGw6ICdwb3B1cEhlYWRlcicsXG4gICAgICAgICAgICBkYXRhOiBoZWFkZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcbiAgICB9LFxuXG4gICAgX2ZpbGxGb290ZXI6IGZ1bmN0aW9uIChob3VzZSkgeyAvLyAoT2JqZWN0KSAtPiAoSFRNTFN0cmluZylcbiAgICAgICAgdmFyIGJ0bnMgPSBbXTtcbiAgICAgICAgdmFyIGhvdXNlRmlsaWFscyA9IGhvdXNlLmxpbmtzICYmIGhvdXNlLmxpbmtzLmJyYW5jaGVzO1xuXG4gICAgICAgIC8vIERlY2lkZSBpZiB3ZSBuZWVkIHRvIGRpc3BsYXkgJ21vcmUgb3JnYW5pc2F0aW9ucycgYnV0dG9uXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvdXNlRmlsaWFscyAmJlxuICAgICAgICAgICAgaG91c2VGaWxpYWxzLml0ZW1zICYmXG4gICAgICAgICAgICBob3VzZUZpbGlhbHMuaXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICBob3VzZUZpbGlhbHMuY291bnQgPiBob3VzZUZpbGlhbHMuaXRlbXMubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgICAgYnRucy5wdXNoKHRoaXMuX2dldFNob3dBbGxEYXRhKGhvdXNlRmlsaWFscy5jb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzUm91dGVTZWFyY2hBbGxvd2VkKCkpIHtcbiAgICAgICAgICAgIGJ0bnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2dvdG8nLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLnQoJ2dvX3RvJyksXG4gICAgICAgICAgICAgICAgaWNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBocmVmOiB0aGlzLl9kaXJlY3Rpb25zVXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICB0bXBsOiAncG9wdXBGb290ZXJCdG5zJyxcbiAgICAgICAgICAgIGRhdGE6IHsnYnRucyc6IGJ0bnN9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0U2hvd0FsbERhdGE6IGZ1bmN0aW9uIChmaWxpYWxzQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdhbGwnLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMudCgnc2hvd19vcmdhbml6YXRpb25faW5fYnVpbGRpbmcnLCBmaWxpYWxzQ291bnQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIF9maWxsSG91c2VPYmplY3Q6IGZ1bmN0aW9uIChob3VzZSkgeyAvLyAoT2JqZWN0KSAtPiAoT2JqZWN0KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlcjogdGhpcy5fZmlsbEhlYWRlcihob3VzZSksXG4gICAgICAgICAgICB0bXBsOiB0aGlzLl9maWxsQm9keShob3VzZSksXG4gICAgICAgICAgICBmb290ZXI6IHRoaXMuX2ZpbGxGb290ZXIoaG91c2UpLFxuICAgICAgICAgICAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0U2hvd01vcmUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbml0UG9wdXBDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLlBvaSA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5Ib3VzZS5leHRlbmQoe1xuXG4gICAgaGFuZGxlOiBmdW5jdGlvbiAocmVzdWx0cykgeyAvLyAoT2JqZWN0KSAtPiBQcm9taXNlXG4gICAgICAgIGlmICghcmVzdWx0cy5wb2kpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uIHNldHVwXG4gICAgICAgIHRoaXMuZmlybUNhcmQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlID0gMTtcbiAgICAgICAgdGhpcy5faG91c2VPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJtTGlzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zpcm1MaXN0T2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlybUNhcmRPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9vblNjcm9sbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc0Zpcm1saXN0T3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2lkID0gcmVzdWx0cy5wb2kucmVmZXJlbmNlLmlkO1xuICAgICAgICB0aGlzLl90b3RhbFBhZ2VzID0gMTtcbiAgICAgICAgdGhpcy5fYXBpID0gdGhpcy5fY29udHJvbGxlci5nZXRDYXRhbG9nQXBpKCk7XG4gICAgICAgIHRoaXMuX3BvcHVwID0gdGhpcy5fdmlldy5nZXRQb3B1cCgpO1xuICAgICAgICB0aGlzLl9pbml0ZWRQb3B1cENsb3NlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbnNVcmwgPSB0aGlzLl9nZXREaXJlY3Rpb25zVXJsKHJlc3VsdHMucG9pLnJlZmVyZW5jZS5uYW1lKTtcbiAgICAgICAgdGhpcy5fZmlybUxpc3RMb2FkZXIgPSB0aGlzLl92aWV3LmluaXRMb2FkZXIodHJ1ZSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIFBPSSByZWZlcnMgdG8gYSBidWlsZGluZyAoZS5nLiBnYWxsZXJpZXMgaW4gU2FudGlhZ28pLFxuICAgICAgICAvLyBzaG93IGEgYnVpbGRpbmcgY2FsbG91dFxuICAgICAgICBpZiAocmVzdWx0cy5wb2kucmVmZXJlbmNlLnR5cGUgPT09ICdidWlsZGluZycpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2FwaS5nZW9HZXQocmVzdWx0cy5wb2kucmVmZXJlbmNlLmlkKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faG91c2VPYmplY3QgPSBzZWxmLl9maWxsSG91c2VPYmplY3QocmVzdWx0LnJlc3VsdC5pdGVtc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5faG91c2VPYmplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzaG93IGEgZmlybSBjYWxsb3V0XG4gICAgICAgIGlmIChyZXN1bHRzLnBvaS5yZWZlcmVuY2UudHlwZSA9PT0gJ2JyYW5jaCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGaXJtQ2FyZE9iamVjdChyZXN1bHRzLnBvaS5yZWZlcmVuY2UuaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5TaWdodCA9IERHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LmV4dGVuZCh7XG5cbiAgICBoYW5kbGU6IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIChPYmplY3QsIFN0cmluZykgLT4gUHJvbWlzZVxuICAgICAgICBpZiAoIXJlc3VsdHMuYXR0cmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9wdXAgPSB0aGlzLl92aWV3LmdldFBvcHVwKCk7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2ZpbGxTaWdodE9iamVjdChyZXN1bHRzKSk7XG4gICAgfSxcblxuICAgIF9maWxsU2lnaHRPYmplY3Q6IGZ1bmN0aW9uIChyZXN1bHRzKSB7IC8vIChPYmplY3QpIC0+IE9iamVjdFxuICAgICAgICB2YXIgYXR0cmFjdGlvbiA9IHJlc3VsdHMuYXR0cmFjdGlvbixcbiAgICAgICAgICAgIGRhdGEgPSB7fSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgZm9vdGVyID0ge1xuICAgICAgICAgICAgICAgIGJ0bnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2dvdG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMudCgnZ29fdG8nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGF0dHJhY3Rpb24ubmFtZSkge1xuICAgICAgICAgICAgZGF0YS5idWlsZGluZ05hbWUgPSBhdHRyYWN0aW9uLm5hbWU7XG4gICAgICAgICAgICBkYXRhLnB1cnBvc2UgPSBhdHRyYWN0aW9uLnN1YnR5cGVfbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEuYnVpbGRpbmdOYW1lID0gYXR0cmFjdGlvbi5zdWJ0eXBlX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmRlc2NyaXB0aW9uID0gYXR0cmFjdGlvbi5kZXNjcmlwdGlvbjtcblxuICAgICAgICBkYXRhLmRyaWxsRG93biA9IHRoaXMuX2dldERyaWxsZG93bihhdHRyYWN0aW9uKTtcblxuICAgICAgICBpZiAodGhpcy5fY2hlY2tEZXNjRmllbGRIZWlnaHQoZGF0YS5kZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIGRhdGEuc2hvd01vcmVUZXh0ID0gdGhpcy50KCdzaG93X21vcmVfYWJvdXRfc2lnaHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvb3Rlci5idG5zWzBdLmhyZWYgPSB0aGlzLl9nZXREaXJlY3Rpb25zVXJsKGRhdGEuYnVpbGRpbmdOYW1lKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG1wbDogJ3NpZ2h0JyxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBoZWFkZXI6IHRoaXMuX3ZpZXcucmVuZGVyKHtcbiAgICAgICAgICAgICAgICB0bXBsOiAncG9wdXBIZWFkZXInLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsndGl0bGUnOiBkYXRhLmJ1aWxkaW5nTmFtZX1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZm9vdGVyOiB0aGlzLl92aWV3LnJlbmRlcih7XG4gICAgICAgICAgICAgICAgdG1wbDogJ3BvcHVwRm9vdGVyQnRucycsXG4gICAgICAgICAgICAgICAgZGF0YTogZm9vdGVyXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX25lZWRTaG93TW9yZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbml0U2hvd01vcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5faW5pdFBvcHVwQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgX2luaXRQb3B1cENsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0ZWRQb3B1cENsb3NlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250cm9sbGVyLmdldE1hcCgpLm9uY2UoJ3BvcHVwY2xvc2UnLCBERy5iaW5kKHRoaXMuX2NsZWFyUG9wdXAsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5faW5pdGVkUG9wdXBDbG9zZSA9IHRydWU7XG4gICAgfSxcblxuICAgIF9jbGVhclBvcHVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luaXRlZFBvcHVwQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcblxuICAgIF9zaG93TW9yZVRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGVzYy5zdHlsZS5tYXhIZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuX2xpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9saW5rKTtcbiAgICAgICAgdGhpcy5fcG9wdXAucmVzaXplKCk7XG4gICAgfSxcblxuICAgIF9pbml0U2hvd01vcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGluayA9IHRoaXMuX3BvcHVwLmZpbmRFbGVtZW50KCcuZGctbWFwLWdlb2NsaWNrZXJfX3Nob3ctbW9yZS1zaWdodHMtbGluaycpO1xuICAgICAgICB0aGlzLl9kZXNjID0gdGhpcy5fcG9wdXAuZmluZEVsZW1lbnQoJy5kZy1tYXAtZ2VvY2xpY2tlcl9fc2lnaHQtZGVzY3JpcHRpb24nKTtcblxuICAgICAgICBpZiAodGhpcy5fbGluayAmJiB0aGlzLl9kZXNjKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoJ2RnLW1hcC1nZW9jbGlja2VyX19zaG93LW1vcmUtc2lnaHRzLWxpbmsnLCBERy5iaW5kKHRoaXMuX3Nob3dNb3JlVGV4dCwgdGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jaGVja0Rlc2NGaWVsZEhlaWdodDogZnVuY3Rpb24gKGRlc2MpIHtcbiAgICAgICAgdmFyIGVsID0gREcuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICcnKSxcbiAgICAgICAgICAgIGhlaWdodDtcblxuICAgICAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IGRlc2M7XG5cbiAgICAgICAgdGhpcy5fcG9wdXAuX2NvbnRlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB0aGlzLl9wb3B1cC5fY29udGVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB0aGlzLl9uZWVkU2hvd01vcmUgPSAoaGVpZ2h0ID4gNDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9uZWVkU2hvd01vcmU7XG4gICAgfVxufSk7XG4iLCJERy5HZW9jbGlja2VyLlZpZXcgPSBERy5DbGFzcy5leHRlbmQoe1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykgeyAvLyAoT2JqZWN0LCBPYmplY3QpXG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5fcG9wdXAgPSBERy5wb3B1cCh7XG4gICAgICAgICAgICBtYXhIZWlnaHQ6IDMwMCxcbiAgICAgICAgICAgIG1pbkhlaWdodDogNTAsXG4gICAgICAgICAgICBtYXhXaWR0aDogMzg1LFxuICAgICAgICAgICAgbWluV2lkdGg6IDMxMCxcbiAgICAgICAgICAgIHNwcmF3bGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25DbGljazogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgREcuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXRMb2FkZXI6IGZ1bmN0aW9uIChpc1NtYWxsKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbG9hZGVyLmlubmVySFRNTCA9IERHLmR1c3QoJ0RHR2VvY2xpY2tlci9sb2FkZXInLCB7XG4gICAgICAgICAgICBzbWFsbDogaXNTbWFsbCxcbiAgICAgICAgICAgIGFuaW06IHRoaXMuX2RldGVjdENzc0FuaW1hdGlvbigpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsb2FkZXIuZmlyc3RDaGlsZDtcbiAgICB9LFxuXG4gICAgc2hvd1BvcHVwOiBmdW5jdGlvbiAobGF0bG5nLCBjb250ZW50KSB7IC8vIChPYmplY3QpXG4gICAgICAgIHRoaXMuX3BvcHVwXG4gICAgICAgICAgICAuc2V0Q29udGVudChjb250ZW50KVxuICAgICAgICAgICAgLnNldExhdExuZyhsYXRsbmcpXG4gICAgICAgICAgICAub3Blbk9uKHRoaXMuX21hcCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKG9wdGlvbnMpIHsgLy8gKE9iamVjdCkgLT4gU3RyaW5nXG4gICAgICAgIHZhciBodG1sLFxuICAgICAgICAgICAgZGF0YSA9IHt9O1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnRtcGwgPSBvcHRpb25zLnRtcGwgfHwgJyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgaHRtbCA9IHRoaXMucmVuZGVyVGVtcGxhdGUob3B0aW9ucy50bXBsLCBvcHRpb25zLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbCA9IG9wdGlvbnMudG1wbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJlZm9yZVJlbmRlcikge1xuICAgICAgICAgICAgb3B0aW9ucy5iZWZvcmVSZW5kZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBvcHVwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmhlYWRlciA9IG9wdGlvbnMuaGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5mb290ZXIgPSBvcHRpb25zLmZvb3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEuYm9keSA9IGh0bWw7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cC5zZXRDb250ZW50KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFmdGVyUmVuZGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFmdGVyUmVuZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuXG4gICAgcmVuZGVyVGVtcGxhdGU6IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBERy5kdXN0KCdER0dlb2NsaWNrZXIvJyArIG5hbWUsIGRhdGEpO1xuICAgIH0sXG5cbiAgICByZW5kZXJQb3B1cDogZnVuY3Rpb24gKG9wdGlvbnMpIHsgLy8gKE9iamVjdCkgLT4gU3RyaW5nXG4gICAgICAgIG9wdGlvbnMucG9wdXAgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IE9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5fcG9wdXA7XG4gICAgfSxcblxuICAgIF9kZXRlY3RDc3NBbmltYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGZhbHNlLFxuICAgICAgICAgICAgZG9tUHJlZml4ZXMgPSAnV2Via2l0IE1veiBPIG1zIEtodG1sJy5zcGxpdCgnICcpLFxuICAgICAgICAgICAgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgaWYgKGVsbS5zdHlsZS5hbmltYXRpb25OYW1lKSB7IGFuaW1hdGlvbiA9IHRydWU7IH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21QcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlbG0uc3R5bGVbZG9tUHJlZml4ZXNbaV0gKyAnQW5pbWF0aW9uTmFtZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfVxufSk7XG4iLCJERy5HZW9jbGlja2VyLkNvbnRyb2xsZXIgPSBERy5DbGFzcy5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge1xuICAgICAgICAvLyBpZiBoYW5kbGVyIHdvcmtlZCBzdWNjZXNzZnVsbHksIGl0IHNob3VsZCByZXR1cm4gcmVuZGVyaW5nIG9iamVjdCB0aGF0IHdpbGwgYmUgcHJvY2Vzc2VkIGluIFZpZXcgLCBvdGhlcndpc2UgaXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgICAgICAvLyBkZWZhdWx0IGhhbmRsZXIgYWx3YXlzIHNob3VsZCByZXR1cm4gcmVuZGVyaW5nIG9iamVjdFxuICAgICAgICAnaGFuZGxlcnNTZXF1ZW5jZSc6IHtcbiAgICAgICAgICAgICdwb2knOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuUG9pLFxuICAgICAgICAgICAgJ2F0dHJhY3Rpb24nOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuU2lnaHQsXG4gICAgICAgICAgICAnYnVpbGRpbmcnOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuSG91c2UsXG4gICAgICAgICAgICAnc3RyZWV0JzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhLFxuICAgICAgICAgICAgJ2FkbV9kaXYucGxhY2UnOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEsXG4gICAgICAgICAgICAnYWRtX2Rpdi5kaXN0cmljdCc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5DaXR5QXJlYSxcbiAgICAgICAgICAgICdhZG1fZGl2LmRpdmlzaW9uJzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkNpdHlBcmVhLFxuICAgICAgICAgICAgJ2FkbV9kaXYuc2V0dGxlbWVudCc6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5DaXR5QXJlYSxcbiAgICAgICAgICAgICdhZG1fZGl2LmNpdHknOiBERy5HZW9jbGlja2VyLkhhbmRsZXIuQ2l0eUFyZWEsXG5cbiAgICAgICAgICAgICdkZWZhdWx0JzogREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQsXG5cbiAgICAgICAgICAgICdhcGlFcnJvcic6IERHLkdlb2NsaWNrZXIuSGFuZGxlci5BcGlFcnJvclxuXG4vLyAgICAgICAgICAgIHN0YXRpb25fcGxhdGZvcm1cbi8vICAgICAgICAgICAgcHJvamVjdFxuLy8gICAgICAgICAgICBzdGF0aW9uXG4vLyAgICAgICAgICAgIGNyb3NzYnJvYWRcbi8vICAgICAgICAgICAgbWV0cm9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7IC8vIChPYmplY3QsIE9iamVjdClcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuX2NhdGFsb2dBcGkgPSBuZXcgREcuR2VvY2xpY2tlci5Qcm92aWRlci5DYXRhbG9nQXBpKG1hcCk7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBERy5HZW9jbGlja2VyLlZpZXcobWFwKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJIYW5kbGVyUmVzdWx0ID0gREcuYmluZCh0aGlzLl9yZW5kZXJIYW5kbGVyUmVzdWx0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbGFzdEhhbmRsZUNsaWNrQXJndW1lbnRzID0gbnVsbDtcbiAgICB9LFxuXG4gICAgaGFuZGxlUG9wdXBDbG9zZTogZnVuY3Rpb24gKHBvcHVwKSB7IC8vIChPYmplY3QpXG4gICAgICAgIGlmIChwb3B1cCA9PT0gdGhpcy5fdmlldy5nZXRQb3B1cCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0SGFuZGxlQ2xpY2tBcmd1bWVudHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2F0YWxvZ0FwaS5jYW5jZWxMYXN0UmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBtZXRhKSB7IC8vIChPYmplY3QsIE51bWJlciwgT2JqZWN0KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICBmdW5jdGlvbiBiZWZvcmVSZXF1ZXN0ICgpIHtcbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSBzZWxmLl92aWV3LmluaXRMb2FkZXIoKTtcbiAgICAgICAgICAgIHNlbGYuX3ZpZXcuX3BvcHVwLmNsZWFyKCk7XG4gICAgICAgICAgICBzZWxmLl92aWV3LnNob3dQb3B1cChsYXRsbmcsIGxvYWRlcik7XG4gICAgICAgICAgICBzZWxmLl9sYXN0SGFuZGxlQ2xpY2tBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS5saW5rZWQgJiYgbWV0YS5saW5rZWQudHlwZSAhPSAnc2lnaHQnICYmIG1ldGEubGlua2VkLnR5cGUgIT0gJ2F0dHJhY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAobWV0YS5saW5rZWQudHlwZSAhPSAnYnJhbmNoJyAmJiBtZXRhLmxpbmtlZC50eXBlICE9ICdidWlsZGluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJlZm9yZVJlcXVlc3QoKTtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIHBvaToge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IG1ldGEubGlua2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jYXRhbG9nQXBpLmdldExvY2F0aW9ucyh7XG4gICAgICAgICAgICAgICAgbGF0bG5nOiBsYXRsbmcsXG4gICAgICAgICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICAgICAgICBiZWZvcmVSZXF1ZXN0OiBiZWZvcmVSZXF1ZXN0XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZVJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZVJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVJlc3BvbnNlOiBmdW5jdGlvbiAocmVzdWx0KSB7IC8vIChPYmplY3QpXG4gICAgICAgIHZhciB0eXBlO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5IYW5kbGVyKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09PSAnbm8gdHlwZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09ICdhYm9ydGVkJykge1xuICAgICAgICAgICAgdGhpcy5fcnVuSGFuZGxlcignYXBpRXJyb3InKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUgPSB0aGlzLmZpbmRIYW5kbGVyKHJlc3VsdCk7XG5cbiAgICAgICAgd2hpbGUgKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ydW5IYW5kbGVyKHR5cGUsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0W3R5cGVdO1xuXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5maW5kSGFuZGxlcihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3J1bkhhbmRsZXIoJ2RlZmF1bHQnKTtcbiAgICB9LFxuXG4gICAgZmluZEhhbmRsZXI6IGZ1bmN0aW9uIChyZXN1bHQpIHsgLy8gKE9iamVjdCkgLT4gU3RyaW5nfE51bGxcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLm9wdGlvbnMuaGFuZGxlcnNTZXF1ZW5jZSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdFtpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGdldENhdGFsb2dBcGk6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gT2JqZWN0XG4gICAgICAgIHJldHVybiB0aGlzLl9jYXRhbG9nQXBpO1xuICAgIH0sXG5cbiAgICBnZXRNYXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcDtcbiAgICB9LFxuXG4gICAgcmVpbnZva2VIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0SGFuZGxlQ2xpY2tBcmd1bWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2suYXBwbHkodGhpcywgdGhpcy5fbGFzdEhhbmRsZUNsaWNrQXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcnVuSGFuZGxlcjogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHsgLy8gKFN0cmluZywgT2JqZWN0KSAtPiBCb29sZWFuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLl9pbml0SGFuZGxlck9uY2UodHlwZSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW3R5cGVdLmFkZENsaWNrRXZlbnQoKTtcblxuICAgICAgICB2YXIgaGFuZGxlclJlc3VsdCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdLmhhbmRsZShkYXRhLCB0eXBlKTtcblxuICAgICAgICByZXR1cm4gaGFuZGxlclJlc3VsdCAmJiBoYW5kbGVyUmVzdWx0LnRoZW4gP1xuICAgICAgICAgICAgaGFuZGxlclJlc3VsdC50aGVuKHRoaXMuX3JlbmRlckhhbmRsZXJSZXN1bHQpIDpcbiAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQ7XG4gICAgfSxcblxuICAgIF9yZW5kZXJIYW5kbGVyUmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMuX3ZpZXcucmVuZGVyUG9wdXAocmVzdWx0KTtcbiAgICB9LFxuXG4gICAgX2luaXRIYW5kbGVyT25jZTogZnVuY3Rpb24gKHR5cGUpIHsgLy8gKFN0cmluZylcbiAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbdHlwZV0gPSBuZXcgdGhpcy5vcHRpb25zLmhhbmRsZXJzU2VxdWVuY2VbdHlwZV0odGhpcywgdGhpcy5fdmlldywgdGhpcy5fbWFwLCB0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuR2VvY2xpY2tlci5IYW5kbGVyLkRlZmF1bHQuRGljdGlvbmFyeS5pdCA9IERHLmV4dGVuZCh7XG4gICAgYXBpRXJyb3JUaXRsZTogJ09oIG9oLCBjXFwnw6gmbmJzcDt1biZuYnNwO2Vycm9yZScsXG4gICAgYXBpRXJyb3JCb2R5OiAnSSBub3N0cmkgc2VydmVyIHNpIHJpZml1dGFubyBkaSByaXNwb25kZXJlLiBTdGlhbW8gZmFjZW5kbyBkZWwgbm9zdHJvIG1lZ2xpbyBwZXIgY29udmluY2VybGkgYSZuYnNwO2NvbXBvcnRhcnNpIGJlbmUuIFJpdG9ybmEgdHJhIHF1YWxjaGUgbWludXRvLicsXG4gICAgd2VfaGF2ZV9ub3QgOiAnTm9uIGRpc3BvbmlhbW8gYW5jb3JhIGRpIGluZm9ybWF6aW9uaSBzdSBxdWVzdG8gcG9zdG8nLFxuICAgIG5vbmFtZSA6ICdOb21lIG5vbiBpbmRpY2F0bycsXG4gICAgJ2FkbV9kaXYucGxhY2UnIDogJ0x1b2dvJyxcbiAgICAnYWRtX2Rpdi5kaXZpc2lvbicgOiAnWm9uYScsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCcgOiAnQ29tdW5lJyxcbiAgICBzdHJlZXQgOiAnVmlhJyxcbiAgICAnYWRtX2Rpdi5kaXN0cmljdCcgOiAnTXVuaWNpcGFsaXTDoCcsXG4gICAgJ2FkbV9kaXYuY2l0eScgOiAn0KFpdHTDoCcsXG4gICAgZ29fdG8gOiAnQ29tZSBhcnJpdmFyZScsXG4gICAgc2hvd19vcmdhbml6YXRpb25faW5fYnVpbGRpbmcgOiBbJ3tufSBhemllbmRhIGluIHR1dHRvJywgJ3tufSBhemllbmRlIGluIHR1dHRvJ10sXG4gICAgc2hvd19tb3JlX2Fib3V0X3NpZ2h0IDogJ01hZ2dpb3JpIGluZm9ybWF6aW9uaScsXG4gICAgYmFja19idXR0b246ICdJbmRpZXRybycsXG4gICAgbl9mbG9vcnMgOiBbJ3tufSBwaWFubycsICd7bn0gcGlhbmknXVxufSwgREcuRGljdGlvbmFyeS5pdCk7XG4iLCJERy5HZW9jbGlja2VyLkhhbmRsZXIuRGVmYXVsdC5EaWN0aW9uYXJ5LnJ1ID0gREcuZXh0ZW5kKHtcbiAgICBhcGlFcnJvclRpdGxlOiAn0J7RiNC40LHQvtGH0LrQsCDQstGL0YjQu9CwJyxcbiAgICBhcGlFcnJvckJvZHk6ICfQndCw0YjQuCDRgdC10YDQstC10YDRiyDQvtGC0LrQsNC30YvQstCw0Y7RgtGB0Y8g0L7RgtCy0LXRh9Cw0YLRjC4g0JzRiyDRg9C20LUg0L/RgNC40LrQu9Cw0LTRi9Cy0LDQtdC8INCy0YHQtSDRgdC40LvRiywg0YfRgtC+0LHRiyDQstGA0LDQt9GD0LzQuNGC0Ywg0LjRhS4g0JLQvtC30LLRgNCw0YnQsNC50YLQtdGB0Ywg0LombmJzcDvQvdCw0Lwg0YfQtdGA0LXQtyZuYnNwO9C90LXRgdC60L7Qu9GM0LrQviDQvNC40L3Rg9GCLicsXG4gICAgd2VfaGF2ZV9ub3QgOiAn0K3RgtC+INC80LXRgdGC0L4g0LzRiyDQtdGJ0ZEg0L3QtSDRg9GB0L/QtdC70Lgg0LjQt9GD0YfQuNGC0YwnLFxuICAgIG5vbmFtZTogJ9CR0LXQtyDQvdCw0LfQstCw0L3QuNGPJyxcbiAgICAnYWRtX2Rpdi5wbGFjZSc6ICfQnNC10YHRgtC+JyxcbiAgICAnYWRtX2Rpdi5kaXZpc2lvbic6ICfQntC60YDRg9CzJyxcbiAgICAnYWRtX2Rpdi5zZXR0bGVtZW50JzogJ9Cd0LDRgdC10LvQtdC90L3Ri9C5INC/0YPQvdC60YInLFxuICAgIHN0cmVldDogJ9Cj0LvQuNGG0LAnLFxuICAgICdhZG1fZGl2LmRpc3RyaWN0JzogJ9Cg0LDQudC+0L0nLFxuICAgICdhZG1fZGl2LmNpdHknOiAn0JPQvtGA0L7QtCcsXG4gICAgZ29fdG86ICfQn9GA0L7QtdGF0LDRgtGMINGB0Y7QtNCwJyxcbiAgICBzaG93X29yZ2FuaXphdGlvbl9pbl9idWlsZGluZzogWyfQktGB0LXQs9C+IHtufSDQvtGA0LPQsNC90LjQt9Cw0YbQuNGPJywgJ9CS0YHQtdCz0L4ge259INC+0YDQs9Cw0L3QuNC30LDRhtC40LgnLCAn0JLRgdC10LPQviB7bn0g0L7RgNCz0LDQvdC40LfQsNGG0LjQuSddLFxuICAgIHNob3dfbW9yZV9hYm91dF9zaWdodDogJ9Cf0L7QtNGA0L7QsdC90LXQtScsXG4gICAgYmFja19idXR0b246ICfQndCw0LfQsNC0JyxcbiAgICBuX2Zsb29yczogWyd7bn0g0Y3RgtCw0LYnLCAne259INGN0YLQsNC20LAnLCAne259INGN0YLQsNC20LXQuSddXG59LCBERy5EaWN0aW9uYXJ5LnJ1KTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LkRpY3Rpb25hcnkuZW4gPSBERy5leHRlbmQoe1xuICAgIGFwaUVycm9yVGl0bGU6ICdPb3BzISBFcnJvciBkZXRlY3RlZC4nLFxuICAgIGFwaUVycm9yQm9keTogJ091ciBzZXJ2ZXJzIGFyZSBub3QgcmVzcG9uZGluZy4gV2UgYXJlIGRvaW5nIG91ciBiZXN0IHRvIHN0cmFpZ2h0ZW4gdGhlbSBvdXQuIFBsZWFzZSByZXR1cm4gdG8gdXMgaW4gYSBmZXcgbWludXRlcy4nLFxuICAgIHdlX2hhdmVfbm90OiAnV2UgaGF2ZW5cXCd0IGNvbGxlY3RlZCBpbmZvIGFib3V0IHRoaXMgcGxhY2UgeWV0JyxcbiAgICBub25hbWUgOiAnTm8gbmFtZScsXG4gICAgJ2FkbV9kaXYucGxhY2UnIDogJ1BsYWNlJyxcbiAgICAnYWRtX2Rpdi5kaXZpc2lvbicgOiAnQXJlYScsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCcgOiAnVmlsbGFnZScsXG4gICAgc3RyZWV0IDogJ1N0cmVldCcsXG4gICAgJ2FkbV9kaXYuZGlzdHJpY3QnIDogJ0Rpc3RyaWN0JyxcbiAgICAnYWRtX2Rpdi5jaXR5JyA6ICdDaXR5JyxcbiAgICBnb190byA6ICdEaXJlY3Rpb25zIHRvIGhlcmUnLFxuICAgIHNob3dfb3JnYW5pemF0aW9uX2luX2J1aWxkaW5nIDogWyd7bn0gb3JnYW5pemF0aW9uIHRvdGFsJywgJ3tufSBvcmdhbml6YXRpb25zIHRvdGFsJ10sXG4gICAgYmFja19idXR0b24gOiAnQmFjaycsXG4gICAgc2hvd19tb3JlX2Fib3V0X3NpZ2h0IDogJ01vcmUgaW5mb3JtYXRpb24nLFxuICAgIG5fZmxvb3JzIDogWyd7bn0gZmxvb3InLCAne259IGZsb29ycyddXG59LCBERy5EaWN0aW9uYXJ5LmVuKTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LkRpY3Rpb25hcnkuY3MgPSBERy5leHRlbmQoe1xuICAgIGFwaUVycm9yVGl0bGU6ICdDaHliacSNa2Egc2UmbmJzcDt2bG91ZGlsYScsXG4gICAgYXBpRXJyb3JCb2R5OiAnTmHFoWUgc2VydmVyeSBvZG3DrXRhasOtIHJlYWdvdmF0LiBKacW+IG55bsOtIHZ5bmFrbMOhZMOhbWUgdmXFoWtlcsOpIMO6c2lsw60sIGFieWNob20gamUgcMWZaXZlZGxpIGsgcm96dW11LiBaa3VzdGUgYWtjaSBvcGFrb3ZhdCB6YSBuxJtrb2xpayBtaW51dC4nLFxuICAgIHdlX2hhdmVfbm90IDogJ08gdG9tdG8gbcOtc3TEmyB6YXTDrW0gbmVtw6FtZSBpbmZvcm1hY2UnLFxuICAgIG5vbmFtZSA6ICdCZXogbsOhenZ1JyxcbiAgICAnYWRtX2Rpdi5wbGFjZScgOiAnTcOtc3RvJyxcbiAgICAnYWRtX2Rpdi5kaXZpc2lvbicgOiAnU3Byw6F2bsOtIG9idm9kJyxcbiAgICAnYWRtX2Rpdi5zZXR0bGVtZW50JyA6ICdPYmVjJyxcbiAgICBzdHJlZXQgOiAnVWxpY2UnLFxuICAgICdhZG1fZGl2LmRpc3RyaWN0JyA6ICdNxJtzdHNrw6EgxI3DoXN0JyxcbiAgICAnYWRtX2Rpdi5jaXR5JyA6ICdNxJtzdG8nLFxuICAgIGdvX3RvIDogJ0Nlc3RhIHNlbScsXG4gICAgc2hvd19vcmdhbml6YXRpb25faW5fYnVpbGRpbmcgOiBbJ0NlbGtlbSB7bn0gb3JnYW5pemFjZScsICdDZWxrZW0ge259IG9yZ2FuaXphY2UnLCAnQ2Vsa2VtIHtufSBvcmdhbml6YWPDrSddLFxuICAgIGJhY2tfYnV0dG9uIDogJ1pwxJt0JyxcbiAgICBzaG93X21vcmVfYWJvdXRfc2lnaHQgOiAnVsOtY2UnLFxuICAgIG5fZmxvb3JzIDogWyd7bn0gcGF0cm8nLCAne259IHBhdHJhJywgJ3tufSBwYXRlciddXG59LCBERy5EaWN0aW9uYXJ5LmNzKTtcbiIsIkRHLkdlb2NsaWNrZXIuSGFuZGxlci5EZWZhdWx0LkRpY3Rpb25hcnkuZXMgPSBERy5leHRlbmQoe1xuICAgIGFwaUVycm9yVGl0bGU6ICdWYXlhLCBoYSBvY3VycmlkbyB1biBlcnJvcicsXG4gICAgYXBpRXJyb3JCb2R5OiAnTnVlc3Ryb3Mgc2Vydmlkb3JlcyBzZSBuaWVnYW4gYSByZXNwb25kZXIuIFlhIG5vcyBlc3RhbW9zIGVzZm9yemFuZG8gcG9yIGhhY2VybG9zIGVudHJhciBlbiByYXrDs24uIFZ1ZWx2YSBjb24gbm9zb3Ryb3PCoHBhc2Fkb3MgdW5vcyBtaW51dG9zLicsXG4gICAgd2VfaGF2ZV9ub3QgOiAnVG9kYXbDrWEgbm8gaGVtb3MgcmVjb3BpbGFkbyBsYSBpbmZvcm1hY2nDs24gc29icmUgZXN0ZSBsdWdhcicsXG4gICAgbm9uYW1lIDogJ1NpbiBub21icmUnLFxuICAgICdhZG1fZGl2LnBsYWNlJyA6ICdMdWdhcicsXG4gICAgJ2FkbV9kaXYuZGl2aXNpb24nIDogJ0NvbXVuYScsXG4gICAgJ2FkbV9kaXYuc2V0dGxlbWVudCcgOiAnUG9ibGFjacOzbicsXG4gICAgc3RyZWV0IDogJ0NhbGxlJyxcbiAgICAnYWRtX2Rpdi5kaXN0cmljdCcgOiAnQ29tdW5hJyxcbiAgICAnYWRtX2Rpdi5jaXR5JyA6ICdDaXVkYWQnLFxuICAgIGdvX3RvIDogJ0lyIHBhcmEgYWxsw6EnLFxuICAgIHNob3dfb3JnYW5pemF0aW9uX2luX2J1aWxkaW5nIDogWydUb3RhbCB7bn0gb3JnYW5pemFjacOzbicsICdUb3RhbCB7bn0gb3JnYW5pemFjaW9uZXMnLCAnVG90YWwge259IG9yZ2FuaXphY2lvbmVzJ10sXG4gICAgc2hvd19tb3JlX2Fib3V0X3NpZ2h0IDogJ1JlYWQgbW9yZScsXG4gICAgYmFja19idXR0b246ICdBdHLDoXMnLFxuICAgIG5fZmxvb3JzIDogWyd7bn0gcGlzbycsICd7bn0gcGlzb3MnXVxufSwgREcuRGljdGlvbmFyeS5lcyk7XG4iLCJ2YXIgRmlybUNhcmQgPSBmdW5jdGlvbiAoZmlybSwgb3B0aW9ucykge1xuICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QgPSB7fTtcbiAgICB0aGlzLl9zY2hlZHVsZSA9IG5ldyBGaXJtQ2FyZC5TY2hlZHVsZSh7XG4gICAgICAgIGxvY2FsTGFuZzogdGhpcy5vcHRpb25zLmxhbmcsXG4gICAgICAgIGRpY3Q6IHRoaXMuZGljdFxuICAgIH0pO1xuXG4gICAgdGhpcy5yZW5kZXIoZmlybSk7XG59O1xuXG5GaXJtQ2FyZC5wcm90b3R5cGUgPSB7XG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIChmaXJtSWQpIHtcbiAgICAgICAgaWYgKCFmaXJtSWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKGZpcm1JZCAhPT0gdGhpcy5fZmlybUlkKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2FyZEJ5SWQoZmlybUlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9maXJtQ29udGVudE9iamVjdDtcbiAgICB9LFxuXG4gICAgZ2V0U2NoZWR1bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlO1xuICAgIH0sXG5cbiAgICBnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX3JlbmRlckNhcmRCeUlkOiBmdW5jdGlvbiAoZmlybUlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLm9wdGlvbnMuYWpheChmaXJtSWQpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgaWYgKCFyZXMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJlcy5yZXN1bHQuaXRlbXM7XG4gICAgICAgICAgICBpZiAoZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9maXJtRGF0YSA9IGRhdGFbMF07XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGZvciBvbGQgV2ViQVBJIGZvcm1hdC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjYWxsIGFmdGVyIFdlYkFQSSByZWxlYXNlXG4gICAgICAgICAgICAgICAgc2VsZi5fY29udmVydFdlYnNpdGUoKTtcblxuICAgICAgICAgICAgICAgIHNlbGYuX2Zpcm1JZCA9IGZpcm1JZDtcbiAgICAgICAgICAgICAgICBzZWxmLl9yZW5kZXJGaXJtQ2FyZCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3RvZ2dsZUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLl9yZW5kZXJFcnJvcigpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUZpcm1Db250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZmlybS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2RnLW1hcC1maXJtLWZ1bGwtJyArIHRoaXMuX2Zpcm1JZCk7XG4gICAgICAgIGZpcm0uc2V0QXR0cmlidXRlKCdjbGFzcycsICdkZy1tYXAtZmlybS1mdWxsJyk7XG5cbiAgICAgICAgcmV0dXJuIGZpcm07XG4gICAgfSxcblxuICAgIF9nZXRQYXltZW50VHlwZXM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGdyb3VwTmFtZSA9ICdnZW5lcmFsX3BheW1lbnRfdHlwZSc7XG5cbiAgICAgICAgaWYgKCFkYXRhLmF0dHJpYnV0ZV9ncm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmF0dHJpYnV0ZV9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGlmIChncm91cC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci50YWcuc3Vic3RyaW5nKDAsIGdyb3VwTmFtZS5sZW5ndGgpID09PSBncm91cE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXR0ci5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2dyb3VwUnVicmljczogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHByaW1hcnk6IFtdLFxuICAgICAgICAgICAgYWRkaXRpb25hbDogW11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWRhdGEucnVicmljcyB8fCAhZGF0YS5ydWJyaWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEucnVicmljcy5mb3JFYWNoKGZ1bmN0aW9uIChydWJyaWMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtydWJyaWMua2luZF0ucHVzaChydWJyaWMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvLyBTdXBwb3J0IGZvciBvbGQgV2ViQVBJIGZvcm1hdC5cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBmdW5jdGlvbiBhZnRlciBXZWJBUEkgcmVsZWFzZVxuICAgIF9jb252ZXJ0V2Vic2l0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Zpcm1EYXRhLmNvbnRhY3RfZ3JvdXBzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9maXJtRGF0YS5jb250YWN0X2dyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgaWYgKCFncm91cC5jb250YWN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAuY29udGFjdHMuZm9yRWFjaChmdW5jdGlvbiAoY29udGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250YWN0LnR5cGUgIT0gJ3dlYnNpdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhY3QudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QudXJsID0gY29udGFjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJGaXJtQ2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlybUNhcmRCb2R5LCBzY2hlZHVsZSwgZm9yZWNhc3QsIGxpbmtzLCBidG5zLCBwYXltZW50VHlwZXMsIHJ1YnJpY3MsXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZmlybURhdGEsXG4gICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9jcmVhdGVGaXJtQ29udGFpbmVyKCk7XG5cbiAgICAgICAgc2NoZWR1bGUgPSB0aGlzLl9zY2hlZHVsZS50cmFuc2Zvcm0oZGF0YS5zY2hlZHVsZSwge1xuICAgICAgICAgICAgem9uZU9mZnNldDogdGhpcy5vcHRpb25zLnRpbWV6b25lT2Zmc2V0LFxuICAgICAgICAgICAgYXBpTGFuZzogdGhpcy5vcHRpb25zLmxhbmcsXG4gICAgICAgICAgICBsb2NhbExhbmc6IHRoaXMub3B0aW9ucy5sYW5nXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvcmVjYXN0ID0gdGhpcy5fc2NoZWR1bGUuZm9yZWNhc3Qoc2NoZWR1bGUpO1xuXG4gICAgICAgIHBheW1lbnRUeXBlcyA9IHRoaXMuX2dldFBheW1lbnRUeXBlcyhkYXRhKTtcbiAgICAgICAgcnVicmljcyA9IHRoaXMuX2dyb3VwUnVicmljcyhkYXRhKTtcblxuICAgICAgICBmaXJtQ2FyZEJvZHkgPSB0aGlzLl9idWlsZEZpcm1DYXJkQm9keShcbiAgICAgICAgICAgIHRoaXMuX2dldENvbmZpZ0Zpcm1DYXJkQm9keShkYXRhLCBzY2hlZHVsZSwgZm9yZWNhc3QsIHBheW1lbnRUeXBlcywgcnVicmljcylcbiAgICAgICAgKTtcblxuICAgICAgICBsaW5rcyA9IHRoaXMuX2ZpbGxIZWFkZXJMaW5rcygpO1xuICAgICAgICBidG5zID0gdGhpcy5fZmlsbEZvb3RlckJ1dHRvbnMoKTtcblxuICAgICAgICAvL2ZpbGwgb2JqZWN0IGZvciB2aWV3IHJlbmRlclxuICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdC5oZWFkZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyKCdmaXJtQ2FyZEhlYWRlcicsIHsnZmlybU5hbWUnOiBkYXRhLm5hbWUsICdsaW5rcyc6IGxpbmtzfSk7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBmaXJtQ2FyZEJvZHk7XG4gICAgICAgIHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0LnRtcGwgPSBjb250YWluZXI7XG4gICAgICAgIGlmIChidG5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fZm9vdGVyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIHRoaXMuX2Zvb3RlckNvbnRhaW5lci5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMucmVuZGVyKCdwb3B1cEZvb3RlckJ0bnMnLCB7J2J0bnMnOiBidG5zfSk7XG4gICAgICAgICAgICB0aGlzLl9maXJtQ29udGVudE9iamVjdC5mb290ZXIgPSB0aGlzLl9mb290ZXJDb250YWluZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uRmlybVJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub25GaXJtUmVhZHkodGhpcy5fZmlybUNvbnRlbnRPYmplY3QpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZW5kZXJFcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Zpcm1Db250ZW50T2JqZWN0LmhlYWRlciA9IHRoaXMub3B0aW9ucy5yZW5kZXIoJ3BvcHVwSGVhZGVyJywge1xuICAgICAgICAgICAgdGl0bGU6IHRoaXMub3B0aW9ucy50KCdhcGlFcnJvclRpdGxlJylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZmlybUNvbnRlbnRPYmplY3QudG1wbCA9IHRoaXMub3B0aW9ucy50KCdhcGlFcnJvckJvZHknKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uRmlybVJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMub25GaXJtUmVhZHkodGhpcy5fZmlybUNvbnRlbnRPYmplY3QpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRDb25maWdGaXJtQ2FyZEJvZHk6IGZ1bmN0aW9uIChkYXRhLCBzY2hlZHVsZSwgZm9yZWNhc3QsIGF0dHJpYnV0ZXMsIHJ1YnJpY3MpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bXBsOiAnZmlybUNhcmRBZGRyJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGRhdGEuYWRkcmVzc19uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50OiBkYXRhLmFkZHJlc3NfY29tbWVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wbDogJ2Zpcm1DYXJkQ29udGFjdHMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzOiBkYXRhLmNvbnRhY3RfZ3JvdXBzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bXBsOiAnZmlybUNhcmRTY2hlZHVsZScsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZTogc2NoZWR1bGUsXG4gICAgICAgICAgICAgICAgICAgIGZvcmVjYXN0OiBmb3JlY2FzdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wbDogJ2ZyaW1DYXJkUGF5bWVudHMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bWVudHM6IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcGw6ICdmaXJtQ2FyZFJ1YnJpYycsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBydWJyaWNzOiBydWJyaWNzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBfYnVpbGRGaXJtQ2FyZEJvZHk6IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKGJvZHksIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gc2VsZi5vcHRpb25zLnJlbmRlcihpdGVtLnRtcGwsIGl0ZW0uZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gYm9keSArIGh0bWw7XG4gICAgICAgIH0sICcnKTtcbiAgICB9LFxuXG4gICAgX2ZpbGxGb290ZXJCdXR0b25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidG5zID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrQnRuKSB7XG4gICAgICAgICAgICBidG5zLnB1c2goeyBuYW1lOiAnZmlybS1jYXJkLWJhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZGljdC50KHRoaXMub3B0aW9ucy5sYW5nLCAnYnRuQmFjaycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dSb3V0ZVNlYXJjaCkge1xuICAgICAgICAgICAgYnRucy5wdXNoKHsgbmFtZTogJ2dvdG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZGljdC50KHRoaXMub3B0aW9ucy5sYW5nLCAnYnRuRmluZFdheScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHRoaXMub3B0aW9ucy5nb3RvVXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1EYXRhLmxpbmtzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlybURhdGEubGlua3MuZW50cmFuY2VzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNob3dFbnRyYW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGJ0bnMucHVzaCh7IG5hbWU6ICdzaG93LWVudHJhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2J0bkVudHJhbmNlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidG5zO1xuICAgIH0sXG5cbiAgICBfZmlsbEhlYWRlckxpbmtzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5rcyA9IFtdLFxuICAgICAgICAgICAgcmV2aWV3RGF0YSA9IHRoaXMuX2Zpcm1EYXRhLnJldmlld3MsXG4gICAgICAgICAgICBib29rbGV0LFxuICAgICAgICAgICAgbGluaztcblxuICAgICAgICBpZiAodGhpcy5fZmlybURhdGEuZXh0ZXJuYWxfY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlybURhdGEuZXh0ZXJuYWxfY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiBlbC50eXBlID09ICdib29rbGV0Jykge1xuICAgICAgICAgICAgICAgICAgICBib29rbGV0ID0gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV2aWV3RGF0YSAmJiByZXZpZXdEYXRhLmlzX3Jldmlld2FibGUpIHtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdmbGFtcF9zdGFycycsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJldmlld0RhdGEucmF0aW5nICogMjBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2ZsYW1wX3Jldmlld3MnLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmRpY3QudCh0aGlzLm9wdGlvbnMubGFuZywgJ2xpbmtSZXZpZXdzJywgcmV2aWV3RGF0YS5yZXZpZXdfY291bnQgPyByZXZpZXdEYXRhLnJldmlld19jb3VudCA6IDApLFxuICAgICAgICAgICAgICAgIGhyZWY6IEZpcm1DYXJkLkRhdGFIZWxwZXIuZ2V0RmxhbXBVcmwodGhpcy5fZmlybUlkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRyaWV2ZSBwaG90byBkYXRhIGZyb20gZXh0ZXJuYWwgY29udGVudCBibG9ja1xuICAgICAgICB2YXIgcGhvdG9zO1xuICAgICAgICB2YXIgZXh0ZXJuYWxDb250ZW50ID0gdGhpcy5fZmlybURhdGEuZXh0ZXJuYWxfY29udGVudDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dGVybmFsQ29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGV4dGVybmFsQ29udGVudFtpXS50eXBlID09ICdwaG90b19hbGJ1bScgJiZcbiAgICAgICAgICAgICAgICBleHRlcm5hbENvbnRlbnRbaV0uc3VidHlwZSA9PSAnY29tbW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcGhvdG9zID0gZXh0ZXJuYWxDb250ZW50W2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNNb2JpbGUgJiYgcGhvdG9zICYmIHBob3Rvcy5jb3VudCAmJiB0aGlzLm9wdGlvbnMuc2hvd1Bob3Rvcykge1xuICAgICAgICAgICAgbGluayA9IEwuVXRpbC50ZW1wbGF0ZShERy5jb25maWcucGhvdG9zTGluaywge1xuICAgICAgICAgICAgICAgICdpZCc6IHRoaXMuX2Zpcm1JZCxcbiAgICAgICAgICAgICAgICAnZG9tYWluJzogdGhpcy5vcHRpb25zLmRvbWFpblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxpbmtzLnB1c2goe25hbWU6ICdwaG90b3MnLFxuICAgICAgICAgICAgICAgIGhyZWY6IGxpbmssXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZGljdC50KHRoaXMub3B0aW9ucy5sYW5nLCAnbGlua1Bob3RvJywgcGhvdG9zLmNvdW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc01vYmlsZSAmJiBib29rbGV0ICYmIGJvb2tsZXQudXJsICYmIHRoaXMub3B0aW9ucy5zaG93Qm9va2xldCkge1xuICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2Jvb2tsZXQnLFxuICAgICAgICAgICAgICAgIGhyZWY6ICBib29rbGV0LnVybCxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5kaWN0LnQodGhpcy5vcHRpb25zLmxhbmcsICdsaW5rQm9va2xldCcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGxpbmtzO1xuICAgIH0sXG5cbiAgICBfZXZlbnRzOiB7XG4gICAgICAgICdkZy1wb3B1cF9fYnV0dG9uX25hbWVfZmlybS1jYXJkLWJhY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5iYWNrQnRuKCk7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICAnZGctcG9wdXBfX2J1dHRvbl9uYW1lX3Nob3ctZW50cmFuY2UnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbnQgPSBuZXcgdGhpcy5vcHRpb25zLnNob3dFbnRyYW5jZSh7J3ZlY3RvcnMnOiB0aGlzLl9maXJtRGF0YS5saW5rcy5lbnRyYW5jZXNbMF0uZ2VvbWV0cnkudmVjdG9yc30pO1xuICAgICAgICAgICAgZW50LmFkZFRvKHRoaXMub3B0aW9ucy5tYXApO1xuICAgICAgICAgICAgZW50LmZpdEJvdW5kcygpO1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2RnLXNjaGVkdWxlX190b2RheSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fb25Ub2dnbGVTY2hlZHVsZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90b2dnbGVFdmVudEhhbmRsZXJzOiBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICB0aGlzLm9wdGlvbnMucG9wdXBbZmxhZyA/ICdvZmYnIDogJ29uJ10oJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXBbZmxhZyA/ICdvZmYnIDogJ29uJ10oJ3BvcHVwY2xvc2UnLCB0aGlzLl9vbkNsb3NlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIGZvciAodmFyIGV2ZW50Q2xhc3MgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50Q2xhc3MpICYmIHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihldmVudENsYXNzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgREcuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnRDbGFzc10uY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25DbG9zZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlRXZlbnRIYW5kbGVycyh0cnVlKTtcbiAgICB9LFxuXG4gICAgX29uVG9nZ2xlU2NoZWR1bGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5kZy1zY2hlZHVsZV9fdGFibGUnKSxcbiAgICAgICAgICAgIGZvcmVjYXN0ID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5kZy1zY2hlZHVsZV9fbm93JyksXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9jb250YWluZXIucXVlcnlTZWxlY3RvcignLmRnLXNjaGVkdWxlX190b2RheScpLFxuICAgICAgICAgICAgc2hvd0NsYXNzID0gJyBkZy1zY2hlZHVsZV9fdG9kYXlfc2hvd25fdHJ1ZSc7XG5cbiAgICAgICAgaWYgKCFzY2hlZHVsZSkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAoc2NoZWR1bGUuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgc2NoZWR1bGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGZvcmVjYXN0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSA9IHRhcmdldC5jbGFzc05hbWUucmVwbGFjZShzaG93Q2xhc3MsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcmVjYXN0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBzY2hlZHVsZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRhcmdldC5jbGFzc05hbWUgKz0gc2hvd0NsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblRvZ2dsZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uVG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRpb24sXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zLmxhbmcgPSBvcHRpb25zLmxhbmcgfHwgJ3J1JztcblxuICAgICAgICBmb3IgKG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2hhc1RvdWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHxcbiAgICAgICAgICAgICAgICAobmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCkgfHxcbiAgICAgICAgICAgICAgICAobmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwKSk7XG4gICAgfVxufTtcbiIsIkZpcm1DYXJkLkRhdGFIZWxwZXIgPSB7XG5cdHBheU1ldGhvZHMgOiBbXG5cdFx0J2FtZXJpY2FuZXhwcmVzcycsXG5cdFx0J2Nhc2gnLFxuXHRcdCdkaW5lcnNjbHViJyxcblx0XHQnZ29sZGNyb3duJyxcblx0XHQnaW50ZXJuZXQnLFxuXHRcdCdtYXN0ZXJjYXJkJyxcblx0XHQnbm9uY2FzaCcsXG5cdFx0J3Zpc2EnXG5cdF0sXG5cblx0X21zZ3MgOiB7fSxcblxuXHRnZXRGbGFtcFVybCA6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIERHLmNvbmZpZy5mbGFtcFVybC5jb25jYXQoaWQsICc/JywgREcuY29uZmlnLmZsYW1wR29vZ2xlQW5hbHl0aWNzKTtcblx0fSxcblxuXHRtc2cgOiBmdW5jdGlvbiAobXNnKSB7XG5cdFx0aWYgKHRoaXMuX21zZ3MuaGFzT3duUHJvcGVydHkobXNnKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX21zZ3NbbXNnXTtcblx0XHR9XG5cdFx0Y29uc29sZSAmJiBjb25zb2xlLmxvZyhcIkNhbnQndCBmaW5kIHRyYW5zbGF0aW9uIGZvciAnXCIgKyBtc2cgKyBcIicuXCIpO1xuXHRcdHJldHVybiBtc2cudG9TdHJpbmcoKS5yZXBsYWNlKCdfJywgJyAnKTtcblx0fSxcblxuXHRnZXRQcm9qZWN0VGltZTogZnVuY3Rpb24gKHRpbWV6b25lT2Zmc2V0LCB0aW1lKSB7XG4gICAgICAgIHZhciBub3csIHV0YztcblxuICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgbm93ID0gbmV3IERhdGUodGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWV6b25lT2Zmc2V0KSB7XG4gICAgICAgICAgICB1dGMgPSBub3cuZ2V0VGltZSgpICsgKG5vdy5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHV0YyArICg2MDAwMCAqIHRpbWV6b25lT2Zmc2V0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm93O1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qIGdsb2JhbFxuICAgIEZpcm1DYXJkOiBmYWxzZVxuKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgRmlybUNhcmQuTGlzdCA9IGZ1bmN0aW9uIChmaXJtcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9maXJtcyA9IHt9OyAvLyB7J2Zpcm1JRCc6IGZpcm1Eb21PYmp9XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsICdkZy1idWlsZGluZy1jYWxsb3V0X19saXN0Jyk7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyc0luaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maXJtQ2FyZCA9IHRoaXMuX2NyZWF0ZUZpcm0oKTtcbiAgICAgICAgdGhpcy5yZW5kZXJMaXN0KGZpcm1zKTtcbiAgICB9O1xuXG4gICAgRmlybUNhcmQuTGlzdC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgcmVuZGVyTGlzdDogZnVuY3Rpb24gKGZpcm1zKSB7XG4gICAgICAgICAgICBpZiAoZmlybXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaXJtcyhmaXJtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9uTGlzdFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTGlzdFJlYWR5KHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Byb2Nlc3NGaXJtczogZnVuY3Rpb24gKGZpcm1zLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghZmlybXMpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gJ18nICsgYWN0aW9uICsgJ0Zpcm0nO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQXJyYXkoZmlybXMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmaXJtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2RdKGZpcm1zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXShmaXJtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZGRGaXJtczogZnVuY3Rpb24oZmlybXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NGaXJtcyhmaXJtcywgJ2FkZCcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUZpcm1zOiBmdW5jdGlvbihmaXJtcykge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0Zpcm1zKGZpcm1zLCAncmVtb3ZlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0TGFuZzogZnVuY3Rpb24gKG5ld0xhbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5sYW5nID0gbmV3TGFuZztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMYW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpcm1DYXJkLmxhbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyTGlzdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zpcm1zID0ge307XG4gICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJDb250YWluZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVtb3ZlRmlybTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Zpcm1zW2lkXSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9maXJtc1tpZF0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Zpcm1zW2lkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkRmlybTogZnVuY3Rpb24gKGZpcm1EYXRhKSB7XG4gICAgICAgICAgICB2YXIgdG1wbCA9IHRoaXMub3B0aW9ucy5maXJtbGlzdEl0ZW1UbXBsLFxuICAgICAgICAgICAgICAgIGRvbUZpcm0sIGZpcm0sIGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGZpcm0gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmlybURhdGEubmFtZSxcbiAgICAgICAgICAgICAgICBpZDogZmlybURhdGEuaWQuc3BsaXQoJ18nKS5zbGljZSgwLCAxKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCEoZmlybS5pZCBpbiB0aGlzLl9maXJtcykpIHtcblxuICAgICAgICAgICAgICAgIGRvbUZpcm0gPSB0aGlzLl9jcmVhdGVMaXN0SXRlbSgpO1xuXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRtcGwgPyB0aGlzLm9wdGlvbnMuZmlybUNhcmQucmVuZGVyKHRtcGwsIHsnZmlybSc6IGZpcm19KSA6IGZpcm0ubmFtZTtcblxuICAgICAgICAgICAgICAgIGRvbUZpcm0uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCBjb250ZW50KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2Zpcm1zW2Zpcm0uaWRdID0gZG9tRmlybTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tRmlybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZUxpc3RJdGVtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnZGctYnVpbGRpbmctY2FsbG91dF9fbGlzdC1pdGVtJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pc0FycmF5OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVGaXJtOiBmdW5jdGlvbiAoZmlybURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlybUNhcmQoZmlybURhdGEsIHRoaXMub3B0aW9ucy5maXJtQ2FyZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzRW1wdHlPYmo6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZXZlbnRzOiB7XG4gICAgICAgICAgICAnZGctcG9wdXBfX2xpbmsnOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuX2Zpcm1DYXJkLnJlbmRlcih0YXJnZXQuaWQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcm1DYXJkW3RoaXMuX2lzRW1wdHlPYmoocykgPyAncGFzdGVMb2FkZXInIDogJ29uRmlybVJlYWR5J10ocyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlybUNhcmQub25GaXJtQ2xpY2sgJiYgdGhpcy5vcHRpb25zLmZpcm1DYXJkLm9uRmlybUNsaWNrKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZy1idWlsZGluZy1jYWxsb3V0X19saXN0LWl0ZW0nOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbJ2RnLXBvcHVwX19saW5rJ10uY2FsbCh0aGlzLCB0YXJnZXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZy1wb3B1cF9fYnV0dG9uX25hbWVfYmFjayc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5vblNob3dMZXNzKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVFdmVudEhhbmRsZXJzKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF90b2dnbGVFdmVudEhhbmRsZXJzIDogZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJtQ2FyZC5wb3B1cFtmbGFnID8gJ29mZicgOiAnb24nXSgnY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBldmVudENsYXNzIGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnRDbGFzcykgJiYgdGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKGV2ZW50Q2xhc3MpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgREcuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50Q2xhc3NdLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xlYXJDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cbiAgICAgICAgICAgIHdoaWxlIChjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcm1DYXJkIHx8ICh0aGlzLm9wdGlvbnMuZmlybUNhcmQgPSB7fSk7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5maXJtQ2FyZC5sYW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcm1DYXJkLmxhbmcgPSAncnUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG4iLCIvKmdsb2JhbFxuICAgIEZpcm1DYXJkOmZhbHNlXG4qL1xuRmlybUNhcmQuU2NoZWR1bGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5sb2NhbExhbmcgPSBvcHRpb25zLmxvY2FsTGFuZyB8fCAncnUnO1xuICAgIHRoaXMuZGljdCA9IG9wdGlvbnMuZGljdDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkZpcm1DYXJkLlNjaGVkdWxlLnByb3RvdHlwZSA9IHtcblxuICAgIHNldExhbmc6IGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgIHRoaXMubG9jYWxMYW5nID0gbGFuZyB8fCAncnUnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobW9kZWwsIHBhcmFtcykge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikgeyAvLyAoRnVuY3Rpb24sIE9iamVjdCkgLT4gRnVuY3Rpb25cbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2RheUtleSwgLy8gTW9uLCBUdWUgLi4uXG4gICAgICAgICAgICB0b2RheSwgLy8g0J7QsdGK0LXQutGCINC80L7QtNC10LvQuCAtINGC0LXQutGD0YnQuNC5INC00LXQvdGMINC90LXQtNC10LvQuFxuICAgICAgICAgICAgZnJvbSwgLy8g0KHQsNC80L7QtSDRgNCw0L3QvdC10LUg0LLRgNC10LzRjyDQvtGC0LrRgNGL0YLQuNGPINC30LAg0LTQtdC90YxcbiAgICAgICAgICAgIHRvLCAvLyDQodCw0LzQvtC1INC/0L7Qt9C00L3QtdC1INCy0YDQtdC80Y8g0LfQsNC60YDRi9GC0LjRjyDQt9CwINC00LXQvdGMXG4gICAgICAgICAgICB6b25lT2Zmc2V0ID0gcGFyYW1zLnpvbmVPZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIHNjaGVkdWxlID0ge30sIC8vINCe0LHRitC10LrRgi3RgNCw0YHQv9C40YHQsNC90LjQtSwg0YTQvtGA0LzQuNGA0YPQtdC80YvQuSDQv9C+0LQg0YjQsNCx0LvQvtC9XG4gICAgICAgICAgICBub3cgPSBwYXJhbXMubm93IHx8IEZpcm1DYXJkLkRhdGFIZWxwZXIuZ2V0UHJvamVjdFRpbWUoem9uZU9mZnNldCkuZ2V0VGltZSgpLCAvLyBDdXJyZW50IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIHdlZWtLZXlzID0gW10sIC8vINCa0LvRjtGH0Lgg0LTQvdC10Lkg0L3QtdC00LXQu9C4LCDQvtC/0YDQtdC00LXQu9GP0Y7RgiDQv9C+0YDRj9C00L7QuiDQtNC90LXQuSDQuCDQv9C10YDQstGL0Lkg0LTQtdC90Ywg0L3QtdC00LXQu9C4LiAwIC0g0L/QtdGA0LLRi9C5INC00LXQvdGMINC90LXQtNC10LvQuCDQsiDRgNC10LPQuNC+0L3QtSAo0L3QtSDQvtCx0Y/Qt9Cw0YLQtdC70YzQvdC+IE1vbilcbiAgICAgICAgICAgIHdlZWtLZXlzTG9jYWwgPSBbXSxcbiAgICAgICAgICAgIHdlZWtGdWxsS2V5c0xvY2FsID0gW10sXG4gICAgICAgICAgICB3ZWVrS2V5c1Nob3J0ID0gIFsgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0JywgJ1N1bicgXSxcbiAgICAgICAgICAgIHdlZWtLZXlzRnVsbCA9IFsnbW9uZGF5JywndHVlc2RheScsJ3dlZG5lc2RheScsJ3RodXJzZGF5JywnZnJpZGF5Jywnc2F0dXJkYXknLCdzdW5kYXknXSxcbiAgICAgICAgICAgIGxvY2FsTGFuZyA9IHBhcmFtcy5sb2NhbExhbmcgfHwgdGhpcy5sb2NhbExhbmcsXG4gICAgICAgICAgICBsb2NhbFdvcmtpbmdEYXlzID0gcGFyYW1zLmxvY2FsV29ya2luZ0RheXMgfHwgWzAsIDEsIDEsIDEsIDEsIDEsIDBdLFxuICAgICAgICAgICAgZmlyc3RkYXlPZmZzZXQgPSBwYXJhbXMuZmlyc3RkYXlPZmZzZXQgfHwgMSxcbiAgICAgICAgICAgIG1pbkhvdXJzVG9EaXNwbGF5Q2xvc3VyZSA9IHBhcmFtcy5taW5Ib3Vyc1RvRGlzcGxheUNsb3N1cmUgfHwgNCxcbiAgICAgICAgICAgIHQgPSBiaW5kKHRoaXMuZGljdC50LCB0aGlzLmRpY3QpO1xuXG5cbiAgICAgICAgZnVuY3Rpb24gY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEhvdXJzKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgMik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRNaW51dGVzKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMywgMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQmtC+0L3QstC10YDRgtCw0YbQuNGPINCy0YDQtdC80LXQvdC90L7QuSDRgtC+0YfQutC4INGE0L7RgNC80LDRgtCwINCw0L/QuCDQsiDRhNC+0YDQvNCw0YIg0L7RgtC+0LHRgNCw0LbQtdC90LjRjyAoMjU6MDAgLT4gMDE6MDApXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWUoc3RyKSB7XG4gICAgICAgICAgICB2YXIgaG91cnMgPSArZ2V0SG91cnMoc3RyKSAlIDI0ICsgJyc7XG5cbiAgICAgICAgICAgIGlmIChob3Vycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBob3VycyA9ICcwJyArIGhvdXJzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaG91cnMgKyAnOicgKyBnZXRNaW51dGVzKHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQmtC+0L3QstC10YDRgtCw0YbQuNGPIGludCDRh9C40YHQu9CwINCyINC90L7QvNC10YAg0LTQvdGPINC90LXQtNC10LvQuCAo0LTQuNCw0L/QsNC30L7QvSAwLTYpXG4gICAgICAgIGZ1bmN0aW9uIGRheU51bShuKSB7XG4gICAgICAgICAgICByZXR1cm4gbiAlIDc7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10YIg0L/QvtGB0LvQtdC00L3QuNC5INGN0LvQtdC80LXQvdGCINC80LDRgdGB0LjQstCwXG4gICAgICAgIC8vINCS0LfRj9GC0L4g0LjQtyBVbmRlcnNjb3JlLmpzIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNsYXN0XG4gICAgICAgIGZ1bmN0aW9uIGdldEFycmF5TGFzdChhcnIsIG4pIHtcbiAgICAgICAgICAgIGlmICggYXJyID09IG51bGwgKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKCAgIG4gPT0gbnVsbCApIHJldHVybiBhcnJbIGFyci5sZW5ndGggLSAxIF07XG4gICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbCggYXJyLCBNYXRoLm1heChhcnIubGVuZ3RoIC0gbiAsIDApICk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vINCS0YvQv9C+0LvQvdGP0LXRgiDQs9C70YPQsdC+0LrQvtC1INGB0YDQsNCy0L3QtdC90LjQtSDQvtCx0YrQtdC60YLQvtCyXG4gICAgICAgIC8vINCS0LfRj9GC0L4g0LjQtyBVbmRlcnNjb3JlLmpzIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNpc0VxdWFsXG4gICAgICAgIC8vINCj0L/RgNC+0YnQtdC90L4g0LTQu9GPINGC0LXRhSDRgtGA0ZHRhSDRgdGA0LDQstC90LXQvdC40LksINC60L7RgtC+0YDRi9C1INCy0YvQv9C+0LvQvdGP0Y7RgtGB0Y8g0LIgU2hlZHVsZS5qc1xuICAgICAgICBmdW5jdGlvbiBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgICAgIGlmICggb2JqMSA9PT0gb2JqMiApIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKCAhICggb2JqMSBpbnN0YW5jZW9mIE9iamVjdCApIHx8ICEgKCBvYmoyIGluc3RhbmNlb2YgT2JqZWN0ICkgKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIG9iajEuY29uc3RydWN0b3IgIT09IG9iajIuY29uc3RydWN0b3IgKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiBvYmoxICkge1xuICAgICAgICAgICAgICAgIGlmICggISBvYmoxLmhhc093blByb3BlcnR5KCBwcm9wICkgKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoICEgb2JqMi5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICggb2JqMVsgcHJvcCBdID09PSBvYmoyWyBwcm9wIF0gKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVvZiggb2JqMVsgcHJvcCBdICkgIT09IFwib2JqZWN0XCIgKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCAhIGlzRXF1YWwoIG9iajFbIHByb3AgXSwgIG9iajJbIHByb3AgXSApICkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICggcHJvcCBpbiBvYmoyICkge1xuICAgICAgICAgICAgaWYgKCBvYmoyLmhhc093blByb3BlcnR5KCBwcm9wICkgJiYgISBvYmoxLmhhc093blByb3BlcnR5KCBwcm9wICkgKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAgICAgICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAgICAgICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICAgICAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gYXJndW1lbnRzWzJdIHx8IDE7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICB3aGlsZShpZHggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy/Ql9Cw0L/QvtC70L3Rj9C10YIg0YHQstC+0LnRgdGC0LLQsCDQvtCx0YrQtdC60YLQsCDQt9C90LDRh9C10L3QuNGP0LzQuCDQv9C+INGD0LzQvtC70YfQsNC90LjRjlxuICAgICAgICAvL9CS0LfRj9GC0L4g0LjQtyBVbmRlcnNjb3JlLmpzIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNkZWZhdWx0c1xuICAgICAgICBmdW5jdGlvbiBmaWxsRGVmYXVsdHMob2JqKSB7XG4gICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdm9pZCAwKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIC8v0KHQvtGA0YLQuNGA0YPQtdGCINC30L3QsNGH0LXQvdC40Y8g0YHQvtCz0LvQsNGB0L3QviDRgSDQuNGC0LXRgNCw0YLQvtGA0L7QvFxuICAgICAgICAvL9CS0LfRj9GC0L4g0YEgVW5kZXJzY29yZS5qcyBodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jc29ydEJ5XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRCeShvYmosIGl0ZXJhdG9yKXtcbiAgICAgICAgICAgIHJldHVybiBwbHVjayhvYmoubWFwKCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdG9yLmNhbGwodGhpcywgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgICAgICAgICAgICAgfSksICd2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgICAgICBmdW5jdGlvbiBwbHVjayhhcnIsIGtleSl7XG4gICAgICAgICAgICB2YXIgaSwgcnYgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJ2W2ldID0gYXJyW2ldW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vINCf0YDQtdC+0LHRgNCw0LfQvtCy0LDRgtGMINGA0LDRgdC/0LjRgdCw0L3QuNC1INC90LAg0LTQtdC90Ywg0LIg0YPQv9C+0YDRj9C00L7Rh9C10L3QvdGL0Lkg0LzQsNGB0YHQuNCyINCy0YDQtdC80LXQvdC90YvRhSDQvtGC0YHQtdGH0LXQuiAoc3RyaW5nKVxuICAgICAgICAvLyDQodC10LnRh9Cw0YEg0L/QvtC70LDQs9Cw0LXRgtGB0Y8sINGH0YLQviBBUEkg0YPQttC1INCy0YvQtNCw0ZHRgiDRgdC+0YDRgtC40YDQvtCy0LDQvdC90YvQuSDQvNCw0YHRgdC40LJcbiAgICAgICAgZnVuY3Rpb24gZ2V0U29ydGVkVGltZVBvaW50cyhkYXkpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBbXSxcbiAgICAgICAgICAgICAgICBmcm9tLCB0byxcbiAgICAgICAgICAgICAgICBkZWx0YUhvdXJzLCBkZWx0YU1pbnV0ZXM7XG5cbiAgICAgICAgICAgIGlmICghZGF5IHx8ICFkYXkud29ya2luZ19ob3Vycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZGF5LndvcmtpbmdfaG91cnMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IGRheS53b3JraW5nX2hvdXJzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgdG8gPSBkYXkud29ya2luZ19ob3Vyc1tpXS50bztcblxuICAgICAgICAgICAgICAgIGRlbHRhSG91cnMgPSBnZXRIb3Vycyh0bykgLSBnZXRIb3Vycyhmcm9tKTtcbiAgICAgICAgICAgICAgICBkZWx0YU1pbnV0ZXMgPSBnZXRNaW51dGVzKHRvKSAtIGdldE1pbnV0ZXMoZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbHRhSG91cnMgPCAwIHx8IChkZWx0YUhvdXJzID09PSAwICYmIGRlbHRhTWludXRlcyA8PSAwKSkgeyAvLyDQldGB0LvQuCBcItC00L5cIiDQvNC10L3RjNGI0LUg0LjQu9C4INGA0LDQstC90L4gXCLQvtGCXCIgLSDQt9C90LDRh9C40YIg0YPQutCw0LfRi9Cy0LDQtdGCINC90LAg0LfQsNCy0YLRgNCwXG4gICAgICAgICAgICAgICAgICAgIHRvID0gKCtnZXRIb3Vycyh0bykgKyAyNCkgKyAnOicgKyBnZXRNaW51dGVzKHRvKTsgLy8gKDAxOjAwIC0+IDI1OjAwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvaW50c1tpICogMl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9pbnRzW2kgKiAyICsgMV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IHRvLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBkYXkud29ya2luZ19ob3Vycy5sZW5ndGggLSAxID09PSBpID8gJ2Nsb3NlJyA6ICdsdW5jaCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10YIg0LzQsNGB0YHQuNCyIHRpbWVzdGFtcCDQstGB0LXRhSDRgtC+0YfQtdC6LCDQstGB0LXRhSDQtNC90LXQuSDQvdC10LTQtdC70LgsINC+0YIg0YHQtdCz0L7QtNC90Y/RiNC90LXQs9C+INC4INCyINCx0YPQtNGD0YnQtdC1XG4gICAgICAgIC8vINCd0LDQv9GA0LjQvNC10YAsINGB0LXQs9C+0LTQvdGPINGB0YDQtdC00LAsINC+0YLRgdC10YfQutC4INCx0YPQtNGD0YIg0LLQt9GP0YLRiyDQtNC70Y8g0LTQsNGCINGB0L4g0YHRgNC10LTRiyAo0YHQtdCz0L7QtNC90Y8pINC/0L4g0YHQu9C10LTRg9GO0YnQuNC5INCy0YLQvtGA0L3QuNC6INCy0LrQu9GO0YfQuNGC0LXQu9GM0L3QvlxuICAgICAgICBmdW5jdGlvbiBnZXRUaW1lU3RhbXBzKG1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wcyA9IFtdLFxuICAgICAgICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgICAgICAgIHRpbWVQb2ludHMsXG4gICAgICAgICAgICAgICAgbnVtID0gd2Vla0tleXMuaW5kZXhPZih0b2RheUtleSk7IC8vINCd0L7QvNC10YAg0YHQtdCz0L7QtNC90Y/RiNC90LXQs9C+INC00L3RjyDQvdC10LTQtdC70LggKNC00LvRjyDQtNCw0L3QvdC+0LPQviDRgNC10LPQuNC+0L3QsClcblxuXG4gICAgICAgICAgICAvLyDQptC40LrQuyDQv9C+INC00L3Rj9C8INC90LXQtNC10LvQuCDQvdCw0YfQuNC90LDRjyDRgSDRgdC10LPQvtC00L3Rj9GI0L3QtdCz0L5cbiAgICAgICAgICAgIHZhciBqOyAvLyDQndC+0LzQtdGAINGC0LXQutGD0YnQtdCz0L4g0LTQvdGPINCyINC80LDRgdGB0LjQstC1IHdlZWtLZXlzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCA3IDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaiA9IGRheU51bShudW0gKyBpKTtcbiAgICAgICAgICAgICAgICB0aW1lUG9pbnRzID0gZ2V0U29ydGVkVGltZVBvaW50cyhtb2RlbFt3ZWVrS2V5c1tqXV0pO1xuICAgICAgICAgICAgICAgIC8vINCm0LjQutC7INC/0L4g0YLQvtGH0LrQsNC8INCy0YDQtdC80LXQvdC4INGBINC60L7QvdCy0LXRgNGC0LDRhtC40LXQuSDQsiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB0aW1lUG9pbnRzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzA4MyAqL1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm93IC0g0L7QsdGP0LfQsNGC0LXQu9GM0L3QviEg0LjQvdCw0YfQtSDQsdGD0LTQtdGCINCx0YDQsNGC0YzRgdGPINGC0LXQutGD0YnQuNC5IHRpbWVzdGFtcCDRh9GC0L4g0YfRgNC10LLQsNGC0L4g0L3QtdGB0L7QstC/0LDQtNC10L3QuNGP0LzQuCDQv9GA0Lgg0LzQtdC00LvQtdC90L3QvtC8INCx0YvRgdGC0YDQvtC00LXQudGB0YLQstC40LhcbiAgICAgICAgICAgICAgICAgICAgLy8g0JLRi9GH0LjRgdC70LjRgtGMINGC0LDQudC80YHRgtC10LzQvyDQtNC70Y8g0LTQsNC90L3QvtCz0L4g0LTQvdGPINC90LXQtNC10LvQuCwg0YfQsNGB0LAg0Lgg0LzQuNC90YPRgtGLLCDQsiDQsdGD0LTRg9GJ0LXQvCwg0L3QviDQsdC70LjQttCw0LnRiNC40Lkg0Logbm93XG4gICAgICAgICAgICAgICAgICAgIHZhciB0c3AgPSBuZXcgRGF0ZShub3cpO1xuICAgICAgICAgICAgICAgICAgICB0c3Auc2V0RGF0ZSh0c3AuZ2V0RGF0ZSgpK2kpO1xuICAgICAgICAgICAgICAgICAgICB0c3Auc2V0SG91cnMoZ2V0SG91cnMocG9pbnQudGltZSkpO1xuICAgICAgICAgICAgICAgICAgICB0c3Auc2V0TWludXRlcyhnZXRNaW51dGVzKHBvaW50LnRpbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRzID0gdHNwLmdldFRpbWUoKTtcblxuXG5cbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzOiB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHBvaW50LnR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSAmJiB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINCf0LDRgNC90L4g0YPQtNCw0LvRj9C10Lwg0YHQvtCy0L/QsNC00LDRjtGJ0LjQtSDRgtC+0YfQutC4ICjQvtC90Lgg0L3QtSDQuNC80LXRjtGCINGB0LzRi9GB0LvQsCAtINGN0YLQviDRgdC10LPQvtC00L3RjyAyNDowMCDQuCDQt9Cw0LLRgtGA0LAgMDA6MDApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdLnRzID09PSB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0udHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdICYmIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g0J/QsNGA0L3QviDQv9C10YDQtdC90L7RgdC40Lwg0YLQvtGH0LrQuCDQsiDQsdGD0LTRg9GJ0LXQtSwg0LXRgdC70Lgg0L7QvdC4INC+0LHQtSDQsiDQv9GA0L7RiNC70L7QvCAo0L/QtdGA0LLQsNGPINGC0L7Rh9C60LAgKFswXSkg0LTQvtC70LbQvdCwINCx0YvRgtGMINCy0YHQtdCz0LTQsCDQvtGC0LrRgNGL0YLQuNC10LwhKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXS50cyA8PSBub3cgJiYgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdLnRzIDw9IG5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXS50cyArPSAoNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXS50cyArPSAoNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGpzaGludCArVzA4MyAqL1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vINCh0L7RgNGC0LjRgNGD0LXQvCDQvdCwINCy0L7Qt9GA0LDRgdGC0LDQvdC40LUsINCy0LXQtNGMINCy0L7Qt9C80L7QttC90L4g0LHRi9C70Lgg0L/QtdGA0LXQvdC+0YHRiyDQsiDQsdGD0LTRg9GJ0LXQtVxuICAgICAgICAgICAgdGltZXN0YW1wcyA9IHNvcnRCeSh0aW1lc3RhbXBzLCBmdW5jdGlvbiAodGltZXN0YW1wKSB7IHJldHVybiB0aW1lc3RhbXAudHM7IH0pO1xuXG4gICAgICAgICAgICAvLyDQo9C00LDQu9GP0LXQvCDQv9C+0L/QsNGA0L3QviDRgdC+0LLQv9Cw0LTQsNGO0YnQuNC1INGC0L7Rh9C60Lgg0LLRgNC10LzQtdC90LhcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzW2kgKyAxXSAmJiB0aW1lc3RhbXBzW2ldLnRzID09PSB0aW1lc3RhbXBzW2kgKyAxXS50cykge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2godGltZXN0YW1wc1tpXS50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g0J/RgNC+0LLQtdGA0LrQsCDQvdCwINC10LbQtdC00L3QtdCy0L3Qvi3QutGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvtGB0YLRjFxuICAgICAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDIgJiYgKG91dFsxXSAtIG91dFswXSkgPT09ICg3ICogMjQgKiA2MCAqIDYwICogMTAwMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd2hlbk9wZW5JbnZlcnNlKGgsIGQsIG51bSkge1xuICAgICAgICAgICAgaWYgKGQgPT09IDEgJiYgaCA+IG1pbkhvdXJzVG9EaXNwbGF5Q2xvc3VyZSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdChsb2NhbExhbmcsICd0b21tb3JvdycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkID4gMSkge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzAxNSAqL1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dFN1bicpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRNb24nKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gdChsb2NhbExhbmcsICduZXh0VHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dFdlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiB0KGxvY2FsTGFuZywgJ25leHRUaHUnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gdChsb2NhbExhbmcsICduZXh0RnJpJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIHQobG9jYWxMYW5nLCAnbmV4dFNhdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgK1cwMTUgKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cblxuICAgICAgICAvL9CS0L7Qt9Cy0YDQsNGJ0LDQtdGCINC40L3RgtC10YDQstCw0Lsg0LIg0YbQtdC70YvRhSDQtNC90Y/RhSwg0YEg0L/QvtC/0YDQsNCy0LrQvtC5INC90LAg0YHQvNC10L3RgyDQtNC90Y8g0LIg0L/QvtC70L3QvtGH0YwsINC80LXQttC00YNcbiAgICAgICAgLy8gQHBhcmFtIHRpbWVzdGFtcEVuZCDQuCBAcGFyYW0gZGF0ZVN0YXJ0XG4gICAgICAgIGZ1bmN0aW9uIGRheUludGVydmFsKHRpbWVzdGFtcEVuZCwgZGF0ZVN0YXJ0KSB7XG5cbiAgICAgICAgICAgIHZhciBvbmVEYXkgPSAxMDAwICogNjAgKiA2MCAqIDI0LFxuICAgICAgICAgICAgICAgIGRhdGVFbmQgPSBuZXcgRGF0ZSh0aW1lc3RhbXBFbmQudHMpO1xuXG4gICAgICAgICAgICB2YXIgZGlmZjtcblxuICAgICAgICAgICAgZGlmZiA9IE1hdGgucm91bmQoKGRhdGVFbmQgLSBkYXRlU3RhcnQpIC8gb25lRGF5KTtcblxuICAgICAgICAgICAgaWYoIHRpbWVzdGFtcEVuZC50eXBlPT09J29wZW4nICYmIGRhdGVFbmQuZ2V0SG91cnMoKSA8IDEgKVxuICAgICAgICAgICAgICAgIHsgZGlmZiArKzsgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8g0J/QvtC80LXRgdGC0LjRgtGMINC00LDQvdC90YvQtSDQsiDQvtCx0YrQtdC60YIg0LTQu9GPINGI0LDQsdC70L7QvdCwINC+INGB0LXQs9C+0LTQvdGP0YjQvdC10Lwg0LTQvdC1XG4gICAgICAgIGZ1bmN0aW9uIHNldFRvZGF5U3RyaW5nKHRvZGF5KSB7XG5cbiAgICAgICAgICAgIHZhciB0aW1lUG9pbnRzLFxuICAgICAgICAgICAgICAgIHBlcmlvZHMgPSBbXSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBzO1xuXG4gICAgICAgICAgICBzY2hlZHVsZS5ub3cgPSB7fTtcblxuICAgICAgICAgICAgLy8gVGltZXN0YW1wcyDQstGB0LXRhSDQvtGC0YHQtdGH0LXQulxuICAgICAgICAgICAgdGltZXN0YW1wcyA9IGdldFRpbWVTdGFtcHMobW9kZWwpO1xuXG4gICAgICAgICAgICBpZiAoIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUuYWx3YXlzID0gdHJ1ZTsgLy8g0KDQsNCx0L7RgtCw0LXRgiDQtdC20LXQtNC90LXQstC90L4g0LrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L5cbiAgICAgICAgICAgICAgICBzY2hlZHVsZS5ub3cub3BlbiA9IHRydWU7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGltZXN0YW1wcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyDQn9C+0L/QsNC70Lgg0LzQtdC20LTRgyDRgtC+0YfQutCw0LzQuCBpLTEg0LggaSAvLyDQnNGLINC90LDRhdC+0LTQuNC80YHRjyDQt9Cw0LLQtdC00L7QvNC+INCyINCx0YPQtNGD0YnQtdC8INC+0YLQvdC+0YHQuNGC0LXQu9GM0L3QviAxXG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSAodGltZXN0YW1wc1tpIC0gMV0gJiYgdGltZXN0YW1wc1tpIC0gMV0udHMgfHwgMCkgJiYgbm93IDwgdGltZXN0YW1wc1tpXS50cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IE1hdGguZmxvb3IoKHRpbWVzdGFtcHNbaV0udHMgLSBub3cpIC8gKDEwMDAgKiA2MCAqIDYwKSksIC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INGH0LDRgdC+0LIg0LTQviDRgdC70LXQtNGD0Y7RidC10LPQviB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBNYXRoLmZsb29yKCh0aW1lc3RhbXBzW2ldLnRzIC0gbm93KSAvICgxMDAwICogNjApIC0gaCAqIDYwKSwgLy8g0JrQvtC70LjRh9C10YHRgtCy0L4g0LzQuNC90YPRgiAo0LHQtdC3INGH0LDRgdC+0LIpINC00L4g0YHQu9C10LTRg9GO0YnQtdCz0L4gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlOb3cgPSBuZXcgRGF0ZShub3cpLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQvtGC0LrRgNGL0YLQviDQtdGB0LvQuCDRgdC70LXQtNGD0Y7RidCw0Y8g0LjRgtC10YDQsNGG0LjRjyDQvdC1INC+0YLQutGA0YvRgtC40LVcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vd0lzT3BlbiA9IHRpbWVzdGFtcHNbaV0udHlwZSAhPT0gJ29wZW4nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBkID0gZGF5T2ZZZWFyKGRheVRzKSAtIGRheU9mWWVhcihkYXlOb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgZCA9IGRheUludGVydmFsKGRheVRzLCBkYXlOb3csIG5vd0lzT3Blbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGRheUludGVydmFsKHRpbWVzdGFtcHNbaV0sIGRheU5vdyk7XG5cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vINC+0LrRgNGD0LPQu9GP0LXQvCDQvNC40L3Rg9GC0Ysg0LTQviDQutGA0LDRgtC90YvRhSA1XG4gICAgICAgICAgICAgICAgICAgIG0gPSBNYXRoLmZsb29yKG0gLyAxMCkgKiAxMCA/IE1hdGguZmxvb3IobSAvIDEwKSAqIDEwIDogNTtcblxuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZS5ub3cub3BlbiA9IG5vd0lzT3BlbjtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUubm93Lmx1bmNoID0gISEodGltZXN0YW1wc1tpIC0gMV0gJiYgdGltZXN0YW1wc1tpIC0gMV0udHlwZSA9PT0gJ2x1bmNoJyB8fCBnZXRBcnJheUxhc3QodGltZXN0YW1wcykudHlwZSA9PT0gJ2x1bmNoJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUud2lsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbGxUeXBlOiB0aW1lc3RhbXBzW2ldLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG06IG1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyDQmtC+0LPQtNCwINC30LDQutGA0L7QtdGC0YHRjyDQuNC70Lgg0L7RgtC60YDQvtC10YLRgdGPXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWxsV2hlbiA9IG5ldyBEYXRlKHRpbWVzdGFtcHNbaV0udHMpO1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZS53aWxsLndoZW4gPSB3aGVuT3BlbkludmVyc2UoaCwgZCwgd2lsbFdoZW4uZ2V0RGF5KCkpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbGxUaWxsID0gbmV3IERhdGUodGltZXN0YW1wc1tpXS50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJIb3VycyA9IHdpbGxUaWxsLmdldEhvdXJzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJNaW51dGVzID0gd2lsbFRpbGwuZ2V0TWludXRlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJIb3VycyA8IDEwKSB7IHN0ckhvdXJzID0gJzAnICsgc3RySG91cnM7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ck1pbnV0ZXMgPCAxMCkgeyBzdHJNaW51dGVzID0gJzAnICsgc3RyTWludXRlczsgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlLndpbGwudGlsbCA9IHN0ckhvdXJzKyc6JytzdHJNaW51dGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0b2RheSkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8g0J3QsCDRgdC10LPQvtC00L3RjyDRgNCw0YHQv9C40YHQsNC90LjRjyDQvdC10YIgLSDRgdC10LnRh9Cw0YEg0LfQsNC60YDRi9GC0L5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGltZVBvaW50cyA9IHBsdWNrKGdldFNvcnRlZFRpbWVQb2ludHModG9kYXkpLCAndGltZScpO1xuXG4gICAgICAgICAgICAvLyDQptC40LrQuyDQv9C+INC/0LXRgNC40L7QtNCw0Lwg0YDQsNCx0L7RgtGLINC30LAg0LTQtdC90YxcbiAgICAgICAgICAgIGZvciAoaSA9IDIgOyBpIDwgdGltZVBvaW50cy5sZW5ndGggOyBpID0gaSArIDIpIHtcbiAgICAgICAgICAgICAgICBwZXJpb2RzLnB1c2goeyBmcm9tOiB0aW1lUG9pbnRzW2kgLSAxXSwgdG86IHRpbWVQb2ludHNbaV0gfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb20gPSBmb3JtYXRUaW1lKHRpbWVQb2ludHNbMF0pO1xuICAgICAgICAgICAgdG8gPSBmb3JtYXRUaW1lKHRpbWVQb2ludHNbdGltZVBvaW50cy5sZW5ndGggLSAxXSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykgeyAvLyDQmtGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlLnRvZGF5ID0ge1xuICAgICAgICAgICAgICAgICAgICBhbGx0aW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGx0aW1lU3RyOiB0KGxvY2FsTGFuZywgJ3dvcmtzQXJvdW5kVGhlQ2xvY2snKSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogJzAwOjAwJyxcbiAgICAgICAgICAgICAgICAgICAgdG86ICcyNDowMCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8g0J7RgiBmcm9tINC00L4gdG9cbiAgICAgICAgICAgICAgICBzY2hlZHVsZS50b2RheSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHRvXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBlcmlvZHMubGVuZ3RoID4gMCkgeyAvLyDQn9C10YDQtdGA0YvQstGLINC90LAg0L7QsdC10LRcbiAgICAgICAgICAgICAgICBzY2hlZHVsZS5sdW5jaCA9IHBlcmlvZHM7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUubHVuY2hTdHIgPSB0KGxvY2FsTGFuZywgJ2x1bmNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQpNC+0YDQvNC40YDQvtCy0LDQvdC40LUg0L7QsdGK0LXQutGC0LAt0YLQsNCx0LvQuNGG0Yst0YDQsNGB0L/QuNGB0LDQvdC40Y8g0LTQu9GPINGI0LDQsdC70L7QvdCwXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBbXSxcbiAgICAgICAgICAgICAgICBoYXNMdW5jaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCA7IGogPCA3IDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRheUtleSA9IHdlZWtLZXlzW2pdLFxuICAgICAgICAgICAgICAgICAgICBsdW5jaE1heExlbmd0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5bal0gPSB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RlbFtkYXlLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXkgPSBtb2RlbFtkYXlLZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZVBvaW50cyA9IHBsdWNrKGdldFNvcnRlZFRpbWVQb2ludHMoZGF5KSwgJ3RpbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGx1bmNoID0gW107IC8vINCe0YLRgNC10LfQutC4INCy0YDQtdC80LXQvdC4ICjQvtGC0YHQvtGA0YLQuNGA0L7QstCw0L3QvdGL0LUg0LzQvtC80LXQvdGC0YspINC90LAg0L7QsdC10LTRi1xuXG4gICAgICAgICAgICAgICAgICAgIC8vINCm0LjQutC7INC/0L4g0L/QtdGA0LjQvtC00LDQvCDRgNCw0LHQvtGC0Ysg0LfQsCDQtNC10L3RjFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMiA7IGkgPCB0aW1lUG9pbnRzLmxlbmd0aCA7IGkgPSBpICsgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTHVuY2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbHVuY2gucHVzaCh7IGZyb206IHRpbWVQb2ludHNbaSAtIDFdLCB0bzogdGltZVBvaW50c1tpXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsdW5jaE1heExlbmd0aCA9IE1hdGgubWF4KHRpbWVQb2ludHMubGVuZ3RoIC8gMiwgbHVuY2hNYXhMZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbltqXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGZvcm1hdFRpbWUodGltZVBvaW50c1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogZm9ybWF0VGltZSh0aW1lUG9pbnRzW3RpbWVQb2ludHMubGVuZ3RoIC0gMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbHVuY2g6IGx1bmNoXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRheUtleSA9PT0gdG9kYXlLZXkpIHsgLy8g0KHQtdCz0L7QtNC90Y/RiNC90LjQuSDQtNC10L3RjCDQvdCw0LTQviDQv9C+0LTRgdCy0LXRgtC40YLRjFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5bal0uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5bal0ua2V5ID0gd2Vla0tleXNMb2NhbFtqXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g0JTQvtC/0L7Qu9C90LXQvdC40LUg0L/Rg9GB0YLRi9C80Lgg0L7QsdGK0LXQutGC0LDQvNC4INC80LDRgdGB0LjQstC+0LIgbHVuY2hcbiAgICAgICAgICAgIGNvbHVtbi5mb3JFYWNoKCBmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5sdW5jaCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsRGVmYXVsdHMoY29sLmx1bmNoLCByYW5nZSgxLCBsdW5jaE1heExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRhYmxlOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgaGFzTHVuY2g6IGhhc0x1bmNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0KHQs9C10L3QtdGA0LjRgNC+0LLQsNGC0Ywg0YHRgtGA0L7QutGDINC00LvRjyDQstGB0LXRhSDQtNC90LXQuSBtb2RlbCwg0YHQvtCy0L/QsNC00LDRjtGJ0LjRhSDRgSBkYXlcbiAgICAgICAgZnVuY3Rpb24gbWFrZVNpbXBsZVN0cmluZyhkYXksIG1vZGVsKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzLFxuICAgICAgICAgICAgICAgIG91dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF5TGlzdDogW10sXG4gICAgICAgICAgICAgICAgICAgIGx1bmNoOiBbXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbHVuY2hlc1RpbWUgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGRheSAmJiBkYXkud29ya2luZ19ob3VycyAmJiBkYXkud29ya2luZ19ob3Vycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBwbHVjayhnZXRTb3J0ZWRUaW1lUG9pbnRzKGRheSksICd0aW1lJyk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLmZvckVhY2goIGZ1bmN0aW9uIChwb2ludCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5mcm9tID0gZm9ybWF0VGltZShwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnRvID0gZm9ybWF0VGltZShwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsdW5jaGVzVGltZS5wdXNoKGZvcm1hdFRpbWUocG9pbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHVuY2hlc1RpbWUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Lmx1bmNoLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbHVuY2hlc1RpbWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogbHVuY2hlc1RpbWVbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbHVuY2hTdHI6IGNhcGl0YWxpc2VGaXJzdExldHRlcih0KGxvY2FsTGFuZywgJ2x1bmNoJykpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvdXQuZnJvbSA9PSAnMDA6MDAnICYmIG91dC50byA9PSAnMDA6MDAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC50byA9ICcyNDowMCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRheS5yb3VuZF90aGVfY2xvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmFsbHRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvdXQuYWxsdGltZVN0ciA9IHQobG9jYWxMYW5nLCAnd29ya3NBcm91bmRUaGVDbG9jaycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vINCS0YvRhdC+0LTQvdC+0LlcbiAgICAgICAgICAgICAgICBvdXQuaG9saWRheSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vINCk0L7RgNC80LjRgNGD0LXQvCDRgdC/0LjRgdC+0Log0LTQvdC10Lkg0L3QsCDQu9C+0LrQsNC70YzQvdC+0Lwg0Y/Qt9GL0LrQtVxuICAgICAgICAgICAgdmFyIGdyb3VwV29ya2luZ0RheXMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMF07IC8vINCk0LvQsNCz0Lgg0YDQsNCx0L7RgtGLINGE0LjRgNC80Ysg0LIg0LTQvdC4INGC0LXQutGD0YnQtdC5INCz0YDRg9C/0L/Ri1xuICAgICAgICAgICAgdmFyIGZsb3cgPSAwO1xuXG4gICAgICAgICAgICB3ZWVrS2V5cy5mb3JFYWNoKCBmdW5jdGlvbiAoZGF5S2V5LCBudW1LZXkpIHsgLy8gJ01vbicsIDBcbiAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbChtb2RlbFtkYXlLZXldLCBkYXkpIHx8ICghbW9kZWxbZGF5S2V5XSAmJiBkYXkgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5kYXlMaXN0LnB1c2god2Vla0Z1bGxLZXlzTG9jYWxbbnVtS2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwV29ya2luZ0RheXNbZGF5TnVtKG51bUtleSArIGZpcnN0ZGF5T2Zmc2V0KV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBmbG93Kys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsb3cgPiAyKSB7IC8vINCR0L7Qu9C10LUgMiDQtNC90LXQuSDQv9C+0LTRgNGP0LRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0RGF5ID0gb3V0LmRheUxpc3QucG9wKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxIDsgaSA8IGZsb3cgLSAxIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmRheUxpc3QucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5kYXlMaXN0W291dC5kYXlMaXN0Lmxlbmd0aCAtIDFdICs9ICcg4oCUICcgKyBsYXN0RGF5O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmxvdyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vINCh0L/QuNGB0L7QuiDQtNC90LXQuSDQsiDQtNCw0L3QvdC+0Lkg0LPRgNGD0L/Qv9C1INC40LTQtdC90YLQuNGH0LXQvSDRgdC/0LjRgdC60YMg0LHRg9C00L3QuNGFINC00L3QtdC5LCDQt9C90LDRh9C40YIg0LzQvtC20L3QviDQt9Cw0LzQtdC90LjRgtGMINGB0LvQvtCy0L7QvCBcItCR0YPQtNC90LhcIlxuICAgICAgICAgICAgb3V0LmJ1ZG5pID0gaXNFcXVhbChsb2NhbFdvcmtpbmdEYXlzLCBncm91cFdvcmtpbmdEYXlzKTtcbiAgICAgICAgICAgIC8vINCh0L/QuNGB0L7QuiDRgNCw0LHQvtGH0LjRhSDQtNC90LXQuSAtINCy0YHQtSDQtNC90Lgg0L3QtdC00LXQu9C4LCDQt9C90LDRh9C40YIg0L3Rg9C20L3QviDQstGL0LLQvtC00LjRgtGMINGE0YDQsNC30YMgXCLQldC20LXQtNC90LXQstC90L5cIlxuICAgICAgICAgICAgb3V0LmV2ZXJ5ZGF5ID0gKCBNYXRoLm1pbi5hcHBseShNYXRoLCBncm91cFdvcmtpbmdEYXlzKSA9PT0gMSApO1xuXG4gICAgICAgICAgICBpZiAoIG91dC5ob2xpZGF5ICkgeyBvdXQuaG9saWRheVN0ciA9IHQobG9jYWxMYW5nLCAncmVzdERheScsIG91dC5kYXlMaXN0Lmxlbmd0aCkuc2xpY2UoMik7IH1cblxuICAgICAgICAgICAgLy8g0JTQtdC70LDQtdC8INC40Lcg0LzQsNGB0YHQuNCy0LAg0YHRgtGA0L7QutGDINC4INC/0L7QtNC90LjQvNCw0LXQvCDQv9C10YDQstGL0Lkg0YHQuNC80LLQvtC7XG4gICAgICAgICAgICBvdXQuZGF5TGlzdCA9IG91dC5kYXlMaXN0LmpvaW4oJywgJyk7XG4gICAgICAgICAgICBvdXQuZGF5TGlzdCA9IG91dC5kYXlMaXN0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3V0LmRheUxpc3Quc2xpY2UoMSk7XG5cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINC80LDRgdGB0LjQsiBzaW1wbGUg0YHRgtGA0L7QuiDQvdCwINC+0YHQvdC+0LLQtSDQvNCw0YHRgdC40LLQsCDQtNC90LXQuSBkYXlzXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBZHZhbmNlZFN0cmluZyhkYXlzLCBtb2RlbCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGF5cy5sZW5ndGggLSAxIDsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobWFrZVNpbXBsZVN0cmluZyhkYXlzW2ldLCBtb2RlbCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JfQsNC/0L7Qu9C90Y/QtdC8INC90LDQt9Cy0LDQvdC40Y8g0LTQvdC10Lkg0L3QtdC00LXQu9C4LCAxIC0g0L/QvtC90LXQtNC10LvRjNC90LjQui4g0JIg0LfQsNC/0L7Qu9C90LXQvdC90YvRhSDQvNCw0YHRgdC40LLQsNGFINC/0L7QvdC10LTQtdC70YzQvdC40Log0Y3RgtC+IDBcblxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCA3IDsgaSsrKSB7XG4gICAgICAgICAgICB3ZWVrS2V5c1tpXSA9IHdlZWtLZXlzU2hvcnRbaV07XG4gICAgICAgICAgICB3ZWVrS2V5c0xvY2FsW2ldID0gdGhpcy5kaWN0LnQobG9jYWxMYW5nLCB3ZWVrS2V5c1Nob3J0W2ldLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgd2Vla0Z1bGxLZXlzTG9jYWxbaV0gPSB0aGlzLmRpY3QudChsb2NhbExhbmcsIHdlZWtLZXlzRnVsbFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyDQktGL0YfQuNGB0LvRj9C10Lwg0YHQtdCz0L7QtNC90Y/RiNC90LjQuSDQtNC10L3RjCDQvdC10LTQtdC70LggKNGB0YHRi9C70LrRgyDQvdCwINC+0LHRitC10LrRgiDQtNC90Y8g0LIg0LzQvtC00LXQu9C4KVxuICAgICAgICB0b2RheUtleSA9IHdlZWtLZXlzU2hvcnRbKG5ldyBEYXRlKG5vdykuZ2V0RGF5KCktZmlyc3RkYXlPZmZzZXQpICUgN107XG4gICAgICAgIHRvZGF5ID0gbW9kZWxbdG9kYXlLZXldOyAvLyDQntCx0YrQtdC60YIg0YDQsNGB0L/QuNGB0LDQvdC40Y8gLSDRgtC10LrRg9GJ0LjQuSDQtNC10L3RjCDQvdC10LTQtdC70LhcbiAgICAgICAgc2V0VG9kYXlTdHJpbmcodG9kYXkpOyAvLyDQodC00LXQu9Cw0YLRjCDQvtCx0YrQtdC60YIg0LTQu9GPINGI0LDQsdC70L7QvdCwIC0g0YHRgtGA0L7QutCwLCDQutC+0YLQvtGA0LDRjyDQvtC/0LjRgdGL0LLQsNC10YIg0LLRgNC10LzRjyDRgNCw0LHQvtGC0Ysg0YHQtdCz0L7QtNC90Y9cblxuICAgICAgICAvLyDQndCw0YXQvtC00LjQvCDQutC+0LvQuNGH0LXRgdGC0LLQviDRgNCw0LfQvdGL0YUg0YDQsNGB0L/QuNGB0LDQvdC40Lkg0Lgg0YHQvtGF0YDQsNC90Y/QtdC8INC40YUg0LIg0LzQsNGB0YHQuNCyXG4gICAgICAgIHZhciBhcGlEaWZmZXJlbnREYXlzID0gW10sIC8vINCc0LDRgdGB0LjQsiDRgNCw0LfQu9C40YfQsNGO0YnQuNGF0YHRjyDQtNC90LXQuSDQuNC3INC80L7QtNC10LvQuFxuICAgICAgICAgICAgYXBpU2NoZWR1bGVEYXlzQ291bnQgPSAwLCAvLyDQmtC+0LvQuNGH0LXRgdGC0LLQviDQvtC/0LjRgdCw0L3QvdGL0YUg0LTQvdC10Lkg0LIg0YDQsNGB0L/QuNGB0LDQvdC40Lgg0LzQvtC00LXQu9C4XG4gICAgICAgICAgICBhcGlEaWZmZXJlbnREYXlzQ291bnQgPSAwLCAvLyDQmtC+0LvQuNGH0LXRgdGC0LLQviDRgNCw0LfQvdGL0YUg0LTQvdC10Lkg0LIg0YDQsNGB0L/QuNGB0LDQvdC40Lgg0LzQvtC00LXQu9C4XG4gICAgICAgICAgICBkaWZmZXJlbnRXb3JraW5nSG91cnNDb3VudCA9IFtdOyAvLyDQmtC+0LvQuNGH0LXRgdGC0LLQviDRgNCw0LHQvtGH0LjRhSDRh9Cw0YHQvtCyINCyINGA0LDQt9C90YvRhSDQtNC90Y/RhVxuXG4gICAgICAgIE9iamVjdC5rZXlzKG1vZGVsKS5mb3JFYWNoKCBmdW5jdGlvbihkYXkpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbFtkYXldICYmIG1vZGVsW2RheV0ud29ya2luZ19ob3VycykgeyAvLyDQn9GA0L7QstC10YDRj9C10Lwg0YfRgtC+INGN0YLQviDQtNC10L3RjCwg0LAg0L3QtSDQutC+0LzQvNC10L3RgtCw0YDQuNC5INC40LvQuCDRh9GC0L4t0YLQviDQtdGJ0ZFcbiAgICAgICAgICAgICAgICBhcGlTY2hlZHVsZURheXNDb3VudCsrO1xuICAgICAgICAgICAgICAgIGlmICghaXNFcXVhbChtb2RlbFtkYXldLCBnZXRBcnJheUxhc3QoYXBpRGlmZmVyZW50RGF5cykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaURpZmZlcmVudERheXMucHVzaChtb2RlbFtkYXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwaURpZmZlcmVudERheXNDb3VudCA9IGFwaURpZmZlcmVudERheXMubGVuZ3RoO1xuICAgICAgICAvLyDQldGB0LvQuCDQvdC1INCy0YHQtSDQtNC90Lgg0L7Qv9C40YHQsNC90Ysg0LIg0LzQvtC00LXQu9C4LCDQt9C90LDRh9C40YIg0LXRgdGC0Ywg0LXRidGRINC+0LTQuNC9INGC0LjQvyDQtNC90LXQuSAtINCy0YvRhdC+0LTQvdC+0LkgKNC+0YLRgdGD0YLRgdGC0LLRg9GJ0LjQuSDQsiDQvNC+0LTQtdC70LgpXG4gICAgICAgIGlmIChhcGlTY2hlZHVsZURheXNDb3VudCA8IDcpIHtcbiAgICAgICAgICAgIGFwaURpZmZlcmVudERheXNDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0JXRgdC70Lgg0YDQsNC30L3Ri9GFINCx0L7Qu9C10LUgMiwg0YLQviDRg9C/0YDQvtGB0YLQuNGC0Ywg0L3QtSDQv9C+0LvRg9GH0LjRgtGB0Y8gLSDQtNC10LvQsNC10Lwg0YLQsNCx0LvQuNGG0YNcbiAgICAgICAgaWYgKGFwaURpZmZlcmVudERheXNDb3VudCA+IDIpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlLndlZWsgPSBtYWtlVGFibGUobW9kZWwpO1xuICAgICAgICB9IGVsc2UgeyAvLyDQmNC90LDRh9C1LCDRgdC+0YHRgtCw0LLQu9GP0LXQvCDQutC+0LzQvNC10L3RgtCw0YDQuNC5INC40Lcg0LTQstGD0YUg0YHRgtGA0L7QulxuXG4gICAgICAgICAgICAvLyDQodC70YPRh9Cw0LksINC60L7Qs9C00LAg0LLRgdC1INC+0LTQuNC90LDQutC+0LLRi9C1XG4gICAgICAgICAgICBpZiAoYXBpRGlmZmVyZW50RGF5c0NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUud2VlayA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRseTogW21ha2VTaW1wbGVTdHJpbmcobW9kZWxbd2Vla0tleXNbMF1dLCBtb2RlbCldXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vINCe0YHRgtCw0ZHRgtGB0Y8g0YHQu9GD0YfQsNC5LCDQutC+0LPQtNCwINC10YHRgtGMINC00LLQsCDRgtC40L/QsCDQtNC90LXQuVxuICAgICAgICAgICAgICAgIC8vINCe0L/RgNC10LTQtdC70Y/QtdC8INC00LXQvdGMINGBINC90LDQuNCx0L7Qu9GM0YjQuNC8INC60L7Qu9C40YfQtdGB0YLQstC+0Lwg0YDQsNCx0L7Rh9C40YUg0YfQsNGB0L7QsiDQuNC3INGH0LjRgdC70LAg0YDQsNC30L3Ri9GFINC00L3QtdC5XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCA7IGkgPCBhcGlEaWZmZXJlbnREYXlzQ291bnQgOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW50V29ya2luZ0hvdXJzQ291bnRbaV0gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcGlEaWZmZXJlbnREYXlzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gcGx1Y2soZ2V0U29ydGVkVGltZVBvaW50cyhhcGlEaWZmZXJlbnREYXlzW2ldKSwgJ3RpbWUnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAgOyBqIDwgcG9pbnRzLmxlbmd0aCA7IGogPSBqICsgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob3VycyA9IChnZXRIb3Vycyhwb2ludHNbaiArIDFdKSArIGdldE1pbnV0ZXMocG9pbnRzW2ogKyAxXSkgLyA2MCkgLSAoZ2V0SG91cnMocG9pbnRzW2pdKSArIGdldE1pbnV0ZXMocG9pbnRzW2pdKSAvIDYwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmZXJlbnRXb3JraW5nSG91cnNDb3VudFtpXSArPSBob3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8g0JLRi9GF0L7QtNC90L7QuVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpRGlmZmVyZW50RGF5c1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYXBpU29ydGVkRGlmZmVyZW50RGF5cyA9IHNvcnRCeShhcGlEaWZmZXJlbnREYXlzLCBmdW5jdGlvbiAoZGF5LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmZlcmVudFdvcmtpbmdIb3Vyc0NvdW50W2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzY2hlZHVsZS53ZWVrID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudGx5OiBtYWtlQWR2YW5jZWRTdHJpbmcoYXBpU29ydGVkRGlmZmVyZW50RGF5cywgbW9kZWwpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVkdWxlLmNvbW1lbnQgPSBtb2RlbC5jb21tZW50O1xuICAgICAgICBpZiAoc2NoZWR1bGUud2VlayAmJiBzY2hlZHVsZS53ZWVrLmV2ZW50bHkgJiYgc2NoZWR1bGUud2Vlay5ldmVudGx5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgc2NoZWR1bGUuZXZlcnlkYXkgPSBzY2hlZHVsZS53ZWVrLmV2ZW50bHlbMF0uZXZlcnlkYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlO1xuICAgIH0sXG5cbiAgICBmb3JlY2FzdDogZnVuY3Rpb24gKHNjaGVkdWxlLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gJycsXG4gICAgICAgIG9wZW4sXG4gICAgICAgIHRvZGF5ID0ge30sXG4gICAgICAgIG5vd1RleHQsXG4gICAgICAgIG1heEhvdXJzID0gcGFyYW1zICYmIHBhcmFtcy5tYXhIb3VycyB8fCAxO1xuXG4gICAgICAgIGlmICghc2NoZWR1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlZHVsZS5hbHdheXMpIHsgLy8g0JrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L4g0LXQttC10LTQvdC10LLQvdC+IC0g0LHQvtC70LXQtSDQvdC40YfQtdCz0L4g0LLRi9Cy0L7QtNC40YLRjCDQvdC1INC90YPQttC90L5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9kYXk6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdhcm91bmRUaGVDbG9jaycpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcGVuOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0KTQvtGA0LzQuNGA0YPQtdC8INGB0YLRgNC+0LrRgyAtINGH0LXRgNC10Lcg0YHQutC+0LvRjNC60L4g0L/RgNC+0LjQt9C+0LnQtNGR0YIg0YHQu9C10LTRg9GO0YnQsNGPINC40L3QstC10YDRgdC40Y8g0L7RgtC60YDRi9GC0L7RgdGC0LhcbiAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwgJiYgc2NoZWR1bGUud2lsbC5oIDwgbWF4SG91cnMpIHtcbiAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsLmgpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCArPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ25Ib3VycycsIHNjaGVkdWxlLndpbGwuaCkgKyAnICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsLm0pIHtcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCArPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ25NaW5zJywgc2NoZWR1bGUud2lsbC5tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vINCU0LDQvdC90YvQtSDQvdCwINGB0LXQs9C+0LTQvdGPXG4gICAgICAgIGlmIChzY2hlZHVsZS50b2RheSkge1xuICAgICAgICAgICAgdG9kYXkudGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAndG9kYXknKTtcbiAgICAgICAgICAgIGlmIChzY2hlZHVsZS5ldmVyeWRheSkge1xuICAgICAgICAgICAgICAgIHRvZGF5LnRleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2V2ZXJ5ZGF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2RheS5mcm9tID0gc2NoZWR1bGUudG9kYXkuZnJvbTtcbiAgICAgICAgICAgIHRvZGF5LnRvID0gc2NoZWR1bGUudG9kYXkudG87XG4gICAgICAgICAgICB0b2RheS5sdW5jaCA9IHNjaGVkdWxlLmx1bmNoO1xuICAgICAgICAgICAgaWYgKHRvZGF5Lmx1bmNoKSB7XG4gICAgICAgICAgICAgICAgdG9kYXkubHVuY2hTdHIgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2x1bmNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2RheS50ZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICd0b2RheUlzUmVzdERheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g0KLQtdC60YPRidC40Lkg0YHRgtCw0YLRg9GBINC4INC/0YDQvtCz0L3QvtC3XG4gICAgICAgIGlmIChzY2hlZHVsZS5hbHdheXMpIHsgLy8g0JXRgdC70Lgg0LrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L4sINC90LjRh9C10LPQviDQutGA0L7QvNC1IFwi0JrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L5cIiDQstGL0LLQvtC00LjRgtGMINC90LUg0L3Rg9C20L3QvlxuICAgICAgICAgICAgdG9kYXkudGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnYXJvdW5kVGhlQ2xvY2snKTtcbiAgICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVkdWxlLm5vdykge1xuICAgICAgICAgICAgb3BlbiA9IHNjaGVkdWxlLm5vdy5vcGVuO1xuICAgICAgICAgICAgaWYgKG9wZW4pIHsgLy8g0L7RgtC60YDRi9GC0L5cbiAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbCAmJiBzY2hlZHVsZS53aWxsLndpbGxUeXBlID09PSAnbHVuY2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vINC00LDQu9C10LUgLSDQt9Cw0LrRgNGL0YLQuNC1INC90LAg0L7QsdC10LRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwgJiYgc2NoZWR1bGUud2lsbC5oIDwgbWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINC80LXQvdC10LUgbWF4SG91cnMg0LTQviDQt9Cw0LrRgNGL0YLQuNGPICDQvdCwINC+0LHQtdC0XG4gICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdfaW4nKSArICcgJyArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnbk1pbnMnLCBpbnRlcnZhbCkgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ2lzQ2xvc2luZ09uRGlubmVyJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQsdC+0LvRjNGI0LUgbWF4SG91cnMg0LTQviDQt9Cw0LrRgNGL0YLQuNGPICDQvdCwINC+0LHQtdC0XG4gICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdpc09wZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g0LTQsNC70LXQtSDQv9GA0L7RgdGC0L4g0LfQsNC60YDRi9GC0LjQtVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGUud2lsbC5oIDwgbWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINC80LXQvdC10LUgbWF4SG91cnMg0LTQviDQt9Cw0LrRgNGL0YLQuNGPINC/0YDQvtGB0YLQvlxuICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnY2xvc2VJbicpICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICduTWlucycsIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINCx0L7Qu9GM0YjQtSBtYXhIb3VycyDQtNC+INC30LDQutGA0YvRgtC40Y8g0L/RgNC+0YHRgtC+XG4gICAgICAgICAgICAgICAgICAgICAgICBub3dUZXh0ID0gdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICdpc09wZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vINC30LDQutGA0YvRgtC+XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwgJiYgc2NoZWR1bGUud2lsbC53aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vINC+0YLQutGA0L7QtdGC0YHRjyDQvdC1INGB0LXQs9C+0LTQvdGPXG4gICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ29wZW4nKSArIHNjaGVkdWxlLndpbGwud2hlbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyDQvtGC0LrRgNC+0LXRgtGB0Y8g0YHQtdCz0L7QtNC90Y9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlLm5vdyAmJiBzY2hlZHVsZS5ub3cubHVuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINGB0LXQudGH0LDRgSDQvtCx0LXQtFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlLndpbGwuaCA8IG1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LzQtdC90LXQtSBtYXhIb3VycyDQtNC+INC+0YLQutGA0YvRgtC40Y8g0YEg0L7QsdC10LTQsFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ0x1bmNoJykgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ29wZW5JbicpICsgdGhpcy5kaWN0LnQodGhpcy5sb2NhbExhbmcsICduTWlucycsIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LHQvtC70YzRiNC1IG1heEhvdXJzINC00L4g0L7RgtC60YDRi9GC0LjRjyDRgSDQvtCx0LXQtNCwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnTHVuY2gnKSArIHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnb3BlbkF0JykgKyBzY2hlZHVsZS53aWxsLnRpbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQv9GA0L7RgdGC0L4g0LfQsNC60YDRi9GC0L5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlZHVsZS53aWxsICYmIHNjaGVkdWxlLndpbGwuaCA8IG1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g0LzQtdC90LXQtSBtYXhIb3VycyDQtNC+INC+0YLQutGA0YvRgtC40Y8g0L/RgNC+0YHRgtC+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93VGV4dCA9IHRoaXMuZGljdC50KHRoaXMubG9jYWxMYW5nLCAnb3BlbkluJykgKyB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ25NaW5zJywgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDQsdC+0LvRjNGI0LUgbWF4SG91cnMg0LTQviDQvtGC0LrRgNGL0YLQuNGPINC/0YDQvtGB0YLQvlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd1RleHQgPSB0aGlzLmRpY3QudCh0aGlzLmxvY2FsTGFuZywgJ29wZW5BdCcpICsgc2NoZWR1bGUud2lsbC50aWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvZGF5OiB0b2RheSxcbiAgICAgICAgICAgIG5vdzogbm93VGV4dCxcbiAgICAgICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgICAgICB3ZWVrOiBzY2hlZHVsZS53ZWVrLFxuICAgICAgICAgICAgY29tbWVudDogc2NoZWR1bGUuY29tbWVudCxcbiAgICAgICAgICAgIGV2ZXJ5ZGF5OiBzY2hlZHVsZS5ldmVyeWRheVxuICAgICAgICB9O1xuICAgIH1cbn07XG4iLCIvKmdsb2JhbFxuICAgIEZpcm1DYXJkOmZhbHNlXG4qL1xuLy8gRmlybUNhcmQuZGljdGlvbmFyeSA9IHt9O1xuXG5GaXJtQ2FyZC5wcm90b3R5cGUuZGljdCA9IHtcblxuICAgIHQ6IGZ1bmN0aW9uIChsYW5nLCBtc2csIGFyZ3VtZW50KSB7IC8vIChTdHJpbmcsIE51bWJlcikgLT4gU3RyaW5nXG4gICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICBtc2dJc3NldCA9IGZhbHNlLFxuICAgICAgICAgICAgZGljdGlvbmFyeU1zZyxcbiAgICAgICAgICAgIGV4cDtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXNbbGFuZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsYW5nID0gJ3J1JztcbiAgICAgICAgfVxuICAgICAgICBkaWN0aW9uYXJ5TXNnID0gdGhpc1tsYW5nXVttc2ddO1xuICAgICAgICBtc2dJc3NldCA9IHR5cGVvZiBkaWN0aW9uYXJ5TXNnICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKCFtc2dJc3NldCkge1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBtc2dJc3NldCA/IGRpY3Rpb25hcnlNc2cgOiBtc2c7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VJbnQoYXJndW1lbnQsIDEwKTtcbiAgICAgICAgICAgIGFyZ3VtZW50ID0gaXNOYU4oYXJndW1lbnQpID8gMCA6IGFyZ3VtZW50O1xuICAgICAgICAgICAgZXhwID0gdGhpc1tsYW5nXS5wbHVyYWxSdWxlcyhhcmd1bWVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudCArICcgJyArIGRpY3Rpb25hcnlNc2dbZXhwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0IDogbXNnO1xuICAgIH0sXG5cbiAgICBydToge1xuICAgICAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDEgJiYgbiAlIDEwMCAhPT0gMTEpIHsgLy8gMSwgMjFcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiYgKG4gJSAxMCkgJSAxID09PSAwKSAmJiAobiAlIDEwMCA8IDEyIHx8IG4gJSAxMDAgPiAxNCkpIHsgLy8gMiwgM1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKG4gJSAxMCA9PT0gMCkgfHwgKG4gJSAxMCA+PSA1ICYmIG4gJSAxMCA8PSA5ICYmIChuICUgMTApICUgMSA9PT0gMCkgfHwgKG4gJSAxMDAgPj0gMTEgJiYgKG4gJSAxMDApIDw9IDE0ICYmIChuICUgMTAwKSAlIDEgPT09IDApKSB7IC8vIDEzLCAxN1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGJ0bkJhY2s6ICfQndCw0LfQsNC0JyxcbiAgICAgICAgYnRuRmluZFdheTogJ9Cf0YDQvtC10YXQsNGC0Ywg0YHRjtC00LAnLFxuICAgICAgICBidG5FbnRyYW5jZTogJ9Cd0LDQudGC0Lgg0LLRhdC+0LQnLFxuICAgICAgICBsaW5rUmV2aWV3czogWyfQvtGC0LfRi9CyJywgJ9C+0YLQt9GL0LLQsCcsICfQvtGC0LfRi9Cy0L7QsiddLFxuICAgICAgICBsaW5rUGhvdG86IFsn0YTQvtGC0L4nLCAn0YTQvtGC0L4nLCAn0YTQvtGC0L4nXSxcbiAgICAgICAgbGlua0Jvb2tsZXQ6ICfQkdGD0LrQu9C10YInLFxuICAgICAgICB0b21tb3JvdzogJ9C30LDQstGC0YDQsCcsXG4gICAgICAgIGFmdGVyVG9tbW9yb3c6ICfQv9C+0YHQu9C10LfQsNCy0YLRgNCwJyxcbiAgICAgICAgYWZ0ZXJXZWVrOiAn0YfQtdGA0LXQtyDQvdC10LTQtdC70Y4nLFxuICAgICAgICBuZXh0U3VuOiAn0LIg0LLQvtGB0LrRgNC10YHQtdC90YzQtScsXG4gICAgICAgIG5leHRNb246ICfQsiDQv9C+0L3QtdC00LXQu9GM0L3QuNC6JyxcbiAgICAgICAgbmV4dFR1ZTogJ9Cy0L4g0LLRgtC+0YDQvdC40LonLFxuICAgICAgICBuZXh0V2VkOiAn0LIg0YHRgNC10LTRgycsXG4gICAgICAgIG5leHRUaHU6ICfQsiDRh9C10YLQstC10YDQsycsXG4gICAgICAgIG5leHRGcmk6ICfQsiDQv9GP0YLQvdC40YbRgycsXG4gICAgICAgIG5leHRTYXQ6ICfQsiDRgdGD0LHQsdC+0YLRgycsXG4gICAgICAgIHdpbGxPcGVuOiAn0L7RgtC60YDQvtC10YLRgdGPJyxcbiAgICAgICAgd2lsbENsb3NlOiAn0LfQsNC60YDQvtC10YLRgdGPJyxcbiAgICAgICAgaXNPcGVuOiAn0J7RgtC60YDRi9GC0L4nLFxuICAgICAgICBvcGVuVGlsbDogJ9Ce0YLQutGA0YvRgtC+INC00L4gJyxcbiAgICAgICAgY2xvc2VJbjogJ9CX0LDQutGA0L7QtdGC0YHRjyDRh9C10YDQtdC3ICcsXG4gICAgICAgIG9wZW5BdDogJ9Ce0YLQutGA0L7QtdGC0YHRjyDQsiAnLFxuICAgICAgICBvcGVuSW46ICfQntGC0LrRgNC+0LXRgtGB0Y8g0YfQtdGA0LXQtyAnLFxuICAgICAgICBvcGVuOiAn0J7RgtC60YDQvtC10YLRgdGPICcsXG4gICAgICAgIG5Ib3VyczogWyfRh9Cw0YEnLCAn0YfQsNGB0LAnLCAn0YfQsNGB0L7QsiddLFxuICAgICAgICBuTWluczogWyfQvNC40L3Rg9GC0YMnLCAn0LzQuNC90YPRgtGLJywgJ9C80LjQvdGD0YInXSxcbiAgICAgICAgbHVuY2g6ICfQvtCx0LXQtCcsXG4gICAgICAgIEx1bmNoOiAn0J7QsdC10LQuICcsXG4gICAgICAgIHdvcmtpbmdEYXlzOiAn0KDQsNCx0L7Rh9C40LUg0LTQvdC4JyxcbiAgICAgICAgd2Vla2RheXM6ICfQkdGD0LTQvdC40LUg0LTQvdC4JyxcbiAgICAgICAgcmVzdERheTogWyfQstGL0YXQvtC00L3QvtC5JywgJ9Cy0YvRhdC+0LTQvdGL0LUnLCfQstGL0YXQvtC00L3Ri9C1J10sXG4gICAgICAgIHJldmlld3NPbkZsYW1wOiAn0J7RgtC30YvQstGLINC90LAg0KTQu9Cw0LzQv9C1JyxcbiAgICAgICAgd3JpdGVSZXZpZXdPbkZsYW1wOiAn0J3QsNC/0LjRgdCw0YLRjCDQvtGC0LfRi9CyINC90LAg0KTQu9Cw0LzQv9C1JyxcbiAgICAgICAgcGF5bWVudDogJ9C+0L/Qu9Cw0YLQsCcsXG4gICAgICAgIGV2ZXJ5ZGF5OiAn0JXQttC10LTQvdC10LLQvdC+IGMnLFxuICAgICAgICB3b3Jrc0Fyb3VuZFRoZUNsb2NrOiAn0KDQsNCx0L7RgtCw0LXRgiDQutGA0YPQs9C70L7RgdGD0YLQvtGH0L3QvicsXG4gICAgICAgIGFyb3VuZFRoZUNsb2NrOiAn0JrRgNGD0LPQu9C+0YHRg9GC0L7Rh9C90L4nLFxuICAgICAgICBrbm93TW9yZTogJ9GD0LfQvdCw0YLRjCDQsdC+0LvRjNGI0LUnLFxuICAgICAgICB0b0Nsb3NlOiAn0LTQviDQt9Cw0LrRgNGL0YLQuNGPJyxcbiAgICAgICAgbW9uZGF5OiAn0L/QvtC90LXQtNC10LvRjNC90LjQuicsXG4gICAgICAgIHR1ZXNkYXk6ICfQstGC0L7RgNC90LjQuicsXG4gICAgICAgIHdlZG5lc2RheTogJ9GB0YDQtdC00LAnLFxuICAgICAgICB0aHVyc2RheTogJ9GH0LXRgtCy0LXRgNCzJyxcbiAgICAgICAgZnJpZGF5OiAn0L/Rj9GC0L3QuNGG0LAnLFxuICAgICAgICBzYXR1cmRheTogJ9GB0YPQsdCx0L7RgtCwJyxcbiAgICAgICAgc3VuZGF5OiAn0LLQvtGB0LrRgNC10YHQtdC90YzQtScsXG4gICAgICAgIG1vbjogJ9C/0L7QvScsXG4gICAgICAgIHR1ZTogJ9Cy0YLRgCcsXG4gICAgICAgIHdlZDogJ9GB0YDQtCcsXG4gICAgICAgIHRodTogJ9GH0YLQsicsXG4gICAgICAgIGZyaTogJ9C/0YLQvScsXG4gICAgICAgIHNhdDogJ9GB0LHRgicsXG4gICAgICAgIHN1bjogJ9Cy0YHQuicsXG4gICAgICAgIHRvTHVuY2g6ICfQtNC+INC+0LHQtdC00LAnLFxuICAgICAgICB0b2RheTogJ9Ch0LXQs9C+0LTQvdGPJyxcbiAgICAgICAgbGVzc1RoZW5Ib3VyOiAn0LzQtdC90LXQtSDRh9Cw0YHQsCcsXG4gICAgICAgIHlvdUNvdWxkTGF0ZTogJ9Cy0Ysg0LzQvtC20LXRgtC1INC90LUg0YPRgdC/0LXRgtGMJyxcbiAgICAgICAgd29ya2luZ1RpbWU6ICfRgNCw0LHQvtGH0LXQtSDQstGA0LXQvNGPJyxcbiAgICAgICAgc2hvd0FsbE9yZ0luUnVicmljOiAn0J/QvtC60LDQt9Cw0YLRjCDQstGB0LUg0L7RgNCz0LDQvdC40LfQsNGG0LjQuCDRgNGD0LHRgNC40LrQuCcsXG4gICAgICAgIHRvZGF5SXNSZXN0RGF5OiAn0KHQtdCz0L7QtNC90Y8g0LLRi9GF0L7QtNC90L7QuScsXG4gICAgICAgIGludGVybmV0OiAn0J7Qv9C70LDRgtCwINGH0LXRgNC10Lcg0JjQvdGC0LXRgNC90LXRgicsXG4gICAgICAgIG5vbmNhc2g6ICfQkdC10LfQvdCw0LvQuNGH0L3Ri9C5INGA0LDRgdGH0LXRgicsXG4gICAgICAgIGdvbGRjcm93bjogJ9CX0L7Qu9C+0YLQsNGPINCa0L7RgNC+0L3QsCcsXG4gICAgICAgIGRpbmVyc2NsdWI6ICdEaW5lcnMgQ2x1YicsXG4gICAgICAgIG1hc3RlcmNhcmQ6ICdNYXN0ZXJjYXJkJyxcbiAgICAgICAgbWFlc3Ryb2NhcmQ6ICdNYWVzdHJvQ2FyZCcsXG4gICAgICAgIHZpc2E6ICdWaXNhJyxcbiAgICAgICAgY2FzaDogJ9Cd0LDQu9C40YfQvdGL0Lkg0YDQsNGB0YfQtdGCJyxcbiAgICAgICAgYW1lcmljYW5leHByZXNzOiAnQW1lcmljYW4gRXhwcmVzcycsXG4gICAgICAgIGhvdXIgOiAn0YfQsNGBJyxcbiAgICAgICAgbGVzczogJ9C80LXQvdC10LUnLFxuICAgICAgICBfaW4gOiAn0KfQtdGA0LXQtycsXG4gICAgICAgIGlzQ2xvc2luZ09uRGlubmVyIDogJyDQt9Cw0LrRgNGL0LLQsNC10YLRgdGPINC90LAg0L7QsdC10LQnXG4gICAgfSxcblxuICAgIGl0OiB7XG4gICAgICAgIHBsdXJhbFJ1bGVzOiBmdW5jdGlvbiAobikgeyAvLyAoTnVtYmVyKVxuICAgICAgICAgICAgaWYgKG4gPT09IDEpIHsgLy8gMVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTsgLy8wLCAyLCAzLCA0IC4uXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnRuQmFjazogJ0luZGlldHJvJyxcbiAgICAgICAgYnRuRmluZFdheTogJ0NvbWUgYXJyaXZhcmUgJyxcbiAgICAgICAgYnRuRW50cmFuY2U6ICdUcm92YSBsXFwnaW5ncmVzc28nLFxuICAgICAgICBsaW5rUmV2aWV3czogWydyZWNlbnNpb25lJywgJ3JlY2Vuc2lvbmknXSxcbiAgICAgICAgbGlua1Bob3RvOiBbJ2ZvdG9ncmFmaWEnLCAnZm90b2dyYWZpZSddLFxuICAgICAgICBsaW5rQm9va2xldDogJ1N1bGxcXCdhemllbmRhJyxcbiAgICAgICAgdG9tbW9yb3c6ICdkb21hbmknLFxuICAgICAgICBhZnRlclRvbW1vcm93OiAnZG9wb2RvbWFuaScsXG4gICAgICAgIGFmdGVyV2VlazogJ3RyYSB1bmEgc2V0dGltYW5hJyxcbiAgICAgICAgbmV4dFN1bjogJ2xhIGRvbWVuaWNhJyxcbiAgICAgICAgbmV4dE1vbjogJ2lsIGx1bmVkaScsXG4gICAgICAgIG5leHRUdWU6ICdpbCBtYXJ0ZWTDrCcsXG4gICAgICAgIG5leHRXZWQ6ICdpbCBtZXJjb2xlZMOsJyxcbiAgICAgICAgbmV4dFRodTogJ2lsIGdpb3ZlZGknLFxuICAgICAgICBuZXh0RnJpOiAnaWwgdmVuZXJkw6wnLFxuICAgICAgICBuZXh0U2F0OiAnaWwgc2FiYXRvJyxcbiAgICAgICAgd2lsbE9wZW46ICdhcHJlJyxcbiAgICAgICAgd2lsbENsb3NlOiAnY2l1c28nLFxuICAgICAgICBpc09wZW46ICdBcGVydG8nLFxuICAgICAgICBvcGVuVGlsbDogJ0FwZXJ0byBmaW5vIGFsbGUgJyxcbiAgICAgICAgY2xvc2VJbjogJ0NoaXVkZSB0cmEgJyxcbiAgICAgICAgb3BlbkF0OiAnQXByZSBhbGxlICcsXG4gICAgICAgIG9wZW5JbjogJ0FwcmUgdHJhICcsXG4gICAgICAgIG9wZW46ICdBcHJlICcsXG4gICAgICAgIG5Ib3VyczogWydvcmEnLCAnb3JlJ10sXG4gICAgICAgIG5NaW5zOiBbJ21pbnV0bycsICdtaW51dGknXSxcbiAgICAgICAgbHVuY2g6ICdwYXVzYSBwcmFuem8nLFxuICAgICAgICBMdW5jaDogJ1BhdXNhIHByYW56by4gJyxcbiAgICAgICAgd29ya2luZ0RheXM6ICdHaW9ybmkgZmVyaWFsaScsXG4gICAgICAgIHdlZWtkYXlzOiAnR2lvcm5pIGZlcmlhbGknLFxuICAgICAgICByZXN0RGF5OiBbJ2NoaXVzdXJhJywnY2hpdXN1cmEnXSxcbiAgICAgICAgcmV2aWV3c09uRmxhbXA6ICdSZWNlbnNpb25pIHN1IEZsYW1wJyxcbiAgICAgICAgd3JpdGVSZXZpZXdPbkZsYW1wOiAnU2NyaXZpIHVuYSByZWNlbnNpb25lIHN1IEZsYW1wJyxcbiAgICAgICAgcGF5bWVudDogJ3BhZ2FtZW50bycsXG4gICAgICAgIGV2ZXJ5ZGF5OiAnT2duaSBnaW9ybm8gZGFsb2xlJyxcbiAgICAgICAgd29ya3NBcm91bmRUaGVDbG9jazogJ09wZXJhdGl2byAyNCBvcmUgc3UgMjQnLFxuICAgICAgICBhcm91bmRUaGVDbG9jazogJzI0IG9yZSBzdSAyNCcsXG4gICAgICAgIGtub3dNb3JlOiAndWx0ZXJpb3JpIGluZm9ybWF6aW9uaScsXG4gICAgICAgIHRvQ2xvc2U6ICdmaW5vIGFsbGEgY2hpdXN1cmEnLFxuICAgICAgICBtb25kYXk6ICdsdW5lZGknLFxuICAgICAgICB0dWVzZGF5OiAnbWFydGVkw6wnLFxuICAgICAgICB3ZWRuZXNkYXk6ICdtZXJjb2xlZMOsJyxcbiAgICAgICAgdGh1cnNkYXk6ICdnaW92ZWRpJyxcbiAgICAgICAgZnJpZGF5OiAndmVuZXJkw6wnLFxuICAgICAgICBzYXR1cmRheTogJ3NhYmF0bycsXG4gICAgICAgIHN1bmRheTogJ2RvbWVuaWNhJyxcbiAgICAgICAgbW9uOiAnbHVuJyxcbiAgICAgICAgdHVlOiAnbWFyJyxcbiAgICAgICAgd2VkOiAnbWVyJyxcbiAgICAgICAgdGh1OiAnZ2lvJyxcbiAgICAgICAgZnJpOiAndmVuJyxcbiAgICAgICAgc2F0OiAnc2FiJyxcbiAgICAgICAgc3VuOiAnZG9tJyxcbiAgICAgICAgdG9MdW5jaDogJ2Zpbm8gYWxsYSBwYXVzYSBwcmFuem8nLFxuICAgICAgICB0b2RheTogJ09nZ2knLFxuICAgICAgICBsZXNzVGhlbkhvdXI6ICdtZW5vIGRpIHVuXFwnb3JhJyxcbiAgICAgICAgeW91Q291bGRMYXRlOiAnYWZmcmV0dGFyc2ksIGNoaXVzdXJhIGltbWluZW50ZScsXG4gICAgICAgIHdvcmtpbmdUaW1lOiAnb3JhcmlvIGRpIGxhdm9ybycsXG4gICAgICAgIHNob3dBbGxPcmdJblJ1YnJpYzogJ1Zpc3VhbGl6emEgdHV0dGUgbGUgYXppZW5kZSBkZWxsYSBjYXRlZ29yaWEnLFxuICAgICAgICB0b2RheUlzUmVzdERheTogJ29nZ2kgY2hpdXNvJyxcbiAgICAgICAgaW50ZXJuZXQ6ICdQYWdhbWVudG8gb24tbGluZScsXG4gICAgICAgIG5vbmNhc2g6ICdQYWdhbWVudG8gbm9uIGluIGNvbnRhbnRpJyxcbiAgICAgICAgZ29sZGNyb3duOiAnWm9sb3RhamEgS29yb25hJyxcbiAgICAgICAgZGluZXJzY2x1YjogJ0RpbmVycyBDbHViJyxcbiAgICAgICAgbWFzdGVyY2FyZDogJ01hc3RlckNhcmQnLFxuICAgICAgICBtYWVzdHJvY2FyZDogJ01hZXN0cm9DYXJkJyxcbiAgICAgICAgdmlzYTogJ1Zpc2EnLFxuICAgICAgICBjYXNoOiAnUGFnYW1lbnRvIGluIGNvbnRhbnRpJyxcbiAgICAgICAgYW1lcmljYW5leHByZXNzOiAnQW1lcmljYW4gRXhwcmVzcycsXG4gICAgICAgIGhvdXIgOiAndW5cXCdvcmEnLFxuICAgICAgICBsZXNzOiAnbWVubyBkaScsXG4gICAgICAgIF9pbiA6ICdUcmEnLFxuICAgICAgICBpc0Nsb3NpbmdPbkRpbm5lciA6ICdjaGl1ZGUgcGVyIHBhdXNhIHByYW56bydcbiAgICB9LFxuXG4gICAgZW46IHtcbiAgICAgICAgcGx1cmFsUnVsZXM6IGZ1bmN0aW9uIChuKSB7IC8vIChOdW1iZXIpXG4gICAgICAgICAgICBpZiAobiA9PT0gMSkgeyAvLyAxXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxOyAvLzAsIDIsIDMsIDQgLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBidG5CYWNrOiAnQmFjaycsXG4gICAgICAgIGJ0bkZpbmRXYXk6ICdHZXQgaGVyZScsXG4gICAgICAgIGJ0bkVudHJhbmNlOiAnRmluZCBlbnRyYW5jZScsXG4gICAgICAgIGxpbmtSZXZpZXdzOiBbJ3JldmlldycsICdyZXZpZXdzJ10sXG4gICAgICAgIGxpbmtQaG90bzogWydwaG90bycsICdwaG90b3MnXSxcbiAgICAgICAgbGlua0Jvb2tsZXQ6ICdBYm91dCBjb21wYW55JyxcbiAgICAgICAgdG9tbW9yb3c6ICd0b21vcnJvdycsXG4gICAgICAgIGFmdGVyVG9tbW9yb3c6ICd0aGUgZGF5IGFmdGVyIHRvbW9ycm93JyxcbiAgICAgICAgYWZ0ZXJXZWVrOiAnaW4gYSB3ZWVrJyxcbiAgICAgICAgbmV4dFN1bjogJ29uIFN1bmRheScsXG4gICAgICAgIG5leHRNb246ICdvbiBNb25kYXknLFxuICAgICAgICBuZXh0VHVlOiAnb24gVHVlc2RheScsXG4gICAgICAgIG5leHRXZWQ6ICdvbiBXZWRuZXNkYXknLFxuICAgICAgICBuZXh0VGh1OiAnb24gVGh1cnNkYXknLFxuICAgICAgICBuZXh0RnJpOiAnb24gRnJpZGF5JyxcbiAgICAgICAgbmV4dFNhdDogJ29uIFNhdHVyZGF5JyxcbiAgICAgICAgd2lsbE9wZW46ICdvcGVucyAnLFxuICAgICAgICB3aWxsQ2xvc2U6ICdjbG9zZXMnLFxuICAgICAgICBpc09wZW46ICdPcGVuJyxcbiAgICAgICAgb3BlblRpbGw6ICdPcGVuIHRpbGwgJyxcbiAgICAgICAgY2xvc2VJbjogJ0Nsb3NlcyBpbiAnLFxuICAgICAgICBvcGVuQXQ6ICdPcGVucyBhdCAnLFxuICAgICAgICBvcGVuSW46ICdPcGVucyBpbiAnLFxuICAgICAgICBvcGVuOiAnT3BlbnMgJyxcbiAgICAgICAgbkhvdXJzOiBbJ2hvdXInLCAnaG91cnMnXSxcbiAgICAgICAgbk1pbnM6IFsnbWludXRlJywgJ21pbnV0ZXMnXSxcbiAgICAgICAgbHVuY2g6ICdsdW5jaCBicmVhaycsXG4gICAgICAgIEx1bmNoOiAnTHVuY2ggYnJlYWsuICcsXG4gICAgICAgIHdvcmtpbmdEYXlzOiAnV29ya2luZyBkYXlzJyxcbiAgICAgICAgd2Vla2RheXM6ICdXZWVrZGF5cycsXG4gICAgICAgIHJlc3REYXk6IFsnZGF5IG9mZicsJ2RheXMgb2ZmJ10sXG4gICAgICAgIHJldmlld3NPbkZsYW1wOiAnUmV2aWV3cyBvbiBGbGFtcCcsXG4gICAgICAgIHdyaXRlUmV2aWV3T25GbGFtcDogJ1dyaXRlIGEgcmV2aWV3IG9uIEZsYW1wJyxcbiAgICAgICAgcGF5bWVudDogJ3BheW1lbnQnLFxuICAgICAgICBldmVyeWRheTogJ0RhaWx5IGZyb20nLFxuICAgICAgICB3b3Jrc0Fyb3VuZFRoZUNsb2NrOiAnT3BlbiAyNCBob3VycycsXG4gICAgICAgIGFyb3VuZFRoZUNsb2NrOiAnMjRoJyxcbiAgICAgICAga25vd01vcmU6ICdzZWUgYWxzbycsXG4gICAgICAgIHRvQ2xvc2U6ICd1bnRpbCBjbG9zaW5nJyxcbiAgICAgICAgbW9uZGF5OiAnTW9uZGF5JyxcbiAgICAgICAgdHVlc2RheTogJ1R1ZXNkYXknLFxuICAgICAgICB3ZWRuZXNkYXk6ICdXZWRuZXNkYXknLFxuICAgICAgICB0aHVyc2RheTogJ1RodXJzZGF5JyxcbiAgICAgICAgZnJpZGF5OiAnRnJpZGF5JyxcbiAgICAgICAgc2F0dXJkYXk6ICdTYXR1cmRheScsXG4gICAgICAgIHN1bmRheTogJ1N1bmRheScsXG4gICAgICAgIG1vbjogJ01vbicsXG4gICAgICAgIHR1ZTogJ1R1ZScsXG4gICAgICAgIHdlZDogJ1dlZCcsXG4gICAgICAgIHRodTogJ1RodScsXG4gICAgICAgIGZyaTogJ0ZyaScsXG4gICAgICAgIHNhdDogJ1NhdCcsXG4gICAgICAgIHN1bjogJ1N1bicsXG4gICAgICAgIHRvTHVuY2g6ICd1bnRpbCBsdW5jaCcsXG4gICAgICAgIHRvZGF5OiAnVG9kYXknLFxuICAgICAgICBsZXNzVGhlbkhvdXI6ICdsZXNzIHRoZW4gb25lIGhvdXInLFxuICAgICAgICB5b3VDb3VsZExhdGU6ICd5b3UgbWlnaHQgYmUgbGF0ZScsXG4gICAgICAgIHdvcmtpbmdUaW1lOiAnd29ya2luZyBob3VycycsXG4gICAgICAgIHNob3dBbGxPcmdJblJ1YnJpYzogJ1Nob3cgYWxsIG9yZ2FuaXphdGlvbnMgaW4gdGhlIGNhdGVnb3J5JyxcbiAgICAgICAgdG9kYXlJc1Jlc3REYXk6ICdjbG9zZWQgdG9kYXknLFxuICAgICAgICBpbnRlcm5ldDogJ09ubGluZScsXG4gICAgICAgIG5vbmNhc2g6ICcgTm8tY2FzaCcsXG4gICAgICAgIGdvbGRjcm93bjogJ0dvbGRlbiBDcm93bicsXG4gICAgICAgIGRpbmVyc2NsdWI6ICdEaW5lcnMgQ2x1YicsXG4gICAgICAgIG1hc3RlcmNhcmQ6ICdNYXN0ZXJjYXJkJyxcbiAgICAgICAgbWFlc3Ryb2NhcmQ6ICdNYWVzdHJvQ2FyZCcsXG4gICAgICAgIHZpc2E6ICdWaXNhJyxcbiAgICAgICAgY2FzaDogJ0Nhc2gnLFxuICAgICAgICBhbWVyaWNhbmV4cHJlc3M6ICdBbWVyaWNhbiBFeHByZXNzJyxcbiAgICAgICAgaG91ciA6ICdob3VyJyxcbiAgICAgICAgbGVzczogJ2xlc3MnLFxuICAgICAgICBfaW4gOiAnSW4nLFxuICAgICAgICBpc0Nsb3NpbmdPbkRpbm5lciA6ICd3aWxsIGJlIGNsb3NpbmcgZm9yIGx1bmNoJ1xuICAgIH0sXG5cbiAgICBjczoge1xuICAgICAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgICAgIHJldHVybiAobiA9PT0gMSkgPyAwIDogKG4gPj0gMiAmJiBuIDw9IDQpID8gMSA6IDI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnRuQmFjazogJ1pwxJt0JyxcbiAgICAgICAgYnRuRmluZFdheTogJ0pldCBzZW0nLFxuICAgICAgICBidG5FbnRyYW5jZTogJ0hsZWRhdCB2c3R1cCcsXG4gICAgICAgIGxpbmtSZXZpZXdzOiBbJ3JlY2VuemUnLCAncmVjZW56ZScsICdyZWNlbnrDrSddLFxuICAgICAgICBsaW5rUGhvdG86IFsnZm90b2dyYWZpZScsICdmb3RvZ3JhZmllJywgJ2ZvdG9ncmFmacOtJ10sXG4gICAgICAgIGxpbmtCb29rbGV0OiAnTGV0w6FrJyxcbiAgICAgICAgdG9tbW9yb3c6ICd6w610cmEnLFxuICAgICAgICBhZnRlclRvbW1vcm93OiAncG96w610xZnDrScsXG4gICAgICAgIGFmdGVyV2VlazogJ3phIHTDvWRlbicsXG4gICAgICAgIG5leHRTdW46ICd2IG5lZMSbbGknLFxuICAgICAgICBuZXh0TW9uOiAndiBwb25kxJtsw60nLFxuICAgICAgICBuZXh0VHVlOiAndiDDunRlcsO9JyxcbiAgICAgICAgbmV4dFdlZDogJ3ZlIHN0xZllZHUnLFxuICAgICAgICBuZXh0VGh1OiAndmUgxI10dnJ0ZWsnLFxuICAgICAgICBuZXh0RnJpOiAndiBww6F0ZWsnLFxuICAgICAgICBuZXh0U2F0OiAndiBzb2JvdHUnLFxuICAgICAgICB3aWxsT3BlbjogJ290ZXbFmWUgc2UnLFxuICAgICAgICB3aWxsQ2xvc2U6ICd6YXbFmWUgc2UnLFxuICAgICAgICBpc09wZW46ICdPdGV2xZllbm8nLFxuICAgICAgICBvcGVuVGlsbDogJ090ZXbFmWVubyBkbyAnLFxuICAgICAgICBjbG9zZUluOiAnWmF2xZllIHNlIHphICcsXG4gICAgICAgIG9wZW5BdDogJ090ZXbFmWUgc2UgdiAnLFxuICAgICAgICBvcGVuSW46ICdPdGV2xZllIHNlIHphICcsXG4gICAgICAgIG9wZW46ICdPdGV2xZllIHNlICcsXG4gICAgICAgIG5Ib3VyczogWyAnaG9kaW51JyAsICdob2RpbnknICwgJ2hvZGluJyBdLFxuICAgICAgICBuTWluczogWyAnbWludXR1JyAsICdtaW51dHknICwgJ21pbnV0JyBdLFxuICAgICAgICBsdW5jaDogJ3BvbGVkbsOtIHDFmWVzdMOhdmthJyxcbiAgICAgICAgTHVuY2g6ICdQb2xlZG7DrSBwxZllc3TDoXZrYS4gJyxcbiAgICAgICAgd29ya2luZ0RheXM6ICdWxaFlZG7DrSBkbnknLFxuICAgICAgICB3ZWVrZGF5czogJ1bFoWVkbsOtIGRueScsXG4gICAgICAgIHJlc3REYXk6IFsnemF2xZllbm8nLCAnemF2xZllbm8nXSxcbiAgICAgICAgcmV2aWV3c09uRmxhbXA6ICdSZWNlbnplIG5hIEZsYW1wdScsXG4gICAgICAgIHdyaXRlUmV2aWV3T25GbGFtcDogJ05hcHNhdCByZWNlbnppIG5hIEZsYW1wdScsXG4gICAgICAgIHBheW1lbnQ6ICdwbGF0YmEnLFxuICAgICAgICBldmVyeWRheTogJ0Rlbm7EmyBvZCAnLFxuICAgICAgICB3b3Jrc0Fyb3VuZFRoZUNsb2NrOiAnUHJhY3VqZSBub25zdG9wJyxcbiAgICAgICAgYXJvdW5kVGhlQ2xvY2s6ICdOb25zdG9wJyxcbiAgICAgICAga25vd01vcmU6ICdkb3p2xJtkxJt0IHNlIHbDrWNlJyxcbiAgICAgICAgdG9DbG9zZTogJ2RvIHV6YXbFmWVuw60nLFxuICAgICAgICBtb25kYXk6ICdwb25kxJtsw60nLFxuICAgICAgICB0dWVzZGF5OiAnw7p0ZXLDvScsXG4gICAgICAgIHdlZG5lc2RheTogJ3N0xZllZGEnLFxuICAgICAgICB0aHVyc2RheTogJ8SNdHZydGVrJyxcbiAgICAgICAgZnJpZGF5OiAncMOhdGVrJyxcbiAgICAgICAgc2F0dXJkYXk6ICdzb2JvdGEnLFxuICAgICAgICBzdW5kYXk6ICduZWTEm2xlJyxcbiAgICAgICAgbW9uOiAncG8nLFxuICAgICAgICB0dWU6ICfDunQnLFxuICAgICAgICB3ZWQ6ICdzdCcsXG4gICAgICAgIHRodTogJ8SNdCcsXG4gICAgICAgIGZyaTogJ3DDoScsXG4gICAgICAgIHNhdDogJ3NvJyxcbiAgICAgICAgc3VuOiAnbmUnLFxuICAgICAgICB0b0x1bmNoOiAnZG8gcG9sZWRuw60gcMWZZXN0w6F2a3knLFxuICAgICAgICB0b2RheTogJ0RuZXMnLFxuICAgICAgICBsZXNzVGhlbkhvdXI6ICdtw6luxJsgbmXFviBob2RpbnUnLFxuICAgICAgICB5b3VDb3VsZExhdGU6ICduZW11c8OtdGUgdG8gc3RpaG5vdXQnLFxuICAgICAgICB3b3JraW5nVGltZTogJ3ByYWNvdm7DrSBkb2JhJyxcbiAgICAgICAgc2hvd0FsbE9yZ0luUnVicmljOiAnWm9icmF6aXQgdsWhZWNobnkgb3JnYW5pemFjZSB2IHJ1YnJpY2UnLFxuICAgICAgICB0b2RheUlzUmVzdERheTogJ0RuZXMgamUgemF2xZllbm8nLFxuICAgICAgICBpbnRlcm5ldDogJ1BsYXRiYSBwcm9zdMWZZWRuaWN0dsOtbSBJbnRlcm5ldHUnLFxuICAgICAgICBub25jYXNoOiAnQmV6aG90b3Zvc3Ruw60gcGxhdGJhJyxcbiAgICAgICAgZ29sZGNyb3duOiAnWm9sb3RhamEgS29yb25hJyxcbiAgICAgICAgZGluZXJzY2x1YjogJ0RpbmVycyBDbHViJyxcbiAgICAgICAgbWFzdGVyY2FyZDogJ01hc3RlcmNhcmQnLFxuICAgICAgICBtYWVzdHJvY2FyZDogJ01hZXN0cm9DYXJkJyxcbiAgICAgICAgdmlzYTogJ1Zpc2EnLFxuICAgICAgICBjYXNoOiAnUGxhdGJhIGhvdG92xJsnLFxuICAgICAgICBhbWVyaWNhbmV4cHJlc3M6ICdBbWVyaWNhbiBFeHByZXNzJyxcbiAgICAgICAgaG91ciA6ICdob2RpbnUnLFxuICAgICAgICBsZXNzOiAnbcOpbsSbJyxcbiAgICAgICAgX2luIDogJ1phJyxcbiAgICAgICAgaXNDbG9zaW5nT25EaW5uZXIgOiAnemHEjcOtbsOhIHBvbGVkbsOtIHDFmWVzdMOhdmthJ1xuICAgIH0sXG5cbiAgICBlczoge1xuICAgICAgICBwbHVyYWxSdWxlczogZnVuY3Rpb24gKG4pIHsgLy8gKE51bWJlcilcbiAgICAgICAgICByZXR1cm4gKG4gPT09IDEpID8gMCA6IChuID49IDIgJiYgbiA8PSA0KSA/IDEgOiAyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJ0bkJhY2s6ICdBdHLDoXMnLFxuICAgICAgICBidG5GaW5kV2F5OiAnSXIgcGFyYSBhbGzDoScsXG4gICAgICAgIGJ0bkVudHJhbmNlOiAnQnVzY2FyIGFjY2VzbycsXG4gICAgICAgIGxpbmtSZXZpZXdzOiBbJ2NvbWVudGFyaW8nLCAnY29tZW50YXJpb3MnLCAnY29tZW50YXJpb3MnXSxcbiAgICAgICAgbGlua1Bob3RvOiBbJ2ZvdG8nLCAnZm90b3MnLCAnZm90b3MnXSxcbiAgICAgICAgbGlua0Jvb2tsZXQ6ICdGb2xsZXRvJyxcbiAgICAgICAgdG9tbW9yb3c6ICdtYcOxYW5hJyxcbiAgICAgICAgYWZ0ZXJUb21tb3JvdzogJ3Bhc2FkbyBtYcOxYW5hJyxcbiAgICAgICAgYWZ0ZXJXZWVrOiAnZW4gdW5hIHNlbWFuYSBtw6FzJyxcbiAgICAgICAgbmV4dFN1bjogJ2VsIGRvbWluZ28nLFxuICAgICAgICBuZXh0TW9uOiAnZWwgbHVuZXMnLFxuICAgICAgICBuZXh0VHVlOiAnZWwgbWFydGVzJyxcbiAgICAgICAgbmV4dFdlZDogJ2VsIG1pw6lyY29sZXMnLFxuICAgICAgICBuZXh0VGh1OiAnZWwganVldmVzJyxcbiAgICAgICAgbmV4dEZyaTogJ2VsIHZpZXJuZXMnLFxuICAgICAgICBuZXh0U2F0OiAnZWwgc8OhYmFkbycsXG4gICAgICAgIHdpbGxPcGVuOiAnc2UgYWJyaXLDoScsXG4gICAgICAgIHdpbGxDbG9zZTogJ3NlIGNlcnJhcsOhJyxcbiAgICAgICAgaXNPcGVuOiAnQWJpZXJ0bycsXG4gICAgICAgIG9wZW5UaWxsOiAnQWJpZXJ0byBoYXN0YSAnLFxuICAgICAgICBjbG9zZUluOiAnU2UgY2VycmFyw6EgZGVudHJvIGRlICcsXG4gICAgICAgIG9wZW5BdDogJ1NlIGFicmlyw6EgZWwgJyxcbiAgICAgICAgb3BlbkluOiAnU2UgYWJyaXLDoSBkZW50cm8gZGUgJyxcbiAgICAgICAgb3BlbjogJ1NlIGFicmlyw6EgJyxcbiAgICAgICAgbkhvdXJzOiBbJ2hvcmEnLCAnaG9yYXMnLCAnaG9yYXMnXSxcbiAgICAgICAgbk1pbnM6IFsnbWludXRvJywgJ21pbnV0b3MnLCAnbWludXRvcyddLFxuICAgICAgICBsdW5jaDogJ2hvcmEgZGUgY29sYWNpw7NuJyxcbiAgICAgICAgTHVuY2g6ICdIb3JhIGRlIGNvbGFjacOzbi4gJyxcbiAgICAgICAgd29ya2luZ0RheXM6ICdEw61hcyBsYWJvcmFibGVzJyxcbiAgICAgICAgd2Vla2RheXM6ICdEw61hcyBsYWJvcmFibGVzJyxcbiAgICAgICAgcmVzdERheTogWydjZXJyYWRvJywnY2VycmFkbyddLFxuICAgICAgICByZXZpZXdzT25GbGFtcDogJ0NvbWVudGFyaW9zIGVuIEZsYW1wJyxcbiAgICAgICAgd3JpdGVSZXZpZXdPbkZsYW1wOiAnRXNjcmliaXIgdW4gY29tZW50YXJpbyBlbiBGbGFtcCcsXG4gICAgICAgIHBheW1lbnQ6ICdwYWdvJyxcbiAgICAgICAgZXZlcnlkYXk6ICdDYWRhIGTDrWEgZGVzZGUnLFxuICAgICAgICB3b3Jrc0Fyb3VuZFRoZUNsb2NrOiAnQWJpZXJ0byBsYXMgMjQgaG9yYXMnLFxuICAgICAgICBhcm91bmRUaGVDbG9jazogJzI0IGhvcmFzJyxcbiAgICAgICAga25vd01vcmU6ICdwYXJhIHNhYmVyIG3DoXMnLFxuICAgICAgICB0b0Nsb3NlOiAnaGFzdGEgZWwgY2llcnJlJyxcbiAgICAgICAgbW9uZGF5OiAnbHVuZXMnLFxuICAgICAgICB0dWVzZGF5OiAnbWFydGVzJyxcbiAgICAgICAgd2VkbmVzZGF5OiAnbWnDqXJjb2xlcycsXG4gICAgICAgIHRodXJzZGF5OiAnanVldmVzJyxcbiAgICAgICAgZnJpZGF5OiAndmllcm5lcycsXG4gICAgICAgIHNhdHVyZGF5OiAnc8OhYmFkbycsXG4gICAgICAgIHN1bmRheTogJ2RvbWluZ28nLFxuICAgICAgICBtb246ICdsdW4nLFxuICAgICAgICB0dWU6ICdtYXInLFxuICAgICAgICB3ZWQ6ICdtacOpJyxcbiAgICAgICAgdGh1OiAnanVlJyxcbiAgICAgICAgZnJpOiAndmllJyxcbiAgICAgICAgc2F0OiAnc8OhYicsXG4gICAgICAgIHN1bjogJ2RvbScsXG4gICAgICAgIHRvTHVuY2g6ICdhbnRlcyBkZSBsYSBob3JhIGRlIGNvbGFjacOzbicsXG4gICAgICAgIHRvZGF5OiAnSG95JyxcbiAgICAgICAgbGVzc1RoZW5Ib3VyOiAnbWVub3MgZGUgdW5hIGhvcmEnLFxuICAgICAgICB5b3VDb3VsZExhdGU6ICdwdWVkZSBzZXIgcXVlIG5vIGFsY2FuemFzIGEgbGxlZ2FyJyxcbiAgICAgICAgd29ya2luZ1RpbWU6ICdob3JhcmlvIGRlIHRyYWJham8nLFxuICAgICAgICBzaG93QWxsT3JnSW5SdWJyaWM6ICdNb3N0cmFyIHRvZGFzIGxhcyBlbXByZXNhcyBkZSBsYSBjYXRlZ29yw61hJyxcbiAgICAgICAgdG9kYXlJc1Jlc3REYXk6ICdIb3kgY2VycmFkbycsXG4gICAgICAgIGludGVybmV0OiAnUGFnbyBwb3IgSW50ZXJuZXQnLFxuICAgICAgICBub25jYXNoOiAnUGFnbyBzaW4gZWZlY3Rpdm8nLFxuICAgICAgICBnb2xkY3Jvd246ICdab2xvdGF5YSBLb3JvbmEnLFxuICAgICAgICBkaW5lcnNjbHViOiAnRGluZXJzIENsdWInLFxuICAgICAgICBtYXN0ZXJjYXJkOiAnTWFzdGVyY2FyZCcsXG4gICAgICAgIG1hZXN0cm9jYXJkOiAnTWFlc3Ryb0NhcmQnLFxuICAgICAgICB2aXNhOiAnVmlzYScsXG4gICAgICAgIGNhc2g6ICdQYWdvIGVuIGVmZWN0aXZvJyxcbiAgICAgICAgYW1lcmljYW5leHByZXNzOiAnQW1lcmljYW4gRXhwcmVzcycsXG4gICAgICAgIGhvdXIgOiAnaG9yYScsXG4gICAgICAgIGxlc3M6ICdtZW5vcyBkZScsXG4gICAgICAgIF9pbiA6ICdEZW50cm8gZGUnLFxuICAgICAgICBpc0Nsb3NpbmdPbkRpbm5lciA6ICdzZSBjaWVycmEgcG9yIGhvcmEgZGUgY29sYWNpw7NuJ1xuICAgIH1cbn07XG4iLCJERy5UcmFmZmljID0gREcuVGlsZUxheWVyLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwZXJpb2Q6IDAsXG4gICAgICAgIGRpc2FibGVMYWJlbDogZmFsc2VcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBEaWN0aW9uYXJ5OiB7fVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl90aWxlVXJsID0gREcuY29uZmlnLnByb3RvY29sICsgKERHLkJyb3dzZXIucmV0aW5hID8gREcuY29uZmlnLnJldGluYVRyYWZmaWNUaWxlU2VydmVyIDogREcuY29uZmlnLnRyYWZmaWNUaWxlU2VydmVyKTtcbiAgICAgICAgdGhpcy5fbWV0YVVybCA9IERHLmNvbmZpZy5wcm90b2NvbCArIChERy5Ccm93c2VyLnJldGluYSA/IERHLmNvbmZpZy5yZXRpbmFUcmFmZmljTWV0YVNlcnZlciA6IERHLmNvbmZpZy50cmFmZmljTWV0YVNlcnZlcik7XG4gICAgICAgIHRoaXMuX3RpbWVVcmwgPSBERy5jb25maWcucHJvdG9jb2wgKyBERy5jb25maWcudHJhZmZpY1RpbWVzdGFtcFNlcnZlcjtcbiAgICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwgPSBERy5jb25maWcudHJhZmZpY0xheWVyVXBkYXRlSW50ZXJ2YWw7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVycm9yVGlsZVVybDogJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNycsXG4gICAgICAgICAgICBzdWJkb21haW5zOiAnMDEyMzQ1Njc5JyxcbiAgICAgICAgICAgIG1heE5hdGl2ZVpvb206IDE4LFxuICAgICAgICAgICAgZGV0ZWN0UmV0aW5hOiB0cnVlLFxuICAgICAgICAgICAgbWluWm9vbTogREcuY29uZmlnLnRyYWZmaWNMYXllck1pblpvb21cbiAgICAgICAgfTtcblxuICAgICAgICBvcHRpb25zID0gREcuc2V0T3B0aW9ucyh0aGlzLCBERy5leHRlbmQob3B0aW9ucyB8fCB7fSwgdGhpcy5fbGF5ZXJzT3B0aW9ucykpO1xuICAgICAgICBvcHRpb25zLnRpbWVzdGFtcFN0cmluZyA9IG9wdGlvbnMucGVyaW9kID8gJycgOiAoJz8nICsgIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpO1xuICAgICAgICB0aGlzLl9tZXRhTGF5ZXIgPSBERy5NZXRhLmxheWVyKG51bGwsIHtcbiAgICAgICAgICAgIGRldGVjdFJldGluYTogb3B0aW9ucy5kZXRlY3RSZXRpbmEsXG4gICAgICAgICAgICBtYXhOYXRpdmVab29tOiBvcHRpb25zLm1heE5hdGl2ZVpvb20sXG4gICAgICAgICAgICBkYXRhRmlsdGVyOiBERy5iaW5kKHRoaXMuX3Byb2Nlc3NEYXRhLCB0aGlzKSxcbiAgICAgICAgICAgIG1pblpvb206IG9wdGlvbnMubWluWm9vbVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faXNEZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX29uVGltZXIgPSBERy5iaW5kKHRoaXMuX29uVGltZXIsIHRoaXMpO1xuICAgICAgICBERy5UaWxlTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl90aWxlVXJsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gI3NldFRpbWUoZGF5IFswLTZdLCB0aW1lWzAtMjNdKSA/Pz8/XG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB0aGlzLl91cGRhdGVMYXllclByb2plY3QoKTtcblxuICAgICAgICBtYXBcbiAgICAgICAgICAgIC5hZGRMYXllcih0aGlzLl9tZXRhTGF5ZXIpXG4gICAgICAgICAgICAub24oJ3Byb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fb25NYXBQcm9qZWN0Q2hhbmdlLCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX21ldGFMYXllci5vbih0aGlzLl9sYXllckV2ZW50c0xpc3RlbmVycywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlciA9IERHLmxhYmVsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdXBkYXRlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fb25UaW1lciwgdGhpcy5fdXBkYXRlSW50ZXJ2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgREcuVGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdXBkYXRlVGltZXIpO1xuXG4gICAgICAgIG1hcFxuICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX21ldGFMYXllcilcbiAgICAgICAgICAgIC5vZmYoJ3Byb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fb25NYXBQcm9qZWN0Q2hhbmdlLCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX21ldGFMYXllci5vZmYodGhpcy5fbGF5ZXJFdmVudHNMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xhYmVsSGVscGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsSGVscGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIERHLlRpbGVMYXllci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLl9nZXRUaW1lc3RhbXBTdHJpbmcoKS50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnRpbWVzdGFtcFN0cmluZyA9ICc/JyArIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMudGltZXN0YW1wU3RyaW5nID0gJz8nICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH0pLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlKCd1cGRhdGUnLCB7dGltZXN0YW1wOiBzZWxmLm9wdGlvbnMudGltZXN0YW1wU3RyaW5nfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fbGF5ZXJFdmVudHNMaXN0ZW5lcnMubW91c2VvdXQuY2FsbChzZWxmKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9tZXRhTGF5ZXIuZ2V0T3JpZ2luKCkuc2V0VVJMKHNlbGYuX3ByZXBhcmVNZXRhVVJMKCksIHNlbGYpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldFN1YmRvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzT3B0aW9ucy5zdWJkb21haW5zW1xuICAgICAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5fbGF5ZXJzT3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aClcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgX2dldFRpbWVzdGFtcFN0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gREcuYWpheChcbiAgICAgICAgICAgIERHLlV0aWwudGVtcGxhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZVVybCxcbiAgICAgICAgICAgICAgICBERy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBzIDogdGhpcy5nZXRTdWJkb21haW4oKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdENvZGU6IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpLmNvZGVcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMgfHwge30pKSxcbiAgICAgICAgICAgIHt0eXBlOiAnZ2V0J31cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgX29uVGltZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZXJpb2QgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Byb2Nlc3NEYXRhOiBmdW5jdGlvbiAodHJhZmZpY0RhdGEsIGNvb3JkKSB7XG4gICAgICAgIHZhciB0aWxlT3JpZ2luUG9pbnQgPSBjb29yZC5zY2FsZUJ5KHRoaXMuZ2V0VGlsZVNpemUoKSk7XG4gICAgICAgIHZhciBwb2x5Z29uTG5nTGF0VG9Qb2ludHMgPSBERy5iaW5kKHRoaXMuX3BvbHlnb25MbmdMYXRUb1BvaW50cywgdGhpcywgdGlsZU9yaWdpblBvaW50KTtcbiAgICAgICAgdmFyIGhpbnRzID0ge307XG5cbiAgICAgICAgaWYgKCFERy5VdGlsLmlzQXJyYXkodHJhZmZpY0RhdGEpKSB7ICAgIC8vIFRPRE8gcmVtb3ZlXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICB0cmFmZmljRGF0YVsxXS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzW2l0ZW0uZ3JhcGhfaWRdID0gaXRlbS5zcGVlZF90ZXh0O1xuICAgICAgICB9LCBoaW50cyk7XG5cbiAgICAgICAgcmV0dXJuIHRyYWZmaWNEYXRhWzBdXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uZ3JhcGhfaWQsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiBoaW50c1tpdGVtLmdyYXBoX2lkXSxcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IERHLldrdC50b0dlb0pTT04oaXRlbS5nZW9tZXRyeVswXS5vYmplY3RbMF0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZ2VvbWV0cnkudHlwZSA9PSAnUG9seWdvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5nZW9tZXRyeS50eXBlID09ICdNdWx0aVBvbHlnb24nO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2VvSnNvbiA9IGl0ZW0uZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2VvSnNvbi50eXBlID09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICBnZW9Kc29uLmNvb3JkaW5hdGVzID0gcG9seWdvbkxuZ0xhdFRvUG9pbnRzKGdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvSnNvbi50eXBlID09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb0pzb24uY29vcmRpbmF0ZXMgPSBnZW9Kc29uLmNvb3JkaW5hdGVzLm1hcChwb2x5Z29uTG5nTGF0VG9Qb2ludHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9wb2x5Z29uTG5nTGF0VG9Qb2ludHM6IGZ1bmN0aW9uIChvcmlnaW5Qb2ludCwgcG9seWdvbikge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIHJldHVybiBwb2x5Z29uLm1hcChmdW5jdGlvbiAoY29udG91cikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRvdXIubWFwKGZ1bmN0aW9uIChsbmdMYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwXG4gICAgICAgICAgICAgICAgICAgIC5wcm9qZWN0KFtsbmdMYXRbMV0sIGxuZ0xhdFswXV0pLnJvdW5kKClcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KG9yaWdpblBvaW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3ByZXBhcmVNZXRhVVJMOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBERy5VdGlsLnRlbXBsYXRlKHRoaXMuX21ldGFVcmwsIERHLmV4dGVuZCh7XG4gICAgICAgICAgICB4OiAne3h9JyxcbiAgICAgICAgICAgIHk6ICd7eX0nLFxuICAgICAgICAgICAgejogJ3t6fScsXG4gICAgICAgICAgICBzOiAne3N9J1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUxheWVyUHJvamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX21hcC5wcm9qZWN0RGV0ZWN0b3IuZ2V0UHJvamVjdCgpO1xuICAgICAgICBERy5zZXRPcHRpb25zKHRoaXMsIHByb2plY3QgJiYgcHJvamVjdC50cmFmZmljID8ge1xuICAgICAgICAgICAgcHJvamVjdENvZGU6IHByb2plY3QuY29kZSxcbiAgICAgICAgICAgIGJvdW5kczogcHJvamVjdC5sYXRMbmdCb3VuZHMsXG4gICAgICAgICAgICBtaW5ab29tOiBNYXRoLm1heChwcm9qZWN0Lm1pblpvb20sIHRoaXMuX2xheWVyc09wdGlvbnMubWluWm9vbSksXG4gICAgICAgICAgICBtYXhab29tOiBwcm9qZWN0Lm1heFpvb21cbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIG1heFpvb206IDAsXG4gICAgICAgICAgICBtaW5ab29tOiAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tZXRhTGF5ZXIuZ2V0T3JpZ2luKCkuc2V0VVJMKHRoaXMuX3ByZXBhcmVNZXRhVVJMKCkpO1xuICAgIH0sXG5cbiAgICBfb25NYXBQcm9qZWN0Q2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyUHJvamVjdCgpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH0sXG5cbiAgICBfbGF5ZXJFdmVudHNMaXN0ZW5lcnM6IHtcbiAgICAgICAgbW91c2VvdmVyOiBmdW5jdGlvbiAoZSkgeyAvLyAoT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKCdwb2ludGVyJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWxIZWxwZXIgJiYgZS5tZXRhLnNwZWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxIZWxwZXJcbiAgICAgICAgICAgICAgICAgICAgLnNldFBvc2l0aW9uKGUubGF0bG5nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q29udGVudChlLm1ldGEuc3BlZWQgKyAnICcgKyB0aGlzLnQoJ3NwZWVkX3VuaXRfa21faCcpKVxuICAgICAgICAgICAgICAgICAgICAuYWRkVG8odGhpcy5fbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEN1cnNvcignJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWxIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGFiZWxIZWxwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWxIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbEhlbHBlci5zZXRQb3NpdGlvbihlLmxhdGxuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldEN1cnNvcjogZnVuY3Rpb24gKGN1cnNvcikgeyAvLyAoU3RyaW5nKVxuICAgICAgICB0aGlzLl9tYXAuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cblxufSk7XG5cbkRHLlRyYWZmaWMuaW5jbHVkZShERy5Mb2NhbGUpO1xuXG5ERy50cmFmZmljID0gZnVuY3Rpb24gKG9wdGlvbnMpIHsgLy8gKE9iamVjdClcbiAgICByZXR1cm4gbmV3IERHLlRyYWZmaWMob3B0aW9ucyk7XG59O1xuIiwiREcuVHJhZmZpYy5EaWN0aW9uYXJ5LnJ1ID0ge1xuICAgIHNwZWVkX3VuaXRfa21faDogJ9C60Lwv0YcnXG59OyIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5pdCA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTsiLCJERy5UcmFmZmljLkRpY3Rpb25hcnkuY3MgPSB7XG4gICAgc3BlZWRfdW5pdF9rbV9oOiAna20vaCdcbn07IiwiREcuVHJhZmZpYy5EaWN0aW9uYXJ5LmVzID0ge1xuICAgIHNwZWVkX3VuaXRfa21faDogJ2ttL2gnXG59OyIsIkRHLlRyYWZmaWMuRGljdGlvbmFyeS5lbiA9IHtcbiAgICBzcGVlZF91bml0X2ttX2g6ICdrbS9oJ1xufTsiLCJERy5Db250cm9sLlRyYWZmaWMgPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wcmlnaHQnLFxuICAgICAgICBpY29uQ2xhc3M6ICd0cmFmZmljJ1xuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3RyYWZmaWNDbGFzcyA9ICdkZy10cmFmZmljLWNvbnRyb2wnO1xuICAgICAgICB0aGlzLl9jb250cm9sSGlkZUNsYXNzID0gJ2RnLWNvbnRyb2wtcm91bmRfaXMtaGlkZGVuX3RydWUnO1xuXG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIERHLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIF90cmFmZmljTGF5ZXI6IG51bGxcbiAgICAgICAgfSkub24odGhpcy5fY29udHJvbEV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIF9jb250cm9sRXZlbnRzOiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhZmZpY0xheWVyID0gREcudHJhZmZpYygpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCd6b29tZW5kIHByb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fdXBkYXRlQ29udHJvbFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gIXRoaXMuX2FjdGl2ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dUcmFmZmljKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpZGVUcmFmZmljKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5fY29udHJvbEV2ZW50cywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCd6b29tZW5kIHByb2plY3RjaGFuZ2UgcHJvamVjdGxlYXZlJywgdGhpcy5fdXBkYXRlQ29udHJvbFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl90cmFmZmljTGF5ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdHJhZmZpY0xheWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2hvd1RyYWZmaWM6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fdXBkYXRlVHJhZmZpY1Njb3JlKCk7XG4gICAgICAgIHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl90cmFmZmljTGF5ZXIpO1xuICAgIH0sXG5cbiAgICBfaGlkZVRyYWZmaWM6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgdGhpcy5faGFuZGxlRG9tKCdyZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3RyYWZmaWNMYXllcik7XG4gICAgfSxcblxuICAgIF9oYW5kbGVEb206IGZ1bmN0aW9uIChtZXRob2QsIHNjb3JlKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5fbGluaztcblxuICAgICAgICBhLmlubmVySFRNTCA9IHNjb3JlIHx8ICcnO1xuICAgICAgICBERy5Eb21VdGlsW21ldGhvZCArICdDbGFzcyddKGEsIHRoaXMuX3RyYWZmaWNDbGFzcyk7XG4gICAgICAgIERHLkRvbVV0aWxbbWV0aG9kICsgJ0NsYXNzJ10oYSwgdGhpcy5fdHJhZmZpY0NsYXNzICsgJ19jb2xvcl8nICsgdGhpcy5fc2NvcmVSYXRlKTtcbiAgICB9LFxuXG4gICAgX2dldFRyYWZmaWNDb2xvcjogZnVuY3Rpb24gKHNjb3JlKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ2dyZWVuJztcblxuICAgICAgICBpZiAoc2NvcmUgPiA3KSB7XG4gICAgICAgICAgICByZXN1bHQgPSAncmVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzY29yZSA+IDQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICd5ZWxsb3cnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUNvbnRyb2xWaXNpYmlsaXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fbWFwLnByb2plY3REZXRlY3Rvci5nZXRQcm9qZWN0KCksXG4gICAgICAgICAgICBwcm9qZWN0SGFzVHJhZmZpYyA9IHByb2plY3QgJiYgcHJvamVjdC50cmFmZmljLFxuICAgICAgICAgICAgbWV0aG9kID0gKCh0aGlzLl9tYXAuZ2V0Wm9vbSgpIDwgREcuY29uZmlnLnRyYWZmaWNMYXllck1pblpvb20pIHx8XG4gICAgICAgICAgICAoIXByb2plY3RIYXNUcmFmZmljKSkgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJztcblxuICAgICAgICBERy5Eb21VdGlsW21ldGhvZF0odGhpcy5fY29udGFpbmVyLCB0aGlzLl9jb250cm9sSGlkZUNsYXNzKTtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSAmJiBwcm9qZWN0SGFzVHJhZmZpYykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVHJhZmZpY1Njb3JlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3VwZGF0ZVRyYWZmaWNTY29yZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fZ2V0VHJhZmZpY1Njb3JlKCkudGhlbihmdW5jdGlvbiAoc2NvcmUpIHtcbiAgICAgICAgICAgIHNjb3JlID0gcGFyc2VJbnQoc2NvcmUsIDEwKTsgLy8gc29tZXRpbWVzIHdlYmFwaSByZXR1cm5zIHNvbWV0aGluZyBsaWtlICc1LCsnXG5cbiAgICAgICAgICAgIHNlbGYuX3Njb3JlUmF0ZSA9IHNlbGYuX2dldFRyYWZmaWNDb2xvcihzY29yZSk7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVEb20oJ2FkZCcsIHNjb3JlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRUcmFmZmljU2NvcmU6IGZ1bmN0aW9uICgpIHsgLy8gKCkgLT4gUHJvbWlzZVxuICAgICAgICB2YXIgdXJsID0gREcuVXRpbC50ZW1wbGF0ZShcbiAgICAgICAgICAgIERHLmNvbmZpZy5wcm90b2NvbCArIERHLmNvbmZpZy50cmFmZmljU2NvcmVTZXJ2ZXIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgczogdGhpcy5fdHJhZmZpY0xheWVyLmdldFN1YmRvbWFpbigpLFxuICAgICAgICAgICAgICAgIHByb2plY3RDb2RlOiB0aGlzLl9tYXAucHJvamVjdERldGVjdG9yLmdldFByb2plY3QoKS5jb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIERHLmFqYXgodXJsLCB7dHlwZTogJ2dldCd9KTtcbiAgICB9LFxuXG4gICAgX3JlbmRlclRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoKSB7IC8vICgpXG4gICAgICAgIHRoaXMuX2xpbmsudGl0bGUgPSB0aGlzLnQoJ2J1dHRvbl90aXRsZScpO1xuICAgIH1cbn0pO1xuXG5ERy5jb250cm9sLnRyYWZmaWMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgREcuQ29udHJvbC5UcmFmZmljKG9wdGlvbnMpO1xufTtcblxuREcuTWFwLm1lcmdlT3B0aW9ucyh7XG4gICAgdHJhZmZpY0NvbnRyb2w6IGZhbHNlXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRyYWZmaWNDb250cm9sKSB7XG4gICAgICAgIHRoaXMudHJhZmZpY0NvbnRyb2wgPSBERy5jb250cm9sLnRyYWZmaWModGhpcy5vcHRpb25zLnRyYWZmaWNDb250cm9sKTtcbiAgICAgICAgdGhpcy5hZGRDb250cm9sKHRoaXMudHJhZmZpY0NvbnRyb2wpO1xuICAgIH1cbn0pO1xuIiwiREcuQ29udHJvbC5UcmFmZmljLkRpY3Rpb25hcnkucnUgPSB7XG5cdGJ1dHRvbl90aXRsZTogJ9Cf0YDQvtCx0LrQuCdcbn07XG4iLCJERy5Db250cm9sLlRyYWZmaWMuRGljdGlvbmFyeS5pdCA9IHtcblx0YnV0dG9uX3RpdGxlOiAnQ29sb25uYSdcbn07XG4iLCJERy5Db250cm9sLlRyYWZmaWMuRGljdGlvbmFyeS5jcyA9IHtcblx0YnV0dG9uX3RpdGxlOiAnWsOhY3B5J1xufTtcbiIsIkRHLkNvbnRyb2wuVHJhZmZpYy5EaWN0aW9uYXJ5LmVzID0ge1xuXHRidXR0b25fdGl0bGU6ICdUYWNvJ1xufTtcbiIsIkRHLkNvbnRyb2wuVHJhZmZpYy5EaWN0aW9uYXJ5LmVuID0ge1xuXHRidXR0b25fdGl0bGU6ICdUcmFmZmljJ1xufTtcbiIsIkRHLlJ1bGVyID0gREcuTGF5ZXIuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZWRpdGFibGU6IHRydWVcbiAgICB9LFxuXG4gICAgaW5jbHVkZXM6IFtERy5Mb2NhbGVdLFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBEaWN0aW9uYXJ5OiB7fVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykgeyAvLyAoQXJyYXksIE9iamVjdClcbiAgICAgICAgREcuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2xheWVycyA9IHtcbiAgICAgICAgICAgIGJhY2sgOiBudWxsLFxuICAgICAgICAgICAgbWlkZGxlIDogbnVsbCxcbiAgICAgICAgICAgIGZyb250IDogbnVsbCxcbiAgICAgICAgICAgIG1vdXNlIDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wb2ludHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9sYXllcnNDb250YWluZXIgPSBERy5mZWF0dXJlR3JvdXAoKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllcnNDb250YWluZXIuYWRkTGF5ZXIodGhpcy5fbGF5ZXJzW25hbWVdID0gREcuZmVhdHVyZUdyb3VwKCkpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9yZXNldCgpO1xuXG4gICAgICAgIGlmIChERy5Ccm93c2VyLm1vYmlsZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpbmVNb3VzZUV2ZW50cy5tb3VzZW92ZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGluZU1vdXNlRXZlbnRzLm1vdXNlb3V0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpbmVNb3VzZUV2ZW50cy5tb3VzZW1vdmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGluZU1vdXNlRXZlbnRzLmNsaWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhdGxuZ3MgJiYgbGF0bG5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGF0TG5ncyhsYXRsbmdzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkgeyAvLyAoTWFwKVxuICAgICAgICB0aGlzLl9tYXAgPSBtYXAub24oJ2xhbmdjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXN0YW5jZSwgdGhpcyk7XG5cbiAgICAgICAgLy8gIFBhbmUgZm9yIHJ1bGVyIE1hcmtlcnNcbiAgICAgICAgaWYgKCF0aGlzLl9tYXAuZ2V0UGFuZSgncnVsZXJNYXJrZXJQYW5lJykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcC5jcmVhdGVQYW5lKCdydWxlck1hcmtlclBhbmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBNYWluIHJ1bGVyIHBhbmUgKHN2ZyBvYmplY3RzIGFuZCBydW5uZXIpXG4gICAgICAgIGlmICghdGhpcy5fbWFwLmdldFBhbmUoJ3J1bGVyUGFuZScpKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuY3JlYXRlUGFuZSgncnVsZXJQYW5lJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXllcnNDb250YWluZXIuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLm1vdXNlLmZpcmUoJ2xheWVyYWRkJyk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaXN0YW5jZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzLm1vdXNlLm9uKHRoaXMuX2xpbmVNb3VzZUV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7IC8vIChNYXApXG4gICAgICAgIG1hcFxuICAgICAgICAgICAgLm9mZignbGFuZ2NoYW5nZScsIHRoaXMuX3VwZGF0ZURpc3RhbmNlLCB0aGlzKVxuICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJzLm1vdXNlLm9mZih0aGlzLl9saW5lTW91c2VFdmVudHMsIHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgIH0sXG5cbiAgICBnZXRUb3RhbERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IE51bWJlclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsY0Rpc3RhbmNlKCk7XG4gICAgfSxcblxuICAgIHNwbGljZUxhdExuZ3M6IGZ1bmN0aW9uIChpbmRleCkgeyAvLyAoTnVtYmVyLCBOdW1iZXIsIGFyZ3MgLi4uKSAtPiBBcnJheVxuICAgICAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5fcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIG11dGF0aW9uU3RhcnQgPSBpbmRleCA+PSAwID8gTWF0aC5taW4oaW5kZXgsIG9sZExlbmd0aCkgOiBvbGRMZW5ndGggLSBpbmRleCxcbiAgICAgICAgICAgIHJlbW92ZWQgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHRoaXMuX3BvaW50cywgYXJndW1lbnRzKS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLm1vdXNlLnJlbW92ZUxheWVyKHBvaW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQub2ZmKCkuZ2V0TGF0TG5nKCk7XG4gICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMuX3BvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG11dGF0aW9uU3RhcnQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX3BvaW50c1tpXSBpbnN0YW5jZW9mIERHLlJ1bGVyLkxheWVyZWRNYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50c1tpXSA9IHRoaXMuX2NyZWF0ZVBvaW50KHRoaXMuX3BvaW50c1tpXSwgdGhpcy5vcHRpb25zLmljb25TdHlsZXMubGFyZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAub24odGhpcy5fcG9pbnRFdmVudHMsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAub25jZSgnYWRkJywgdGhpcy5fYWRkQ2xvc2VIYW5kbGVyLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFRvKHRoaXMuX2xheWVycy5tb3VzZSwgdGhpcy5fbGF5ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgJiYgIXRoaXMuX3BvaW50c1tpIC0gMV0uX2xlZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkTGVncyh0aGlzLl9wb2ludHNbaSAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRzW2ldLnNldFBvaW50U3R5bGUodGhpcy5vcHRpb25zLmljb25TdHlsZXNbaSAmJiBpIDwgbGVuZ3RoIC0gMSA/ICdzbWFsbCcgOiAnbGFyZ2UnXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRzW2ldLl9wb3MgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGVncyh0aGlzLl9wb2ludHNbbGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgaWYgKG9sZExlbmd0aCA+IDAgJiYgb2xkTGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRzW29sZExlbmd0aCAtIDFdLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9pbnRzW211dGF0aW9uU3RhcnRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGVncyh0aGlzLl9wb2ludHNbbXV0YXRpb25TdGFydF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11dGF0aW9uU3RhcnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRzW211dGF0aW9uU3RhcnQgLSAxXS5zZXRQb2ludFN0eWxlKHRoaXMub3B0aW9ucy5pY29uU3R5bGVzLnNtYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVSdWxlclBvaW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChERy5Ccm93c2VyLnRvdWNoICYmIHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIuY29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykgeyAvLyAoTGF0TG5nKSAtPiBSdWxlclxuICAgICAgICB2YXIgbGFzdFBvaW50ID0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgICBsYXRsbmcgPSBERy5sYXRMbmcobGF0bG5nKTtcblxuICAgICAgICBpZiAobGFzdFBvaW50KSB7XG4gICAgICAgICAgICBsYXRsbmcgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcobGF0bG5nLCBsYXN0UG9pbnQuZ2V0TGF0TG5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zcGxpY2VMYXRMbmdzKHRoaXMuX3BvaW50cy5sZW5ndGgsIDAsIGxhdGxuZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IEFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50LmdldExhdExuZygpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHsgLy8gKEFycmF5KSAtPiBSdWxlclxuICAgICAgICB2YXIgYXJncyA9IGxhdGxuZ3Muc2xpY2UoKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KDAsIHRoaXMuX3BvaW50cy5sZW5ndGgpO1xuICAgICAgICB0aGlzLnNwbGljZUxhdExuZ3MuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgREcuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIF9saW5lTWFya2VySGVscGVyOiBudWxsLFxuICAgICAgICAgICAgX21vcnBoaW5nTm93OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2xpbmVNb3VzZUV2ZW50czoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQubGF5ZXI7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgREcuTWFya2VyICYmIHRhcmdldC5fcG9zICE9PSB0aGlzLl9wb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZSh0YXJnZXQpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyID0gdGFyZ2V0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBERy5QYXRoICYmIHRoaXMub3B0aW9ucy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXRsbmcgPSBldmVudC5sYXRsbmcsXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFBvcyA9IHRhcmdldC5fcG9pbnQuX3BvcyArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpY2VMYXRMbmdzKGluc2VydFBvcywgMCwgbGF0bG5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdmVyOiBmdW5jdGlvbiAoZXZlbnQpIHsgLy8gKE1vdXNlRXZlbnQpXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQubGF5ZXI7XG5cbiAgICAgICAgICAgIHRhcmdldC5faG92ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9ycGhpbmdOb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgREcuTWFya2VyICYmIHRhcmdldC5fcG9zICE9PSB0aGlzLl9wb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UodGFyZ2V0KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERHLlBhdGggJiYgIXRoaXMuX2xpbmVNYXJrZXJIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSB0YXJnZXQuX3BvaW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlciA9IHRoaXMuX2FkZFJ1bm5pbmdMYWJlbChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVhcmVzdFBvaW50KHBvaW50Ll9sZWdzLm1pZGRsZSwgZXZlbnQubGF0bG5nKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LmxheWVyLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXYgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAgICAgICB0YXJnZXQuX2hvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3JwaGluZ05vdyB8fCB0YXJnZXQuX3BvcyA9PT0gdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgREcuTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2Ugb25seSB3aGVuIHdlIG1vdmUgb3V0IGZyb20gbGFiZWwgY29udGFpbmVyIChpZiBicm93c2VyIHN1cHBvcnQgcmVsYXRlZFRhcmdldClcbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsRXYucmVsYXRlZFRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICAob3JpZ2luYWxFdi5yZWxhdGVkVGFyZ2V0ICE9PSB0YXJnZXQucXVlcnlTZWxlY3RvcignY29udGFpbmVyJykgJiZcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdi5yZWxhdGVkVGFyZ2V0LnBhcmVudE5vZGUgIT09IHRhcmdldC5xdWVyeVNlbGVjdG9yKCdjb250YWluZXInKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVSdW5uaW5nTGFiZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHsgLy8gKE1vdXNlRXZlbnQpXG4gICAgICAgICAgICBpZiAodGhpcy5fbW9ycGhpbmdOb3cgfHwgIXRoaXMuX2xpbmVNYXJrZXJIZWxwZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IGV2ZW50LmxheWVyLl9wb2ludCxcbiAgICAgICAgICAgICAgICBsYXRsbmcgPSB0aGlzLl9uZWFyZXN0UG9pbnQocG9pbnQuX2xlZ3MubWlkZGxlLCBldmVudC5sYXRsbmcpO1xuXG4gICAgICAgICAgICB0aGlzLl9saW5lTWFya2VySGVscGVyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRMYXRMbmcobGF0bG5nKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VGV4dCh0aGlzLl9nZXRGb3JtYXRlZERpc3RhbmNlKHBvaW50LCBwb2ludC5nZXRMYXRMbmcoKS5kaXN0YW5jZVRvKGxhdGxuZykpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGF5ZXJhZGQ6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tuYW1lXS5icmluZ1RvRnJvbnQoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9maXJlQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2VkJywge2xhdGxuZ3MgOiB0aGlzLmdldExhdExuZ3MoKX0pO1xuICAgIH0sXG5cbiAgICBfYWRkUnVubmluZ0xhYmVsOiBmdW5jdGlvbiAobGF0bG5nLCBwcmV2aW91c1BvaW50KSB7IC8vIChMYXRMbmcsIFJ1bGVyLkxheWVyZWRNYXJrZXIpXG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuX2NyZWF0ZVBvaW50KGxhdGxuZykuYWRkVG8odGhpcy5fbGF5ZXJzLm1vdXNlLCB0aGlzLl9sYXllcnMpO1xuICAgICAgICB2YXIgcGFuZSA9IHRoaXMuX21hcC5nZXRQYW5lKCdydWxlclBhbmUnKTtcbiAgICAgICAgcGFuZS5pbnNlcnRCZWZvcmUocG9pbnQuX2ljb24sIHBhbmUubGFzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgIHJldHVybiBwb2ludC5zZXRUZXh0KHRoaXMuX2dldEZvcm1hdGVkRGlzdGFuY2UocHJldmlvdXNQb2ludCwgcHJldmlvdXNQb2ludC5nZXRMYXRMbmcoKS5kaXN0YW5jZVRvKGxhdGxuZykpKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVJ1bm5pbmdMYWJlbDogZnVuY3Rpb24gKCkgeyAvLyAoKVxuICAgICAgICBpZiAodGhpcy5fbGluZU1hcmtlckhlbHBlcikge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLm1vdXNlLnJlbW92ZUxheWVyKHRoaXMuX2xpbmVNYXJrZXJIZWxwZXIpO1xuICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luc2VydFBvaW50SW5MaW5lOiBmdW5jdGlvbiAoZXZlbnQpIHsgLy8gKE1vdXNlRXZlbnQpXG4gICAgICAgIHZhciBsYXRsbmcgPSB0aGlzLl9saW5lTWFya2VySGVscGVyLmdldExhdExuZygpLFxuICAgICAgICAgICAgaW5zZXJ0UG9zID0gZXZlbnQudGFyZ2V0Ll9wb2ludC5fcG9zICsgMSxcbiAgICAgICAgICAgIHBvaW50O1xuXG4gICAgICAgIGlmIChMLkJyb3dzZXIuaWUpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gZXZlbnQub3JpZ2luYWxFdmVudC50YXJnZXQgfHwgZXZlbnQub3JpZ2luYWxFdmVudC5zcmNFbGVtZW50LFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGgucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChwYXRoKTsgLy8gSUUgY2xpY2sgZXZlbnQgbGVha2luZyBwcm9ibGVtIHNvbHV0aW9uOiB3ZSByZWFwcGVuZCBtb3VzZWRvd24gZXZlbnQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyhpbnNlcnRQb3MsIDAsIGxhdGxuZyk7XG4gICAgICAgIHBvaW50ID0gdGhpcy5fcG9pbnRzW2luc2VydFBvc107XG4gICAgICAgIHBvaW50LnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZShwb2ludCkpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAgICAgICAgICAgICBlLmluaXRNb3VzZUV2ZW50KCdtb3VzZXVwJywgZmFsc2UsIGZhbHNlLCBkb2N1bWVudC5kZWZhdWx0VmlldywgMSwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDEsIHBvaW50Ll9pY29uKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGUpO1xuXG4gICAgICAgICAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgICAgICAgICAgICAgIGUuaW5pdE1vdXNlRXZlbnQoJ21vdXNlZG93bicsIGZhbHNlLCBmYWxzZSwgZG9jdW1lbnQuZGVmYXVsdFZpZXcsIDEsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAxLCBwb2ludC5faWNvbik7XG4gICAgICAgICAgICAgICAgcG9pbnQuX2ljb24uZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuX2ljb24uZmlyZUV2ZW50KCdvbk1vdXNlVXAnLCBERy5leHRlbmQoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSwge1xuICAgICAgICAgICAgICAgICAgICBidXR0b246IDEsXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBwb2ludC5faWNvbi5maXJlRXZlbnQoJ29uTW91c2VEb3duJywgREcuZXh0ZW5kKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCksIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiAxLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHRoaXMuX3JlbW92ZVJ1bm5pbmdMYWJlbCgpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxlZ3MocG9pbnQpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBwb2ludCBvbiBnaXZlbiBwb2x5bGluZSB3aGljaCBpcyBjbG9zZXN0IHRvIGdpdmVuIGxhdGxuZ1xuICAgIF9uZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uIChwb2x5bGluZSwgbGF0bG5nKSB7IC8vIChQb2x5bGluZSwgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIENvbnZlcnQgZXZlcnl0aGluZyB0byBwaXhlbCBjb29yZGluYXRlc1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLl9wcm9qZWN0KGxhdGxuZyk7XG4gICAgICAgIHZhciBsaW5lUG9pbnRzID0gcG9seWxpbmUuZ2V0TGF0TG5ncygpLm1hcChmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcHJvamVjdChsYXRsbmcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaXJzdCBsb29rIGZvciBjbG9zZXN0IHBvbHlsaW5lIHNlZ21lbnRcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlO1xuICAgICAgICB2YXIgY2xvc2VzdFNlZ21lbnRJbmRleDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gREcuTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShcbiAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnRzW2ldLFxuICAgICAgICAgICAgICAgIGxpbmVQb2ludHNbaSArIDFdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAobWluRGlzdGFuY2UgPT09IHVuZGVmaW5lZCB8fCBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0U2VnbWVudEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZW4gbG9vayBmb3IgY2xvc2VzdCBwb2ludCBvbiB0aGF0IHNlZ21lbnRcbiAgICAgICAgdmFyIGNsb3Nlc3RQb2ludCA9IERHLkxpbmVVdGlsLmNsb3Nlc3RQb2ludE9uU2VnbWVudChcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgbGluZVBvaW50c1tjbG9zZXN0U2VnbWVudEluZGV4XSxcbiAgICAgICAgICAgIGxpbmVQb2ludHNbY2xvc2VzdFNlZ21lbnRJbmRleCArIDFdXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIExhdExuZ1xuICAgICAgICByZXR1cm4gdGhpcy5fdW5wcm9qZWN0KGNsb3Nlc3RQb2ludCk7XG4gICAgfSxcblxuICAgIF9hZGRDbG9zZUhhbmRsZXI6IGZ1bmN0aW9uIChldmVudCkgeyAvLyAoRXZlbnQpXG4gICAgICAgIGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLl9kZWxldGVQb2ludCwgdGhpcylcbiAgICAgICAgICAgICAgICAucXVlcnlTZWxlY3RvcigncmVtb3ZlLWxpbmsnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgfSxcblxuICAgIF9jcmVhdGVQb2ludDogZnVuY3Rpb24gKGxhdGxuZywgc3R5bGUpIHsgLy8gKExhdExuZywgT2JqZWN0KSAtPiBSdWxlci5MYXllcmVkTWFya2VyXG4gICAgICAgIHZhciBwb2ludFN0eWxlID0gc3R5bGUgPyBzdHlsZSA6IHRoaXMub3B0aW9ucy5pY29uU3R5bGVzLmxhcmdlLFxuICAgICAgICAgICAgbGF5ZXJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHBvaW50U3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllcnNbbGF5ZXJdID0gREcuY2lyY2xlTWFya2VyKGxhdGxuZywgcG9pbnRTdHlsZVtsYXllcl0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gREcuUnVsZXIubGF5ZXJlZE1hcmtlcihsYXRsbmcsIHtcbiAgICAgICAgICAgIGxheWVycyA6IGxheWVycyxcbiAgICAgICAgICAgIGRyYWdnYWJsZSA6IHRoaXMub3B0aW9ucy5lZGl0YWJsZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gTW92ZXMgY3VyciBMYXRMbmcgdG8gY29ycmVjdCB3b3JsZCBpZiBuZWNlc3Nhcnkgc28gdGhhdCBydWxlciBzZWN0aW9uXG4gICAgLy8gYmV0d2VlbiBjdXJyIGFuZCBiYXNlIGNhbiBiZSBwbG90dGVkIGNvcnJlY3RseS4gUmV0dXJucyBhIG5ldyBMYXRMbmdcbiAgICAvLyBvYmplY3QuXG4gICAgX25vcm1hbGl6ZUxhdExuZzogZnVuY3Rpb24gKGN1cnIsIGJhc2UpIHsgLy8gKExhdExuZywgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIGRpZmYgPSAoY3Vyci5sbmcgPCBiYXNlLmxuZykgPyAzNjAgOiAtMzYwO1xuXG4gICAgICAgIHZhciBuZXdMbmcgPSBjdXJyLmxuZztcbiAgICAgICAgd2hpbGUgKE1hdGguYWJzKG5ld0xuZyAtIGJhc2UubG5nKSA+IDE4MCkge1xuICAgICAgICAgICAgbmV3TG5nICs9IGRpZmY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcubGF0TG5nKGN1cnIubGF0LCBuZXdMbmcpO1xuICAgIH0sXG5cbiAgICAvLyBSZWFycmFuZ2VzIHJ1bGVyIHBvaW50cyBiZXR3ZWVuIHdvcmxkcyBiYXNlZCBvbiBwb2ludCBwYXJhbSBzbyB0aGF0IGFsbFxuICAgIC8vIHJ1bGVyIHNlY3Rpb25zIGNhbiBiZSBwbG90dGVkIGNvcnJlY3RseS5cbiAgICBfbm9ybWFsaXplUnVsZXJQb2ludHM6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUnVsZXIuTGF5ZXJlZE1hcmtlcilcbiAgICAgICAgcG9pbnQgPSBwb2ludCB8fCB0aGlzLl9wb2ludHNbMF07XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb2ludC5fcG9zO1xuICAgICAgICB2YXIgY2hhbmdlZFBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgaSwgY3VyclBvaW50LCBwcmV2UG9pbnQsIGxhdGxuZywgbm9ybWFsaXplZDtcblxuICAgICAgICAvLyBDaGVjayBwb2ludHMgdG8gdGhlIHJpZ2h0XG4gICAgICAgIGZvciAoaSA9IHBvc2l0aW9uICsgMTsgaSA8IHRoaXMuX3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VyclBvaW50ID0gdGhpcy5fcG9pbnRzW2ldO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gdGhpcy5fcG9pbnRzW2kgLSAxXTtcblxuICAgICAgICAgICAgbGF0bG5nID0gY3VyclBvaW50LmdldExhdExuZygpO1xuICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhsYXRsbmcsIHByZXZQb2ludC5nZXRMYXRMbmcoKSk7XG5cbiAgICAgICAgICAgIGlmICghbm9ybWFsaXplZC5lcXVhbHMobGF0bG5nKSkge1xuICAgICAgICAgICAgICAgIGN1cnJQb2ludC5zZXRMYXRMbmcobm9ybWFsaXplZCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFBvaW50cy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgcG9pbnRzIHRvIHRoZSBsZWZ0XG4gICAgICAgIGZvciAoaSA9IHBvc2l0aW9uIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGN1cnJQb2ludCA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgICAgIHByZXZQb2ludCA9IHRoaXMuX3BvaW50c1tpICsgMV07XG5cbiAgICAgICAgICAgIGxhdGxuZyA9IGN1cnJQb2ludC5nZXRMYXRMbmcoKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0aGlzLl9ub3JtYWxpemVMYXRMbmcobGF0bG5nLCBwcmV2UG9pbnQuZ2V0TGF0TG5nKCkpO1xuXG4gICAgICAgICAgICBpZiAoIW5vcm1hbGl6ZWQuZXF1YWxzKGxhdGxuZykpIHtcbiAgICAgICAgICAgICAgICBjdXJyUG9pbnQuc2V0TGF0TG5nKG5vcm1hbGl6ZWQpO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRQb2ludHMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBsZWdzIG9mIGFsbCBwb2ludHMgdGhhdCBjaGFuZ2VkIHBvc2l0aW9uXG4gICAgICAgIGNoYW5nZWRQb2ludHMuc29ydCgpLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBza2lwUHJldmlvdXMgPSBwcmV2aW91cyAmJiBwcmV2aW91cyA9PT0gY3VycmVudCAtIDE7XG5cbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUxlZ3Moc2VsZi5fcG9pbnRzW2N1cnJlbnRdLCBza2lwUHJldmlvdXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfSwgbnVsbCk7XG4gICAgfSxcblxuICAgIF9wb2ludEV2ZW50czoge1xuICAgICAgICBkcmFnOiBmdW5jdGlvbiAoZXZlbnQpIHsgLy8gKEV2ZW50KVxuICAgICAgICAgICAgdmFyIHBvaW50ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVSdWxlclBvaW50cyhwb2ludCk7XG5cbiAgICAgICAgICAgIGlmICghREcuQnJvd3Nlci50b3VjaCAmJiBwb2ludCAhPT0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHBvaW50LnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZShwb2ludCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMZWdzKHBvaW50KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc3RhbmNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uIChldmVudCkgeyAvLyAoRXZlbnQpXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLl9tb3JwaGluZ05vdyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFwb2ludC5faG92ZXJlZCAmJiBwb2ludCAhPT0gdGhpcy5fcG9pbnRzW3RoaXMuX3BvaW50cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHBvaW50LmNvbGxhcHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbiAoKSB7IC8vICgpXG4gICAgICAgICAgICBpZiAoREcuQnJvd3Nlci50b3VjaCAmJiB0aGlzLl9saW5lTWFya2VySGVscGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU1hcmtlckhlbHBlci5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9ycGhpbmdOb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kZWxldGVQb2ludDogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50KVxuICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICB0YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldCAgfHwgb3JpZ2luYWxFdmVudC5zcmNFbGVtZW50O1xuXG4gICAgICAgIGlmICh0YXJnZXQuY2xhc3NOYW1lICE9PSAnZGctcnVsZXJfX2xhYmVsLXJlbW92ZS1saW5rJyAmJlxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ2RnLXJ1bGVyX19yZW1vdmUtbGluay1vdmVybGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIERHLkRvbUV2ZW50LnN0b3AoZXZlbnQub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIHRoaXMuc3BsaWNlTGF0TG5ncyhldmVudC50YXJnZXQuX3BvcywgMSk7XG4gICAgfSxcblxuICAgIF9kZWdUb1JhZDogZnVuY3Rpb24gKGRlZykge1xuICAgICAgICByZXR1cm4gKE1hdGguUEkgLyAxODApICogZGVnO1xuICAgIH0sXG5cbiAgICBfcmFkVG9EZWc6IGZ1bmN0aW9uIChyYWQpIHtcbiAgICAgICAgcmV0dXJuICgxODAgLyBNYXRoLlBJKSAqIHJhZDtcbiAgICB9LFxuXG4gICAgLy8gTWFwLWluZGVwZW5kZW50IHByb2plY3QgbWV0aG9kXG4gICAgX3Byb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5wcm9qZWN0KGxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gREcuQ1JTLkVQU0czODU3LmxhdExuZ1RvUG9pbnQobGF0bG5nLCAxKTtcbiAgICB9LFxuXG4gICAgLy8gTWFwLWluZGVwZW5kZW50IHVucHJvamVjdCBtZXRob2RcbiAgICBfdW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcC51bnByb2plY3QocG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERHLkNSUy5FUFNHMzg1Ny5wb2ludFRvTGF0TG5nKHBvaW50LCAxKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgc2l6ZSBvZiBhbmdsZSBwb2ludDEtcG9pbnQtcG9pbnQyXG4gICAgX2NhbGNBbmdsZTogZnVuY3Rpb24gKHBvaW50LCBwb2ludDEsIHBvaW50MikgeyAvLyAoTGF0TG5nLCBMYXRMbmcsIExhdExuZykgLT4gTnVtYmVyXG4gICAgICAgIHBvaW50MSA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhwb2ludDEsIHBvaW50KTtcbiAgICAgICAgcG9pbnQyID0gdGhpcy5fbm9ybWFsaXplTGF0TG5nKHBvaW50MiwgcG9pbnQpO1xuXG4gICAgICAgIHBvaW50ID0gdGhpcy5fcHJvamVjdChwb2ludCk7XG4gICAgICAgIHBvaW50MSA9IHRoaXMuX3Byb2plY3QocG9pbnQxKTtcbiAgICAgICAgcG9pbnQyID0gdGhpcy5fcHJvamVjdChwb2ludDIpO1xuXG4gICAgICAgIHZhciB4MSA9IHBvaW50MS54IC0gcG9pbnQueDtcbiAgICAgICAgdmFyIHgyID0gcG9pbnQyLnggLSBwb2ludC54O1xuICAgICAgICB2YXIgeTEgPSBwb2ludDEueSAtIHBvaW50Lnk7XG4gICAgICAgIHZhciB5MiA9IHBvaW50Mi55IC0gcG9pbnQueTtcblxuICAgICAgICB2YXIgZG90UHJvZHVjdCA9IHgxICogeDIgKyB5MSAqIHkyO1xuICAgICAgICB2YXIgbWFnMSA9IE1hdGguc3FydCh4MSAqIHgxICsgeTEgKiB5MSk7XG4gICAgICAgIHZhciBtYWcyID0gTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hY29zKGRvdFByb2R1Y3QgLyAobWFnMSAqIG1hZzIpKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgbWlkcG9pbnQgb24gdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIHR3byBMYXRMbmdzXG4gICAgX2NhbGNNaWRQb2ludDogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHsgLy8gKExhdExuZywgTGF0TG5nKSAtPiBMYXRMbmdcbiAgICAgICAgdmFyIGxvbjEgPSB0aGlzLl9kZWdUb1JhZChsYXRsbmcxLmxuZyk7XG4gICAgICAgIHZhciBsYXQxID0gdGhpcy5fZGVnVG9SYWQobGF0bG5nMS5sYXQpO1xuXG4gICAgICAgIHZhciBsb24yID0gdGhpcy5fZGVnVG9SYWQobGF0bG5nMi5sbmcpO1xuICAgICAgICB2YXIgbGF0MiA9IHRoaXMuX2RlZ1RvUmFkKGxhdGxuZzIubGF0KTtcblxuICAgICAgICAvLyBCYXNlZCBvbiBmb3JtdWxhZSBmcm9tXG4gICAgICAgIC8vIGh0dHA6Ly93aWxsaWFtcy5iZXN0LnZ3aC5uZXQvYXZmb3JtLmh0bSNJbnRlcm1lZGlhdGVcbiAgICAgICAgdmFyIGQgPSBNYXRoLmFjb3MoTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQyKSArXG4gICAgICAgICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMSAtIGxvbjIpKTtcblxuICAgICAgICAvLyBTcGxpdCB0aGUgYXJjIGluIGhhbGZcbiAgICAgICAgdmFyIGYgPSAwLjU7XG5cbiAgICAgICAgdmFyIEEgPSBNYXRoLnNpbigoMSAtIGYpICogZCkgLyBNYXRoLnNpbihkKTtcbiAgICAgICAgdmFyIEIgPSBNYXRoLnNpbihmICogZCkgLyBNYXRoLnNpbihkKTtcblxuICAgICAgICB2YXIgeCA9IEEgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxvbjEpICtcbiAgICAgICAgICAgIEIgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIpO1xuXG4gICAgICAgIHZhciB5ID0gQSAqIE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obG9uMSkgK1xuICAgICAgICAgICAgQiAqIE1hdGguY29zKGxhdDIpICogTWF0aC5zaW4obG9uMik7XG5cbiAgICAgICAgdmFyIHogPSBBICogTWF0aC5zaW4obGF0MSkgKyBCICogTWF0aC5zaW4obGF0Mik7XG5cbiAgICAgICAgdmFyIGxhdCA9IE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcbiAgICAgICAgdmFyIGxvbiA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgICAgICAgcmV0dXJuIERHLmxhdExuZyh0aGlzLl9yYWRUb0RlZyhsYXQpLCB0aGlzLl9yYWRUb0RlZyhsb24pKTtcbiAgICB9LFxuXG4gICAgLy8gQWRhcHRpdmUgc2FtcGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uXG4gICAgLy8gaHR0cDovL2FyaWVsLmNocm9ub3RleHQub3JnL2RkL2RlZmlndWVpcmVkbzkzYWRhcHRpdmUucGRmXG4gICAgX2FkYXB0aXZlU2FtcGxlOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGRlcHRoLCBtaWRkbGUpIHsgLy8gKExhdExuZywgTGF0TG5nLCBOdW1iZXJbLCBMYXRMbmddKSAtPiBMYXRMbmdbXVxuICAgICAgICBpZiAoZGVwdGggPiA5KSB7XG4gICAgICAgICAgICAvLyBNYXggcmVjdXJzaW9uIGRlcHRoIHJlYWNoZWRcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pZGRsZSA9IG1pZGRsZSB8fCB0aGlzLl9jYWxjTWlkUG9pbnQobGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHZhciBsZWZ0TWlkZGxlID0gdGhpcy5fY2FsY01pZFBvaW50KGxlZnQsIG1pZGRsZSk7XG4gICAgICAgIHZhciByaWdodE1pZGRsZSA9IHRoaXMuX2NhbGNNaWRQb2ludChtaWRkbGUsIHJpZ2h0KTtcblxuICAgICAgICB2YXIgYW5nbGUxID0gdGhpcy5fY2FsY0FuZ2xlKGxlZnRNaWRkbGUsIG1pZGRsZSwgbGVmdCk7XG4gICAgICAgIHZhciBhbmdsZTIgPSB0aGlzLl9jYWxjQW5nbGUobWlkZGxlLCBsZWZ0LCByaWdodCk7XG4gICAgICAgIHZhciBhbmdsZTMgPSB0aGlzLl9jYWxjQW5nbGUocmlnaHRNaWRkbGUsIG1pZGRsZSwgcmlnaHQpO1xuXG4gICAgICAgIC8vIGxlZnQgLS0tIGxlZnRNaWRkbGUgLS0tIG1pZGRsZSAtLS0gcmlnaHRNaWRkbGUgLS0tIHJpZ2h0XG4gICAgICAgIC8vICAgICAgICAgICAgYW5nbGUxICAgICAgIGFuZ2xlMiAgICAgICBhbmdsZTNcblxuICAgICAgICB2YXIgbWluQW5nbGUgPSAzLjE7XG4gICAgICAgIGlmIChhbmdsZTEgPiBtaW5BbmdsZSAmJiBhbmdsZTIgPiBtaW5BbmdsZSAmJiBhbmdsZTMgPiBtaW5BbmdsZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIHN0cmFpZ2h0IGVub3VnaCwgbm8gaW50ZXJtZWRpYXRlIHBvaW50cyBuZWVkZWQuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbmdsZXMgYXJlIHRvbyBzbWFsbC4gUmVjdXJzaXZlbHkgc2FtcGxlIGhhbHZlcyBvZiB0aGlzIHNlY3Rpb24uXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuX2FkYXB0aXZlU2FtcGxlKGxlZnQsIG1pZGRsZSwgZGVwdGggKyAxLCBsZWZ0TWlkZGxlKSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChtaWRkbGUpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLl9hZGFwdGl2ZVNhbXBsZShtaWRkbGUsIHJpZ2h0LCBkZXB0aCArIDEsIHJpZ2h0TWlkZGxlKSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgZ3JlYXQgY2lyY2xlIGFyYyBiZXR3ZWVuIHR3byBMYXRMbmdzLlxuICAgIF9jYWxjR3JlYXRDaXJjbGU6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7IC8vIChMYXRMbmcsIExhdExuZykgLT4gTGF0TG5nW11cbiAgICAgICAgbGF0bG5nMiA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhsYXRsbmcyLCBsYXRsbmcxKTtcblxuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHBvaW50cyBhcmUgY2xvc2UgdG8gZWFjaCBvdGhlciAod2l0aGluIDEgZGVncmVlKVxuICAgICAgICBpZiAobGF0bG5nMS5lcXVhbHMobGF0bG5nMiwgMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGF0bG5nMSwgbGF0bG5nMl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHRoZSBncmVhdCBjaXJjbGUgY3Jvc3NlcyBhIHBvbGVcbiAgICAgICAgaWYgKE1hdGguYWJzKGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcpID09IDE4MCkge1xuICAgICAgICAgICAgLy8gTm9ydGggb3Igc291dGggcG9sZT9cbiAgICAgICAgICAgIHZhciBsYXRpdHVkZSA9IChsYXRsbmcxLmxhdCArIGxhdGxuZzIubGF0ID4gMCkgPyA5MCA6IC05MDtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBsYXRsbmcxLFxuICAgICAgICAgICAgICAgIERHLmxhdExuZyhsYXRpdHVkZSwgbGF0bG5nMS5sbmcpLFxuICAgICAgICAgICAgICAgIERHLmxhdExuZyhsYXRpdHVkZSwgbGF0bG5nMi5sbmcpLFxuICAgICAgICAgICAgICAgIGxhdGxuZzJcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgcmVzdWx0LnB1c2gobGF0bG5nMSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5fYWRhcHRpdmVTYW1wbGUobGF0bG5nMSwgbGF0bG5nMiwgMCkpO1xuICAgICAgICByZXN1bHQucHVzaChsYXRsbmcyKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGFyYyBkb2Vzbid0IGp1bXAgYmV0d2VlbiB3b3JsZHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX25vcm1hbGl6ZUxhdExuZyhyZXN1bHRbaV0sIHJlc3VsdFtpIC0gMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2FkZExlZ3M6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgcGF0aFN0eWxlcyA9IHRoaXMub3B0aW9ucy5wYXRoU3R5bGVzO1xuXG4gICAgICAgIHZhciBncmVhdENpcmNsZVBvaW50cyA9IHRoaXMuX2NhbGNHcmVhdENpcmNsZShcbiAgICAgICAgICAgIHBvaW50LmdldExhdExuZygpLFxuICAgICAgICAgICAgdGhpcy5fcG9pbnRzW3BvaW50Ll9wb3MgKyAxXS5nZXRMYXRMbmcoKVxuICAgICAgICApO1xuXG4gICAgICAgIHBvaW50Ll9sZWdzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHBhdGhTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBwb2ludC5fbGVnc1tsYXllcl0gPSBERy5wb2x5bGluZShncmVhdENpcmNsZVBvaW50cywgcGF0aFN0eWxlc1tsYXllcl0pLmFkZFRvKHRoaXMuX2xheWVyc1tsYXllcl0pO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBwb2ludC5fbGVncy5tb3VzZS5fcG9pbnQgPSBwb2ludC5vbmNlKCdyZW1vdmUnLCB0aGlzLl9jbGVhclJlbW92aW5nUG9pbnRMZWdzLCB0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlICYmICFERy5Ccm93c2VyLm1vYmlsZSkge1xuICAgICAgICAgICAgcG9pbnQuX2xlZ3MubW91c2Uub24oJ21vdXNlZG93bicsIHRoaXMuX2luc2VydFBvaW50SW5MaW5lLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVycy5tb3VzZS5hZGRMYXllcihwb2ludC5fbGVncy5tb3VzZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NsZWFyUmVtb3ZpbmdQb2ludExlZ3M6IGZ1bmN0aW9uIChldmVudCkgeyAvLyAoRXZlbnQpXG4gICAgICAgIHRoaXMuX3JlbW92ZUxlZ3MoZXZlbnQudGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUxlZ3M6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUnVsZXIuTGF5ZXJlZE1hcmtlcilcbiAgICAgICAgaWYgKHBvaW50Ll9sZWdzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwb2ludC5fbGVncykuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbbGF5ZXJdLnJlbW92ZUxheWVyKHBvaW50Ll9sZWdzW2xheWVyXSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHBvaW50Ll9sZWdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlTGVnczogZnVuY3Rpb24gKHBvaW50LCBza2lwUHJldmlvdXMpIHsgLy8gKFJ1bGVyLkxheWVyZWRNYXJrZXIsIEJvb2xlYW4pXG4gICAgICAgIHZhciBsYXRsbmcgPSBwb2ludC5nZXRMYXRMbmcoKSxcbiAgICAgICAgICAgIHByZXZpb3VzUG9pbnQgPSB0aGlzLl9wb2ludHNbcG9pbnQuX3BvcyAtIDFdLFxuICAgICAgICAgICAgbmV4dFBvaW50ID0gdGhpcy5fcG9pbnRzW3BvaW50Ll9wb3MgKyAxXSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgbmV3UG9pbnRzO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1BvaW50ICYmICFza2lwUHJldmlvdXMpIHtcbiAgICAgICAgICAgIG5ld1BvaW50cyA9IHNlbGYuX2NhbGNHcmVhdENpcmNsZShwcmV2aW91c1BvaW50LmdldExhdExuZygpLCBsYXRsbmcpO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcmV2aW91c1BvaW50Ll9sZWdzKS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUG9pbnQuX2xlZ3NbbGF5ZXJdLnNldExhdExuZ3MobmV3UG9pbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQb2ludCkge1xuICAgICAgICAgICAgbmV3UG9pbnRzID0gc2VsZi5fY2FsY0dyZWF0Q2lyY2xlKGxhdGxuZywgbmV4dFBvaW50LmdldExhdExuZygpKTtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMocG9pbnQuX2xlZ3MpLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuX2xlZ3NbbGF5ZXJdLnNldExhdExuZ3MobmV3UG9pbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jYWxjRGlzdGFuY2U6IGZ1bmN0aW9uIChmaW5pc2hQb2ludCwgdGFpbCkgeyAvLyAoUnVsZXIuTGF5ZXJlZE1hcmtlciwgTnVtYmVyKSAtPiBOdW1iZXJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdGFpbCA/IHRhaWwgOiAwLFxuICAgICAgICAgICAgY2FsY1RvID0gZmluaXNoUG9pbnQgPyBmaW5pc2hQb2ludC5fcG9zIDogdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxjVG87IGkrKykge1xuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGhpcy5fcG9pbnRzW2ldLmdldExhdExuZygpLmRpc3RhbmNlVG8odGhpcy5fcG9pbnRzW2kgKyAxXS5nZXRMYXRMbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XG4gICAgfSxcblxuICAgIF9nZXRGb3JtYXRlZERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7IC8vICgpIC0+IFN0cmluZ1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLl9jYWxjRGlzdGFuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHVuaXRzID0gJ20nO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IDEwMDApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlIC89IDEwMDA7XG4gICAgICAgICAgICB1bml0cyA9ICdrbSc7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZS50b0ZpeGVkKCk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZS5zbGljZSgwLCAtMykgKyAnICcgKyBkaXN0YW5jZS5zbGljZSgtMyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2UudG9GaXhlZCgyKS5zcGxpdCgnLicpLmpvaW4odGhpcy50KCdkZWxpbWl0ZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGgucm91bmQoZGlzdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtkaXN0YW5jZSB8fCAwLCAnICcsIHRoaXMudCh1bml0cyldLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlRGlzdGFuY2U6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgaWYgKHRoaXMuX21hcCAmJiB0aGlzLl9wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHNbdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDFdLnNldFRleHQodGhpcy5fZ2V0Rm9ybWF0ZWREaXN0YW5jZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5ERy5ydWxlciA9IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7IC8vIChBcnJheSwgT2JqZWN0KVxuICAgIHJldHVybiBuZXcgREcuUnVsZXIobGF0bG5ncywgb3B0aW9ucyk7XG59O1xuIiwiREcuUnVsZXIuTGF5ZXJlZE1hcmtlciA9IERHLk1hcmtlci5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAga2V5Ym9hcmQ6IGZhbHNlLFxuICAgICAgICByaXNlT25Ib3ZlcjogdHJ1ZSxcbiAgICAgICAgcGFuZTogJ3J1bGVyTWFya2VyUGFuZScsXG4gICAgICAgIGljb25IVE1MOiBbXG4gICAgICAgICAgICAnPGltZyBjbGFzcz1cImRnLXJ1bGVyX19sYWJlbC1zcGFjZXJcIiBzcmM9XCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTdcIiB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiAvPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRnLXJ1bGVyX19sYWJlbC1jb250YWluZXJcIj4nLFxuICAgICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwiZGctcnVsZXJfX3BvaW50XCI+PC9kaXY+JyxcbiAgICAgICAgICAgICcgICAgPHNwYW4gY2xhc3M9XCJkZy1ydWxlcl9fbGFiZWwtZGlzdGFuY2VcIj4wINC60Lw8L3NwYW4+JyxcbiAgICAgICAgICAgICcgICAgPHNwYW4gY2xhc3M9XCJkZy1ydWxlcl9fbGFiZWwtcmVtb3ZlLWxpbmtcIj48L3NwYW4+JyxcbiAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cImRnLXJ1bGVyX19yZW1vdmUtbGluay1vdmVybGF5XCI+PC9kaXY+JyxcbiAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgIF0uam9pbignXFxuJylcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBkb21DbGFzcyA6ICdkZy1ydWxlcl9fbGFiZWwnXG4gICAgfSxcblxuICAgIGFkZFRvIDogZnVuY3Rpb24gKG1hcCwgbGF5ZXJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgbGF5ZXJzW25hbWVdLmFkZExheWVyKHRoaXMuX2xheWVyc1tuYW1lXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gbGF5ZXJzO1xuICAgICAgICByZXR1cm4gREcuTWFya2VyLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMub24oJ21vdmUnLCB0aGlzLl9vbk1vdmUpLCBtYXApO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZSA6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbGF5ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydFtuYW1lXS5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbbmFtZV0pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vZmYoJ21vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIERHLk1hcmtlci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgIH0sXG5cbiAgICBzZXRUZXh0IDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ljb25Db2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faWNvbk5vZGVzLmxhYmVsLmlubmVySFRNTCA9IHRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRQb2ludFN0eWxlIDogZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZSAhPT0gc3R5bGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0eWxlID0gc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbbmFtZV0uc2V0U3R5bGUoc3R5bGVbbmFtZV0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGV4cGFuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faWNvbkNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMuc3BhY2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjb2xsYXBzZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faWNvbkNvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ljb25Ob2Rlcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5faWNvbk5vZGVzLnNwYWNlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHF1ZXJ5U2VsZWN0b3IgOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ljb24ucXVlcnlTZWxlY3RvcignLicgKyBERy5SdWxlci5MYXllcmVkTWFya2VyLmRvbUNsYXNzICsgJy0nICsgc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICBfb25Nb3ZlIDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBsYXRsbmcgPSBldmVudC5sYXRsbmc7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW25hbWVdLnNldExhdExuZyhsYXRsbmcpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgX2luaXRJY29uIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBERy5NYXJrZXIucHJvdG90eXBlLl9pbml0SWNvbi5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9pY29uQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faWNvbi5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICB0aGlzLl9pY29uTm9kZXMgPSB7XG4gICAgICAgICAgICBsYWJlbCA6IHRoaXMucXVlcnlTZWxlY3RvcignZGlzdGFuY2UnKSxcbiAgICAgICAgICAgIHNwYWNlciA6IHRoaXMucXVlcnlTZWxlY3Rvcignc3BhY2VyJyksXG4gICAgICAgICAgICBjb250YWluZXIgOiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2NvbnRhaW5lcicpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIGRvbid0IGNoYW5nZSBpY29uIHpJbmRleFxuICAgIF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NoYWRvdykge1xuICAgICAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfYWZ0ZXJJbml0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYXllcnMgPSB0aGlzLm9wdGlvbnMubGF5ZXJzIHx8IG51bGw7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pY29uID0gREcuZGl2SWNvbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IERHLlJ1bGVyLkxheWVyZWRNYXJrZXIuZG9tQ2xhc3MsXG4gICAgICAgICAgICBpY29uU2l6ZTogWzI2LCAyNl0sXG4gICAgICAgICAgICBpY29uQW5jaG9yOiBbMTMsIDEzXSxcbiAgICAgICAgICAgIGh0bWw6IHRoaXMub3B0aW9ucy5pY29uSFRNTFxuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xuXG5ERy5SdWxlci5MYXllcmVkTWFya2VyLmFkZEluaXRIb29rKCdfYWZ0ZXJJbml0Jyk7XG5cbkRHLlJ1bGVyLmxheWVyZWRNYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBERy5SdWxlci5MYXllcmVkTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59O1xuIiwidmFyIHJ1bGVyUmVuZGVyZXIgPSBERy5zdmcoe3BhbmU6ICdydWxlclBhbmUnfSk7XG52YXIgaG92ZXJSZW5kZXJlciA9IERHLnN2Zyh7cGFuZTogJ3J1bGVyUGFuZSd9KTtcblxuREcuUnVsZXIubWVyZ2VPcHRpb25zKHtcbiAgICBwYXRoU3R5bGVzOiB7XG4gICAgICAgIGJhY2s6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgd2VpZ2h0OiAxMixcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICAgIG5vQ2xpcDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyLFxuICAgICAgICAgICAgc21vb3RoRmFjdG9yOiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgICAgY29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB3ZWlnaHQ6IDQsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICBub0NsaXA6IHRydWUsXG4gICAgICAgICAgICByZW5kZXJlcjogcnVsZXJSZW5kZXJlcixcbiAgICAgICAgICAgIHNtb290aEZhY3RvcjogMFxuICAgICAgICB9LFxuICAgICAgICBtb3VzZToge1xuICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IERHLkJyb3dzZXIudm1sID8gMC4xIDogMCxcbiAgICAgICAgICAgIHdlaWdodDogREcuQnJvd3Nlci50b3VjaCA/IDQwIDogMjAsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAncGFpbnRlZCcsXG4gICAgICAgICAgICBub0NsaXA6IHRydWUsXG4gICAgICAgICAgICByZW5kZXJlcjogaG92ZXJSZW5kZXJlcixcbiAgICAgICAgICAgIHNtb290aEZhY3RvcjogMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBpY29uU3R5bGVzOiB7XG4gICAgICAgIGxhcmdlOiB7XG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDEzLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9udDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICcjMGRhNWQ1JyxcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IDQsXG4gICAgICAgICAgICAgICAgcmFkaXVzOiA1LFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBydWxlclJlbmRlcmVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNtYWxsOiB7XG4gICAgICAgICAgICBiYWNrOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDksXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaWRkbGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnIzBkYTVkNScsXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogcnVsZXJSZW5kZXJlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb250OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJyMwZGE1ZDUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHdlaWdodDogNCxcbiAgICAgICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICAgICAgcmVuZGVyZXI6IHJ1bGVyUmVuZGVyZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiREcuUnVsZXIuRGljdGlvbmFyeS5ydSA9IHtcblx0a20gOiAn0LrQvCcsXG5cdG0gOiAn0LwnLFxuXHRkZWxpbWl0ZXIgOiAnLCdcbn07XG4iLCJERy5SdWxlci5EaWN0aW9uYXJ5Lml0ID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmNzID0ge1xuXHRrbTogJ2ttJyxcblx0bTogJ20nLFxuXHRkZWxpbWl0ZXI6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmVzID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcsJ1xufTsiLCJERy5SdWxlci5EaWN0aW9uYXJ5LmVuID0ge1xuXHRrbSA6ICdrbScsXG5cdG0gOiAnbScsXG5cdGRlbGltaXRlciA6ICcuJ1xufTtcbiIsIkRHLkNvbnRyb2wuUnVsZXIgPSBERy5Sb3VuZENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3ByaWdodCcsXG4gICAgICAgIGljb25DbGFzczogJ3J1bGVyJ1xuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIERpY3Rpb25hcnk6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIERHLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIERHLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBfYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIF9kcmF3aW5nSGVscGVyOiBudWxsLFxuICAgICAgICAgICAgX2dlb2NsaWNrZXJOZWVkUmVzdG9yZTogZmFsc2VcbiAgICAgICAgfSkub24odGhpcy5fY29udHJvbEV2ZW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIF9jb250cm9sRXZlbnRzOiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0hlbHBlciA9IERHLnJ1bGVyKFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9ICF0aGlzLl9hY3RpdmU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoRHJhd2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuX2NvbnRyb2xFdmVudHMsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9kcmF3aW5nSGVscGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdIZWxwZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zdGFydERyYXdpbmc6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAuYWRkTGF5ZXIodGhpcy5fZHJhd2luZ0hlbHBlcilcbiAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLl9oYW5kbGVNYXBDbGljaywgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3J1bGVyc3RhcnQnKTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaERyYXdpbmc6IGZ1bmN0aW9uICgpIHsgLy8gKClcbiAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAub2ZmKCdjbGljaycsIHRoaXMuX2hhbmRsZU1hcENsaWNrLCB0aGlzKVxuICAgICAgICAgICAgLnJlbW92ZUxheWVyKHRoaXMuX2RyYXdpbmdIZWxwZXIpO1xuXG4gICAgICAgIHRoaXMuX2RyYXdpbmdIZWxwZXIuc2V0TGF0TG5ncyhbXSk7XG5cbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3J1bGVyZW5kJyk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVNYXBDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7IC8vIChNb3VzZUV2ZW50cylcbiAgICAgICAgdGhpcy5fZHJhd2luZ0hlbHBlci5hZGRMYXRMbmcoZXZlbnQubGF0bG5nKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlclRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoKSB7IC8vICgpXG4gICAgICAgIHRoaXMuX2xpbmsudGl0bGUgPSB0aGlzLnQoJ2J1dHRvbl90aXRsZScpO1xuICAgIH1cbn0pO1xuXG5ERy5jb250cm9sLnJ1bGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IERHLkNvbnRyb2wuUnVsZXIob3B0aW9ucyk7XG59O1xuXG5ERy5NYXAubWVyZ2VPcHRpb25zKHtcbiAgICBydWxlckNvbnRyb2w6IGZhbHNlXG59KTtcblxuREcuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJ1bGVyQ29udHJvbCkge1xuICAgICAgICB0aGlzLnJ1bGVyQ29udHJvbCA9IERHLmNvbnRyb2wucnVsZXIodGhpcy5vcHRpb25zLnJ1bGVyQ29udHJvbCk7XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbCh0aGlzLnJ1bGVyQ29udHJvbCk7XG4gICAgfVxufSk7XG4iLCJERy5Db250cm9sLlJ1bGVyLkRpY3Rpb25hcnkucnUgPSB7XG5cdGJ1dHRvbl90aXRsZTogJ9Cb0LjQvdC10LnQutCwJ1xufTsiLCJERy5Db250cm9sLlJ1bGVyLkRpY3Rpb25hcnkuaXQgPSB7XG5cdGJ1dHRvbl90aXRsZSA6ICdSaWdoZWxsbydcbn07IiwiREcuQ29udHJvbC5SdWxlci5EaWN0aW9uYXJ5LmNzID0ge1xuXHRidXR0b25fdGl0bGU6ICdQcmF2w610a28nXG59OyIsIkRHLkNvbnRyb2wuUnVsZXIuRGljdGlvbmFyeS5lcyA9IHtcblx0YnV0dG9uX3RpdGxlIDogJ1JlZ2xhJ1xufTtcbiIsIkRHLkNvbnRyb2wuUnVsZXIuRGljdGlvbmFyeS5lbiA9IHtcblx0YnV0dG9uX3RpdGxlIDogJ1J1bGVyJ1xufTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHQXR0cmlidXRpb25cXC9jb3B5cmlnaHRcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1hdHRyaWJ1dGlvbl9fY29weXJpZ2h0XFxcIj48dWwgY2xhc3M9XFxcImRnLWF0dHJpYnV0aW9uX19saW5rc1xcXCI+PGxpIGNsYXNzPVxcXCJkZy1hdHRyaWJ1dGlvbl9fbGluay1pdGVtXFxcIj5cIikueChjdHguZ2V0KFtcIm9zbVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pLncoXCI8YSBocmVmPVxcXCJcIikuZihjdHguZ2V0KFtcImNvcHlyaWdodF9hcGlsaW5rXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcImRnLWF0dHJpYnV0aW9uX19saW5rXFxcIj5cIikubngoY3R4LmdldChbXCJvc21cIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzJ9LHt9KS5mKGN0eC5nZXQoW1wiQVBJXzJHSVNcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2E+PC9saT48bGkgY2xhc3M9XFxcImRnLWF0dHJpYnV0aW9uX19saW5rLWl0ZW1cXFwiPjxhIGhyZWY9XFxcIlwiKS5mKGN0eC5nZXQoW1wiY29weXJpZ2h0X2xpY2Vuc2VcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2xpbmtcXFwiPlwiKS5mKGN0eC5nZXQoW1wibGljZW5zZV9hZ3JlZW1lbnRcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2E+PC9saT48L3VsPjxhIGhyZWY9XFxcIlwiKS5mKGN0eC5nZXQoW1wiY29weXJpZ2h0X2xvZ29cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2xvZ28tdXJsXFxcIj48L2E+PC9kaXY+XCIpO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiwqkgPGEgaHJlZj1cXFwiaHR0cDovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiZGctYXR0cmlidXRpb25fX2xpbmtcXFwiPk9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzPC9hPiwgXCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXQoW1wid29ya19vblwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiBcIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2NpdHlhcmVhXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2UgZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9cIikuZihjdHguZ2V0KFtcInR5cGVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCJcXFwiPlwiKS5mKGN0eC5nZXQoW1wicHVycG9zZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKS5zKGN0eC5nZXQoW1wiZHJpbGxkb3duXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fZHJpbGxkb3duXFxcIj5cIikuZihjdHguZ2V0KFtcImRyaWxsZG93blwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvZmlybUNhcmRBZGRyXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGFkZHJlc3MgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fYWRkcmVzcyBkZy1maXJtLWNhcmRfX2ljb25cXFwiPlwiKS5mKGN0eC5nZXQoW1wiYWRkcmVzc1wiXSwgZmFsc2UpLGN0eCxcImhcIikucyhjdHguZ2V0KFtcImNvbW1lbnRcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KS53KFwiPC9hZGRyZXNzPlwiKTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxzcGFuIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2NvbW1lbnRcXFwiPiZtZGFzaDsgXCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvc3Bhbj5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2Zpcm1DYXJkQ29udGFjdHNcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLnMoY3R4LmdldChbXCJncm91cHNcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsucyhjdHguZ2V0KFtcImNvbnRhY3RzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8yfSx7fSk7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLmgoXCJzZWxlY3RcIixjdHgse1wiYmxvY2tcIjpib2R5XzN9LHtcImtleVwiOmN0eC5nZXQoW1widHlwZVwiXSwgZmFsc2UpLFwidHlwZVwiOlwic3RyaW5nXCJ9LFwiaFwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsuaChcImVxXCIsY3R4LHtcImJsb2NrXCI6Ym9keV80fSx7XCJ2YWx1ZVwiOlwicGhvbmVcIixcInR5cGVcIjpcInN0cmluZ1wifSxcImhcIikuaChcImVxXCIsY3R4LHtcImJsb2NrXCI6Ym9keV82fSx7XCJ2YWx1ZVwiOlwiZmF4XCIsXCJ0eXBlXCI6XCJzdHJpbmdcIn0sXCJoXCIpLmgoXCJlcVwiLGN0eCx7XCJibG9ja1wiOmJvZHlfOH0se1widmFsdWVcIjpcIndlYnNpdGVcIixcInR5cGVcIjpcInN0cmluZ1wifSxcImhcIikuaChcImVxXCIsY3R4LHtcImJsb2NrXCI6Ym9keV85fSx7XCJ2YWx1ZVwiOlwiZW1haWxcIixcInR5cGVcIjpcInN0cmluZ1wifSxcImhcIik7fWJvZHlfMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3Bob25lIGRnLWZpcm0tY2FyZF9faWNvblxcXCI+PHNwYW4gY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcGhvbmUtbnVtXFxcIj5cIikuZihjdHguZ2V0KFtcInRleHRcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLnMoY3R4LmdldChbXCJjb21tZW50XCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV81fSx7fSkudyhcIjwvc3Bhbj48L2Rpdj5cIik7fWJvZHlfNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8c3BhbiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19jb21tZW50XFxcIiB0aXRsZT1cXFwiXCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIlxcXCI+Jm1kYXNoOyZuYnNwOyZuYnNwO1wiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L3NwYW4+XCIpO31ib2R5XzUuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzYoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19waG9uZSBkZy1maXJtLWNhcmRfX2ljb25cXFwiPjxzcGFuIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3Bob25lLW51bVxcXCI+XCIpLmYoY3R4LmdldChbXCJ0ZXh0XCJdLCBmYWxzZSksY3R4LFwiaFwiKS5zKGN0eC5nZXQoW1wiY29tbWVudFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfN30se30pLncoXCI8L3NwYW4+PC9kaXY+XCIpO31ib2R5XzYuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzcoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHNwYW4gY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fY29tbWVudFxcXCIgdGl0bGU9XFxcIlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCJcXFwiPiZtZGFzaDsmbmJzcDsmbmJzcDtcIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9zcGFuPlwiKTt9Ym9keV83Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV84KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fbGluayBkZy1maXJtLWNhcmRfX3NpdGUgZGctZmlybS1jYXJkX19pY29uXFxcIj48YSBocmVmPVxcXCJcIikuZihjdHguZ2V0KFtcInVybFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJkZy1saW5rX3NjaGVtZV9kYXJrIGRnLWZpcm0tY2FyZF9fc2l0ZWxpbmtcXFwiPlwiKS5mKGN0eC5nZXQoW1widGV4dFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvYT48L2Rpdj5cIik7fWJvZHlfOC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfOShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX2xpbmsgZGctZmlybS1jYXJkX19lbWFpbCBkZy1maXJtLWNhcmRfX2ljb25cXFwiPjxhIGhyZWY9XFxcIm1haWx0bzpcIikuZihjdHguZ2V0KFtcInZhbHVlXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIj5cIikuZihjdHguZ2V0KFtcInZhbHVlXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9hPjwvZGl2PlwiKTt9Ym9keV85Ll9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvZmlybUNhcmRIZWFkZXJcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1wb3B1cF9faGVhZGVyLXRpdGxlIGRnLXBvcHVwX19oZWFkZXItdGl0bGVfZm9yX2Zpcm1jYXJkXFxcIiB0aXRsZT1cXFwiXCIpLmYoY3R4LmdldChbXCJmaXJtTmFtZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIlxcXCI+XCIpLmYoY3R4LmdldChbXCJmaXJtTmFtZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKS54KGN0eC5nZXQoW1wibGlua3NcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXBvcHVwX19oZWFkZXItbGlua3NcXFwiPlwiKS5zKGN0eC5nZXQoW1wibGlua3NcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzJ9LHt9KS53KFwiPC9kaXY+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay5oKFwiZXFcIixjdHgse1wiZWxzZVwiOmJvZHlfMyxcImJsb2NrXCI6Ym9keV82fSx7XCJrZXlcIjpib2R5XzcsXCJ2YWx1ZVwiOlwiZmxhbXBfc3RhcnNcIixcInR5cGVcIjpcInN0cmluZ1wifSxcImhcIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8YSBjbGFzcz1cXFwiZGctcG9wdXBfX2hlYWRlci1saW5rIGRnLXBvcHVwX19saW5rIGRnLXBvcHVwX19saW5rX3R5cGVfXCIpLmYoY3R4LmdldChbXCJuYW1lXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiXFxcIlwiKS54KGN0eC5nZXQoW1wiaHJlZlwiXSwgZmFsc2UpLGN0eCx7XCJlbHNlXCI6Ym9keV80LFwiYmxvY2tcIjpib2R5XzV9LHt9KS53KFwiPlwiKS5mKGN0eC5nZXQoW1wibGFiZWxcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2E+XCIpO31ib2R5XzMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcIlwiKTt9Ym9keV80Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV81KGNoayxjdHgpe3JldHVybiBjaGsudyhcImhyZWY9XCIpLmYoY3R4LmdldChbXCJocmVmXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIlwiKTt9Ym9keV81Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV82KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXBvcHVwX19yYXRpbmdcXFwiPjxkaXYgY2xhc3M9XFxcImRnLXBvcHVwX19yYXRpbmctc3RhcnNcXFwiIHN0eWxlPVxcXCJ3aWR0aDogXCIpLmYoY3R4LmdldChbXCJ3aWR0aFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiVcXFwiPjwvZGl2PjwvZGl2PlwiKTt9Ym9keV82Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV83KGNoayxjdHgpe3JldHVybiBjaGsuZihjdHguZ2V0KFtcIm5hbWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpO31ib2R5XzcuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9maXJtQ2FyZFJ1YnJpY1wiLGJvZHlfMCk7ZnVuY3Rpb24gYm9keV8wKGNoayxjdHgpe3JldHVybiBjaGsucyhjdHguZ2V0KFtcInJ1YnJpY3NcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxzZWN0aW9uIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3J1YnJpY3NcXFwiPlwiKS54KGN0eC5nZXQoW1wicHJpbWFyeVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMn0se30pLngoY3R4LmdldChbXCJhZGRpdGlvbmFsXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV80fSx7fSkudyhcIjwvc2VjdGlvbj5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8dWwgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0IGRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0X3R5cGVfcHJpbWFyeVxcXCI+XCIpLnMoY3R4LmdldChbXCJwcmltYXJ5XCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8zfSx7fSkudyhcIjwvdWw+XCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGxpIGNsYXNzPVxcXCJkZy1maXJtLWNhcmRfX3J1YnJpY3MtbGlzdC1pdGVtXFxcIj5cIikuZihjdHguZ2V0KFtcIm5hbWVcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2xpPlwiKTt9Ym9keV8zLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjx1bCBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3QgZGctZmlybS1jYXJkX19ydWJyaWNzLWxpc3RfdHlwZV9hZGRpdGlvbmFsXFxcIj5cIikucyhjdHguZ2V0KFtcImFkZGl0aW9uYWxcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzV9LHt9KS53KFwiPC91bD5cIik7fWJvZHlfNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8bGkgY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fcnVicmljcy1saXN0LWl0ZW1cXFwiPlwiKS5mKGN0eC5nZXQoW1wibmFtZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvbGk+XCIpO31ib2R5XzUuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9maXJtQ2FyZFNjaGVkdWxlXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19zY2hlZHVsZSBkZy1zY2hlZHVsZSBkZy1zY2hlZHVsZV9vcGVuX1wiKS54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwib3BlblwiXSksY3R4LHtcImVsc2VcIjpib2R5XzEsXCJibG9ja1wiOmJvZHlfMn0se30pLncoXCIgZGctc2NoZWR1bGVfd29ya3MtZXZlcnlkYXlfXCIpLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJldmVyeWRheVwiXSksY3R4LHtcImVsc2VcIjpib2R5XzMsXCJibG9ja1wiOmJvZHlfNH0se30pLncoXCJcXFwiPlwiKS54KGN0eC5nZXQoW1wic2NoZWR1bGVcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzV9LHt9KS53KFwiPC9kaXY+XCIpO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiZmFsc2VcIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJ0cnVlXCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiZmFsc2VcIik7fWJvZHlfMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJ0cnVlXCIpO31ib2R5XzQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwidG9kYXlcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfNn0se30pLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJub3dcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMTB9LHt9KS5ueChjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcImV2ZXJ5ZGF5XCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzEyfSx7fSk7fWJvZHlfNS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdG9kYXlcXFwiPjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190b2RheS1pbm5lclxcXCI+XCIpLmYoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJ0b2RheVwiLFwidGV4dFwiXSksY3R4LFwiaFwiKS53KFwiJm5ic3A7XCIpLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZvcmVjYXN0XCIsXCJ0b2RheVwiLFwiZnJvbVwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV83fSx7fSkueChjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcImx1bmNoXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5Xzh9LHt9KS53KFwiPC9kaXY+PC9kaXY+XCIpO31ib2R5XzYuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzcoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwidG9kYXlcIixcImZyb21cIl0pLGN0eCxcImhcIikudyhcIiZuZGFzaDtcIikuZihjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcInRvZGF5XCIsXCJ0b1wiXSksY3R4LFwiaFwiKTt9Ym9keV83Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV84KGNoayxjdHgpe3JldHVybiBjaGsudyhcIiwmbmJzcDtcIikuZihjdHguZ2V0UGF0aChmYWxzZSwgW1wiZm9yZWNhc3RcIixcInRvZGF5XCIsXCJsdW5jaFN0clwiXSksY3R4LFwiaFwiKS53KFwiJm5ic3A7XCIpLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJsdW5jaFwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV85fSx7fSk7fWJvZHlfOC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfOShjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldChbXCJmcm9tXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiJm5kYXNoO1wiKS5mKGN0eC5nZXQoW1widG9cIl0sIGZhbHNlKSxjdHgsXCJoXCIpO31ib2R5XzkuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEwKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX19ub3dcXFwiPjxzcGFuIGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fbm93LXRleHRcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJjb21tZW50XCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzExfSx7fSkudyhcIjwvc3Bhbj48L2Rpdj5cIik7fWJvZHlfMTAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzExKGNoayxjdHgpe3JldHVybiBjaGsudyhcIiwgXCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIik7fWJvZHlfMTEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEyKGNoayxjdHgpe3JldHVybiBjaGsueChjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcIndlZWtcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMTN9LHt9KTt9Ym9keV8xMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTMoY2hrLGN0eCl7cmV0dXJuIGNoay54KGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwid2Vla1wiLFwiZXZlbnRseVwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8xNH0se30pLngoY3R4LmdldFBhdGgoZmFsc2UsIFtcInNjaGVkdWxlXCIsXCJ3ZWVrXCIsXCJ0YWJsZVwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8yMn0se30pO31ib2R5XzEzLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGFibGVcXFwiPlwiKS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwid2Vla1wiLFwiZXZlbnRseVwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8xNX0se30pLncoXCI8L2Rpdj5cIik7fWJvZHlfMTQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzE1KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX19zdHJpbmdcXFwiPlwiKS54KGN0eC5nZXQoW1wiYWxsdGltZVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMTZ9LHt9KS54KGN0eC5nZXQoW1wiZXZlcnlkYXlcIl0sIGZhbHNlKSxjdHgse1wiZWxzZVwiOmJvZHlfMTcsXCJibG9ja1wiOmJvZHlfMTh9LHt9KS54KGN0eC5nZXQoW1wiaG9saWRheVwiXSwgZmFsc2UpLGN0eCx7XCJlbHNlXCI6Ym9keV8xOSxcImJsb2NrXCI6Ym9keV8yMX0se30pLncoXCI8L2Rpdj5cIik7fWJvZHlfMTUuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzE2KGNoayxjdHgpe3JldHVybiBjaGsuZihjdHguZ2V0KFtcImFsbHRpbWVTdHJcIl0sIGZhbHNlKSxjdHgsXCJoXCIpO31ib2R5XzE2Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xNyhjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldChbXCJkYXlMaXN0XCJdLCBmYWxzZSksY3R4LFwiaFwiKTt9Ym9keV8xNy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMTgoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJmb3JlY2FzdFwiLFwidG9kYXlcIixcInRleHRcIl0pLGN0eCxcImhcIik7fWJvZHlfMTguX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzE5KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxzcGFuIGNsYXNzPVxcXCJzY2hlZHVsZV9fc3RyaW5nLXRpbWVcXFwiPiZuYnNwO1wiKS5mKGN0eC5nZXQoW1wiZnJvbVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiZuZGFzaDtcIikuZihjdHguZ2V0KFtcInRvXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9zcGFuPlwiKS5zKGN0eC5nZXQoW1wibHVuY2hcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzIwfSx7fSk7fWJvZHlfMTkuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIwKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxwPlwiKS5mKGN0eC5nZXQoW1wibHVuY2hTdHJcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCImbWRhc2g7PHNwYW4gY2xhc3M9XFxcInNjaGVkdWxlX19zdHJpbmctdGltZVxcXCI+XCIpLmYoY3R4LmdldChbXCJmcm9tXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiJm5kYXNoO1wiKS5mKGN0eC5nZXQoW1widG9cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L3NwYW4+PC9wPlwiKTt9Ym9keV8yMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiJm5ic3A7Jm1kYXNoOzxzcGFuIGNsYXNzPVxcXCJzY2hlZHVsZV9fc3RyaW5nLXRpbWVcXFwiPiZuYnNwO1wiKS5mKGN0eC5nZXQoW1wiaG9saWRheVN0clwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvc3Bhbj5cIik7fWJvZHlfMjEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIyKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXY+PGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RhYmxlXFxcIj48ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGMgZGctc2NoZWR1bGVfX3RjX3ByZVxcXCI+PGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX2RheS1uYW1lXFxcIj4mbmJzcDs8L2Rpdj48ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGFibGUtY2xvY2sgZGctc2NoZWR1bGVfX3RkXFxcIj48L2Rpdj5cIikueChjdHguZ2V0UGF0aChmYWxzZSwgW1wic2NoZWR1bGVcIixcIndlZWtcIixcImhhc0x1bmNoXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzIzfSx7fSkudyhcIjwvZGl2PlwiKS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJzY2hlZHVsZVwiLFwid2Vla1wiLFwidGFibGVcIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfMjR9LHt9KS53KFwiPC9kaXY+ICA8L2Rpdj5cIik7fWJvZHlfMjIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIzKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXNjaGVkdWxlX190YWJsZS1sdW5jaCBkZy1zY2hlZHVsZV9fdGRcXFwiPjwvZGl2PlwiKTt9Ym9keV8yMy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjQoY2hrLGN0eCl7cmV0dXJuIGNoay5oKFwiaWZcIixjdHgse1wiYmxvY2tcIjpib2R5XzI1fSx7XCJjb25kXCI6Ym9keV8yNn0sXCJoXCIpLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fdGNcIikueChjdHguZ2V0KFtcImFjdGl2ZVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMjd9LHt9KS53KFwiXFxcIj48ZGl2IGNsYXNzPVxcXCJkZy1zY2hlZHVsZV9fZGF5LW5hbWVcXFwiPlwiKS5mKGN0eC5nZXQoW1wia2V5XCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiPC9kaXY+PGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RkXFxcIj5cIikueChjdHguZ2V0KFtcImZyb21cIl0sIGZhbHNlKSxjdHgse1wiZWxzZVwiOmJvZHlfMjgsXCJibG9ja1wiOmJvZHlfMjl9LHt9KS53KFwiPC9kaXY+XCIpLnMoY3R4LmdldChbXCJsdW5jaFwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMzB9LHt9KS53KFwiPC9kaXY+IFwiKS5oKFwiaWZcIixjdHgse1wiYmxvY2tcIjpib2R5XzMzfSx7XCJjb25kXCI6Ym9keV8zNH0sXCJoXCIpO31ib2R5XzI0Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yNShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8c3BhbiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RhYmxlLWNlbGwtZ3JvdXBcXFwiPlwiKTt9Ym9keV8yNS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjYoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiKFwiKS5mKGN0eC5nZXQoW1wiJGlkeFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiA9PSBcIikuZihjdHguZ2V0KFtcIiRsZW5cIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCIgLSAyKVwiKTt9Ym9keV8yNi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjcoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiIGRnLXNjaGVkdWxlX190Y19hY3RpdmVfdHJ1ZVwiKTt9Ym9keV8yNy5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjgoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiJm5kYXNoO1wiKTt9Ym9keV8yOC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMjkoY2hrLGN0eCl7cmV0dXJuIGNoay5mKGN0eC5nZXQoW1wiZnJvbVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiBcIikuZihjdHguZ2V0KFtcInRvXCJdLCBmYWxzZSksY3R4LFwiaFwiKTt9Ym9keV8yOS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctc2NoZWR1bGVfX3RkXFxcIj5cIikueChjdHguZ2V0KFtcImZyb21cIl0sIGZhbHNlKSxjdHgse1wiZWxzZVwiOmJvZHlfMzEsXCJibG9ja1wiOmJvZHlfMzJ9LHt9KS53KFwiPC9kaXY+XCIpO31ib2R5XzMwLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCImbmRhc2g7XCIpO31ib2R5XzMxLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zMihjaGssY3R4KXtyZXR1cm4gY2hrLmYoY3R4LmdldChbXCJmcm9tXCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiIFwiKS5mKGN0eC5nZXQoW1widG9cIl0sIGZhbHNlKSxjdHgsXCJoXCIpO31ib2R5XzMyLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8L3NwYW4+XCIpO31ib2R5XzMzLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zNChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCIoXCIpLmYoY3R4LmdldChbXCIkaWR4XCJdLCBmYWxzZSksY3R4LFwiaFwiKS53KFwiID09IFwiKS5mKGN0eC5nZXQoW1wiJGxlblwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIilcIik7fWJvZHlfMzQuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9maXJtbGlzdEl0ZW1cIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8YSBpZD1cXFwiXCIpLmYoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZpcm1cIixcImlkXCJdKSxjdHgsXCJoXCIpLncoXCJcXFwiIGNsYXNzPVxcXCJkZy1wb3B1cF9fbGlua1xcXCIgaHJlZj1cXFwiI1xcXCI+XCIpLmYoY3R4LmdldFBhdGgoZmFsc2UsIFtcImZpcm1cIixcIm5hbWVcIl0pLGN0eCxcImhcIikudyhcIjwvYT5cIik7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL2ZyaW1DYXJkUGF5bWVudHNcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLngoY3R4LmdldChbXCJwYXltZW50c1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pO31ib2R5XzAuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzEoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPHNlY3Rpb24gY2xhc3M9XFxcImRnLWZpcm0tY2FyZF9fYWFcXFwiPjx1bCBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19hYS1saXN0XFxcIj5cIikucyhjdHguZ2V0KFtcInBheW1lbnRzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8yfSx7fSkudyhcIjwvdWw+PC9zZWN0aW9uPlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxsaSBjbGFzcz1cXFwiZGctZmlybS1jYXJkX19hYS1saXN0LWl0ZW1cXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2xpPlwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvaG91c2VcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLnMoY3R4LmdldChbXCJhZGRyZXNzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSkucyhjdHguZ2V0KFtcInB1cnBvc2VcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzR9LHt9KS5zKGN0eC5nZXQoW1wiYXR0cmFjdGlvbnNcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzV9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxhZGRyZXNzIGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fYWRkcmVzc1xcXCI+XCIpLnMoY3R4LmdldFBhdGgoZmFsc2UsIFtcImFkZHJlc3NcIixcImhlYWRlclwiXSksY3R4LHtcImJsb2NrXCI6Ym9keV8yfSx7fSkucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wiYWRkcmVzc1wiLFwiZHJpbGxkb3duXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzN9LHt9KS53KFwiPC9hZGRyZXNzPlwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWhlYWRlclxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV8yLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8zKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzLWRyaWxsZG93blxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV8zLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19wdXJwb3NlXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2UgZGctbWFwLWdlb2NsaWNrZXJfX3B1cnBvc2VfdHlwZV9zaWdodFxcXCI+XCIpLmYoY3R4LmdldFBhdGgodHJ1ZSwgW10pLGN0eCxcImhcIikudyhcIjwvZGl2PlwiKTt9Ym9keV81Ll9fZHVzdEJvZHk9ITA7cmV0dXJuIGJvZHlfMH0oZHVzdCkpOyIsIihmdW5jdGlvbihkdXN0KXtkdXN0LnJlZ2lzdGVyKFwiREdHZW9jbGlja2VyXFwvbG9hZGVyXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctcHJlbG9hZGVyIGRnLXByZWxvYWRlcl9zY2hlbWVfcmVndWxhciBkZy1wcmVsb2FkZXJfYW5pbWF0aW9uX1wiKS54KGN0eC5nZXQoW1wiYW5pbVwiXSwgZmFsc2UpLGN0eCx7XCJlbHNlXCI6Ym9keV8xLFwiYmxvY2tcIjpib2R5XzJ9LHt9KS54KGN0eC5nZXQoW1wic21hbGxcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzN9LHt9KS53KFwiXFxcIj48L2Rpdj5cIik7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJmYWxzZVwiKTt9Ym9keV8xLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8yKGNoayxjdHgpe3JldHVybiBjaGsudyhcInRydWVcIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCIgZGctcHJlbG9hZGVyX3NpemVfc21hbGxcIik7fWJvZHlfMy5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL3BvcHVwRm9vdGVyXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctcG9wdXBfX2Zvb3Rlci10aXRsZVxcXCI+PGEgY2xhc3M9XFxcImRnLXBvcHVwX19zaG93LWxlc3MtaG91c2UtbGlua1xcXCIgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApXFxcIj5cIikuZihjdHguZ2V0KFtcImhpZGVGaXJtc1RleHRcIl0sIGZhbHNlKSxjdHgsXCJoXCIpLncoXCI8L2E+PC9kaXY+XCIpO31ib2R5XzAuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiKGZ1bmN0aW9uKGR1c3Qpe2R1c3QucmVnaXN0ZXIoXCJER0dlb2NsaWNrZXJcXC9wb3B1cEZvb3RlckJ0bnNcIixib2R5XzApO2Z1bmN0aW9uIGJvZHlfMChjaGssY3R4KXtyZXR1cm4gY2hrLngoY3R4LmdldChbXCJidG5zXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8xfSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8Zm9vdGVyIGNsYXNzPVxcXCJkZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbnNcXFwiPlwiKS5zKGN0eC5nZXQoW1wiYnRuc1wiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMn0se30pLncoXCI8L2Zvb3Rlcj5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMihjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1wb3B1cF9fZm9vdGVyLWJ1dHRvbi13cmFwcGVyXFxcIj48YSBjbGFzcz1cXFwiZGctcG9wdXBfX2J1dHRvbl9uYW1lX1wiKS5mKGN0eC5nZXQoW1wibmFtZVwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiBkZy1wb3B1cF9fZm9vdGVyLWJ1dHRvblwiKS54KGN0eC5nZXQoW1wiaWNvblwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfM30se30pLncoXCJcXFwiXCIpLngoY3R4LmdldChbXCJocmVmXCJdLCBmYWxzZSksY3R4LHtcImVsc2VcIjpib2R5XzQsXCJibG9ja1wiOmJvZHlfNX0se30pLncoXCI+XCIpLmYoY3R4LmdldChbXCJsYWJlbFwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIjwvYT48L2Rpdj5cIik7fWJvZHlfMi5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMyhjaGssY3R4KXtyZXR1cm4gY2hrLncoXCIgZGctcG9wdXBfX2Zvb3Rlci1pY29uLWJ1dHRvblwiKTt9Ym9keV8zLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV80KGNoayxjdHgpe3JldHVybiBjaGsudyhcImhyZWY9XFxcImphdmFzY3JpcHQ6dm9pZCgwKVxcXCJcIik7fWJvZHlfNC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfNShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCJocmVmPVwiKS5mKGN0eC5nZXQoW1wiaHJlZlwiXSwgZmFsc2UpLGN0eCxcImhcIikudyhcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCJcIik7fWJvZHlfNS5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL3BvcHVwSGVhZGVyXCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay5zKGN0eC5nZXQoW1widGl0bGVcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzF9LHt9KTt9Ym9keV8wLl9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV8xKGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxkaXYgY2xhc3M9XFxcImRnLXBvcHVwX19oZWFkZXItdGl0bGVcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2Rpdj5cIik7fWJvZHlfMS5fX2R1c3RCb2R5PSEwO3JldHVybiBib2R5XzB9KGR1c3QpKTsiLCIoZnVuY3Rpb24oZHVzdCl7ZHVzdC5yZWdpc3RlcihcIkRHR2VvY2xpY2tlclxcL3NpZ2h0XCIsYm9keV8wKTtmdW5jdGlvbiBib2R5XzAoY2hrLGN0eCl7cmV0dXJuIGNoay5zKGN0eC5nZXQoW1wicHVycG9zZVwiXSwgZmFsc2UpLGN0eCx7XCJibG9ja1wiOmJvZHlfMX0se30pLnMoY3R4LmdldChbXCJhZGRyZXNzXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV8yfSx7fSkucyhjdHguZ2V0KFtcImRlc2NyaXB0aW9uXCJdLCBmYWxzZSksY3R4LHtcImJsb2NrXCI6Ym9keV81fSx7fSk7fWJvZHlfMC5fX2R1c3RCb2R5PSEwO2Z1bmN0aW9uIGJvZHlfMShjaGssY3R4KXtyZXR1cm4gY2hrLncoXCI8ZGl2IGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZSBkZy1tYXAtZ2VvY2xpY2tlcl9fcHVycG9zZV90eXBlX3NpZ2h0XFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzEuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzIoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGFkZHJlc3MgY2xhc3M9XFxcImRnLW1hcC1nZW9jbGlja2VyX19hZGRyZXNzXFxcIj5cIikucyhjdHguZ2V0UGF0aChmYWxzZSwgW1wiYWRkcmVzc1wiLFwiaGVhZGVyXCJdKSxjdHgse1wiYmxvY2tcIjpib2R5XzN9LHt9KS5zKGN0eC5nZXRQYXRoKGZhbHNlLCBbXCJhZGRyZXNzXCIsXCJkcmlsbGRvd25cIl0pLGN0eCx7XCJibG9ja1wiOmJvZHlfNH0se30pLncoXCI8L2FkZHJlc3M+XCIpO31ib2R5XzIuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzMoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtaGVhZGVyXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzMuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzQoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX2FkZHJlc3MtZHJpbGxkb3duXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpO31ib2R5XzQuX19kdXN0Qm9keT0hMDtmdW5jdGlvbiBib2R5XzUoY2hrLGN0eCl7cmV0dXJuIGNoay53KFwiPGRpdiBjbGFzcz1cXFwiZGctbWFwLWdlb2NsaWNrZXJfX3NpZ2h0LWRlc2NyaXB0aW9uXFxcIj5cIikuZihjdHguZ2V0UGF0aCh0cnVlLCBbXSksY3R4LFwiaFwiKS53KFwiPC9kaXY+XCIpLnMoY3R4LmdldChbXCJzaG93TW9yZVRleHRcIl0sIGZhbHNlKSxjdHgse1wiYmxvY2tcIjpib2R5XzZ9LHt9KTt9Ym9keV81Ll9fZHVzdEJvZHk9ITA7ZnVuY3Rpb24gYm9keV82KGNoayxjdHgpe3JldHVybiBjaGsudyhcIjxhIGNsYXNzPVxcXCJkZy1tYXAtZ2VvY2xpY2tlcl9fc2hvdy1tb3JlLXNpZ2h0cy1saW5rXFxcIiBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMClcXFwiPlwiKS5mKGN0eC5nZXRQYXRoKHRydWUsIFtdKSxjdHgsXCJoXCIpLncoXCI8L2E+XCIpO31ib2R5XzYuX19kdXN0Qm9keT0hMDtyZXR1cm4gYm9keV8wfShkdXN0KSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgYnJvd3NlciBmaWVsZCwgY2hlY2sgb3V0IHRoZSBicm93c2VyIGZpZWxkIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9icm93c2VyaWZ5LWhhbmRib29rI2Jyb3dzZXItZmllbGQuXG5cbnZhciBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXIgaW5zZXJ0U3R5bGVFbGVtZW50ID0gZnVuY3Rpb24oc3R5bGVFbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgdmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmluc2VydEF0ID0gb3B0aW9ucy5pbnNlcnRBdCB8fCAnYm90dG9tJztcblxuICAgIGlmIChvcHRpb25zLmluc2VydEF0ID09PSAndG9wJykge1xuICAgICAgICBpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG4gICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcXCdpbnNlcnRBdFxcJy4gTXVzdCBiZSBcXCd0b3BcXCcgb3IgXFwnYm90dG9tXFwnLicpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8vIENyZWF0ZSBhIDxsaW5rPiB0YWcgd2l0aCBvcHRpb25hbCBkYXRhIGF0dHJpYnV0ZXNcbiAgICBjcmVhdGVMaW5rOiBmdW5jdGlvbihocmVmLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcblxuICAgICAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgICAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCAhIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICB9LFxuICAgIC8vIENyZWF0ZSBhIDxzdHlsZT4gdGFnIHdpdGggb3B0aW9uYWwgZGF0YSBhdHRyaWJ1dGVzXG4gICAgY3JlYXRlU3R5bGU6IGZ1bmN0aW9uKGNzc1RleHQsIGF0dHJpYnV0ZXMsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICBleHRyYU9wdGlvbnMgPSBleHRyYU9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICggISBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnZGF0YS0nICsga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3R5bGUuc2hlZXQpIHsgLy8gZm9yIGpzZG9tIGFuZCBJRTkrXG4gICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBjc3NUZXh0O1xuICAgICAgICAgICAgc3R5bGUuc2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgICAgICBpbnNlcnRTdHlsZUVsZW1lbnQoc3R5bGUsIHsgaW5zZXJ0QXQ6IGV4dHJhT3B0aW9ucy5pbnNlcnRBdCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7IC8vIGZvciBJRTggYW5kIGJlbG93XG4gICAgICAgICAgICBpbnNlcnRTdHlsZUVsZW1lbnQoc3R5bGUsIHsgaW5zZXJ0QXQ6IGV4dHJhT3B0aW9ucy5pbnNlcnRBdCB9KTtcbiAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIH0gZWxzZSB7IC8vIGZvciBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1RleHQpKTtcbiAgICAgICAgICAgIGluc2VydFN0eWxlRWxlbWVudChzdHlsZSwgeyBpbnNlcnRBdDogZXh0cmFPcHRpb25zLmluc2VydEF0IH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICYmIGRlZmluZS5hbWQuZHVzdCA9PT0gdHJ1ZSkge1xuICAgIGRlZmluZShbJ2R1c3QuY29yZSddLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnZHVzdGpzLWxpbmtlZGluJykpO1xuICB9IGVsc2Uge1xuICAgIGZhY3Rvcnkocm9vdC5kdXN0KTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbihkdXN0KSB7XG5cbmZ1bmN0aW9uIGxvZyhoZWxwZXIsIG1zZywgbGV2ZWwpIHtcbiAgbGV2ZWwgPSBsZXZlbCB8fCBcIklORk9cIjtcbiAgaGVscGVyID0gaGVscGVyID8gJ3tAJyArIGhlbHBlciArICd9OiAnIDogJyc7XG4gIGR1c3QubG9nKGhlbHBlciArIG1zZywgbGV2ZWwpO1xufVxuXG52YXIgX2RlcHJlY2F0ZWRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gX2RlcHJlY2F0ZWQodGFyZ2V0KSB7XG4gIGlmKF9kZXByZWNhdGVkQ2FjaGVbdGFyZ2V0XSkgeyByZXR1cm47IH1cbiAgbG9nKHRhcmdldCwgXCJEZXByZWNhdGlvbiB3YXJuaW5nOiBcIiArIHRhcmdldCArIFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIGR1c3Rqcy1oZWxwZXJzXCIsIFwiV0FSTlwiKTtcbiAgbG9nKG51bGwsIFwiRm9yIGhlbHAgYW5kIGEgZGVwcmVjYXRpb24gdGltZWxpbmUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbGlua2VkaW4vZHVzdGpzLWhlbHBlcnMvd2lraS9EZXByZWNhdGVkLUZlYXR1cmVzI1wiICsgdGFyZ2V0LnJlcGxhY2UoL1xcVysvZywgXCJcIiksIFwiV0FSTlwiKTtcbiAgX2RlcHJlY2F0ZWRDYWNoZVt0YXJnZXRdID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNTZWxlY3QoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5zdGFjay50YWlsICYmXG4gICAgICAgICBjb250ZXh0LnN0YWNrLnRhaWwuaGVhZCAmJlxuICAgICAgICAgdHlwZW9mIGNvbnRleHQuc3RhY2sudGFpbC5oZWFkLl9fc2VsZWN0X18gIT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdFN0YXRlKGNvbnRleHQpIHtcbiAgcmV0dXJuIGlzU2VsZWN0KGNvbnRleHQpICYmIGNvbnRleHQuZ2V0KCdfX3NlbGVjdF9fJyk7XG59XG5cbi8qKlxuICogQWRkcyBhIHNwZWNpYWwgX19zZWxlY3RfXyBrZXkgYmVoaW5kIHRoZSBoZWFkIG9mIHRoZSBjb250ZXh0IHN0YWNrLiBVc2VkIHRvIG1haW50YWluIHRoZSBzdGF0ZVxuICogb2Yge0BzZWxlY3R9IGJsb2Nrc1xuICogQHBhcmFtIGNvbnRleHQge0NvbnRleHR9IGFkZCBzdGF0ZSB0byB0aGlzIENvbnRleHRcbiAqIEBwYXJhbSBvcHRzIHtPYmplY3R9IGFkZCB0aGVzZSBwcm9wZXJ0aWVzIHRvIHRoZSBzdGF0ZSAoYGtleWAgYW5kIGB0eXBlYClcbiAqL1xuZnVuY3Rpb24gYWRkU2VsZWN0U3RhdGUoY29udGV4dCwgb3B0cykge1xuICB2YXIgaGVhZCA9IGNvbnRleHQuc3RhY2suaGVhZCxcbiAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0LnJlYmFzZSgpLFxuICAgICAga2V5O1xuXG4gIGlmKGNvbnRleHQuc3RhY2sgJiYgY29udGV4dC5zdGFjay50YWlsKSB7XG4gICAgbmV3Q29udGV4dC5zdGFjayA9IGNvbnRleHQuc3RhY2sudGFpbDtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBpc1BlbmRpbmc6IGZhbHNlLFxuICAgIGlzUmVzb2x2ZWQ6IGZhbHNlLFxuICAgIGlzRGVmZXJyZWRDb21wbGV0ZTogZmFsc2UsXG4gICAgZGVmZXJyZWRzOiBbXVxuICB9O1xuXG4gIGZvcihrZXkgaW4gb3B0cykge1xuICAgIHN0YXRlW2tleV0gPSBvcHRzW2tleV07XG4gIH1cblxuICByZXR1cm4gbmV3Q29udGV4dFxuICAucHVzaCh7IFwiX19zZWxlY3RfX1wiOiBzdGF0ZSB9KVxuICAucHVzaChoZWFkLCBjb250ZXh0LnN0YWNrLmluZGV4LCBjb250ZXh0LnN0YWNrLm9mKTtcbn1cblxuLyoqXG4gKiBBZnRlciBhIHtAc2VsZWN0fSBvciB7QG1hdGh9IGJsb2NrIGlzIGNvbXBsZXRlLCB0aGV5IGludm9rZSB0aGlzIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3REZWZlcnJlZHMoc3RhdGUpIHtcbiAgdmFyIHgsIGxlbjtcbiAgc3RhdGUuaXNEZWZlcnJlZFBlbmRpbmcgPSB0cnVlO1xuICBpZihzdGF0ZS5kZWZlcnJlZHMubGVuZ3RoKSB7XG4gICAgc3RhdGUuaXNEZWZlcnJlZENvbXBsZXRlID0gdHJ1ZTtcbiAgICBmb3IoeD0wLCBsZW49c3RhdGUuZGVmZXJyZWRzLmxlbmd0aDsgeDxsZW47IHgrKykge1xuICAgICAgc3RhdGUuZGVmZXJyZWRzW3hdKCk7XG4gICAgfVxuICB9XG4gIHN0YXRlLmlzRGVmZXJyZWRQZW5kaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogVXNlZCBieSB7QGNvbnRleHREdW1wfVxuICovXG5mdW5jdGlvbiBqc29uRmlsdGVyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKClcbiAgICAgIC5yZXBsYWNlKC8oXlxccyt8XFxzKyQpL21nLCAnJylcbiAgICAgIC5yZXBsYWNlKC9cXG4vbWcsICcnKVxuICAgICAgLnJlcGxhY2UoLyxcXHMqL21nLCAnLCAnKVxuICAgICAgLnJlcGxhY2UoL1xcKVxcey9tZywgJykgeycpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRydXRoIHRlc3QgaGVscGVyXG4gKi9cbmZ1bmN0aW9uIHRydXRoVGVzdChuYW1lLCB0ZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gZmlsdGVyKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcywgbmFtZSwgdGVzdCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkIGJ5IHRydXRoIHRlc3QgaGVscGVyc1xuICovXG5mdW5jdGlvbiBmaWx0ZXIoY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zLCBoZWxwZXJOYW1lLCB0ZXN0KSB7XG4gIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgc2tpcCA9IGJvZGllc1snZWxzZSddLFxuICAgICAgc2VsZWN0U3RhdGUgPSBnZXRTZWxlY3RTdGF0ZShjb250ZXh0KSB8fCB7fSxcbiAgICAgIHdpbGxSZXNvbHZlLCBrZXksIHZhbHVlLCB0eXBlO1xuXG4gIC8vIE9uY2Ugb25lIHRydXRoIHRlc3QgaW4gYSBzZWxlY3QgcGFzc2VzLCBzaG9ydC1jaXJjdWl0IHRoZSByZXN0IG9mIHRoZSB0ZXN0c1xuICBpZiAoc2VsZWN0U3RhdGUuaXNSZXNvbHZlZCAmJiAhc2VsZWN0U3RhdGUuaXNEZWZlcnJlZFBlbmRpbmcpIHtcbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxuICAvLyBGaXJzdCBjaGVjayBmb3IgYSBrZXkgb24gdGhlIGhlbHBlciBpdHNlbGYsIHRoZW4gbG9vayBmb3IgYSBrZXkgb24gdGhlIHtAc2VsZWN0fVxuICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgIGtleSA9IHBhcmFtcy5rZXk7XG4gIH0gZWxzZSBpZiAoc2VsZWN0U3RhdGUuaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAga2V5ID0gc2VsZWN0U3RhdGUua2V5O1xuICB9IGVsc2Uge1xuICAgIGxvZyhoZWxwZXJOYW1lLCBcIk5vIGtleSBzcGVjaWZpZWRcIiwgXCJXQVJOXCIpO1xuICAgIHJldHVybiBjaHVuaztcbiAgfVxuXG4gIHR5cGUgPSBwYXJhbXMudHlwZSB8fCBzZWxlY3RTdGF0ZS50eXBlO1xuXG4gIGtleSA9IGNvZXJjZShjb250ZXh0LnJlc29sdmUoa2V5KSwgdHlwZSk7XG4gIHZhbHVlID0gY29lcmNlKGNvbnRleHQucmVzb2x2ZShwYXJhbXMudmFsdWUpLCB0eXBlKTtcblxuICBpZiAodGVzdChrZXksIHZhbHVlKSkge1xuICAgIC8vIE9uY2UgYSB0cnV0aCB0ZXN0IHBhc3NlcywgcHV0IHRoZSBzZWxlY3QgaW50byBcInBlbmRpbmdcIiBzdGF0ZS4gTm93IHdlIGNhbiByZW5kZXIgdGhlIGJvZHkgb2ZcbiAgICAvLyB0aGUgdHJ1dGggdGVzdCAod2hpY2ggbWF5IGNvbnRhaW4gdHJ1dGggdGVzdHMpIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHN0YXRlIG9mIHRoZSBzZWxlY3QuXG4gICAgaWYgKCFzZWxlY3RTdGF0ZS5pc1BlbmRpbmcpIHtcbiAgICAgIHdpbGxSZXNvbHZlID0gdHJ1ZTtcbiAgICAgIHNlbGVjdFN0YXRlLmlzUGVuZGluZyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICBjaHVuayA9IGNodW5rLnJlbmRlcihib2R5LCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHdpbGxSZXNvbHZlKSB7XG4gICAgICBzZWxlY3RTdGF0ZS5pc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2tpcCkge1xuICAgIGNodW5rID0gY2h1bmsucmVuZGVyKHNraXAsIGNvbnRleHQpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuZnVuY3Rpb24gY29lcmNlKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdudW1iZXInOiByZXR1cm4gK3ZhbHVlO1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgdmFsdWUgPSAodmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlKTtcbiAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbiAgICBjYXNlICdkYXRlJzogcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIGhlbHBlcnMgPSB7XG5cbiAgLy8gVXRpbGl0eSBoZWxwaW5nIHRvIHJlc29sdmUgZHVzdCByZWZlcmVuY2VzIGluIHRoZSBnaXZlbiBjaHVua1xuICAvLyB1c2VzIG5hdGl2ZSBEdXN0IENvbnRleHQjcmVzb2x2ZSAoYXZhaWxhYmxlIHNpbmNlIER1c3QgMi42LjIpXG4gIFwidGFwXCI6IGZ1bmN0aW9uKGlucHV0LCBjaHVuaywgY29udGV4dCkge1xuICAgIC8vIGRlcHJlY2F0ZWQgZm9yIHJlbW92YWwgaW4gMS44XG4gICAgX2RlcHJlY2F0ZWQoXCJ0YXBcIik7XG4gICAgcmV0dXJuIGNvbnRleHQucmVzb2x2ZShpbnB1dCk7XG4gIH0sXG5cbiAgXCJzZXBcIjogZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrO1xuICAgIGlmIChjb250ZXh0LnN0YWNrLmluZGV4ID09PSBjb250ZXh0LnN0YWNrLm9mIC0gMSkge1xuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBpZiAoYm9keSkge1xuICAgICAgcmV0dXJuIGJvZHkoY2h1bmssIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICB9LFxuXG4gIFwiZmlyc3RcIjogZnVuY3Rpb24oY2h1bmssIGNvbnRleHQsIGJvZGllcykge1xuICAgIGlmIChjb250ZXh0LnN0YWNrLmluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gYm9kaWVzLmJsb2NrKGNodW5rLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIFwibGFzdFwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzKSB7XG4gICAgaWYgKGNvbnRleHQuc3RhY2suaW5kZXggPT09IGNvbnRleHQuc3RhY2sub2YgLSAxKSB7XG4gICAgICByZXR1cm4gYm9kaWVzLmJsb2NrKGNodW5rLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiB7QGNvbnRleHREdW1wfVxuICAgKiBAcGFyYW0ga2V5IHtTdHJpbmd9IHNldCB0byBcImZ1bGxcIiB0byB0aGUgZnVsbCBjb250ZXh0IHN0YWNrLCBvdGhlcndpc2UgdGhlIGN1cnJlbnQgY29udGV4dCBpcyBkdW1wZWRcbiAgICogQHBhcmFtIHRvIHtTdHJpbmd9IHNldCB0byBcImNvbnNvbGVcIiB0byBsb2cgdG8gY29uc29sZSwgb3RoZXJ3aXNlIG91dHB1dHMgdG8gdGhlIGNodW5rXG4gICAqL1xuICBcImNvbnRleHREdW1wXCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciB0byA9IGNvbnRleHQucmVzb2x2ZShwYXJhbXMudG8pLFxuICAgICAgICBrZXkgPSBjb250ZXh0LnJlc29sdmUocGFyYW1zLmtleSksXG4gICAgICAgIHRhcmdldCwgb3V0cHV0O1xuICAgIHN3aXRjaChrZXkpIHtcbiAgICAgIGNhc2UgJ2Z1bGwnOlxuICAgICAgICB0YXJnZXQgPSBjb250ZXh0LnN0YWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRhcmdldCA9IGNvbnRleHQuc3RhY2suaGVhZDtcbiAgICB9XG4gICAgb3V0cHV0ID0gSlNPTi5zdHJpbmdpZnkodGFyZ2V0LCBqc29uRmlsdGVyLCAyKTtcbiAgICBzd2l0Y2godG8pIHtcbiAgICAgIGNhc2UgJ2NvbnNvbGUnOlxuICAgICAgICBsb2coJ2NvbnRleHREdW1wJywgb3V0cHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvPC9nLCAnXFxcXHUwMDNjJyk7XG4gICAgICAgIGNodW5rID0gY2h1bmsud3JpdGUob3V0cHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiB7QG1hdGh9XG4gICAqIEBwYXJhbSBrZXkgZmlyc3QgdmFsdWVcbiAgICogQHBhcmFtIG1ldGhvZCB7U3RyaW5nfSBvcGVyYXRpb24gdG8gcGVyZm9ybVxuICAgKiBAcGFyYW0gb3BlcmFuZCBzZWNvbmQgdmFsdWUgKG5vdCByZXF1aXJlZCBmb3Igb3BlcmF0aW9ucyBsaWtlIGBhYnNgKVxuICAgKiBAcGFyYW0gcm91bmQgaWYgdHJ1dGh5LCByb3VuZCgpIHRoZSByZXN1bHRcbiAgICovXG4gIFwibWF0aFwiOiBmdW5jdGlvbiAoY2h1bmssIGNvbnRleHQsIGJvZGllcywgcGFyYW1zKSB7XG4gICAgdmFyIGtleSA9IHBhcmFtcy5rZXksXG4gICAgICAgIG1ldGhvZCA9IHBhcmFtcy5tZXRob2QsXG4gICAgICAgIG9wZXJhbmQgPSBwYXJhbXMub3BlcmFuZCxcbiAgICAgICAgcm91bmQgPSBwYXJhbXMucm91bmQsXG4gICAgICAgIG91dHB1dCwgc3RhdGUsIHgsIGxlbjtcblxuICAgIGlmKCFwYXJhbXMuaGFzT3duUHJvcGVydHkoJ2tleScpIHx8ICFwYXJhbXMubWV0aG9kKSB7XG4gICAgICBsb2coXCJtYXRoXCIsIFwiYGtleWAgb3IgYG1ldGhvZGAgd2FzIG5vdCBwcm92aWRlZFwiLCBcIkVSUk9SXCIpO1xuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cblxuICAgIGtleSA9IHBhcnNlRmxvYXQoY29udGV4dC5yZXNvbHZlKGtleSkpO1xuICAgIG9wZXJhbmQgPSBwYXJzZUZsb2F0KGNvbnRleHQucmVzb2x2ZShvcGVyYW5kKSk7XG5cbiAgICBzd2l0Y2gobWV0aG9kKSB7XG4gICAgICBjYXNlIFwibW9kXCI6XG4gICAgICAgIGlmKG9wZXJhbmQgPT09IDApIHtcbiAgICAgICAgICBsb2coXCJtYXRoXCIsIFwiRGl2aXNpb24gYnkgMFwiLCBcIkVSUk9SXCIpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCA9IGtleSAlIG9wZXJhbmQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICBvdXRwdXQgPSBrZXkgKyBvcGVyYW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzdWJ0cmFjdFwiOlxuICAgICAgICBvdXRwdXQgPSBrZXkgLSBvcGVyYW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtdWx0aXBseVwiOlxuICAgICAgICBvdXRwdXQgPSBrZXkgKiBvcGVyYW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXZpZGVcIjpcbiAgICAgICAgaWYob3BlcmFuZCA9PT0gMCkge1xuICAgICAgICAgIGxvZyhcIm1hdGhcIiwgXCJEaXZpc2lvbiBieSAwXCIsIFwiRVJST1JcIik7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ID0ga2V5IC8gb3BlcmFuZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY2VpbFwiOlxuICAgICAgY2FzZSBcImZsb29yXCI6XG4gICAgICBjYXNlIFwicm91bmRcIjpcbiAgICAgIGNhc2UgXCJhYnNcIjpcbiAgICAgICAgb3V0cHV0ID0gTWF0aFttZXRob2RdKGtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvaW50XCI6XG4gICAgICAgIG91dHB1dCA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxvZyhcIm1hdGhcIiwgXCJNZXRob2QgYFwiICsgbWV0aG9kICsgXCJgIGlzIG5vdCBzdXBwb3J0ZWRcIiwgXCJFUlJPUlwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG91dHB1dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICBvdXRwdXQgPSBNYXRoLnJvdW5kKG91dHB1dCk7XG4gICAgICB9XG4gICAgICBpZiAoYm9kaWVzICYmIGJvZGllcy5ibG9jaykge1xuICAgICAgICBjb250ZXh0ID0gYWRkU2VsZWN0U3RhdGUoY29udGV4dCwgeyBrZXk6IG91dHB1dCB9KTtcbiAgICAgICAgY2h1bmsgPSBjaHVuay5yZW5kZXIoYm9kaWVzLmJsb2NrLCBjb250ZXh0KTtcbiAgICAgICAgcmVzb2x2ZVNlbGVjdERlZmVycmVkcyhnZXRTZWxlY3RTdGF0ZShjb250ZXh0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVuayA9IGNodW5rLndyaXRlKG91dHB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiB7QHNlbGVjdH1cbiAgICogR3JvdXBzIGEgc2V0IG9mIHRydXRoIHRlc3RzIGFuZCBvdXRwdXRzIHRoZSBmaXJzdCBvbmUgdGhhdCBwYXNzZXMuXG4gICAqIEFsc28gY29udGFpbnMge0Bhbnl9IGFuZCB7QG5vbmV9IGJsb2Nrcy5cbiAgICogQHBhcmFtIGtleSBhIHZhbHVlIG9yIHJlZmVyZW5jZSB0byB1c2UgYXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIGNvbXBhcmlzb25zXG4gICAqIEBwYXJhbSB0eXBlIGNvZXJjZSBhbGwgdHJ1dGggdGVzdCBrZXlzIHdpdGhvdXQgYW4gZXhwbGljaXQgdHlwZSB0byB0aGlzIHR5cGVcbiAgICovXG4gIFwic2VsZWN0XCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgICBzdGF0ZSA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHtcbiAgICAgIHN0YXRlLmtleSA9IGNvbnRleHQucmVzb2x2ZShwYXJhbXMua2V5KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgICBzdGF0ZS50eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIGNvbnRleHQgPSBhZGRTZWxlY3RTdGF0ZShjb250ZXh0LCBzdGF0ZSk7XG4gICAgICBjaHVuayA9IGNodW5rLnJlbmRlcihib2R5LCBjb250ZXh0KTtcbiAgICAgIHJlc29sdmVTZWxlY3REZWZlcnJlZHMoZ2V0U2VsZWN0U3RhdGUoY29udGV4dCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2coXCJzZWxlY3RcIiwgXCJNaXNzaW5nIGJvZHkgYmxvY2tcIiwgXCJXQVJOXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRydXRoIHRlc3QgaGVscGVyc1xuICAgKiBAcGFyYW0ga2V5IGEgdmFsdWUgb3IgcmVmZXJlbmNlIHRvIHVzZSBhcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgY29tcGFyaXNvbnNcbiAgICogQHBhcmFtIHZhbHVlIGEgdmFsdWUgb3IgcmVmZXJlbmNlIHRvIHVzZSBhcyB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIGNvbXBhcmlzb25zXG4gICAqIEBwYXJhbSB0eXBlIGlmIHNwZWNpZmllZCwgYGtleWAgYW5kIGB2YWx1ZWAgd2lsbCBiZSBmb3JjaWJseSBjYXN0IHRvIHRoaXMgdHlwZVxuICAgKi9cbiAgXCJlcVwiOiB0cnV0aFRlc3QoJ2VxJywgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIH0pLFxuICBcIm5lXCI6IHRydXRoVGVzdCgnbmUnLCBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0ICE9PSByaWdodDtcbiAgfSksXG4gIFwibHRcIjogdHJ1dGhUZXN0KCdsdCcsIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPCByaWdodDtcbiAgfSksXG4gIFwibHRlXCI6IHRydXRoVGVzdCgnbHRlJywgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCA8PSByaWdodDtcbiAgfSksXG4gIFwiZ3RcIjogdHJ1dGhUZXN0KCdndCcsIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPiByaWdodDtcbiAgfSksXG4gIFwiZ3RlXCI6IHRydXRoVGVzdCgnZ3RlJywgZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCA+PSByaWdodDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIHtAYW55fVxuICAgKiBPdXRwdXRzIGFzIGxvbmcgYXMgYXQgbGVhc3Qgb25lIHRydXRoIHRlc3QgaW5zaWRlIGEge0BzZWxlY3R9IGhhcyBwYXNzZWQuXG4gICAqIE11c3QgYmUgY29udGFpbmVkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9jay5cbiAgICogVGhlIHBhc3NpbmcgdHJ1dGggdGVzdCBjYW4gYmUgYmVmb3JlIG9yIGFmdGVyIHRoZSB7QGFueX0gYmxvY2suXG4gICAqL1xuICBcImFueVwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIgc2VsZWN0U3RhdGUgPSBnZXRTZWxlY3RTdGF0ZShjb250ZXh0KTtcblxuICAgIGlmKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgbG9nKFwiYW55XCIsIFwiTXVzdCBiZSB1c2VkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9ja1wiLCBcIkVSUk9SXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihzZWxlY3RTdGF0ZS5pc0RlZmVycmVkQ29tcGxldGUpIHtcbiAgICAgICAgbG9nKFwiYW55XCIsIFwiTXVzdCBub3QgYmUgbmVzdGVkIGluc2lkZSB7QGFueX0gb3Ige0Bub25lfSBibG9ja1wiLCBcIkVSUk9SXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsgPSBjaHVuay5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICBzZWxlY3RTdGF0ZS5kZWZlcnJlZHMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHNlbGVjdFN0YXRlLmlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5yZW5kZXIoYm9kaWVzLmJsb2NrLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rLmVuZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9LFxuXG4gIC8qKlxuICAgKiB7QG5vbmV9XG4gICAqIE91dHB1dHMgaWYgbm8gdHJ1dGggdGVzdHMgaW5zaWRlIGEge0BzZWxlY3R9IHBhc3MuXG4gICAqIE11c3QgYmUgY29udGFpbmVkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9jay5cbiAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgZG9lcyBub3QgbWF0dGVyLlxuICAgKi9cbiAgXCJub25lXCI6IGZ1bmN0aW9uKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciBzZWxlY3RTdGF0ZSA9IGdldFNlbGVjdFN0YXRlKGNvbnRleHQpO1xuXG4gICAgaWYoIXNlbGVjdFN0YXRlKSB7XG4gICAgICBsb2coXCJub25lXCIsIFwiTXVzdCBiZSB1c2VkIGluc2lkZSBhIHtAc2VsZWN0fSBibG9ja1wiLCBcIkVSUk9SXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihzZWxlY3RTdGF0ZS5pc0RlZmVycmVkQ29tcGxldGUpIHtcbiAgICAgICAgbG9nKFwibm9uZVwiLCBcIk11c3Qgbm90IGJlIG5lc3RlZCBpbnNpZGUge0Bhbnl9IG9yIHtAbm9uZX0gYmxvY2tcIiwgXCJFUlJPUlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rID0gY2h1bmsubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgc2VsZWN0U3RhdGUuZGVmZXJyZWRzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZighc2VsZWN0U3RhdGUuaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnJlbmRlcihib2RpZXMuYmxvY2ssIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmsuZW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2h1bms7XG4gIH0sXG5cbiAgLyoqXG4gICoge0BzaXplfVxuICAqIFdyaXRlIHRoZSBzaXplIG9mIHRoZSB0YXJnZXQgdG8gdGhlIGNodW5rXG4gICogRmFsc3kgdmFsdWVzIGFuZCB0cnVlIGhhdmUgc2l6ZSAwXG4gICogTnVtYmVycyBhcmUgcmV0dXJuZWQgYXMtaXNcbiAgKiBBcnJheXMgYW5kIFN0cmluZ3MgaGF2ZSBzaXplIGVxdWFsIHRvIHRoZWlyIGxlbmd0aFxuICAqIE9iamVjdHMgaGF2ZSBzaXplIGVxdWFsIHRvIHRoZSBudW1iZXIgb2Yga2V5cyB0aGV5IGNvbnRhaW5cbiAgKiBEdXN0IGJvZGllcyBhcmUgZXZhbHVhdGVkIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgKiBGdW5jdGlvbnMgYXJlIGV2YWx1YXRlZCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVpciByZXR1cm4gdmFsdWUgaXMgZXZhbHVhdGVkXG4gICogQHBhcmFtIGtleSBmaW5kIHRoZSBzaXplIG9mIHRoaXMgdmFsdWUgb3IgcmVmZXJlbmNlXG4gICovXG4gIFwic2l6ZVwiOiBmdW5jdGlvbihjaHVuaywgY29udGV4dCwgYm9kaWVzLCBwYXJhbXMpIHtcbiAgICB2YXIga2V5ID0gcGFyYW1zLmtleSxcbiAgICAgICAgdmFsdWUsIGs7XG5cbiAgICBrZXkgPSBjb250ZXh0LnJlc29sdmUocGFyYW1zLmtleSk7XG4gICAgaWYgKCFrZXkgfHwga2V5ID09PSB0cnVlKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfSBlbHNlIGlmKGR1c3QuaXNBcnJheShrZXkpKSB7XG4gICAgICB2YWx1ZSA9IGtleS5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICghaXNOYU4ocGFyc2VGbG9hdChrZXkpKSAmJiBpc0Zpbml0ZShrZXkpKSB7XG4gICAgICB2YWx1ZSA9IGtleTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHZhbHVlID0gMDtcbiAgICAgIGZvcihrIGluIGtleSl7XG4gICAgICAgIGlmKGtleS5oYXNPd25Qcm9wZXJ0eShrKSl7XG4gICAgICAgICAgdmFsdWUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IChrZXkgKyAnJykubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmsud3JpdGUodmFsdWUpO1xuICB9XG5cbn07XG5cbmZvcih2YXIga2V5IGluIGhlbHBlcnMpIHtcbiAgZHVzdC5oZWxwZXJzW2tleV0gPSBoZWxwZXJzW2tleV07XG59XG5cbnJldHVybiBkdXN0O1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUuYW1kLmR1c3QgPT09IHRydWUpIHtcbiAgICBkZWZpbmUoJ2R1c3QuY29yZScsIFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290LmR1c3QgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gIHZhciBkdXN0ID0ge1xuICAgICAgICBcInZlcnNpb25cIjogXCIyLjcuMlwiXG4gICAgICB9LFxuICAgICAgTk9ORSA9ICdOT05FJywgRVJST1IgPSAnRVJST1InLCBXQVJOID0gJ1dBUk4nLCBJTkZPID0gJ0lORk8nLCBERUJVRyA9ICdERUJVRycsXG4gICAgICBFTVBUWV9GVU5DID0gZnVuY3Rpb24oKSB7fTtcblxuICBkdXN0LmNvbmZpZyA9IHtcbiAgICB3aGl0ZXNwYWNlOiBmYWxzZSxcbiAgICBhbWQ6IGZhbHNlLFxuICAgIGNqczogZmFsc2UsXG4gICAgY2FjaGU6IHRydWVcbiAgfTtcblxuICAvLyBEaXJlY3RpdmUgYWxpYXNlcyB0byBtaW5pZnkgY29kZVxuICBkdXN0Ll9hbGlhc2VzID0ge1xuICAgIFwid3JpdGVcIjogXCJ3XCIsXG4gICAgXCJlbmRcIjogXCJlXCIsXG4gICAgXCJtYXBcIjogXCJtXCIsXG4gICAgXCJyZW5kZXJcIjogXCJyXCIsXG4gICAgXCJyZWZlcmVuY2VcIjogXCJmXCIsXG4gICAgXCJzZWN0aW9uXCI6IFwic1wiLFxuICAgIFwiZXhpc3RzXCI6IFwieFwiLFxuICAgIFwibm90ZXhpc3RzXCI6IFwibnhcIixcbiAgICBcImJsb2NrXCI6IFwiYlwiLFxuICAgIFwicGFydGlhbFwiOiBcInBcIixcbiAgICBcImhlbHBlclwiOiBcImhcIlxuICB9O1xuXG4gIChmdW5jdGlvbiBpbml0TG9nZ2luZygpIHtcbiAgICAvKmdsb2JhbCBwcm9jZXNzLCBjb25zb2xlKi9cbiAgICB2YXIgbG9nZ2luZ0xldmVscyA9IHsgREVCVUc6IDAsIElORk86IDEsIFdBUk46IDIsIEVSUk9SOiAzLCBOT05FOiA0IH0sXG4gICAgICAgIGNvbnNvbGVMb2csXG4gICAgICAgIGxvZztcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgIGNvbnNvbGVMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIGlmKHR5cGVvZiBjb25zb2xlTG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGVMb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGVMb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykuam9pbignICcpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nID0gRU1QVFlfRlVOQztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIG1lc3NhZ2VzIGJhc2VkIG9uIGBkdXN0LmRlYnVnTGV2ZWxgLlxuICAgICAqIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHByaW50IHRvIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBwcmludC90aHJvd1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBzZXZlcml0eSBvZiB0aGUgbWVzc2FnZShFUlJPUiwgV0FSTiwgSU5GTywgb3IgREVCVUcpXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGR1c3QubG9nID0gZnVuY3Rpb24obWVzc2FnZSwgdHlwZSkge1xuICAgICAgdHlwZSA9IHR5cGUgfHwgSU5GTztcbiAgICAgIGlmIChsb2dnaW5nTGV2ZWxzW3R5cGVdID49IGxvZ2dpbmdMZXZlbHNbZHVzdC5kZWJ1Z0xldmVsXSkge1xuICAgICAgICBsb2coJ1tEVVNUOicgKyB0eXBlICsgJ10nLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZHVzdC5kZWJ1Z0xldmVsID0gTk9ORTtcbiAgICBpZih0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgL1xcYmR1c3RcXGIvLnRlc3QocHJvY2Vzcy5lbnYuREVCVUcpKSB7XG4gICAgICBkdXN0LmRlYnVnTGV2ZWwgPSBERUJVRztcbiAgICB9XG5cbiAgfSgpKTtcblxuICBkdXN0LmhlbHBlcnMgPSB7fTtcblxuICBkdXN0LmNhY2hlID0ge307XG5cbiAgZHVzdC5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIHRtcGwpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdG1wbC50ZW1wbGF0ZU5hbWUgPSBuYW1lO1xuICAgIGlmIChkdXN0LmNvbmZpZy5jYWNoZSAhPT0gZmFsc2UpIHtcbiAgICAgIGR1c3QuY2FjaGVbbmFtZV0gPSB0bXBsO1xuICAgIH1cbiAgfTtcblxuICBkdXN0LnJlbmRlciA9IGZ1bmN0aW9uKG5hbWVPclRlbXBsYXRlLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgIHZhciBjaHVuayA9IG5ldyBTdHViKGNhbGxiYWNrKS5oZWFkO1xuICAgIHRyeSB7XG4gICAgICBsb2FkKG5hbWVPclRlbXBsYXRlLCBjaHVuaywgY29udGV4dCkuZW5kKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjaHVuay5zZXRFcnJvcihlcnIpO1xuICAgIH1cbiAgfTtcblxuICBkdXN0LnN0cmVhbSA9IGZ1bmN0aW9uKG5hbWVPclRlbXBsYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJlYW0oKSxcbiAgICAgICAgY2h1bmsgPSBzdHJlYW0uaGVhZDtcbiAgICBkdXN0Lm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9hZChuYW1lT3JUZW1wbGF0ZSwgY2h1bmssIGNvbnRleHQpLmVuZCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNodW5rLnNldEVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdHMgYSB0ZW1wbGF0ZSBmdW5jdGlvbiAoYm9keV8wKSBmcm9tIHdoYXRldmVyIGlzIHBhc3NlZC5cbiAgICogQHBhcmFtIG5hbWVPclRlbXBsYXRlIHsqfSBDb3VsZCBiZTpcbiAgICogICAtIHRoZSBuYW1lIG9mIGEgdGVtcGxhdGUgdG8gbG9hZCBmcm9tIGNhY2hlXG4gICAqICAgLSBhIENvbW1vbkpTLWNvbXBpbGVkIHRlbXBsYXRlIChhIGZ1bmN0aW9uIHdpdGggYSBgdGVtcGxhdGVgIHByb3BlcnR5KVxuICAgKiAgIC0gYSB0ZW1wbGF0ZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gbG9hZEZyb21DYWNoZSB7Qm9vbGVhbn0gaWYgZmFsc2UsIGRvbid0IGxvb2sgaW4gdGhlIGNhY2hlXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIHRlbXBsYXRlIGZ1bmN0aW9uLCBpZiBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VGVtcGxhdGUobmFtZU9yVGVtcGxhdGUsIGxvYWRGcm9tQ2FjaGUvKj10cnVlKi8pIHtcbiAgICBpZighbmFtZU9yVGVtcGxhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYodHlwZW9mIG5hbWVPclRlbXBsYXRlID09PSAnZnVuY3Rpb24nICYmIG5hbWVPclRlbXBsYXRlLnRlbXBsYXRlKSB7XG4gICAgICAvLyBTdWdhciBhd2F5IENvbW1vbkpTIG1vZHVsZSB0ZW1wbGF0ZXNcbiAgICAgIHJldHVybiBuYW1lT3JUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICB9XG4gICAgaWYoZHVzdC5pc1RlbXBsYXRlRm4obmFtZU9yVGVtcGxhdGUpKSB7XG4gICAgICAvLyBUZW1wbGF0ZSBmdW5jdGlvbnMgcGFzc2VkIGRpcmVjdGx5XG4gICAgICByZXR1cm4gbmFtZU9yVGVtcGxhdGU7XG4gICAgfVxuICAgIGlmKGxvYWRGcm9tQ2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICAvLyBUcnkgbG9hZGluZyBhIHRlbXBsYXRlIHdpdGggdGhpcyBuYW1lIGZyb20gY2FjaGVcbiAgICAgIHJldHVybiBkdXN0LmNhY2hlW25hbWVPclRlbXBsYXRlXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkKG5hbWVPclRlbXBsYXRlLCBjaHVuaywgY29udGV4dCkge1xuICAgIGlmKCFuYW1lT3JUZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIGNodW5rLnNldEVycm9yKG5ldyBFcnJvcignTm8gdGVtcGxhdGUgb3IgdGVtcGxhdGUgbmFtZSBwcm92aWRlZCB0byByZW5kZXInKSk7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZ2V0VGVtcGxhdGUobmFtZU9yVGVtcGxhdGUsIGR1c3QuY29uZmlnLmNhY2hlKTtcblxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlKGNodW5rLCBDb250ZXh0LndyYXAoY29udGV4dCwgdGVtcGxhdGUudGVtcGxhdGVOYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkdXN0Lm9uTG9hZCkge1xuICAgICAgICByZXR1cm4gY2h1bmsubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgLy8gQWxpYXMganVzdCBzbyBpdCdzIGVhc2llciB0byByZWFkIHRoYXQgdGhpcyB3b3VsZCBhbHdheXMgYmUgYSBuYW1lXG4gICAgICAgICAgdmFyIG5hbWUgPSBuYW1lT3JUZW1wbGF0ZTtcbiAgICAgICAgICAvLyBUaHJlZSBwb3NzaWJsZSBzY2VuYXJpb3MgZm9yIGEgc3VjY2Vzc2Z1bCBjYWxsYmFjazpcbiAgICAgICAgICAvLyAgIC0gYHJlcXVpcmUobmFtZU9yVGVtcGxhdGUpKGR1c3QpOyBjYigpYFxuICAgICAgICAgIC8vICAgLSBgc3JjID0gcmVhZEZpbGUoJ3NyYy5kdXN0Jyk7IGNiKG51bGwsIHNyYylgXG4gICAgICAgICAgLy8gICAtIGBjb21waWxlZFRlbXBsYXRlID0gcmVxdWlyZShuYW1lT3JUZW1wbGF0ZSkoZHVzdCk7IGNiKG51bGwsIGNvbXBpbGVkVGVtcGxhdGUpYFxuICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyLCBzcmNPclRlbXBsYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGU7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjaHVuay5zZXRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJlZmVyIGEgdGVtcGxhdGUgdGhhdCBpcyBwYXNzZWQgdmlhIGNhbGxiYWNrIG92ZXIgdGhlIGNhY2hlZCB2ZXJzaW9uLlxuICAgICAgICAgICAgdGVtcGxhdGUgPSBnZXRUZW1wbGF0ZShzcmNPclRlbXBsYXRlLCBmYWxzZSkgfHwgZ2V0VGVtcGxhdGUobmFtZSwgZHVzdC5jb25maWcuY2FjaGUpO1xuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAvLyBJdCdzIGEgdGVtcGxhdGUgc3RyaW5nLCBjb21waWxlIGl0IGFuZCByZWdpc3RlciB1bmRlciBgbmFtZWBcbiAgICAgICAgICAgICAgaWYoZHVzdC5jb21waWxlKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBkdXN0LmxvYWRTb3VyY2UoZHVzdC5jb21waWxlKHNyY09yVGVtcGxhdGUsIG5hbWUpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmsuc2V0RXJyb3IobmV3IEVycm9yKCdEdXN0IGNvbXBpbGVyIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBsYXRlKGNodW5rLCBDb250ZXh0LndyYXAoY29udGV4dCwgdGVtcGxhdGUudGVtcGxhdGVOYW1lKSkuZW5kKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoZHVzdC5vbkxvYWQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBkdXN0Lm9uTG9hZChuYW1lLCBjb250ZXh0Lm9wdGlvbnMsIGRvbmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdXN0Lm9uTG9hZChuYW1lLCBkb25lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNodW5rLnNldEVycm9yKG5ldyBFcnJvcignVGVtcGxhdGUgTm90IEZvdW5kOiAnICsgbmFtZU9yVGVtcGxhdGUpKTtcbiAgICB9XG4gIH1cblxuICBkdXN0LmxvYWRTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAvKmpzaGludCBldmlsOnRydWUqL1xuICAgIHJldHVybiBldmFsKHNvdXJjZSk7XG4gIH07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICBkdXN0LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICB9IGVsc2Uge1xuICAgIGR1c3QuaXNBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBkdXN0Lm5leHRUaWNrID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogRHVzdCBoYXMgaXRzIG93biBydWxlcyBmb3Igd2hhdCBpcyBcImVtcHR5XCItLSB3aGljaCBpcyBub3QgdGhlIHNhbWUgYXMgZmFsc3kuXG4gICAqIEVtcHR5IGFycmF5cywgbnVsbCwgYW5kIHVuZGVmaW5lZCBhcmUgZW1wdHlcbiAgICovXG4gIGR1c3QuaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkdXN0LmlzQXJyYXkodmFsdWUpICYmICF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIXZhbHVlO1xuICB9O1xuXG4gIGR1c3QuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iai5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBkdXN0LmlzVGVtcGxhdGVGbiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIGVsZW0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgZWxlbS5fX2R1c3RCb2R5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNpZGUgc29tZXdoYXQtbmFpdmVseSBpZiBzb21ldGhpbmcgaXMgYSBUaGVuYWJsZS5cbiAgICogQHBhcmFtIGVsZW0geyp9IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzIGBlbGVtYCBhIFRoZW5hYmxlP1xuICAgKi9cbiAgZHVzdC5pc1RoZW5hYmxlID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIHJldHVybiBlbGVtICYmXG4gICAgICAgICAgIHR5cGVvZiBlbGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICB0eXBlb2YgZWxlbS50aGVuID09PSAnZnVuY3Rpb24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNpZGUgdmVyeSBuYWl2ZWx5IGlmIHNvbWV0aGluZyBpcyBhIFN0cmVhbS5cbiAgICogQHBhcmFtIGVsZW0geyp9IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzIGBlbGVtYCBhIFN0cmVhbT9cbiAgICovXG4gIGR1c3QuaXNTdHJlYW1hYmxlID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIHJldHVybiBlbGVtICYmXG4gICAgICAgICAgIHR5cGVvZiBlbGVtLm9uID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgIHR5cGVvZiBlbGVtLnBpcGUgPT09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgLy8gYXBwbHkgdGhlIGZpbHRlciBjaGFpbiBhbmQgcmV0dXJuIHRoZSBvdXRwdXQgc3RyaW5nXG4gIGR1c3QuZmlsdGVyID0gZnVuY3Rpb24oc3RyaW5nLCBhdXRvLCBmaWx0ZXJzLCBjb250ZXh0KSB7XG4gICAgdmFyIGksIGxlbiwgbmFtZSwgZmlsdGVyO1xuICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmaWx0ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBmaWx0ZXJzW2ldO1xuICAgICAgICBpZiAoIW5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyID0gZHVzdC5maWx0ZXJzW25hbWVdO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3MnKSB7XG4gICAgICAgICAgYXV0byA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHN0cmluZyA9IGZpbHRlcihzdHJpbmcsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR1c3QubG9nKCdJbnZhbGlkIGZpbHRlciBgJyArIG5hbWUgKyAnYCcsIFdBUk4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGJ5IGRlZmF1bHQgYWx3YXlzIGFwcGx5IHRoZSBoIGZpbHRlciwgdW5sZXNzIGFza2VkIHRvIHVuZXNjYXBlIHdpdGggfHNcbiAgICBpZiAoYXV0bykge1xuICAgICAgc3RyaW5nID0gZHVzdC5maWx0ZXJzW2F1dG9dKHN0cmluZywgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG5cbiAgZHVzdC5maWx0ZXJzID0ge1xuICAgIGg6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBkdXN0LmVzY2FwZUh0bWwodmFsdWUpOyB9LFxuICAgIGo6IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBkdXN0LmVzY2FwZUpzKHZhbHVlKTsgfSxcbiAgICB1OiBlbmNvZGVVUkksXG4gICAgdWM6IGVuY29kZVVSSUNvbXBvbmVudCxcbiAgICBqczogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGR1c3QuZXNjYXBlSlNPTih2YWx1ZSk7IH0sXG4gICAganA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIUpTT04pIHtkdXN0LmxvZygnSlNPTiBpcyB1bmRlZmluZWQ7IGNvdWxkIG5vdCBwYXJzZSBgJyArIHZhbHVlICsgJ2AnLCBXQVJOKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBDb250ZXh0KHN0YWNrLCBnbG9iYWwsIG9wdGlvbnMsIGJsb2NrcywgdGVtcGxhdGVOYW1lKSB7XG4gICAgaWYoc3RhY2sgIT09IHVuZGVmaW5lZCAmJiAhKHN0YWNrIGluc3RhbmNlb2YgU3RhY2spKSB7XG4gICAgICBzdGFjayA9IG5ldyBTdGFjayhzdGFjayk7XG4gICAgfVxuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmdsb2JhbCA9IGdsb2JhbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICB9XG5cbiAgZHVzdC5tYWtlQmFzZSA9IGR1c3QuY29udGV4dCA9IGZ1bmN0aW9uKGdsb2JhbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29udGV4dCh1bmRlZmluZWQsIGdsb2JhbCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgY2xvc3VyZSBzY29wZSBhcm91bmQgYSBUaGVuYWJsZS1jYWxsYmFjay5cbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBhIFRoZW5hYmxlIHRoYXQgd2lsbCByZXN1bWUgYVxuICAgKiBDb250ZXh0IGxvb2t1cCBvbmNlIHRoZSBUaGVuYWJsZSByZXNvbHZlcyB3aXRoIG5ldyBkYXRhLCBhZGRpbmcgdGhhdCBuZXdcbiAgICogZGF0YSB0byB0aGUgbG9va3VwIHN0YWNrLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0V2l0aFJlc29sdmVkRGF0YShjdHgsIGN1ciwgZG93bikge1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gY3R4LnB1c2goZGF0YSkuX2dldChjdXIsIGRvd24pO1xuICAgIH07XG4gIH1cblxuICBDb250ZXh0LndyYXAgPSBmdW5jdGlvbihjb250ZXh0LCBuYW1lKSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0KSB7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KGNvbnRleHQsIHt9LCB7fSwgbnVsbCwgbmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBBUEkgZm9yIGdldHRpbmcgYSB2YWx1ZSBmcm9tIHRoZSBjb250ZXh0LlxuICAgKiBAbWV0aG9kIGdldFxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gcGF0aCBUaGUgcGF0aCB0byB0aGUgdmFsdWUuIFN1cHBvcnRlZCBmb3JtYXRzIGFyZTpcbiAgICogJ2tleSdcbiAgICogJ3BhdGgudG8ua2V5J1xuICAgKiAnLnBhdGgudG8ua2V5J1xuICAgKiBbJ3BhdGgnLCAndG8nLCAna2V5J11cbiAgICogWydrZXknXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjdXI9ZmFsc2VdIEJvb2xlYW4gd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgc2VhcmNoIHNob3VsZCBiZSBsaW1pdGVkIHRvIHRoZVxuICAgKiBjdXJyZW50IGNvbnRleHQgKHRydWUpLCBvciBpZiBnZXQgc2hvdWxkIHNlYXJjaCBpbiBwYXJlbnQgY29udGV4dHMgYXMgd2VsbCAoZmFsc2UpLlxuICAgKiBAcHVibGljXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8b2JqZWN0fVxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGF0aCwgY3VyKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHBhdGhbMF0gPT09ICcuJykge1xuICAgICAgICBjdXIgPSB0cnVlO1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICB9XG4gICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0KGN1ciwgcGF0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHZhbHVlIGZyb20gdGhlIGNvbnRleHRcbiAgICogQG1ldGhvZCBfZ2V0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3VyIEdldCBvbmx5IGZyb20gdGhlIGN1cnJlbnQgY29udGV4dFxuICAgKiBAcGFyYW0ge2FycmF5fSBkb3duIEFuIGFycmF5IG9mIGVhY2ggc3RlcCBpbiB0aGUgcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBvYmplY3R9XG4gICAqL1xuICBDb250ZXh0LnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24oY3VyLCBkb3duKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuc3RhY2sgfHwge30sXG4gICAgICAgIGkgPSAxLFxuICAgICAgICB2YWx1ZSwgZmlyc3QsIGxlbiwgY3R4VGhpcywgZm47XG5cbiAgICBmaXJzdCA9IGRvd25bMF07XG4gICAgbGVuID0gZG93bi5sZW5ndGg7XG5cbiAgICBpZiAoY3VyICYmIGxlbiA9PT0gMCkge1xuICAgICAgY3R4VGhpcyA9IGN0eDtcbiAgICAgIGN0eCA9IGN0eC5oZWFkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cikge1xuICAgICAgICAvLyBTZWFyY2ggdXAgdGhlIHN0YWNrIGZvciB0aGUgZmlyc3QgdmFsdWVcbiAgICAgICAgd2hpbGUgKGN0eCkge1xuICAgICAgICAgIGlmIChjdHguaXNPYmplY3QpIHtcbiAgICAgICAgICAgIGN0eFRoaXMgPSBjdHguaGVhZDtcbiAgICAgICAgICAgIHZhbHVlID0gY3R4LmhlYWRbZmlyc3RdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eCA9IGN0eC50YWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJ5IGxvb2tpbmcgaW4gdGhlIGdsb2JhbCBjb250ZXh0IGlmIHdlIGhhdmVuJ3QgZm91bmQgYW55dGhpbmcgeWV0XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4ID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5nbG9iYWwgJiYgdGhpcy5nbG9iYWxbZmlyc3RdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN0eCkge1xuICAgICAgICAvLyBpZiBzY29wZSBpcyBsaW1pdGVkIGJ5IGEgbGVhZGluZyBkb3QsIGRvbid0IHNlYXJjaCB1cCB0aGUgdHJlZVxuICAgICAgICBpZihjdHguaGVhZCkge1xuICAgICAgICAgIGN0eCA9IGN0eC5oZWFkW2ZpcnN0XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb250ZXh0J3MgaGVhZCBpcyBlbXB0eSwgdmFsdWUgd2UgYXJlIHNlYXJjaGluZyBmb3IgaXMgbm90IGRlZmluZWRcbiAgICAgICAgICBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGN0eCAmJiBpIDwgbGVuKSB7XG4gICAgICAgIGlmIChkdXN0LmlzVGhlbmFibGUoY3R4KSkge1xuICAgICAgICAgIC8vIEJhaWwgZWFybHkgYnkgcmV0dXJuaW5nIGEgVGhlbmFibGUgZm9yIHRoZSByZW1haW5kZXIgb2YgdGhlIHNlYXJjaCB0cmVlXG4gICAgICAgICAgcmV0dXJuIGN0eC50aGVuKGdldFdpdGhSZXNvbHZlZERhdGEodGhpcywgY3VyLCBkb3duLnNsaWNlKGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4VGhpcyA9IGN0eDtcbiAgICAgICAgY3R4ID0gY3R4W2Rvd25baV1dO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGN0eC5hcHBseShjdHhUaGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBkdXN0LmxvZyhlcnIsIEVSUk9SKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmbi5fX2R1c3RCb2R5ID0gISFjdHguX19kdXN0Qm9keTtcbiAgICAgIHJldHVybiBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGR1c3QubG9nKCdDYW5ub3QgZmluZCByZWZlcmVuY2UgYHsnICsgZG93bi5qb2luKCcuJykgKyAnfWAgaW4gdGVtcGxhdGUgYCcgKyB0aGlzLmdldFRlbXBsYXRlTmFtZSgpICsgJ2AnLCBJTkZPKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbihjdXIsIGRvd24pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGN1ciwgZG93bik7XG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGhlYWQsIGlkeCwgbGVuKSB7XG4gICAgaWYoaGVhZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkdXN0LmxvZyhcIk5vdCBwdXNoaW5nIGFuIHVuZGVmaW5lZCB2YXJpYWJsZSBvbnRvIHRoZSBjb250ZXh0XCIsIElORk8pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlYmFzZShuZXcgU3RhY2soaGVhZCwgdGhpcy5zdGFjaywgaWR4LCBsZW4pKTtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuY3VycmVudCgpO1xuICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrICYmIHRoaXMuc3RhY2sudGFpbDtcbiAgICByZXR1cm4gaGVhZDtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5yZWJhc2UgPSBmdW5jdGlvbihoZWFkKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KGhlYWQsIHRoaXMuZ2xvYmFsLCB0aGlzLm9wdGlvbnMsIHRoaXMuYmxvY2tzLCB0aGlzLmdldFRlbXBsYXRlTmFtZSgpKTtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZWJhc2UoKTtcbiAgICBjb250ZXh0LnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2sgJiYgdGhpcy5zdGFjay5oZWFkO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmdldEJsb2NrID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGJsb2NrcywgbGVuLCBmbjtcblxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBrZXkgPSBrZXkobmV3IENodW5rKCksIHRoaXMpLmRhdGEuam9pbignJyk7XG4gICAgfVxuXG4gICAgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG5cbiAgICBpZiAoIWJsb2Nrcykge1xuICAgICAgZHVzdC5sb2coJ05vIGJsb2NrcyBmb3IgY29udGV4dCBgJyArIGtleSArICdgIGluIHRlbXBsYXRlIGAnICsgdGhpcy5nZXRUZW1wbGF0ZU5hbWUoKSArICdgJywgREVCVUcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxlbiA9IGJsb2Nrcy5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICBmbiA9IGJsb2Nrc1tsZW5dW2tleV07XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGR1c3QubG9nKCdNYWxmb3JtZWQgdGVtcGxhdGUgYCcgKyB0aGlzLmdldFRlbXBsYXRlTmFtZSgpICsgJ2Agd2FzIG1pc3Npbmcgb25lIG9yIG1vcmUgYmxvY2tzLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5zaGlmdEJsb2NrcyA9IGZ1bmN0aW9uKGxvY2Fscykge1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcyxcbiAgICAgICAgbmV3QmxvY2tzO1xuXG4gICAgaWYgKGxvY2Fscykge1xuICAgICAgaWYgKCFibG9ja3MpIHtcbiAgICAgICAgbmV3QmxvY2tzID0gW2xvY2Fsc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdCbG9ja3MgPSBibG9ja3MuY29uY2F0KFtsb2NhbHNdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ29udGV4dCh0aGlzLnN0YWNrLCB0aGlzLmdsb2JhbCwgdGhpcy5vcHRpb25zLCBuZXdCbG9ja3MsIHRoaXMuZ2V0VGVtcGxhdGVOYW1lKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24oYm9keSkge1xuICAgIHZhciBjaHVuaztcblxuICAgIGlmKHR5cGVvZiBib2R5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gICAgY2h1bmsgPSBuZXcgQ2h1bmsoKS5yZW5kZXIoYm9keSwgdGhpcyk7XG4gICAgaWYoY2h1bmsgaW5zdGFuY2VvZiBDaHVuaykge1xuICAgICAgcmV0dXJuIGNodW5rLmRhdGEuam9pbignJyk7IC8vIGllNyBwZXJmXG4gICAgfVxuICAgIHJldHVybiBjaHVuaztcbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5nZXRUZW1wbGF0ZU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZU5hbWU7XG4gIH07XG5cbiAgZnVuY3Rpb24gU3RhY2soaGVhZCwgdGFpbCwgaWR4LCBsZW4pIHtcbiAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgIHRoaXMuaXNPYmplY3QgPSBoZWFkICYmIHR5cGVvZiBoZWFkID09PSAnb2JqZWN0JztcbiAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgIHRoaXMuaW5kZXggPSBpZHg7XG4gICAgdGhpcy5vZiA9IGxlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIFN0dWIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmhlYWQgPSBuZXcgQ2h1bmsodGhpcyk7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMub3V0ID0gJyc7XG4gIH1cblxuICBTdHViLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaHVuayA9IHRoaXMuaGVhZDtcblxuICAgIHdoaWxlIChjaHVuaykge1xuICAgICAgaWYgKGNodW5rLmZsdXNoYWJsZSkge1xuICAgICAgICB0aGlzLm91dCArPSBjaHVuay5kYXRhLmpvaW4oJycpOyAvL2llNyBwZXJmXG4gICAgICB9IGVsc2UgaWYgKGNodW5rLmVycm9yKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soY2h1bmsuZXJyb3IpO1xuICAgICAgICBkdXN0LmxvZygnUmVuZGVyaW5nIGZhaWxlZCB3aXRoIGVycm9yIGAnICsgY2h1bmsuZXJyb3IgKyAnYCcsIEVSUk9SKTtcbiAgICAgICAgdGhpcy5mbHVzaCA9IEVNUFRZX0ZVTkM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNodW5rID0gY2h1bmsubmV4dDtcbiAgICAgIHRoaXMuaGVhZCA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLmNhbGxiYWNrKG51bGwsIHRoaXMub3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnRlcmZhY2Ugc29ydCBvZiBsaWtlIGEgU3RyZWFtczIgUmVhZGFibGVTdHJlYW0uXG4gICAqL1xuICBmdW5jdGlvbiBTdHJlYW0oKSB7XG4gICAgdGhpcy5oZWFkID0gbmV3IENodW5rKHRoaXMpO1xuICB9XG5cbiAgU3RyZWFtLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaHVuayA9IHRoaXMuaGVhZDtcblxuICAgIHdoaWxlKGNodW5rKSB7XG4gICAgICBpZiAoY2h1bmsuZmx1c2hhYmxlKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rLmRhdGEuam9pbignJykpOyAvL2llNyBwZXJmXG4gICAgICB9IGVsc2UgaWYgKGNodW5rLmVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBjaHVuay5lcnJvcik7XG4gICAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgICAgIGR1c3QubG9nKCdTdHJlYW1pbmcgZmFpbGVkIHdpdGggZXJyb3IgYCcgKyBjaHVuay5lcnJvciArICdgJywgRVJST1IpO1xuICAgICAgICB0aGlzLmZsdXNoID0gRU1QVFlfRlVOQztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2h1bmsgPSBjaHVuay5uZXh0O1xuICAgICAgdGhpcy5oZWFkID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGxpc3RlbmVycyBmb3IgYHR5cGVgIGJ5IHBhc3NpbmcgZGF0YS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20gYVxuICAgKiBOb2RlIHN0cmVhbSwgd2hpY2ggY2FuIHBhc3MgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBhcmd1bWVudHNcbiAgICogQHJldHVybiBgdHJ1ZWAgaWYgZXZlbnQgaGFkIGxpc3RlbmVycywgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIFN0cmVhbS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge30sXG4gICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdIHx8IFtdLFxuICAgICAgICBpLCBsO1xuXG4gICAgaWYgKCFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIGR1c3QubG9nKCdTdHJlYW0gYnJvYWRjYXN0aW5nLCBidXQgbm8gbGlzdGVuZXJzIGZvciBgJyArIHR5cGUgKyAnYCcsIERFQlVHKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBoYW5kbGVycyA9IGhhbmRsZXJzLnNsaWNlKDApO1xuICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cyB8fCB7fSxcbiAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0gPSBldmVudHNbdHlwZV0gfHwgW107XG5cbiAgICBpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGR1c3QubG9nKCdObyBjYWxsYmFjayBmdW5jdGlvbiBwcm92aWRlZCBmb3IgYCcgKyB0eXBlICsgJ2AgZXZlbnQgbGlzdGVuZXInLCBXQVJOKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQaXBlcyB0byBhIFdyaXRhYmxlU3RyZWFtLiBOb3RlIHRoYXQgYmFja3ByZXNzdXJlIGlzbid0IGltcGxlbWVudGVkLFxuICAgKiBzbyB3ZSBqdXN0IHdyaXRlIGFzIGZhc3QgYXMgd2UgY2FuLlxuICAgKiBAcGFyYW0gc3RyZWFtIHtXcml0YWJsZVN0cmVhbX1cbiAgICogQHJldHVybiBzZWxmXG4gICAqL1xuICBTdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICBpZih0eXBlb2Ygc3RyZWFtLndyaXRlICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgdHlwZW9mIHN0cmVhbS5lbmQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGR1c3QubG9nKCdJbmNvbXBhdGlibGUgc3RyZWFtIHBhc3NlZCB0byBgcGlwZWAnLCBXQVJOKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBkZXN0RW5kZWQgPSBmYWxzZTtcblxuICAgIGlmKHR5cGVvZiBzdHJlYW0uZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RyZWFtLmVtaXQoJ3BpcGUnLCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2Ygc3RyZWFtLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlc3RFbmRlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICAgIC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGlmKGRlc3RFbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzdHJlYW0ud3JpdGUoZGF0YSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkdXN0LmxvZyhlcnIsIEVSUk9SKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZihkZXN0RW5kZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyZWFtLmVuZCgpO1xuICAgICAgICBkZXN0RW5kZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGR1c3QubG9nKGVyciwgRVJST1IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENodW5rKHJvb3QsIG5leHQsIHRhcHMpIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgdGhpcy5kYXRhID0gW107IC8vaWU3IHBlcmZcbiAgICB0aGlzLmZsdXNoYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMudGFwcyA9IHRhcHM7XG4gIH1cblxuICBDaHVuay5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHRhcHMgPSB0aGlzLnRhcHM7XG5cbiAgICBpZiAodGFwcykge1xuICAgICAgZGF0YSA9IHRhcHMuZ28oZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuZGF0YS5wdXNoKGRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMud3JpdGUoZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuZmx1c2hhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnJvb3QuZmx1c2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgY3Vyc29yID0gbmV3IENodW5rKHRoaXMucm9vdCwgdGhpcy5uZXh0LCB0aGlzLnRhcHMpLFxuICAgICAgICBicmFuY2ggPSBuZXcgQ2h1bmsodGhpcy5yb290LCBjdXJzb3IsIHRoaXMudGFwcyk7XG5cbiAgICB0aGlzLm5leHQgPSBicmFuY2g7XG4gICAgdGhpcy5mbHVzaGFibGUgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjayhicmFuY2gpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBkdXN0LmxvZyhlcnIsIEVSUk9SKTtcbiAgICAgIGJyYW5jaC5zZXRFcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gY3Vyc29yO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbih0YXApIHtcbiAgICB2YXIgdGFwcyA9IHRoaXMudGFwcztcblxuICAgIGlmICh0YXBzKSB7XG4gICAgICB0aGlzLnRhcHMgPSB0YXBzLnB1c2godGFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXBzID0gbmV3IFRhcCh0YXApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUudW50YXAgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRhcHMgPSB0aGlzLnRhcHMudGFpbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oYm9keSwgY29udGV4dCkge1xuICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQpO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5yZWZlcmVuY2UgPSBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCBhdXRvLCBmaWx0ZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlbGVtID0gZWxlbS5hcHBseShjb250ZXh0LmN1cnJlbnQoKSwgW3RoaXMsIGNvbnRleHQsIG51bGwsIHthdXRvOiBhdXRvLCBmaWx0ZXJzOiBmaWx0ZXJzfV0pO1xuICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBDaHVuaykge1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZShlbGVtLCBjb250ZXh0LCBhdXRvLCBmaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGR1c3QuaXNUaGVuYWJsZShlbGVtKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXdhaXQoZWxlbSwgY29udGV4dCwgbnVsbCwgYXV0bywgZmlsdGVycyk7XG4gICAgfSBlbHNlIGlmIChkdXN0LmlzU3RyZWFtYWJsZShlbGVtKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtKGVsZW0sIGNvbnRleHQsIG51bGwsIGF1dG8sIGZpbHRlcnMpO1xuICAgIH0gZWxzZSBpZiAoIWR1c3QuaXNFbXB0eShlbGVtKSkge1xuICAgICAgcmV0dXJuIHRoaXMud3JpdGUoZHVzdC5maWx0ZXIoZWxlbSwgYXV0bywgZmlsdGVycywgY29udGV4dCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLnNlY3Rpb24gPSBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgICBza2lwID0gYm9kaWVzWydlbHNlJ10sXG4gICAgICAgIGNodW5rID0gdGhpcyxcbiAgICAgICAgaSwgbGVuLCBoZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBlbGVtID09PSAnZnVuY3Rpb24nICYmICFkdXN0LmlzVGVtcGxhdGVGbihlbGVtKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWxlbSA9IGVsZW0uYXBwbHkoY29udGV4dC5jdXJyZW50KCksIFt0aGlzLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtc10pO1xuICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgZHVzdC5sb2coZXJyLCBFUlJPUik7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEVycm9yKGVycik7XG4gICAgICB9XG4gICAgICAvLyBGdW5jdGlvbnMgdGhhdCByZXR1cm4gY2h1bmtzIGFyZSBhc3N1bWVkIHRvIGhhdmUgaGFuZGxlZCB0aGUgY2h1bmsgbWFudWFsbHkuXG4gICAgICAvLyBNYWtlIHRoYXQgY2h1bmsgdGhlIGN1cnJlbnQgb25lIGFuZCBnbyB0byB0aGUgbmV4dCBtZXRob2QgaW4gdGhlIGNoYWluLlxuICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBDaHVuaykge1xuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHVzdC5pc0VtcHR5T2JqZWN0KGJvZGllcykpIHtcbiAgICAgIC8vIE5vIGJvZGllcyB0byByZW5kZXIsIGFuZCB3ZSd2ZSBhbHJlYWR5IGludm9rZWQgYW55IGZ1bmN0aW9uIHRoYXQgd2FzIGF2YWlsYWJsZSBpblxuICAgICAgLy8gaG9wZXMgb2YgcmV0dXJuaW5nIGEgQ2h1bmsuXG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuXG4gICAgaWYgKCFkdXN0LmlzRW1wdHlPYmplY3QocGFyYW1zKSkge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQucHVzaChwYXJhbXMpO1xuICAgIH1cblxuICAgIC8qXG4gICAgRHVzdCdzIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gZW51bWVyYXRlIG92ZXIgdGhlIGFycmF5IGVsZW0sIHBhc3NpbmcgZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5IHRvIHRoZSBibG9jay5cbiAgICBXaGVuIGVsZW0gcmVzb2x2ZXMgdG8gYSB2YWx1ZSBvciBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSwgRHVzdCBzZXRzIHRoZSBjdXJyZW50IGNvbnRleHQgdG8gdGhlIHZhbHVlXG4gICAgYW5kIHJlbmRlcnMgdGhlIGJsb2NrIG9uZSB0aW1lLlxuICAgICovXG4gICAgaWYgKGR1c3QuaXNBcnJheShlbGVtKSkge1xuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgbGVuID0gZWxlbS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgaGVhZCA9IGNvbnRleHQuc3RhY2sgJiYgY29udGV4dC5zdGFjay5oZWFkIHx8IHt9O1xuICAgICAgICAgIGhlYWQuJGxlbiA9IGxlbjtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGhlYWQuJGlkeCA9IGk7XG4gICAgICAgICAgICBjaHVuayA9IGJvZHkoY2h1bmssIGNvbnRleHQucHVzaChlbGVtW2ldLCBpLCBsZW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGVhZC4kaWR4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGhlYWQuJGxlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgICAgIH0gZWxzZSBpZiAoc2tpcCkge1xuICAgICAgICAgIHJldHVybiBza2lwKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkdXN0LmlzVGhlbmFibGUoZWxlbSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmF3YWl0KGVsZW0sIGNvbnRleHQsIGJvZGllcyk7XG4gICAgfSBlbHNlIGlmIChkdXN0LmlzU3RyZWFtYWJsZShlbGVtKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtKGVsZW0sIGNvbnRleHQsIGJvZGllcyk7XG4gICAgfSBlbHNlIGlmIChlbGVtID09PSB0cnVlKSB7XG4gICAgIC8vIHRydWUgaXMgdHJ1dGh5IGJ1dCBkb2VzIG5vdCBjaGFuZ2UgY29udGV4dFxuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkodGhpcywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbGVtIHx8IGVsZW0gPT09IDApIHtcbiAgICAgICAvLyBldmVyeXRoaW5nIHRoYXQgZXZhbHVhdGVzIHRvIHRydWUgYXJlIHRydXRoeSAoIGUuZy4gTm9uLWVtcHR5IHN0cmluZ3MgYW5kIEVtcHR5IG9iamVjdHMgYXJlIHRydXRoeS4gKVxuICAgICAgIC8vIHplcm8gaXMgdHJ1dGh5XG4gICAgICAgLy8gZm9yIGFub255bW91cyBmdW5jdGlvbnMgdGhhdCBkaWQgbm90IHJldHVybnMgYSBjaHVuaywgdHJ1dGhpbmVzcyBpcyBldmFsdWF0ZWQgYmFzZWQgb24gdGhlIHJldHVybiB2YWx1ZVxuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkodGhpcywgY29udGV4dC5wdXNoKGVsZW0pKTtcbiAgICAgIH1cbiAgICAgLy8gbm9uZXhpc3RlbnQsIHNjYWxhciBmYWxzZSB2YWx1ZSwgc2NhbGFyIGVtcHR5IHN0cmluZywgbnVsbCxcbiAgICAgLy8gdW5kZWZpbmVkIGFyZSBhbGwgZmFsc3lcbiAgICB9IGVsc2UgaWYgKHNraXApIHtcbiAgICAgIHJldHVybiBza2lwKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBkdXN0LmxvZygnU2VjdGlvbiB3aXRob3V0IGNvcnJlc3BvbmRpbmcga2V5IGluIHRlbXBsYXRlIGAnICsgY29udGV4dC5nZXRUZW1wbGF0ZU5hbWUoKSArICdgJywgREVCVUcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCBib2RpZXMpIHtcbiAgICB2YXIgYm9keSA9IGJvZGllcy5ibG9jayxcbiAgICAgICAgc2tpcCA9IGJvZGllc1snZWxzZSddO1xuXG4gICAgaWYgKCFkdXN0LmlzRW1wdHkoZWxlbSkpIHtcbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZHVzdC5sb2coJ05vIGJsb2NrIGZvciBleGlzdHMgY2hlY2sgaW4gdGVtcGxhdGUgYCcgKyBjb250ZXh0LmdldFRlbXBsYXRlTmFtZSgpICsgJ2AnLCBERUJVRyk7XG4gICAgfSBlbHNlIGlmIChza2lwKSB7XG4gICAgICByZXR1cm4gc2tpcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLm5vdGV4aXN0cyA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIGJvZGllcykge1xuICAgIHZhciBib2R5ID0gYm9kaWVzLmJsb2NrLFxuICAgICAgICBza2lwID0gYm9kaWVzWydlbHNlJ107XG5cbiAgICBpZiAoZHVzdC5pc0VtcHR5KGVsZW0pKSB7XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICByZXR1cm4gYm9keSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGR1c3QubG9nKCdObyBibG9jayBmb3Igbm90LWV4aXN0cyBjaGVjayBpbiB0ZW1wbGF0ZSBgJyArIGNvbnRleHQuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnYCcsIERFQlVHKTtcbiAgICB9IGVsc2UgaWYgKHNraXApIHtcbiAgICAgIHJldHVybiBza2lwKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUuYmxvY2sgPSBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCBib2RpZXMpIHtcbiAgICB2YXIgYm9keSA9IGVsZW0gfHwgYm9kaWVzLmJsb2NrO1xuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHJldHVybiBib2R5KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDaHVuay5wcm90b3R5cGUucGFydGlhbCA9IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIHBhcnRpYWxDb250ZXh0LCBwYXJhbXMpIHtcbiAgICB2YXIgaGVhZDtcblxuICAgIGlmKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDb21wYXRpYmlsaXR5IGZvciA8IDIuNy4wIHdoZXJlIGBwYXJ0aWFsQ29udGV4dGAgZGlkIG5vdCBleGlzdFxuICAgICAgcGFyYW1zID0gcGFydGlhbENvbnRleHQ7XG4gICAgICBwYXJ0aWFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKCFkdXN0LmlzRW1wdHlPYmplY3QocGFyYW1zKSkge1xuICAgICAgcGFydGlhbENvbnRleHQgPSBwYXJ0aWFsQ29udGV4dC5jbG9uZSgpO1xuICAgICAgaGVhZCA9IHBhcnRpYWxDb250ZXh0LnBvcCgpO1xuICAgICAgcGFydGlhbENvbnRleHQgPSBwYXJ0aWFsQ29udGV4dC5wdXNoKHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHVzaChoZWFkKTtcbiAgICB9XG5cbiAgICBpZiAoZHVzdC5pc1RlbXBsYXRlRm4oZWxlbSkpIHtcbiAgICAgIC8vIFRoZSBldmVudHVhbCByZXN1bHQgb2YgZXZhbHVhdGluZyBgZWxlbWAgaXMgYSBwYXJ0aWFsIG5hbWVcbiAgICAgIC8vIExvYWQgdGhlIHBhcnRpYWwgYWZ0ZXIgZ2V0dGluZyBpdHMgbmFtZSBhbmQgZW5kIHRoZSBhc3luYyBjaHVua1xuICAgICAgcmV0dXJuIHRoaXMuY2FwdHVyZShlbGVtLCBjb250ZXh0LCBmdW5jdGlvbihuYW1lLCBjaHVuaykge1xuICAgICAgICBwYXJ0aWFsQ29udGV4dC50ZW1wbGF0ZU5hbWUgPSBuYW1lO1xuICAgICAgICBsb2FkKG5hbWUsIGNodW5rLCBwYXJ0aWFsQ29udGV4dCkuZW5kKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGlhbENvbnRleHQudGVtcGxhdGVOYW1lID0gZWxlbTtcbiAgICAgIHJldHVybiBsb2FkKGVsZW0sIHRoaXMsIHBhcnRpYWxDb250ZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgQ2h1bmsucHJvdG90eXBlLmhlbHBlciA9IGZ1bmN0aW9uKG5hbWUsIGNvbnRleHQsIGJvZGllcywgcGFyYW1zLCBhdXRvKSB7XG4gICAgdmFyIGNodW5rID0gdGhpcyxcbiAgICAgICAgZmlsdGVycyA9IHBhcmFtcy5maWx0ZXJzLFxuICAgICAgICByZXQ7XG5cbiAgICAvLyBQcmUtMi43LjEgY29tcGF0OiBpZiBhdXRvIGlzIHVuZGVmaW5lZCwgaXQncyBhbiBvbGQgdGVtcGxhdGUuIEF1dG9tYXRpY2FsbHkgZXNjYXBlXG4gICAgaWYgKGF1dG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXV0byA9ICdoJztcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgaW52YWxpZCBoZWxwZXJzLCBzaW1pbGFyIHRvIGludmFsaWQgZmlsdGVyc1xuICAgIGlmKGR1c3QuaGVscGVyc1tuYW1lXSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gZHVzdC5oZWxwZXJzW25hbWVdKGNodW5rLCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBDaHVuaykge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIGZpbHRlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZmlsdGVycyA9IGZpbHRlcnMuc3BsaXQoJ3wnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWR1c3QuaXNFbXB0eU9iamVjdChib2RpZXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGNodW5rLnNlY3Rpb24ocmV0LCBjb250ZXh0LCBib2RpZXMsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGVscGVycyBhY3Qgc2xpZ2h0bHkgZGlmZmVyZW50bHkgZnJvbSBmdW5jdGlvbnMgaW4gY29udGV4dCBpbiB0aGF0IHRoZXkgd2lsbCBhY3QgYXNcbiAgICAgICAgLy8gYSByZWZlcmVuY2UgaWYgdGhleSBhcmUgc2VsZi1jbG9zaW5nIChkdWUgdG8gZ3JhbW1hciBsaW1pdGF0aW9ucylcbiAgICAgICAgLy8gSW4gdGhlIENodW5rLmF3YWl0IGZ1bmN0aW9uIHdlIGNoZWNrIHRvIG1ha2Ugc3VyZSBib2RpZXMgaXMgbnVsbCBiZWZvcmUgYWN0aW5nIGFzIGEgcmVmZXJlbmNlXG4gICAgICAgIHJldHVybiBjaHVuay5yZWZlcmVuY2UocmV0LCBjb250ZXh0LCBhdXRvLCBmaWx0ZXJzKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGR1c3QubG9nKCdFcnJvciBpbiBoZWxwZXIgYCcgKyBuYW1lICsgJ2A6ICcgKyBlcnIubWVzc2FnZSwgRVJST1IpO1xuICAgICAgICByZXR1cm4gY2h1bmsuc2V0RXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHVzdC5sb2coJ0hlbHBlciBgJyArIG5hbWUgKyAnYCBkb2VzIG5vdCBleGlzdCcsIFdBUk4pO1xuICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzZXJ2ZSBhIGNodW5rIHRvIGJlIGV2YWx1YXRlZCBvbmNlIGEgdGhlbmFibGUgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWRcbiAgICogQHBhcmFtIHRoZW5hYmxlIHtUaGVuYWJsZX0gdGhlIHRhcmdldCB0aGVuYWJsZSB0byBhd2FpdFxuICAgKiBAcGFyYW0gY29udGV4dCB7Q29udGV4dH0gY29udGV4dCB0byB1c2UgdG8gcmVuZGVyIHRoZSBkZWZlcnJlZCBjaHVua1xuICAgKiBAcGFyYW0gYm9kaWVzIHtPYmplY3R9IG11c3QgY29udGFpbiBhIFwiYm9keVwiLCBtYXkgY29udGFpbiBhbiBcImVycm9yXCJcbiAgICogQHBhcmFtIGF1dG8ge1N0cmluZ30gYXV0b21hdGljYWxseSBhcHBseSB0aGlzIGZpbHRlciBpZiB0aGUgVGhlbmFibGUgaXMgYSByZWZlcmVuY2VcbiAgICogQHBhcmFtIGZpbHRlcnMge0FycmF5fSBhcHBseSB0aGVzZSBmaWx0ZXJzIGlmIHRoZSBUaGVuYWJsZSBpcyBhIHJlZmVyZW5jZVxuICAgKiBAcmV0dXJuIHtDaHVua31cbiAgICovXG4gIENodW5rLnByb3RvdHlwZS5hd2FpdCA9IGZ1bmN0aW9uKHRoZW5hYmxlLCBjb250ZXh0LCBib2RpZXMsIGF1dG8sIGZpbHRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoYm9kaWVzKSB7XG4gICAgICAgICAgY2h1bmsgPSBjaHVuay5zZWN0aW9uKGRhdGEsIGNvbnRleHQsIGJvZGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWN0dWFsbHkgYSByZWZlcmVuY2UuIFNlbGYtY2xvc2luZyBzZWN0aW9ucyBkb24ndCByZW5kZXJcbiAgICAgICAgICBjaHVuayA9IGNodW5rLnJlZmVyZW5jZShkYXRhLCBjb250ZXh0LCBhdXRvLCBmaWx0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjaHVuay5lbmQoKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICB2YXIgZXJyb3JCb2R5ID0gYm9kaWVzICYmIGJvZGllcy5lcnJvcjtcbiAgICAgICAgaWYoZXJyb3JCb2R5KSB7XG4gICAgICAgICAgY2h1bmsucmVuZGVyKGVycm9yQm9keSwgY29udGV4dC5wdXNoKGVycikpLmVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR1c3QubG9nKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24gaW4gYCcgKyBjb250ZXh0LmdldFRlbXBsYXRlTmFtZSgpICsgJ2AnLCBJTkZPKTtcbiAgICAgICAgICBjaHVuay5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2VydmUgYSBjaHVuayB0byBiZSBldmFsdWF0ZWQgd2l0aCB0aGUgY29udGVudHMgb2YgYSBzdHJlYW1hYmxlLlxuICAgKiBDdXJyZW50bHkgYW4gZXJyb3IgZXZlbnQgd2lsbCBib21iIG91dCB0aGUgc3RyZWFtLiBPbmNlIGFuIGVycm9yXG4gICAqIGlzIHJlY2VpdmVkLCB3ZSBwdXNoIGl0IHRvIGFuIHs6ZXJyb3J9IGJsb2NrIGlmIG9uZSBleGlzdHMsIGFuZCBsb2cgb3RoZXJ3aXNlLFxuICAgKiB0aGVuIHN0b3AgbGlzdGVuaW5nIHRvIHRoZSBzdHJlYW0uXG4gICAqIEBwYXJhbSBzdHJlYW1hYmxlIHtTdHJlYW1hYmxlfSB0aGUgdGFyZ2V0IHN0cmVhbWFibGUgdGhhdCB3aWxsIGVtaXQgZXZlbnRzXG4gICAqIEBwYXJhbSBjb250ZXh0IHtDb250ZXh0fSBjb250ZXh0IHRvIHVzZSB0byByZW5kZXIgZWFjaCB0aHVua1xuICAgKiBAcGFyYW0gYm9kaWVzIHtPYmplY3R9IG11c3QgY29udGFpbiBhIFwiYm9keVwiLCBtYXkgY29udGFpbiBhbiBcImVycm9yXCJcbiAgICogQHJldHVybiB7Q2h1bmt9XG4gICAqL1xuICBDaHVuay5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtLCBjb250ZXh0LCBib2RpZXMsIGF1dG8sIGZpbHRlcnMpIHtcbiAgICB2YXIgYm9keSA9IGJvZGllcyAmJiBib2RpZXMuYmxvY2ssXG4gICAgICAgIGVycm9yQm9keSA9IGJvZGllcyAmJiBib2RpZXMuZXJyb3I7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICB2YXIgZW5kZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbVxuICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiBkYXRhKHRodW5rKSB7XG4gICAgICAgICAgaWYoZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoYm9keSkge1xuICAgICAgICAgICAgLy8gRm9yayBhIG5ldyBjaHVuayBvdXQgb2YgdGhlIGJsb2Nrc3RyZWFtIHNvIHRoYXQgd2UgY2FuIGZsdXNoIGl0IGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsubWFwKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNodW5rLnJlbmRlcihib2R5LCBjb250ZXh0LnB1c2godGh1bmspKS5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZighYm9kaWVzKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGFjdHVhbGx5IGEgcmVmZXJlbmNlLCBkb24ndCBmb3JrLCBqdXN0IHdyaXRlIGludG8gdGhlIG1hc3RlciBhc3luYyBjaHVua1xuICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5yZWZlcmVuY2UodGh1bmssIGNvbnRleHQsIGF1dG8sIGZpbHRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgICAgIGlmKGVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGVycm9yQm9keSkge1xuICAgICAgICAgICAgY2h1bmsucmVuZGVyKGVycm9yQm9keSwgY29udGV4dC5wdXNoKGVycikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdXN0LmxvZygnVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBgJyArIGNvbnRleHQuZ2V0VGVtcGxhdGVOYW1lKCkgKyAnYCcsIElORk8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZighZW5kZWQpIHtcbiAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNodW5rLmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAgICAgaWYoIWVuZGVkKSB7XG4gICAgICAgICAgICBlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBjaHVuay5lbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5jYXB0dXJlID0gZnVuY3Rpb24oYm9keSwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIHZhciBzdHViID0gbmV3IFN0dWIoZnVuY3Rpb24oZXJyLCBvdXQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNodW5rLnNldEVycm9yKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sob3V0LCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYm9keShzdHViLmhlYWQsIGNvbnRleHQpLmVuZCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIENodW5rLnByb3RvdHlwZS5zZXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnI7XG4gICAgdGhpcy5yb290LmZsdXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQ2h1bmsgYWxpYXNlc1xuICBmb3IodmFyIGYgaW4gQ2h1bmsucHJvdG90eXBlKSB7XG4gICAgaWYoZHVzdC5fYWxpYXNlc1tmXSkge1xuICAgICAgQ2h1bmsucHJvdG90eXBlW2R1c3QuX2FsaWFzZXNbZl1dID0gQ2h1bmsucHJvdG90eXBlW2ZdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFRhcChoZWFkLCB0YWlsKSB7XG4gICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICB9XG5cbiAgVGFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24odGFwKSB7XG4gICAgcmV0dXJuIG5ldyBUYXAodGFwLCB0aGlzKTtcbiAgfTtcblxuICBUYXAucHJvdG90eXBlLmdvID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdGFwID0gdGhpcztcblxuICAgIHdoaWxlKHRhcCkge1xuICAgICAgdmFsdWUgPSB0YXAuaGVhZCh2YWx1ZSk7XG4gICAgICB0YXAgPSB0YXAudGFpbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHZhciBIQ0hBUlMgPSAvWyY8PlwiJ10vLFxuICAgICAgQU1QICAgID0gLyYvZyxcbiAgICAgIExUICAgICA9IC88L2csXG4gICAgICBHVCAgICAgPSAvPi9nLFxuICAgICAgUVVPVCAgID0gL1xcXCIvZyxcbiAgICAgIFNRVU9UICA9IC9cXCcvZztcblxuICBkdXN0LmVzY2FwZUh0bWwgPSBmdW5jdGlvbihzKSB7XG4gICAgaWYgKHR5cGVvZiBzID09PSBcInN0cmluZ1wiIHx8IChzICYmIHR5cGVvZiBzLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICBpZiAodHlwZW9mIHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcyA9IHMudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICghSENIQVJTLnRlc3QocykpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcy5yZXBsYWNlKEFNUCwnJmFtcDsnKS5yZXBsYWNlKExULCcmbHQ7JykucmVwbGFjZShHVCwnJmd0OycpLnJlcGxhY2UoUVVPVCwnJnF1b3Q7JykucmVwbGFjZShTUVVPVCwgJyYjMzk7Jyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuXG4gIHZhciBCUyA9IC9cXFxcL2csXG4gICAgICBGUyA9IC9cXC8vZyxcbiAgICAgIENSID0gL1xcci9nLFxuICAgICAgTFMgPSAvXFx1MjAyOC9nLFxuICAgICAgUFMgPSAvXFx1MjAyOS9nLFxuICAgICAgTkwgPSAvXFxuL2csXG4gICAgICBMRiA9IC9cXGYvZyxcbiAgICAgIFNRID0gLycvZyxcbiAgICAgIERRID0gL1wiL2csXG4gICAgICBUQiA9IC9cXHQvZztcblxuICBkdXN0LmVzY2FwZUpzID0gZnVuY3Rpb24ocykge1xuICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzXG4gICAgICAgIC5yZXBsYWNlKEJTLCAnXFxcXFxcXFwnKVxuICAgICAgICAucmVwbGFjZShGUywgJ1xcXFwvJylcbiAgICAgICAgLnJlcGxhY2UoRFEsICdcXFxcXCInKVxuICAgICAgICAucmVwbGFjZShTUSwgJ1xcXFxcXCcnKVxuICAgICAgICAucmVwbGFjZShDUiwgJ1xcXFxyJylcbiAgICAgICAgLnJlcGxhY2UoTFMsICdcXFxcdTIwMjgnKVxuICAgICAgICAucmVwbGFjZShQUywgJ1xcXFx1MjAyOScpXG4gICAgICAgIC5yZXBsYWNlKE5MLCAnXFxcXG4nKVxuICAgICAgICAucmVwbGFjZShMRiwgJ1xcXFxmJylcbiAgICAgICAgLnJlcGxhY2UoVEIsICdcXFxcdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfTtcblxuICBkdXN0LmVzY2FwZUpTT04gPSBmdW5jdGlvbihvKSB7XG4gICAgaWYgKCFKU09OKSB7XG4gICAgICBkdXN0LmxvZygnSlNPTiBpcyB1bmRlZmluZWQ7IGNvdWxkIG5vdCBlc2NhcGUgYCcgKyBvICsgJ2AnLCBXQVJOKTtcbiAgICAgIHJldHVybiBvO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobylcbiAgICAgICAgLnJlcGxhY2UoTFMsICdcXFxcdTIwMjgnKVxuICAgICAgICAucmVwbGFjZShQUywgJ1xcXFx1MjAyOScpXG4gICAgICAgIC5yZXBsYWNlKExULCAnXFxcXHUwMDNjJyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkdXN0O1xuXG59KSk7XG4iLCIvKipcbiogQHByZXNlcnZlIEhUTUw1IFNoaXYgMy43LjMgfCBAYWZhcmthcyBAamRhbHRvbiBAam9uX25lYWwgQHJlbSB8IE1JVC9HUEwyIExpY2Vuc2VkXG4qL1xuOyhmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50KSB7XG4vKmpzaGludCBldmlsOnRydWUgKi9cbiAgLyoqIHZlcnNpb24gKi9cbiAgdmFyIHZlcnNpb24gPSAnMy43LjMtcHJlJztcblxuICAvKiogUHJlc2V0IG9wdGlvbnMgKi9cbiAgdmFyIG9wdGlvbnMgPSB3aW5kb3cuaHRtbDUgfHwge307XG5cbiAgLyoqIFVzZWQgdG8gc2tpcCBwcm9ibGVtIGVsZW1lbnRzICovXG4gIHZhciByZVNraXAgPSAvXjx8Xig/OmJ1dHRvbnxtYXB8c2VsZWN0fHRleHRhcmVhfG9iamVjdHxpZnJhbWV8b3B0aW9ufG9wdGdyb3VwKSQvaTtcblxuICAvKiogTm90IGFsbCBlbGVtZW50cyBjYW4gYmUgY2xvbmVkIGluIElFICoqL1xuICB2YXIgc2F2ZUNsb25lcyA9IC9eKD86YXxifGNvZGV8ZGl2fGZpZWxkc2V0fGgxfGgyfGgzfGg0fGg1fGg2fGl8bGFiZWx8bGl8b2x8cHxxfHNwYW58c3Ryb25nfHN0eWxlfHRhYmxlfHRib2R5fHRkfHRofHRyfHVsKSQvaTtcblxuICAvKiogRGV0ZWN0IHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgZGVmYXVsdCBodG1sNSBzdHlsZXMgKi9cbiAgdmFyIHN1cHBvcnRzSHRtbDVTdHlsZXM7XG5cbiAgLyoqIE5hbWUgb2YgdGhlIGV4cGFuZG8sIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBkb2N1bWVudHMgb3IgdG8gcmUtc2hpdiBvbmUgZG9jdW1lbnQgKi9cbiAgdmFyIGV4cGFuZG8gPSAnX2h0bWw1c2hpdic7XG5cbiAgLyoqIFRoZSBpZCBmb3IgdGhlIHRoZSBkb2N1bWVudHMgZXhwYW5kbyAqL1xuICB2YXIgZXhwYW5JRCA9IDA7XG5cbiAgLyoqIENhY2hlZCBkYXRhIGZvciBlYWNoIGRvY3VtZW50ICovXG4gIHZhciBleHBhbmRvRGF0YSA9IHt9O1xuXG4gIC8qKiBEZXRlY3Qgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB1bmtub3duIGVsZW1lbnRzICovXG4gIHZhciBzdXBwb3J0c1Vua25vd25FbGVtZW50cztcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGEuaW5uZXJIVE1MID0gJzx4eXo+PC94eXo+JztcbiAgICAgICAgLy9pZiB0aGUgaGlkZGVuIHByb3BlcnR5IGlzIGltcGxlbWVudGVkIHdlIGNhbiBhc3N1bWUsIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYmFzaWMgSFRNTDUgU3R5bGVzXG4gICAgICAgIHN1cHBvcnRzSHRtbDVTdHlsZXMgPSAoJ2hpZGRlbicgaW4gYSk7XG5cbiAgICAgICAgc3VwcG9ydHNVbmtub3duRWxlbWVudHMgPSBhLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgfHwgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIGFzc2lnbiBhIGZhbHNlIHBvc2l0aXZlIGlmIHVuYWJsZSB0byBzaGl2XG4gICAgICAgICAgKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpKCdhJyk7XG4gICAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNsb25lTm9kZSA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWcuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGZyYWcuY3JlYXRlRWxlbWVudCA9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0oKSk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBhc3NpZ24gYSBmYWxzZSBwb3NpdGl2ZSBpZiBkZXRlY3Rpb24gZmFpbHMgPT4gdW5hYmxlIHRvIHNoaXZcbiAgICAgIHN1cHBvcnRzSHRtbDVTdHlsZXMgPSB0cnVlO1xuICAgICAgc3VwcG9ydHNVbmtub3duRWxlbWVudHMgPSB0cnVlO1xuICAgIH1cblxuICB9KCkpO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3R5bGUgc2hlZXQgd2l0aCB0aGUgZ2l2ZW4gQ1NTIHRleHQgYW5kIGFkZHMgaXQgdG8gdGhlIGRvY3VtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNzc1RleHQgVGhlIENTUyB0ZXh0LlxuICAgKiBAcmV0dXJucyB7U3R5bGVTaGVldH0gVGhlIHN0eWxlIGVsZW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRTdHlsZVNoZWV0KG93bmVyRG9jdW1lbnQsIGNzc1RleHQpIHtcbiAgICB2YXIgcCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpLFxuICAgICAgICBwYXJlbnQgPSBvd25lckRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0gfHwgb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICBwLmlubmVySFRNTCA9ICd4PHN0eWxlPicgKyBjc3NUZXh0ICsgJzwvc3R5bGU+JztcbiAgICByZXR1cm4gcGFyZW50Lmluc2VydEJlZm9yZShwLmxhc3RDaGlsZCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGBodG1sNS5lbGVtZW50c2AgYXMgYW4gYXJyYXkuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2Ygc2hpdmVkIGVsZW1lbnQgbm9kZSBuYW1lcy5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRzKCkge1xuICAgIHZhciBlbGVtZW50cyA9IGh0bWw1LmVsZW1lbnRzO1xuICAgIHJldHVybiB0eXBlb2YgZWxlbWVudHMgPT0gJ3N0cmluZycgPyBlbGVtZW50cy5zcGxpdCgnICcpIDogZWxlbWVudHM7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kcyB0aGUgYnVpbHQtaW4gbGlzdCBvZiBodG1sNSBlbGVtZW50c1xuICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG5ld0VsZW1lbnRzIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb3IgYXJyYXkgb2YgbmV3IGVsZW1lbnQgbmFtZXMgdG8gc2hpdlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRWxlbWVudHMobmV3RWxlbWVudHMsIG93bmVyRG9jdW1lbnQpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBodG1sNS5lbGVtZW50cztcbiAgICBpZih0eXBlb2YgZWxlbWVudHMgIT0gJ3N0cmluZycpe1xuICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5qb2luKCcgJyk7XG4gICAgfVxuICAgIGlmKHR5cGVvZiBuZXdFbGVtZW50cyAhPSAnc3RyaW5nJyl7XG4gICAgICBuZXdFbGVtZW50cyA9IG5ld0VsZW1lbnRzLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgaHRtbDUuZWxlbWVudHMgPSBlbGVtZW50cyArJyAnKyBuZXdFbGVtZW50cztcbiAgICBzaGl2RG9jdW1lbnQob3duZXJEb2N1bWVudCk7XG4gIH1cblxuICAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBvZiBkYXRhLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCkge1xuICAgIHZhciBkYXRhID0gZXhwYW5kb0RhdGFbb3duZXJEb2N1bWVudFtleHBhbmRvXV07XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgZXhwYW5JRCsrO1xuICAgICAgICBvd25lckRvY3VtZW50W2V4cGFuZG9dID0gZXhwYW5JRDtcbiAgICAgICAgZXhwYW5kb0RhdGFbZXhwYW5JRF0gPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgc2hpdmVkIGVsZW1lbnQgZm9yIHRoZSBnaXZlbiBub2RlTmFtZSBhbmQgZG9jdW1lbnRcbiAgICogQG1lbWJlck9mIGh0bWw1XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZSBuYW1lIG9mIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGNvbnRleHQgZG9jdW1lbnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzaGl2ZWQgZWxlbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobm9kZU5hbWUsIG93bmVyRG9jdW1lbnQsIGRhdGEpe1xuICAgIGlmICghb3duZXJEb2N1bWVudCkge1xuICAgICAgICBvd25lckRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIGlmKHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzKXtcbiAgICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgfVxuICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCk7XG4gICAgfVxuICAgIHZhciBub2RlO1xuXG4gICAgaWYgKGRhdGEuY2FjaGVbbm9kZU5hbWVdKSB7XG4gICAgICAgIG5vZGUgPSBkYXRhLmNhY2hlW25vZGVOYW1lXS5jbG9uZU5vZGUoKTtcbiAgICB9IGVsc2UgaWYgKHNhdmVDbG9uZXMudGVzdChub2RlTmFtZSkpIHtcbiAgICAgICAgbm9kZSA9IChkYXRhLmNhY2hlW25vZGVOYW1lXSA9IGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSkpLmNsb25lTm9kZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBkYXRhLmNyZWF0ZUVsZW0obm9kZU5hbWUpO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIGFkZGluZyBzb21lIGVsZW1lbnRzIHRvIGZyYWdtZW50cyBpbiBJRSA8IDkgYmVjYXVzZVxuICAgIC8vICogQXR0cmlidXRlcyBsaWtlIGBuYW1lYCBvciBgdHlwZWAgY2Fubm90IGJlIHNldC9jaGFuZ2VkIG9uY2UgYW4gZWxlbWVudFxuICAgIC8vICAgaXMgaW5zZXJ0ZWQgaW50byBhIGRvY3VtZW50L2ZyYWdtZW50XG4gICAgLy8gKiBMaW5rIGVsZW1lbnRzIHdpdGggYHNyY2AgYXR0cmlidXRlcyB0aGF0IGFyZSBpbmFjY2Vzc2libGUsIGFzIHdpdGhcbiAgICAvLyAgIGEgNDAzIHJlc3BvbnNlLCB3aWxsIGNhdXNlIHRoZSB0YWIvd2luZG93IHRvIGNyYXNoXG4gICAgLy8gKiBTY3JpcHQgZWxlbWVudHMgYXBwZW5kZWQgdG8gZnJhZ21lbnRzIHdpbGwgZXhlY3V0ZSB3aGVuIHRoZWlyIGBzcmNgXG4gICAgLy8gICBvciBgdGV4dGAgcHJvcGVydHkgaXMgc2V0XG4gICAgcmV0dXJuIG5vZGUuY2FuSGF2ZUNoaWxkcmVuICYmICFyZVNraXAudGVzdChub2RlTmFtZSkgJiYgIW5vZGUudGFnVXJuID8gZGF0YS5mcmFnLmFwcGVuZENoaWxkKG5vZGUpIDogbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgc2hpdmVkIERvY3VtZW50RnJhZ21lbnQgZm9yIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgY29udGV4dCBkb2N1bWVudC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHNoaXZlZCBEb2N1bWVudEZyYWdtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRGcmFnbWVudChvd25lckRvY3VtZW50LCBkYXRhKXtcbiAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgb3duZXJEb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH1cbiAgICBpZihzdXBwb3J0c1Vua25vd25FbGVtZW50cyl7XG4gICAgICAgIHJldHVybiBvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgZGF0YSA9IGRhdGEgfHwgZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCk7XG4gICAgdmFyIGNsb25lID0gZGF0YS5mcmFnLmNsb25lTm9kZSgpLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgZWxlbXMgPSBnZXRFbGVtZW50cygpLFxuICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xuICAgIGZvcig7aTxsO2krKyl7XG4gICAgICAgIGNsb25lLmNyZWF0ZUVsZW1lbnQoZWxlbXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICAvKipcbiAgICogU2hpdnMgdGhlIGBjcmVhdGVFbGVtZW50YCBhbmQgYGNyZWF0ZURvY3VtZW50RnJhZ21lbnRgIG1ldGhvZHMgb2YgdGhlIGRvY3VtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0RvY3VtZW50fERvY3VtZW50RnJhZ21lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBvZiB0aGUgZG9jdW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBzaGl2TWV0aG9kcyhvd25lckRvY3VtZW50LCBkYXRhKSB7XG4gICAgaWYgKCFkYXRhLmNhY2hlKSB7XG4gICAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICAgICAgZGF0YS5jcmVhdGVFbGVtID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50O1xuICAgICAgICBkYXRhLmNyZWF0ZUZyYWcgPSBvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQ7XG4gICAgICAgIGRhdGEuZnJhZyA9IGRhdGEuY3JlYXRlRnJhZygpO1xuICAgIH1cblxuXG4gICAgb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24obm9kZU5hbWUpIHtcbiAgICAgIC8vYWJvcnQgc2hpdlxuICAgICAgaWYgKCFodG1sNS5zaGl2TWV0aG9kcykge1xuICAgICAgICAgIHJldHVybiBkYXRhLmNyZWF0ZUVsZW0obm9kZU5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQobm9kZU5hbWUsIG93bmVyRG9jdW1lbnQsIGRhdGEpO1xuICAgIH07XG5cbiAgICBvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBGdW5jdGlvbignaCxmJywgJ3JldHVybiBmdW5jdGlvbigpeycgK1xuICAgICAgJ3ZhciBuPWYuY2xvbmVOb2RlKCksYz1uLmNyZWF0ZUVsZW1lbnQ7JyArXG4gICAgICAnaC5zaGl2TWV0aG9kcyYmKCcgK1xuICAgICAgICAvLyB1bnJvbGwgdGhlIGBjcmVhdGVFbGVtZW50YCBjYWxsc1xuICAgICAgICBnZXRFbGVtZW50cygpLmpvaW4oKS5yZXBsYWNlKC9bXFx3XFwtOl0rL2csIGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgICAgICAgZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICAgICAgICBkYXRhLmZyYWcuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgICAgcmV0dXJuICdjKFwiJyArIG5vZGVOYW1lICsgJ1wiKSc7XG4gICAgICAgIH0pICtcbiAgICAgICcpO3JldHVybiBufSdcbiAgICApKGh0bWw1LCBkYXRhLmZyYWcpO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFNoaXZzIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICogQG1lbWJlck9mIGh0bWw1XG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIHNoaXYuXG4gICAqIEByZXR1cm5zIHtEb2N1bWVudH0gVGhlIHNoaXZlZCBkb2N1bWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIHNoaXZEb2N1bWVudChvd25lckRvY3VtZW50KSB7XG4gICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBnZXRFeHBhbmRvRGF0YShvd25lckRvY3VtZW50KTtcblxuICAgIGlmIChodG1sNS5zaGl2Q1NTICYmICFzdXBwb3J0c0h0bWw1U3R5bGVzICYmICFkYXRhLmhhc0NTUykge1xuICAgICAgZGF0YS5oYXNDU1MgPSAhIWFkZFN0eWxlU2hlZXQob3duZXJEb2N1bWVudCxcbiAgICAgICAgLy8gY29ycmVjdHMgYmxvY2sgZGlzcGxheSBub3QgZGVmaW5lZCBpbiBJRTYvNy84LzlcbiAgICAgICAgJ2FydGljbGUsYXNpZGUsZGlhbG9nLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaGdyb3VwLG1haW4sbmF2LHNlY3Rpb257ZGlzcGxheTpibG9ja30nICtcbiAgICAgICAgLy8gYWRkcyBzdHlsaW5nIG5vdCBwcmVzZW50IGluIElFNi83LzgvOVxuICAgICAgICAnbWFya3tiYWNrZ3JvdW5kOiNGRjA7Y29sb3I6IzAwMH0nICtcbiAgICAgICAgLy8gaGlkZXMgbm9uLXJlbmRlcmVkIGVsZW1lbnRzXG4gICAgICAgICd0ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFzdXBwb3J0c1Vua25vd25FbGVtZW50cykge1xuICAgICAgc2hpdk1ldGhvZHMob3duZXJEb2N1bWVudCwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBvd25lckRvY3VtZW50O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBgaHRtbDVgIG9iamVjdCBpcyBleHBvc2VkIHNvIHRoYXQgbW9yZSBlbGVtZW50cyBjYW4gYmUgc2hpdmVkIGFuZFxuICAgKiBleGlzdGluZyBzaGl2aW5nIGNhbiBiZSBkZXRlY3RlZCBvbiBpZnJhbWVzLlxuICAgKiBAdHlwZSBPYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogLy8gb3B0aW9ucyBjYW4gYmUgY2hhbmdlZCBiZWZvcmUgdGhlIHNjcmlwdCBpcyBpbmNsdWRlZFxuICAgKiBodG1sNSA9IHsgJ2VsZW1lbnRzJzogJ21hcmsgc2VjdGlvbicsICdzaGl2Q1NTJzogZmFsc2UsICdzaGl2TWV0aG9kcyc6IGZhbHNlIH07XG4gICAqL1xuICB2YXIgaHRtbDUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIG5vZGUgbmFtZXMgb2YgdGhlIGVsZW1lbnRzIHRvIHNoaXYuXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHR5cGUgQXJyYXl8U3RyaW5nXG4gICAgICovXG4gICAgJ2VsZW1lbnRzJzogb3B0aW9ucy5lbGVtZW50cyB8fCAnYWJiciBhcnRpY2xlIGFzaWRlIGF1ZGlvIGJkaSBjYW52YXMgZGF0YSBkYXRhbGlzdCBkZXRhaWxzIGRpYWxvZyBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgaGVhZGVyIGhncm91cCBtYWluIG1hcmsgbWV0ZXIgbmF2IG91dHB1dCBwaWN0dXJlIHByb2dyZXNzIHNlY3Rpb24gc3VtbWFyeSB0ZW1wbGF0ZSB0aW1lIHZpZGVvJyxcblxuICAgIC8qKlxuICAgICAqIGN1cnJlbnQgdmVyc2lvbiBvZiBodG1sNXNoaXZcbiAgICAgKi9cbiAgICAndmVyc2lvbic6IHZlcnNpb24sXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgSFRNTDUgc3R5bGUgc2hlZXQgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICAnc2hpdkNTUyc6IChvcHRpb25zLnNoaXZDU1MgIT09IGZhbHNlKSxcblxuICAgIC8qKlxuICAgICAqIElzIGVxdWFsIHRvIHRydWUgaWYgYSBicm93c2VyIHN1cHBvcnRzIGNyZWF0aW5nIHVua25vd24vSFRNTDUgZWxlbWVudHNcbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgJ3N1cHBvcnRzVW5rbm93bkVsZW1lbnRzJzogc3VwcG9ydHNVbmtub3duRWxlbWVudHMsXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZG9jdW1lbnQncyBgY3JlYXRlRWxlbWVudGAgYW5kIGBjcmVhdGVEb2N1bWVudEZyYWdtZW50YFxuICAgICAqIG1ldGhvZHMgc2hvdWxkIGJlIG92ZXJ3cml0dGVuLlxuICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICAnc2hpdk1ldGhvZHMnOiAob3B0aW9ucy5zaGl2TWV0aG9kcyAhPT0gZmFsc2UpLFxuXG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgdG8gZGVzY3JpYmUgdGhlIHR5cGUgb2YgYGh0bWw1YCBvYmplY3QgKFwiZGVmYXVsdFwiIG9yIFwiZGVmYXVsdCBwcmludFwiKS5cbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICAndHlwZSc6ICdkZWZhdWx0JyxcblxuICAgIC8vIHNoaXZzIHRoZSBkb2N1bWVudCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBgaHRtbDVgIG9iamVjdCBvcHRpb25zXG4gICAgJ3NoaXZEb2N1bWVudCc6IHNoaXZEb2N1bWVudCxcblxuICAgIC8vY3JlYXRlcyBhIHNoaXZlZCBlbGVtZW50XG4gICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblxuICAgIC8vY3JlYXRlcyBhIHNoaXZlZCBkb2N1bWVudEZyYWdtZW50XG4gICAgY3JlYXRlRG9jdW1lbnRGcmFnbWVudDogY3JlYXRlRG9jdW1lbnRGcmFnbWVudCxcblxuICAgIC8vZXh0ZW5kcyBsaXN0IG9mIGVsZW1lbnRzXG4gICAgYWRkRWxlbWVudHM6IGFkZEVsZW1lbnRzXG4gIH07XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIGh0bWw1XG4gIHdpbmRvdy5odG1sNSA9IGh0bWw1O1xuXG4gIC8vIHNoaXYgdGhlIGRvY3VtZW50XG4gIHNoaXZEb2N1bWVudChkb2N1bWVudCk7XG5cbiAgaWYodHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyl7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBodG1sNTtcbiAgfVxuXG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBkb2N1bWVudCkpO1xuIiwiXHJcbnZhciBMID0ge1xyXG5cdHZlcnNpb246ICcxLjAuMSdcclxufTtcclxuXHJcbmZ1bmN0aW9uIGV4cG9zZSgpIHtcclxuXHR2YXIgb2xkTCA9IHdpbmRvdy5MO1xyXG5cclxuXHRMLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR3aW5kb3cuTCA9IG9sZEw7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cclxuXHR3aW5kb3cuTCA9IEw7XHJcbn1cclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGZvciBOb2RlIG1vZHVsZSBwYXR0ZXJuIGxvYWRlcnMsIGluY2x1ZGluZyBCcm93c2VyaWZ5XHJcbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBMO1xyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYW4gQU1EIG1vZHVsZVxyXG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdGRlZmluZShMKTtcclxufVxyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYSBnbG9iYWwgTCB2YXJpYWJsZSwgc2F2aW5nIHRoZSBvcmlnaW5hbCBMIHRvIHJlc3RvcmUgbGF0ZXIgaWYgbmVlZGVkXHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG5cdGV4cG9zZSgpO1xyXG59XHJcblxuLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbkwuVXRpbCA9IHtcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGV4dGVuZChkZXN0OiBPYmplY3QsIHNyYz86IE9iamVjdCk6IE9iamVjdFxyXG5cdC8vIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgYHNyY2Agb2JqZWN0IChvciBtdWx0aXBsZSBvYmplY3RzKSBpbnRvIGBkZXN0YCBvYmplY3QgYW5kIHJldHVybnMgdGhlIGxhdHRlci4gSGFzIGFuIGBMLmV4dGVuZGAgc2hvcnRjdXQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAoZGVzdCkge1xyXG5cdFx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRcdGZvciAoaiA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xyXG5cdFx0XHRzcmMgPSBhcmd1bWVudHNbal07XHJcblx0XHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGVzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY3JlYXRlKHByb3RvOiBPYmplY3QsIHByb3BlcnRpZXM/OiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuXHRjcmVhdGU6IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHRcdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEYoKTtcclxuXHRcdH07XHJcblx0fSkoKSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGJpbmQoZm46IEZ1bmN0aW9uLCDigKYpOiBGdW5jdGlvblxyXG5cdC8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuXHQvLyBIYXMgYSBgTC5iaW5kKClgIHNob3J0Y3V0LlxyXG5cdGJpbmQ6IGZ1bmN0aW9uIChmbiwgb2JqKSB7XHJcblx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG5cdFx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5sZW5ndGggPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHN0YW1wKG9iajogT2JqZWN0KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWdpbmcgaXQgb25lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdC5cclxuXHRzdGFtcDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0b2JqLl9sZWFmbGV0X2lkID0gb2JqLl9sZWFmbGV0X2lkIHx8ICsrTC5VdGlsLmxhc3RJZDtcclxuXHRcdHJldHVybiBvYmouX2xlYWZsZXRfaWQ7XHJcblx0XHQvKmVzbGludC1lbmFibGUgKi9cclxuXHR9LFxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGFzdElkOiBOdW1iZXJcclxuXHQvLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5cdGxhc3RJZDogMCxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRocm90dGxlKGZuOiBGdW5jdGlvbiwgdGltZTogTnVtYmVyLCBjb250ZXh0OiBPYmplY3QpOiBGdW5jdGlvblxyXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG5cdC8vIChzbyB0aGF0IHRoZSBgdGhpc2Aga2V5d29yZCByZWZlcnMgdG8gYGNvbnRleHRgIGluc2lkZSBgZm5gJ3MgY29kZSkuIFRoZSBmdW5jdGlvblxyXG5cdC8vIGBmbmAgd2lsbCBiZSBjYWxsZWQgbm8gbW9yZSB0aGFuIG9uZSB0aW1lIHBlciBnaXZlbiBhbW91bnQgb2YgYHRpbWVgLiBUaGUgYXJndW1lbnRzXHJcblx0Ly8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG5cdC8vIGZ1bmN0aW9uLCBmb2xsb3dlZCBieSBhbnkgYXJndW1lbnRzIHBhc3NlZCB3aGVuIGludm9raW5nIHRoZSBib3VuZCBmdW5jdGlvbi5cclxuXHQvLyBIYXMgYW4gYEwuYmluZGAgc2hvcnRjdXQuXHJcblx0dGhyb3R0bGU6IGZ1bmN0aW9uIChmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XHJcblxyXG5cdFx0bGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRcdGxvY2sgPSBmYWxzZTtcclxuXHRcdFx0aWYgKGFyZ3MpIHtcclxuXHRcdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdFx0YXJncyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKGxvY2spIHtcclxuXHRcdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KGxhdGVyLCB0aW1lKTtcclxuXHRcdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gd3JhcHBlckZuO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB3cmFwTnVtKG51bTogTnVtYmVyLCByYW5nZTogTnVtYmVyW10sIGluY2x1ZGVNYXg/OiBCb29sZWFuKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbnVtYmVyIGBudW1gIG1vZHVsbyBgcmFuZ2VgIGluIHN1Y2ggYSB3YXkgc28gaXQgbGllcyB3aXRoaW5cclxuXHQvLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcblx0Ly8gYHJhbmdlWzFdYCB1bmxlc3MgYGluY2x1ZGVNYXhgIGlzIHNldCB0byBgdHJ1ZWAuXHJcblx0d3JhcE51bTogZnVuY3Rpb24gKHgsIHJhbmdlLCBpbmNsdWRlTWF4KSB7XHJcblx0XHR2YXIgbWF4ID0gcmFuZ2VbMV0sXHJcblx0XHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0XHQgICAgZCA9IG1heCAtIG1pbjtcclxuXHRcdHJldHVybiB4ID09PSBtYXggJiYgaW5jbHVkZU1heCA/IHggOiAoKHggLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxyXG5cdGZhbHNlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZm9ybWF0TnVtKG51bTogTnVtYmVyLCBkaWdpdHM/OiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgcm91bmRlZCB0byBgZGlnaXRzYCBkZWNpbWFscywgb3IgdG8gNSBkZWNpbWFscyBieSBkZWZhdWx0LlxyXG5cdGZvcm1hdE51bTogZnVuY3Rpb24gKG51bSwgZGlnaXRzKSB7XHJcblx0XHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIGRpZ2l0cyB8fCA1KTtcclxuXHRcdHJldHVybiBNYXRoLnJvdW5kKG51bSAqIHBvdykgLyBwb3c7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuXHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbU3RyaW5nLnByb3RvdHlwZS50cmltXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSlcclxuXHR0cmltOiBmdW5jdGlvbiAoc3RyKSB7XHJcblx0XHRyZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcblx0Ly8gVHJpbXMgYW5kIHNwbGl0cyB0aGUgc3RyaW5nIG9uIHdoaXRlc3BhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHBhcnRzLlxyXG5cdHNwbGl0V29yZHM6IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRcdHJldHVybiBMLlV0aWwudHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqOiBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCk6IE9iamVjdFxyXG5cdC8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eSgnb3B0aW9ucycpKSB7XHJcblx0XHRcdG9iai5vcHRpb25zID0gb2JqLm9wdGlvbnMgPyBMLlV0aWwuY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdFx0fVxyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBvYmoub3B0aW9ucztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcblx0Ly8gQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBwYXJhbWV0ZXIgVVJMIHN0cmluZywgZS5nLiBge2E6IFwiZm9vXCIsIGI6IFwiYmFyXCJ9YFxyXG5cdC8vIHRyYW5zbGF0ZXMgdG8gYCc/YT1mb28mYj1iYXInYC4gSWYgYGV4aXN0aW5nVXJsYCBpcyBzZXQsIHRoZSBwYXJhbWV0ZXJzIHdpbGxcclxuXHQvLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG5cdC8vIGJlIHVwcGVyY2FzZWQgKGUuZy4gYCc/QT1mb28mQj1iYXInYClcclxuXHRnZXRQYXJhbVN0cmluZzogZnVuY3Rpb24gKG9iaiwgZXhpc3RpbmdVcmwsIHVwcGVyY2FzZSkge1xyXG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdFx0cGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHVwcGVyY2FzZSA/IGkudG9VcHBlckNhc2UoKSA6IGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBTaW1wbGUgdGVtcGxhdGluZyBmYWNpbGl0eSwgYWNjZXB0cyBhIHRlbXBsYXRlIHN0cmluZyBvZiB0aGUgZm9ybSBgJ0hlbGxvIHthfSwge2J9J2BcclxuXHQvLyBhbmQgYSBkYXRhIG9iamVjdCBsaWtlIGB7YTogJ2ZvbycsIGI6ICdiYXInfWAsIHJldHVybnMgZXZhbHVhdGVkIHN0cmluZ1xyXG5cdC8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG5cdC8vIGRhdGEgdmFsdWVzIOKAlCB0aGV5IHdpbGwgYmUgZXZhbHVhdGVkIHBhc3NpbmcgYGRhdGFgIGFzIGFuIGFyZ3VtZW50LlxyXG5cdHRlbXBsYXRlOiBmdW5jdGlvbiAoc3RyLCBkYXRhKSB7XHJcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoTC5VdGlsLnRlbXBsYXRlUmUsIGZ1bmN0aW9uIChzdHIsIGtleSkge1xyXG5cdFx0XHR2YXIgdmFsdWUgPSBkYXRhW2tleV07XHJcblxyXG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignTm8gdmFsdWUgcHJvdmlkZWQgZm9yIHZhcmlhYmxlICcgKyBzdHIpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHRlbXBsYXRlUmU6IC9cXHsgKihbXFx3X1xcLV0rKSAqXFx9L2csXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBpc0FycmF5KG9iaik6IEJvb2xlYW5cclxuXHQvLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkuaXNBcnJheV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheSlcclxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG5cdC8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5wcm90b3R5cGUuaW5kZXhPZl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZilcclxuXHRpbmRleE9mOiBmdW5jdGlvbiAoYXJyYXksIGVsKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9LFxyXG5cclxuXHQvLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcblx0Ly8gRGF0YSBVUkkgc3RyaW5nIGNvbnRhaW5pbmcgYSBiYXNlNjQtZW5jb2RlZCBlbXB0eSBHSUYgaW1hZ2UuXHJcblx0Ly8gVXNlZCBhcyBhIGhhY2sgdG8gZnJlZSBtZW1vcnkgZnJvbSB1bnVzZWQgaW1hZ2VzIG9uIFdlYktpdC1wb3dlcmVkXHJcblx0Ly8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5cdGVtcHR5SW1hZ2VVcmw6ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9J1xyXG59O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuXHQvLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuXHRmdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0XHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxuXHR9XHJcblxyXG5cdHZhciBsYXN0VGltZSA9IDA7XHJcblxyXG5cdC8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuXHRmdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHRcdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0XHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRcdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG5cdH1cclxuXHJcblx0dmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ1JlcXVlc3RBbmltYXRpb25GcmFtZScpIHx8IHRpbWVvdXREZWZlcixcclxuXHQgICAgY2FuY2VsRm4gPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHQgICAgICAgICAgICAgICBnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcblx0Ly8gU2NoZWR1bGVzIGBmbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgYnJvd3NlciByZXBhaW50cy4gYGZuYCBpcyBib3VuZCB0b1xyXG5cdC8vIGBjb250ZXh0YCBpZiBnaXZlbi4gV2hlbiBgaW1tZWRpYXRlYCBpcyBzZXQsIGBmbmAgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGlmXHJcblx0Ly8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG5cdC8vIFtgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSxcclxuXHQvLyBvdGhlcndpc2UgaXQncyBkZWxheWVkLiBSZXR1cm5zIGEgcmVxdWVzdCBJRCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cclxuXHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSA9IGZ1bmN0aW9uIChmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0XHRpZiAoaW1tZWRpYXRlICYmIHJlcXVlc3RGbiA9PT0gdGltZW91dERlZmVyKSB7XHJcblx0XHRcdGZuLmNhbGwoY29udGV4dCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gcmVxdWVzdEZuLmNhbGwod2luZG93LCBMLmJpbmQoZm4sIGNvbnRleHQpKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkOiBOdW1iZXIpOiB1bmRlZmluZWRcclxuXHQvLyBDYW5jZWxzIGEgcHJldmlvdXMgYHJlcXVlc3RBbmltRnJhbWVgLiBTZWUgYWxzbyBbd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lKS5cclxuXHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRpZiAoaWQpIHtcclxuXHRcdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHRcdH1cclxuXHR9O1xyXG59KSgpO1xyXG5cclxuLy8gc2hvcnRjdXRzIGZvciBtb3N0IHVzZWQgdXRpbGl0eSBmdW5jdGlvbnNcclxuTC5leHRlbmQgPSBMLlV0aWwuZXh0ZW5kO1xyXG5MLmJpbmQgPSBMLlV0aWwuYmluZDtcclxuTC5zdGFtcCA9IEwuVXRpbC5zdGFtcDtcclxuTC5zZXRPcHRpb25zID0gTC5VdGlsLnNldE9wdGlvbnM7XHJcblxuXHJcbi8vIEBjbGFzcyBDbGFzc1xyXG4vLyBAYWthIEwuQ2xhc3NcclxuXHJcbi8vIEBzZWN0aW9uXHJcbi8vIEB1bmluaGVyaXRhYmxlXHJcblxyXG4vLyBUaGFua3MgdG8gSm9obiBSZXNpZyBhbmQgRGVhbiBFZHdhcmRzIGZvciBpbnNwaXJhdGlvbiFcclxuXHJcbkwuQ2xhc3MgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbkwuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcblx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcblx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGNhbGwgdGhlIGNvbnN0cnVjdG9yXHJcblx0XHRpZiAodGhpcy5pbml0aWFsaXplKSB7XHJcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNhbGwgYWxsIGNvbnN0cnVjdG9yIGhvb2tzXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgcGFyZW50UHJvdG8gPSBOZXdDbGFzcy5fX3N1cGVyX18gPSB0aGlzLnByb3RvdHlwZTtcclxuXHJcblx0dmFyIHByb3RvID0gTC5VdGlsLmNyZWF0ZShwYXJlbnRQcm90byk7XHJcblx0cHJvdG8uY29uc3RydWN0b3IgPSBOZXdDbGFzcztcclxuXHJcblx0TmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG5cdC8vIGluaGVyaXQgcGFyZW50J3Mgc3RhdGljc1xyXG5cdGZvciAodmFyIGkgaW4gdGhpcykge1xyXG5cdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ3Byb3RvdHlwZScpIHtcclxuXHRcdFx0TmV3Q2xhc3NbaV0gPSB0aGlzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbWl4IHN0YXRpYyBwcm9wZXJ0aWVzIGludG8gdGhlIGNsYXNzXHJcblx0aWYgKHByb3BzLnN0YXRpY3MpIHtcclxuXHRcdEwuZXh0ZW5kKE5ld0NsYXNzLCBwcm9wcy5zdGF0aWNzKTtcclxuXHRcdGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGluY2x1ZGVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG5cdFx0TC5VdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdFx0ZGVsZXRlIHByb3BzLmluY2x1ZGVzO1xyXG5cdH1cclxuXHJcblx0Ly8gbWVyZ2Ugb3B0aW9uc1xyXG5cdGlmIChwcm90by5vcHRpb25zKSB7XHJcblx0XHRwcm9wcy5vcHRpb25zID0gTC5VdGlsLmV4dGVuZChMLlV0aWwuY3JlYXRlKHByb3RvLm9wdGlvbnMpLCBwcm9wcy5vcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8vIG1peCBnaXZlbiBwcm9wZXJ0aWVzIGludG8gdGhlIHByb3RvdHlwZVxyXG5cdEwuZXh0ZW5kKHByb3RvLCBwcm9wcyk7XHJcblxyXG5cdHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcblx0Ly8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuXHRwcm90by5jYWxsSW5pdEhvb2tzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0SG9va3NDYWxsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MpIHtcclxuXHRcdFx0cGFyZW50UHJvdG8uY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRIb29rc0NhbGxlZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHJldHVybiBOZXdDbGFzcztcclxufTtcclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaW5jbHVkZShwcm9wZXJ0aWVzOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtJbmNsdWRlcyBhIG1peGluXSgjY2xhc3MtaW5jbHVkZXMpIGludG8gdGhlIGN1cnJlbnQgY2xhc3MuXHJcbkwuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdEwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBAZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnM6IE9iamVjdCk6IHRoaXNcclxuLy8gW01lcmdlcyBgb3B0aW9uc2BdKCNjbGFzcy1vcHRpb25zKSBpbnRvIHRoZSBkZWZhdWx0cyBvZiB0aGUgY2xhc3MuXHJcbkwuQ2xhc3MubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRMLmV4dGVuZCh0aGlzLnByb3RvdHlwZS5vcHRpb25zLCBvcHRpb25zKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRJbml0SG9vayhmbjogRnVuY3Rpb24pOiB0aGlzXHJcbi8vIEFkZHMgYSBbY29uc3RydWN0b3IgaG9va10oI2NsYXNzLWNvbnN0cnVjdG9yLWhvb2tzKSB0byB0aGUgY2xhc3MuXHJcbkwuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgRXZlbnRlZFxyXG4gKiBAYWthIEwuRXZlbnRlZFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogQSBzZXQgb2YgbWV0aG9kcyBzaGFyZWQgYmV0d2VlbiBldmVudC1wb3dlcmVkIGNsYXNzZXMgKGxpa2UgYE1hcGAgYW5kIGBNYXJrZXJgKS4gR2VuZXJhbGx5LCBldmVudHMgYWxsb3cgeW91IHRvIGV4ZWN1dGUgc29tZSBmdW5jdGlvbiB3aGVuIHNvbWV0aGluZyBoYXBwZW5zIHdpdGggYW4gb2JqZWN0IChlLmcuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwLCBjYXVzaW5nIHRoZSBtYXAgdG8gZmlyZSBgJ2NsaWNrJ2AgZXZlbnQpLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gKiBcdGFsZXJ0KGUubGF0bG5nKTtcclxuICogfSApO1xyXG4gKiBgYGBcclxuICpcclxuICogTGVhZmxldCBkZWFscyB3aXRoIGV2ZW50IGxpc3RlbmVycyBieSByZWZlcmVuY2UsIHNvIGlmIHlvdSB3YW50IHRvIGFkZCBhIGxpc3RlbmVyIGFuZCB0aGVuIHJlbW92ZSBpdCwgZGVmaW5lIGl0IGFzIGEgZnVuY3Rpb246XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIG9uQ2xpY2soZSkgeyAuLi4gfVxyXG4gKlxyXG4gKiBtYXAub24oJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIG1hcC5vZmYoJ2NsaWNrJywgb25DbGljayk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG5MLkV2ZW50ZWQgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBtZXRob2Qgb24odHlwZTogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBvZiB0aGUgb2JqZWN0LiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXIgKG9iamVjdCB0aGUgdGhpcyBrZXl3b3JkIHdpbGwgcG9pbnQgdG8pLiBZb3UgY2FuIGFsc28gcGFzcyBzZXZlcmFsIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvbihldmVudE1hcDogT2JqZWN0KTogdGhpc1xyXG5cdCAqIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHQgKi9cclxuXHRvbjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghdHlwZXMpIHtcclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHNcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29mZih0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYodHlwZXNbaV0sIGZuLCBjb250ZXh0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIGF0dGFjaCBsaXN0ZW5lciAod2l0aG91dCBzeW50YWN0aWMgc3VnYXIgbm93KVxyXG5cdF9vbjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcblxyXG5cdFx0LyogZ2V0L2luaXQgbGlzdGVuZXJzIGZvciB0eXBlICovXHJcblx0XHR2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmICghdHlwZUxpc3RlbmVycykge1xyXG5cdFx0XHR0eXBlTGlzdGVuZXJzID0gW107XHJcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IHR5cGVMaXN0ZW5lcnM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fSxcclxuXHRcdCAgICBsaXN0ZW5lcnMgPSB0eXBlTGlzdGVuZXJzO1xyXG5cclxuXHRcdC8vIGNoZWNrIGlmIGZuIGFscmVhZHkgdGhlcmVcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3RlbmVycy5wdXNoKG5ld0xpc3RlbmVyKTtcclxuXHRcdHR5cGVMaXN0ZW5lcnMuY291bnQrKztcclxuXHR9LFxyXG5cclxuXHRfb2ZmOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMsXHJcblx0XHQgICAgaSxcclxuXHRcdCAgICBsZW47XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0bGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdGlmICghbGlzdGVuZXJzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWZuKSB7XHJcblx0XHRcdC8vIFNldCBhbGwgcmVtb3ZlZCBsaXN0ZW5lcnMgdG8gbm9vcCBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0bGlzdGVuZXJzW2ldLmZuID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGlzdGVuZXJzKSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIGZuIGFuZCByZW1vdmUgaXRcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGwgPSBsaXN0ZW5lcnNbaV07XHJcblx0XHRcdFx0aWYgKGwuY3R4ICE9PSBjb250ZXh0KSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0aWYgKGwuZm4gPT09IGZuKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdFx0bC5mbiA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLl9maXJpbmdDb3VudCkge1xyXG5cdFx0XHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhbiBkYXRhXHJcblx0Ly8gb2JqZWN0IOKAlCB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgY29udGFpbiBpdHNcclxuXHQvLyBwcm9wZXJ0aWVzLiBUaGUgZXZlbnQgbWlnaHQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCB0byBldmVudCBwYXJlbnRzLlxyXG5cdGZpcmU6IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICghdGhpcy5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgZXZlbnQgPSBMLlV0aWwuZXh0ZW5kKHt9LCBkYXRhLCB7dHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzfSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2V2ZW50cykge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdGwuZm4uY2FsbChsLmN0eCB8fCB0aGlzLCBldmVudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9maXJpbmdDb3VudC0tO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBwcm9wYWdhdGUgdGhlIGV2ZW50IHRvIHBhcmVudHMgKHNldCB3aXRoIGFkZEV2ZW50UGFyZW50KVxyXG5cdFx0XHR0aGlzLl9wcm9wYWdhdGVFdmVudChldmVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhIHBhcnRpY3VsYXIgZXZlbnQgdHlwZSBoYXMgYW55IGxpc3RlbmVycyBhdHRhY2hlZCB0byBpdC5cclxuXHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gYWxzbyBjaGVjayBwYXJlbnRzIGZvciBsaXN0ZW5lcnMgaWYgZXZlbnQgcHJvcGFnYXRlc1xyXG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzW2lkXS5saXN0ZW5zKHR5cGUsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9uY2UodHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IEwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0XHQgICAgLm9mZih0eXBlcywgaGFuZGxlciwgY29udGV4dCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHQvLyBhZGQgYSBsaXN0ZW5lciB0aGF0J3MgZXhlY3V0ZWQgb25jZSBhbmQgcmVtb3ZlZCBhZnRlciB0aGF0XHJcblx0XHRyZXR1cm4gdGhpc1xyXG5cdFx0ICAgIC5vbih0eXBlcywgZm4sIGNvbnRleHQpXHJcblx0XHQgICAgLm9uKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIGV2ZW50IHBhcmVudCAtIGFuIGBFdmVudGVkYCB0aGF0IHdpbGwgcmVjZWl2ZSBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdGFkZEV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHMgPSB0aGlzLl9ldmVudFBhcmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudFBhcmVudHNbTC5zdGFtcChvYmopXSA9IG9iajtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlRXZlbnRQYXJlbnQob2JqOiBFdmVudGVkKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gZXZlbnQgcGFyZW50LCBzbyBpdCB3aWxsIHN0b3AgcmVjZWl2aW5nIHByb3BhZ2F0ZWQgZXZlbnRzXHJcblx0cmVtb3ZlRXZlbnRQYXJlbnQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHMpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2V2ZW50UGFyZW50c1tMLnN0YW1wKG9iaildO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Byb3BhZ2F0ZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdHRoaXMuX2V2ZW50UGFyZW50c1tpZF0uZmlyZShlLnR5cGUsIEwuZXh0ZW5kKHtsYXllcjogZS50YXJnZXR9LCBlKSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBwcm90byA9IEwuRXZlbnRlZC5wcm90b3R5cGU7XHJcblxyXG4vLyBhbGlhc2VzOyB3ZSBzaG91bGQgZGl0Y2ggdGhvc2UgZXZlbnR1YWxseVxyXG5cclxuLy8gQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BvbijigKYpYF0oI2V2ZW50ZWQtb24pXHJcbnByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5vbjtcclxuXHJcbi8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4vLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG8uY2xlYXJBbGxFdmVudExpc3RlbmVycyA9IHByb3RvLm9mZjtcclxuXHJcbi8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbnByb3RvLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyID0gcHJvdG8ub25jZTtcclxuXHJcbi8vIEBtZXRob2QgZmlyZUV2ZW50KOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BmaXJlKOKApilgXSgjZXZlbnRlZC1maXJlKVxyXG5wcm90by5maXJlRXZlbnQgPSBwcm90by5maXJlO1xyXG5cclxuLy8gQG1ldGhvZCBoYXNFdmVudExpc3RlbmVycyjigKYpOiBCb29sZWFuXHJcbi8vIEFsaWFzIHRvIFtgbGlzdGVucyjigKYpYF0oI2V2ZW50ZWQtbGlzdGVucylcclxucHJvdG8uaGFzRXZlbnRMaXN0ZW5lcnMgPSBwcm90by5saXN0ZW5zO1xyXG5cclxuTC5NaXhpbiA9IHtFdmVudHM6IHByb3RvfTtcclxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIEJyb3dzZXJcclxuICogQGFrYSBMLkJyb3dzZXJcclxuICpcclxuICogQSBuYW1lc3BhY2Ugd2l0aCBzdGF0aWMgcHJvcGVydGllcyBmb3IgYnJvd3Nlci9mZWF0dXJlIGRldGVjdGlvbiB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogaWYgKEwuQnJvd3Nlci5pZWx0OSkge1xyXG4gKiAgIGFsZXJ0KCdVcGdyYWRlIHlvdXIgYnJvd3NlciwgZHVkZSEnKTtcclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXHJcblx0ICAgIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuXHJcblx0ICAgIGllID0gJ0FjdGl2ZVhPYmplY3QnIGluIHdpbmRvdyxcclxuXHJcblx0ICAgIHdlYmtpdCAgICA9IHVhLmluZGV4T2YoJ3dlYmtpdCcpICE9PSAtMSxcclxuXHQgICAgcGhhbnRvbWpzID0gdWEuaW5kZXhPZigncGhhbnRvbScpICE9PSAtMSxcclxuXHQgICAgYW5kcm9pZDIzID0gdWEuc2VhcmNoKCdhbmRyb2lkIFsyM10nKSAhPT0gLTEsXHJcblx0ICAgIGNocm9tZSAgICA9IHVhLmluZGV4T2YoJ2Nocm9tZScpICE9PSAtMSxcclxuXHQgICAgZ2Vja28gICAgID0gdWEuaW5kZXhPZignZ2Vja28nKSAhPT0gLTEgICYmICF3ZWJraXQgJiYgIXdpbmRvdy5vcGVyYSAmJiAhaWUsXHJcblxyXG5cdCAgICB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDAsXHJcblxyXG5cdCAgICBtb2JpbGUgPSB0eXBlb2Ygb3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnIHx8IHVhLmluZGV4T2YoJ21vYmlsZScpICE9PSAtMSxcclxuXHQgICAgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50LFxyXG5cdCAgICBwb2ludGVyID0gd2luZG93LlBvaW50ZXJFdmVudCB8fCBtc1BvaW50ZXIsXHJcblxyXG5cdCAgICBpZTNkID0gaWUgJiYgKCd0cmFuc2l0aW9uJyBpbiBkb2Muc3R5bGUpLFxyXG5cdCAgICB3ZWJraXQzZCA9ICgnV2ViS2l0Q1NTTWF0cml4JyBpbiB3aW5kb3cpICYmICgnbTExJyBpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCgpKSAmJiAhYW5kcm9pZDIzLFxyXG5cdCAgICBnZWNrbzNkID0gJ01velBlcnNwZWN0aXZlJyBpbiBkb2Muc3R5bGUsXHJcblx0ICAgIG9wZXJhMTIgPSAnT1RyYW5zaXRpb24nIGluIGRvYy5zdHlsZTtcclxuXHJcblxyXG5cdHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAocG9pbnRlciB8fCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcclxuXHRcdFx0KHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcblx0TC5Ccm93c2VyID0ge1xyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBpZTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgKG5vdCBFZGdlKS5cclxuXHRcdGllOiBpZSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgaWVsdDk6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgbGVzcyB0aGFuIDkuXHJcblx0XHRpZWx0OTogaWUgJiYgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGVkZ2U6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIEVkZ2Ugd2ViIGJyb3dzZXIuXHJcblx0XHRlZGdlOiAnbXNMYXVuY2hVcmknIGluIG5hdmlnYXRvciAmJiAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgd2Via2l0OiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIHdlYmtpdC1iYXNlZCBicm93c2VycyBsaWtlIENocm9tZSBhbmQgU2FmYXJpIChpbmNsdWRpbmcgbW9iaWxlIHZlcnNpb25zKS5cclxuXHRcdHdlYmtpdDogd2Via2l0LFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBnZWNrbzogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBsaWtlIEZpcmVmb3guXHJcblx0XHRnZWNrbzogZ2Vja28sXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGFuZHJvaWQ6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYW55IGJyb3dzZXIgcnVubmluZyBvbiBhbiBBbmRyb2lkIHBsYXRmb3JtLlxyXG5cdFx0YW5kcm9pZDogdWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgYW5kcm9pZDIzOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxuXHRcdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG5cdFx0Y2hyb21lOiBjaHJvbWUsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcblx0XHRzYWZhcmk6ICFjaHJvbWUgJiYgdWEuaW5kZXhPZignc2FmYXJpJykgIT09IC0xLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgd2luOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBpcyBydW5uaW5nIGluIGEgV2luZG93cyBwbGF0Zm9ybVxyXG5cdFx0d2luOiB3aW4sXHJcblxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBpZTNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG5cdFx0aWUzZDogaWUzZCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgd2Via2l0M2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3Igd2Via2l0LWJhc2VkIGJyb3dzZXJzIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IGdlY2tvM2Q6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdGdlY2tvM2Q6IGdlY2tvM2QsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG9wZXJhMTI6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcblx0XHRvcGVyYTEyOiBvcGVyYTEyLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBhbnkzZDogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxuXHRcdGFueTNkOiAhd2luZG93LkxfRElTQUJMRV8zRCAmJiAoaWUzZCB8fCB3ZWJraXQzZCB8fCBnZWNrbzNkKSAmJiAhb3BlcmExMiAmJiAhcGhhbnRvbWpzLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxuXHRcdG1vYmlsZTogbW9iaWxlLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVXZWJraXQ6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIHdlYmtpdC1iYXNlZCBicm93c2VycyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGVXZWJraXQ6IG1vYmlsZSAmJiB3ZWJraXQsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDNkOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgaW4gYSBtb2JpbGUgZGV2aWNlIHN1cHBvcnRpbmcgQ1NTIHRyYW5zZm9ybXMuXHJcblx0XHRtb2JpbGVXZWJraXQzZDogbW9iaWxlICYmIHdlYmtpdDNkLFxyXG5cclxuXHRcdC8vIEBwcm9wZXJ0eSBtb2JpbGVPcGVyYTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlciBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGVPcGVyYTogbW9iaWxlICYmIHdpbmRvdy5vcGVyYSxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbW9iaWxlR2Vja286IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcblx0XHRtb2JpbGVHZWNrbzogbW9iaWxlICYmIGdlY2tvLFxyXG5cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgdG91Y2g6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3RvdWNoIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1RvdWNoX2V2ZW50cykuXHJcblx0XHR0b3VjaDogISF0b3VjaCxcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcblx0XHQvLyBgdHJ1ZWAgZm9yIGJyb3dzZXJzIGltcGxlbWVudGluZyB0aGUgTWljcm9zb2Z0IHRvdWNoIGV2ZW50cyBtb2RlbCAobm90YWJseSBJRTEwKS5cclxuXHRcdG1zUG9pbnRlcjogISFtc1BvaW50ZXIsXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuXHRcdC8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgW3BvaW50ZXIgZXZlbnRzXShodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RuNDMzMjQ0JTI4dj12cy44NSUyOS5hc3B4KS5cclxuXHRcdHBvaW50ZXI6ICEhcG9pbnRlcixcclxuXHJcblxyXG5cdFx0Ly8gQHByb3BlcnR5IHJldGluYTogQm9vbGVhblxyXG5cdFx0Ly8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbi5cclxuXHRcdHJldGluYTogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8ICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSkgPiAxXHJcblx0fTtcclxuXHJcbn0oKSk7XHJcblxuLypcclxuICogQGNsYXNzIFBvaW50XHJcbiAqIEBha2EgTC5Qb2ludFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5Qb2ludCA9IGZ1bmN0aW9uICh4LCB5LCByb3VuZCkge1xyXG5cdHRoaXMueCA9IChyb3VuZCA/IE1hdGgucm91bmQoeCkgOiB4KTtcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn07XHJcblxyXG5MLlBvaW50LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9uZSgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50LlxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKEwucG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QoTC5wb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5zY2FsZUJ5KHNjYWxlOiBQb2ludCk6IFBvaW50XHJcblx0Ly8gSW52ZXJzZSBvZiBgc2NhbGVCeWAuIERpdmlkZSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnJlbnQgcG9pbnQgYnlcclxuXHQvLyBlYWNoIGNvb3JkaW5hdGUgb2YgYHNjYWxlYC5cclxuXHR1bnNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgcm91bmQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIHJvdW5kZWQgY29vcmRpbmF0ZXMuXHJcblx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7XHJcblx0fSxcclxuXHJcblx0X3JvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZsb29yKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBmbG9vcmVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIGRvd24pLlxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9mbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjZWlsKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQgd2l0aCBjZWlsZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgdXApLlxyXG5cdGNlaWw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2NlaWwoKTtcclxuXHR9LFxyXG5cclxuXHRfY2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBMLlV0aWwuZm9ybWF0TnVtKHRoaXMueCkgKyAnLCAnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLnkpICsgJyknO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoeDogTnVtYmVyLCB5OiBOdW1iZXIsIHJvdW5kPzogQm9vbGVhbilcclxuLy8gQ3JlYXRlcyBhIFBvaW50IG9iamVjdCB3aXRoIHRoZSBnaXZlbiBgeGAgYW5kIGB5YCBjb29yZGluYXRlcy4gSWYgb3B0aW9uYWwgYHJvdW5kYCBpcyBzZXQgdG8gdHJ1ZSwgcm91bmRzIHRoZSBgeGAgYW5kIGB5YCB2YWx1ZXMuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE51bWJlcltdKVxyXG4vLyBFeHBlY3RzIGFuIGFycmF5IG9mIHRoZSBmb3JtIGBbeCwgeV1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5wb2ludChjb29yZHM6IE9iamVjdClcclxuLy8gRXhwZWN0cyBhIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge3g6IE51bWJlciwgeTogTnVtYmVyfWAgaW5zdGVhZC5cclxuTC5wb2ludCA9IGZ1bmN0aW9uICh4LCB5LCByb3VuZCkge1xyXG5cdGlmICh4IGluc3RhbmNlb2YgTC5Qb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChMLlV0aWwuaXNBcnJheSh4KSkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeC54LCB4LnkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEwuUG9pbnQoeCwgeSwgcm91bmQpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBCb3VuZHNcclxuICogQGFrYSBMLkJvdW5kc1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHAxID0gTC5wb2ludCgxMCwgMTApLFxyXG4gKiBwMiA9IEwucG9pbnQoNDAsIDYwKSxcclxuICogYm91bmRzID0gTC5ib3VuZHMocDEsIHAyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgYEJvdW5kc2Agb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG90aGVyQm91bmRzLmludGVyc2VjdHMoW1sxMCwgMTBdLCBbNDAsIDYwXV0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkJvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cG9pbnQgPSBMLnBvaW50KHBvaW50KTtcclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IHBvaW50LmNsb25lKCk7XHJcblx0XHRcdHRoaXMubWF4ID0gcG9pbnQuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWluLnggPSBNYXRoLm1pbihwb2ludC54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KHBvaW50LngsIHRoaXMubWF4LngpO1xyXG5cdFx0XHR0aGlzLm1pbi55ID0gTWF0aC5taW4ocG9pbnQueSwgdGhpcy5taW4ueSk7XHJcblx0XHRcdHRoaXMubWF4LnkgPSBNYXRoLm1heChwb2ludC55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3R0b21MZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgYm90dG9tLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRCb3R0b21MZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5taW4ueCwgdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BSaWdodCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHRvcC1yaWdodCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuUG9pbnQpIHtcclxuXHRcdFx0b2JqID0gTC5wb2ludChvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5ib3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5Cb3VuZHMpIHtcclxuXHRcdFx0bWluID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4ID0gb2JqLm1heDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1pbiA9IG1heCA9IG9iajtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKG1pbi54ID49IHRoaXMubWluLngpICYmXHJcblx0XHQgICAgICAgKG1heC54IDw9IHRoaXMubWF4LngpICYmXHJcblx0XHQgICAgICAgKG1pbi55ID49IHRoaXMubWluLnkpICYmXHJcblx0XHQgICAgICAgKG1heC55IDw9IHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW50ZXJzZWN0cyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaW50ZXJzZWN0cyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKEJvdW5kcykgLT4gQm9vbGVhblxyXG5cdFx0Ym91bmRzID0gTC5ib3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgbWluID0gdGhpcy5taW4sXHJcblx0XHQgICAgbWF4ID0gdGhpcy5tYXgsXHJcblx0XHQgICAgbWluMiA9IGJvdW5kcy5taW4sXHJcblx0XHQgICAgbWF4MiA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeEludGVyc2VjdHMgPSAobWF4Mi54ID49IG1pbi54KSAmJiAobWluMi54IDw9IG1heC54KSxcclxuXHRcdCAgICB5SW50ZXJzZWN0cyA9IChtYXgyLnkgPj0gbWluLnkpICYmIChtaW4yLnkgPD0gbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4SW50ZXJzZWN0cyAmJiB5SW50ZXJzZWN0cztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG92ZXJsYXBzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBvdmVybGFwcyB0aGUgZ2l2ZW4gYm91bmRzLiBUd28gYm91bmRzXHJcblx0Ly8gb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSBMLmJvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4T3ZlcmxhcHMgPSAobWF4Mi54ID4gbWluLngpICYmIChtaW4yLnggPCBtYXgueCksXHJcblx0XHQgICAgeU92ZXJsYXBzID0gKG1heDIueSA+IG1pbi55KSAmJiAobWluMi55IDwgbWF4LnkpO1xyXG5cclxuXHRcdHJldHVybiB4T3ZlcmxhcHMgJiYgeU92ZXJsYXBzO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHRvcExlZnQ6IFBvaW50LCBib3R0b21SaWdodDogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvb3JkaW5hdGVzICh1c3VhbGx5IHRvcC1sZWZ0IGFuZCBib3R0b20tcmlnaHQgY29ybmVycykuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhwb2ludHM6IFBvaW50W10pXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdGhlIHBvaW50cyBpdCBjb250YWluc1xyXG5MLmJvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Cb3VuZHMoYSwgYik7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIFRyYW5zZm9ybWF0aW9uXHJcbiAqIEBha2EgTC5UcmFuc2Zvcm1hdGlvblxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjogYSBzZXQgb2YgY29lZmZpY2llbnRzIGBhYCwgYGJgLCBgY2AsIGBkYFxyXG4gKiBmb3IgdHJhbnNmb3JtaW5nIGEgcG9pbnQgb2YgYSBmb3JtIGAoeCwgeSlgIGludG8gYChhKnggKyBiLCBjKnkgKyBkKWAgYW5kIGRvaW5nXHJcbiAqIHRoZSByZXZlcnNlLiBVc2VkIGJ5IExlYWZsZXQgaW4gaXRzIHByb2plY3Rpb25zIGNvZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciB0cmFuc2Zvcm1hdGlvbiA9IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDIsIDUsIC0xLCAxMCksXHJcbiAqIFx0cCA9IEwucG9pbnQoMSwgMiksXHJcbiAqIFx0cDIgPSB0cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0ocCksIC8vICBMLnBvaW50KDcsIDgpXHJcbiAqIFx0cDMgPSB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwMik7IC8vICBMLnBvaW50KDEsIDIpXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcblxyXG4vLyBmYWN0b3J5IG5ldyBMLlRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuLy8gQ3JlYXRlcyBhIGBUcmFuc2Zvcm1hdGlvbmAgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZWZmaWNpZW50cy5cclxuTC5UcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn07XHJcblxyXG5MLlRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIHRyYW5zZm9ybShwb2ludDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgdHJhbnNmb3JtZWQgcG9pbnQsIG9wdGlvbmFsbHkgbXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gc2NhbGUuXHJcblx0Ly8gT25seSBhY2NlcHRzIHJlYWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW50cmFuc2Zvcm0ocG9pbnQ6IFBvaW50LCBzY2FsZT86IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmV2ZXJzZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgZ2l2ZW4gcG9pbnQsIG9wdGlvbmFsbHkgZGl2aWRlZFxyXG5cdC8vIGJ5IHRoZSBnaXZlbiBzY2FsZS4gT25seSBhY2NlcHRzIHJlYWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0ICAgICAgICAocG9pbnQueCAvIHNjYWxlIC0gdGhpcy5fYikgLyB0aGlzLl9hLFxyXG5cdFx0ICAgICAgICAocG9pbnQueSAvIHNjYWxlIC0gdGhpcy5fZCkgLyB0aGlzLl9jKTtcclxuXHR9XHJcbn07XHJcblxuLypcclxuICogQG5hbWVzcGFjZSBEb21VdGlsXHJcbiAqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCB0aGUgW0RPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbClcclxuICogdHJlZSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIE1vc3QgZnVuY3Rpb25zIGV4cGVjdGluZyBvciByZXR1cm5pbmcgYSBgSFRNTEVsZW1lbnRgIGFsc28gd29yayBmb3JcclxuICogU1ZHIGVsZW1lbnRzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgY2xhc3NlcyByZWZlciB0byBDU1MgY2xhc3Nlc1xyXG4gKiBpbiBIVE1MIGFuZCBTVkcgY2xhc3NlcyBpbiBTVkcuXHJcbiAqL1xyXG5cclxuTC5Eb21VdGlsID0ge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0KGlkOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYW4gZWxlbWVudCBnaXZlbiBpdHMgRE9NIGlkLCBvciByZXR1cm5zIHRoZSBlbGVtZW50IGl0c2VsZlxyXG5cdC8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcblx0Z2V0OiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgc3R5bGVBdHRyaWI6IFN0cmluZyk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcblx0Ly8gaW5jbHVkaW5nIGNvbXB1dGVkIHZhbHVlcyBvciB2YWx1ZXMgc2V0IHRocm91Z2ggQ1NTLlxyXG5cdGdldFN0eWxlOiBmdW5jdGlvbiAoZWwsIHN0eWxlKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlID0gZWwuc3R5bGVbc3R5bGVdIHx8IChlbC5jdXJyZW50U3R5bGUgJiYgZWwuY3VycmVudFN0eWxlW3N0eWxlXSk7XHJcblxyXG5cdFx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDcmVhdGVzIGFuIEhUTUwgZWxlbWVudCB3aXRoIGB0YWdOYW1lYCwgc2V0cyBpdHMgY2xhc3MgdG8gYGNsYXNzTmFtZWAsIGFuZCBvcHRpb25hbGx5IGFwcGVuZHMgaXQgdG8gYGNvbnRhaW5lcmAgZWxlbWVudC5cclxuXHRjcmVhdGU6IGZ1bmN0aW9uICh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xyXG5cclxuXHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcblx0XHRlbC5jbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgJyc7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lcikge1xyXG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuXHQvLyBSZW1vdmVzIGBlbGAgZnJvbSBpdHMgcGFyZW50IGVsZW1lbnRcclxuXHRyZW1vdmU6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0XHRpZiAocGFyZW50KSB7XHJcblx0XHRcdHBhcmVudC5yZW1vdmVDaGlsZChlbCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuXHQvLyBSZW1vdmVzIGFsbCBvZiBgZWxgJ3MgY2hpbGRyZW4gZWxlbWVudHMgZnJvbSBgZWxgXHJcblx0ZW1wdHk6IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHRvRnJvbnQoZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGRyZW4gb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcblx0dG9Gcm9udDogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRlbC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gdG9CYWNrKGVsOiBIVE1MRWxlbWVudClcclxuXHQvLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZHJlbiBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJhY2sgZnJvbSB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcblx0dG9CYWNrOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBoYXNDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcblx0aGFzQ2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XHJcblx0XHR9XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gTC5Eb21VdGlsLmdldENsYXNzKGVsKTtcclxuXHRcdHJldHVybiBjbGFzc05hbWUubGVuZ3RoID4gMCAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKS50ZXN0KGNsYXNzTmFtZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGFkZENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG5cdC8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5cdGFkZENsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR2YXIgY2xhc3NlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoIUwuRG9tVXRpbC5oYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IEwuRG9tVXRpbC5nZXRDbGFzcyhlbCk7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbDogSFRNTEVsZW1lbnQsIG5hbWU6IFN0cmluZylcclxuXHQvLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldENsYXNzKGVsLCBMLlV0aWwudHJpbSgoJyAnICsgTC5Eb21VdGlsLmdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldENsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG5cdC8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuXHRzZXRDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRlbC5jbGFzc05hbWUgPSBuYW1lO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gaW4gY2FzZSBvZiBTVkcgZWxlbWVudFxyXG5cdFx0XHRlbC5jbGFzc05hbWUuYmFzZVZhbCA9IG5hbWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldENsYXNzKGVsOiBIVE1MRWxlbWVudCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuXHRnZXRDbGFzczogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG5cdC8vIFNldCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IChpbmNsdWRpbmcgb2xkIElFIHN1cHBvcnQpLlxyXG5cdC8vIGBvcGFjaXR5YCBtdXN0IGJlIGEgbnVtYmVyIGZyb20gYDBgIHRvIGAxYC5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XHJcblxyXG5cdFx0aWYgKCdvcGFjaXR5JyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9zZXRPcGFjaXR5SUU6IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcclxuXHRcdHZhciBmaWx0ZXIgPSBmYWxzZSxcclxuXHRcdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0XHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHRcdHRyeSB7XHJcblx0XHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Ly8gZG9uJ3Qgc2V0IG9wYWNpdHkgdG8gMSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgc2V0IGFuIG9wYWNpdHksXHJcblx0XHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHJcblx0XHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRcdGlmIChmaWx0ZXIpIHtcclxuXHRcdFx0ZmlsdGVyLkVuYWJsZWQgPSAodmFsdWUgIT09IDEwMCk7XHJcblx0XHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5zdHlsZS5maWx0ZXIgKz0gJyBwcm9naWQ6JyArIGZpbHRlck5hbWUgKyAnKG9wYWNpdHk9JyArIHZhbHVlICsgJyknO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuXHQvLyBHb2VzIHRocm91Z2ggdGhlIGFycmF5IG9mIHN0eWxlIG5hbWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBuYW1lXHJcblx0Ly8gdGhhdCBpcyBhIHZhbGlkIHN0eWxlIG5hbWUgZm9yIGFuIGVsZW1lbnQuIElmIG5vIHN1Y2ggbmFtZSBpcyBmb3VuZCxcclxuXHQvLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuXHR0ZXN0UHJvcDogZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHByb3BzW2ldIGluIHN0eWxlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbDogSFRNTEVsZW1lbnQsIG9mZnNldDogUG9pbnQsIHNjYWxlPzogTnVtYmVyKVxyXG5cdC8vIFJlc2V0cyB0aGUgM0QgQ1NTIHRyYW5zZm9ybSBvZiBgZWxgIHNvIGl0IGlzIHRyYW5zbGF0ZWQgYnkgYG9mZnNldGAgcGl4ZWxzXHJcblx0Ly8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG5cdC8vIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IDNEIENTUyB0cmFuc2Zvcm1zLlxyXG5cdHNldFRyYW5zZm9ybTogZnVuY3Rpb24gKGVsLCBvZmZzZXQsIHNjYWxlKSB7XHJcblx0XHR2YXIgcG9zID0gb2Zmc2V0IHx8IG5ldyBMLlBvaW50KDAsIDApO1xyXG5cclxuXHRcdGVsLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dID1cclxuXHRcdFx0KEwuQnJvd3Nlci5pZTNkID9cclxuXHRcdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcblx0XHRcdFx0J3RyYW5zbGF0ZTNkKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgsMCknKSArXHJcblx0XHRcdChzY2FsZSA/ICcgc2NhbGUoJyArIHNjYWxlICsgJyknIDogJycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBgZWxgIHRvIGNvb3JkaW5hdGVzIHNwZWNpZmllZCBieSBgcG9zaXRpb25gLFxyXG5cdC8vIHVzaW5nIENTUyB0cmFuc2xhdGUgb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyXHJcblx0Ly8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoZWwsIHBvaW50KSB7IC8vIChIVE1MRWxlbWVudCwgUG9pbnRbLCBCb29sZWFuXSlcclxuXHJcblx0XHQvKmVzbGludC1kaXNhYmxlICovXHJcblx0XHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHRcdC8qZXNsaW50LWVuYWJsZSAqL1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybShlbCwgcG9pbnQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG5cdFx0XHRlbC5zdHlsZS50b3AgPSBwb2ludC55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiBhbiBlbGVtZW50IHByZXZpb3VzbHkgcG9zaXRpb25lZCB3aXRoIHNldFBvc2l0aW9uLlxyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdFx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcblx0XHRyZXR1cm4gZWwuX2xlYWZsZXRfcG9zIHx8IG5ldyBMLlBvaW50KDAsIDApO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cdC8vIHByZWZpeCBzdHlsZSBwcm9wZXJ0eSBuYW1lc1xyXG5cclxuXHQvLyBAcHJvcGVydHkgVFJBTlNGT1JNOiBTdHJpbmdcclxuXHQvLyBWZW5kb3ItcHJlZml4ZWQgZnJhbnNmb3JtIHN0eWxlIG5hbWUgKGUuZy4gYCd3ZWJraXRUcmFuc2Zvcm0nYCBmb3IgV2ViS2l0KS5cclxuXHRMLkRvbVV0aWwuVFJBTlNGT1JNID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG5cdFx0XHRbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXSk7XHJcblxyXG5cclxuXHQvLyB3ZWJraXRUcmFuc2l0aW9uIGNvbWVzIGZpcnN0IGJlY2F1c2Ugc29tZSBicm93c2VyIHZlcnNpb25zIHRoYXQgZHJvcCB2ZW5kb3IgcHJlZml4IGRvbid0IGRvXHJcblx0Ly8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBUUkFOU0lUSU9OOiBTdHJpbmdcclxuXHQvLyBWZW5kb3ItcHJlZml4ZWQgdHJhbnNmb3JtIHN0eWxlIG5hbWUuXHJcblx0dmFyIHRyYW5zaXRpb24gPSBMLkRvbVV0aWwuVFJBTlNJVElPTiA9IEwuRG9tVXRpbC50ZXN0UHJvcChcclxuXHRcdFx0Wyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XHJcblxyXG5cdEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCA9XHJcblx0XHRcdHRyYW5zaXRpb24gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCB0cmFuc2l0aW9uID09PSAnT1RyYW5zaXRpb24nID8gdHJhbnNpdGlvbiArICdFbmQnIDogJ3RyYW5zaXRpb25lbmQnO1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gZGlzYWJsZVRleHRTZWxlY3Rpb24oKVxyXG5cdC8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcblx0Ly8gd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgbW91c2UgdGhyb3VnaCBhIHBhZ2Ugd2l0aCB0ZXh0LiBVc2VkIGludGVybmFsbHlcclxuXHQvLyBieSBMZWFmbGV0IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvdXIgb2YgYW55IGNsaWNrLWFuZC1kcmFnIGludGVyYWN0aW9uIG9uXHJcblx0Ly8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBlbmFibGVUZXh0U2VsZWN0aW9uKClcclxuXHQvLyBDYW5jZWxzIHRoZSBlZmZlY3RzIG9mIGEgcHJldmlvdXMgW2BMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb25gXSgjZG9tdXRpbC1kaXNhYmxldGV4dHNlbGVjdGlvbikuXHJcblx0aWYgKCdvbnNlbGVjdHN0YXJ0JyBpbiBkb2N1bWVudCkge1xyXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0XHR9O1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub2ZmKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0XHR9O1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIHVzZXJTZWxlY3RQcm9wZXJ0eSA9IEwuRG9tVXRpbC50ZXN0UHJvcChcclxuXHRcdFx0Wyd1c2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnT1VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdtc1VzZXJTZWxlY3QnXSk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodXNlclNlbGVjdFByb3BlcnR5KSB7XHJcblx0XHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cdFx0XHRcdHRoaXMuX3VzZXJTZWxlY3QgPSBzdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldO1xyXG5cdFx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVt1c2VyU2VsZWN0UHJvcGVydHldID0gdGhpcy5fdXNlclNlbGVjdDtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5fdXNlclNlbGVjdDtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKClcclxuXHQvLyBBcyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKSwgYnV0XHJcblx0Ly8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcblx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBlbmFibGVJbWFnZURyYWcoKVxyXG5cdC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5cdEwuRG9tVXRpbC5lbmFibGVJbWFnZURyYWcgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWw6IEhUTUxFbGVtZW50KVxyXG5cdC8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcblx0Ly8gb2YgdGhlIGVsZW1lbnQgYGVsYCBpbnZpc2libGUuIFVzZWQgaW50ZXJuYWxseSBieSBMZWFmbGV0IHRvIHByZXZlbnRcclxuXHQvLyBmb2N1c2FibGUgZWxlbWVudHMgZnJvbSBkaXNwbGF5aW5nIGFuIG91dGxpbmUgd2hlbiB0aGUgdXNlciBwZXJmb3JtcyBhXHJcblx0Ly8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG5cdEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcblx0XHR3aGlsZSAoZWxlbWVudC50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHRcdGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5zdHlsZSkgeyByZXR1cm47IH1cclxuXHRcdEwuRG9tVXRpbC5yZXN0b3JlT3V0bGluZSgpO1xyXG5cdFx0dGhpcy5fb3V0bGluZUVsZW1lbnQgPSBlbGVtZW50O1xyXG5cdFx0dGhpcy5fb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lO1xyXG5cdFx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xyXG5cdFx0TC5Eb21FdmVudC5vbih3aW5kb3csICdrZXlkb3duJywgTC5Eb21VdGlsLnJlc3RvcmVPdXRsaW5lLCB0aGlzKTtcclxuXHR9O1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gcmVzdG9yZU91dGxpbmUoKVxyXG5cdC8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZWBdKCkuXHJcblx0TC5Eb21VdGlsLnJlc3RvcmVPdXRsaW5lID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9vdXRsaW5lRWxlbWVudCkgeyByZXR1cm47IH1cclxuXHRcdHRoaXMuX291dGxpbmVFbGVtZW50LnN0eWxlLm91dGxpbmUgPSB0aGlzLl9vdXRsaW5lU3R5bGU7XHJcblx0XHRkZWxldGUgdGhpcy5fb3V0bGluZUVsZW1lbnQ7XHJcblx0XHRkZWxldGUgdGhpcy5fb3V0bGluZVN0eWxlO1xyXG5cdFx0TC5Eb21FdmVudC5vZmYod2luZG93LCAna2V5ZG93bicsIEwuRG9tVXRpbC5yZXN0b3JlT3V0bGluZSwgdGhpcyk7XHJcblx0fTtcclxufSkoKTtcclxuXG4vKiBAY2xhc3MgTGF0TG5nXHJcbiAqIEBha2EgTC5MYXRMbmdcclxuICpcclxuICogUmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBwb2ludCB3aXRoIGEgY2VydGFpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogdmFyIGxhdGxuZyA9IEwubGF0TG5nKDUwLjUsIDMwLjUpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmcgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gYW5kIHNpbXBsZSBvYmplY3QgZm9ybSAodW5sZXNzIG5vdGVkIG90aGVyd2lzZSksIHNvIHRoZXNlIGxpbmVzIGFyZSBlcXVpdmFsZW50OlxyXG4gKlxyXG4gKiBgYGBcclxuICogbWFwLnBhblRvKFs1MCwgMzBdKTtcclxuICogbWFwLnBhblRvKHtsb246IDMwLCBsYXQ6IDUwfSk7XHJcbiAqIG1hcC5wYW5Ubyh7bGF0OiA1MCwgbG5nOiAzMH0pO1xyXG4gKiBtYXAucGFuVG8oTC5sYXRMbmcoNTAsIDMwKSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuTGF0TG5nID0gZnVuY3Rpb24gKGxhdCwgbG5nLCBhbHQpIHtcclxuXHRpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTGF0TG5nIG9iamVjdDogKCcgKyBsYXQgKyAnLCAnICsgbG5nICsgJyknKTtcclxuXHR9XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsYXQ6IE51bWJlclxyXG5cdC8vIExhdGl0dWRlIGluIGRlZ3JlZXNcclxuXHR0aGlzLmxhdCA9ICtsYXQ7XHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBsbmc6IE51bWJlclxyXG5cdC8vIExvbmdpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sbmcgPSArbG5nO1xyXG5cclxuXHQvLyBAcHJvcGVydHkgYWx0OiBOdW1iZXJcclxuXHQvLyBBbHRpdHVkZSBpbiBtZXRlcnMgKG9wdGlvbmFsKVxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSArYWx0O1xyXG5cdH1cclxufTtcclxuXHJcbkwuTGF0TG5nLnByb3RvdHlwZSA9IHtcclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckxhdExuZzogTGF0TG5nLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGBMYXRMbmdgIHBvaW50IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpLiBUaGUgbWFyZ2luIG9mIGVycm9yIGNhbiBiZSBvdmVycmlkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChvYmosIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0b2JqID0gTC5sYXRMbmcob2JqKTtcclxuXHJcblx0XHR2YXIgbWFyZ2luID0gTWF0aC5tYXgoXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubGF0IC0gb2JqLmxhdCksXHJcblx0XHQgICAgICAgIE1hdGguYWJzKHRoaXMubG5nIC0gb2JqLmxuZykpO1xyXG5cclxuXHRcdHJldHVybiBtYXJnaW4gPD0gKG1heE1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMS4wRS05IDogbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvU3RyaW5nKCk6IFN0cmluZ1xyXG5cdC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvaW50IChmb3IgZGVidWdnaW5nIHB1cnBvc2VzKS5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKHByZWNpc2lvbikge1xyXG5cdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc3RhbmNlVG8ob3RoZXJMYXRMbmc6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIChpbiBtZXRlcnMpIHRvIHRoZSBnaXZlbiBgTGF0TG5nYCBjYWxjdWxhdGVkIHVzaW5nIHRoZSBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChvdGhlcikge1xyXG5cdFx0cmV0dXJuIEwuQ1JTLkVhcnRoLmRpc3RhbmNlKHRoaXMsIEwubGF0TG5nKG90aGVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBuZXcgYExhdExuZ2Agb2JqZWN0IHdpdGggdGhlIGxvbmdpdHVkZSB3cmFwcGVkIHNvIGl0J3MgYWx3YXlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkNSUy5FYXJ0aC53cmFwTGF0TG5nKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9Cb3VuZHMoc2l6ZUluTWV0ZXJzOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdCb3VuZHNgIG9iamVjdCBpbiB3aGljaCBlYWNoIGJvdW5kYXJ5IGlzIGBzaXplSW5NZXRlcnNgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gTC5sYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmxhdCwgdGhpcy5sbmcsIHRoaXMuYWx0KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGxhdGl0dWRlOiBOdW1iZXIsIGxvbmdpdHVkZTogTnVtYmVyLCBhbHRpdHVkZT86IE51bWJlcik6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBnZW9ncmFwaGljYWwgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSAoYW5kIG9wdGlvbmFsbHkgYWx0aXR1ZGUpLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nKGNvb3JkczogQXJyYXkpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW051bWJlciwgTnVtYmVyXWAgb3IgYFtOdW1iZXIsIE51bWJlciwgTnVtYmVyXWAgaW5zdGVhZC5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IE9iamVjdCk6IExhdExuZ1xyXG4vLyBFeHBlY3RzIGFuIHBsYWluIG9iamVjdCBvZiB0aGUgZm9ybSBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlcn1gIG9yIGB7bGF0OiBOdW1iZXIsIGxuZzogTnVtYmVyLCBhbHQ6IE51bWJlcn1gIGluc3RlYWQuXHJcblxyXG5MLmxhdExuZyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChMLlV0aWwuaXNBcnJheShhKSAmJiB0eXBlb2YgYVswXSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdGlmIChhLmxlbmd0aCA9PT0gMykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKGEubGF0LCAnbG5nJyBpbiBhID8gYS5sbmcgOiBhLmxvbiwgYS5hbHQpO1xyXG5cdH1cclxuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkxhdExuZyhhLCBiLCBjKTtcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgc291dGhXZXN0ID0gTC5sYXRMbmcoNDAuNzEyLCAtNzQuMjI3KSxcclxuICogbm9ydGhFYXN0ID0gTC5sYXRMbmcoNDAuNzc0LCAtNzQuMTI1KSxcclxuICogYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoc291dGhXZXN0LCBub3J0aEVhc3QpO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyB0aGF0IGFjY2VwdCBMYXRMbmdCb3VuZHMgb2JqZWN0cyBhbHNvIGFjY2VwdCB0aGVtIGluIGEgc2ltcGxlIEFycmF5IGZvcm0gKHVubGVzcyBub3RlZCBvdGhlcndpc2UpLCBzbyB0aGUgYm91bmRzIGV4YW1wbGUgYWJvdmUgY2FuIGJlIHBhc3NlZCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5maXRCb3VuZHMoW1xyXG4gKiBcdFs0MC43MTIsIC03NC4yMjddLFxyXG4gKiBcdFs0MC43NzQsIC03NC4xMjVdXHJcbiAqIF0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkxhdExuZ0JvdW5kcyA9IGZ1bmN0aW9uIChzb3V0aFdlc3QsIG5vcnRoRWFzdCkgeyAvLyAoTGF0TG5nLCBMYXRMbmcpIG9yIChMYXRMbmdbXSlcclxuXHRpZiAoIXNvdXRoV2VzdCkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIGxhdGxuZ3MgPSBub3J0aEVhc3QgPyBbc291dGhXZXN0LCBub3J0aEVhc3RdIDogc291dGhXZXN0O1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRzdzIgPSBvYmo7XHJcblx0XHRcdG5lMiA9IG9iajtcclxuXHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5fc291dGhXZXN0O1xyXG5cdFx0XHRuZTIgPSBvYmouX25vcnRoRWFzdDtcclxuXHJcblx0XHRcdGlmICghc3cyIHx8ICFuZTIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gb2JqID8gdGhpcy5leHRlbmQoTC5sYXRMbmcob2JqKSB8fCBMLmxhdExuZ0JvdW5kcyhvYmopKSA6IHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFzdyAmJiAhbmUpIHtcclxuXHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IEwuTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTC5MYXRMbmcobmUyLmxhdCwgbmUyLmxuZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xyXG5cdFx0XHRzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xyXG5cdFx0XHRuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xyXG5cdFx0XHRuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFkKGJ1ZmZlclJhdGlvOiBOdW1iZXIpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGJpZ2dlciBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgdGhlIGN1cnJlbnQgYm91bmRzIGJ5IGEgZ2l2ZW4gcGVyY2VudGFnZSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHRwYWQ6IGZ1bmN0aW9uIChidWZmZXJSYXRpbykge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIGhlaWdodEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxhdCAtIG5lLmxhdCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdCAgICB3aWR0aEJ1ZmZlciA9IE1hdGguYWJzKHN3LmxuZyAtIG5lLmxuZykgKiBidWZmZXJSYXRpbztcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBuZXcgTC5MYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMLkxhdExuZyhuZS5sYXQgKyBoZWlnaHRCdWZmZXIsIG5lLmxuZyArIHdpZHRoQnVmZmVyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3Q7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aEVhc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgbm9ydGgtZWFzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldE5vcnRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoV2VzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC13ZXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcodGhpcy5nZXRTb3V0aCgpLCB0aGlzLmdldEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRXZXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHdlc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNvdXRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFYXN0KCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGVhc3QgbG9uZ2l0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXRFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoIGxhdGl0dWRlIG9mIHRoZSBib3VuZHNcclxuXHRnZXROb3J0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIG9uZS5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyAobGF0bG5nOiBMYXRMbmcpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChvYmopIHsgLy8gKExhdExuZ0JvdW5kcykgb3IgKExhdExuZykgLT4gQm9vbGVhblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XHJcblx0XHRcdG9iaiA9IEwubGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTC5MYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLmdldFNvdXRoV2VzdCgpO1xyXG5cdFx0XHRuZTIgPSBvYmouZ2V0Tm9ydGhFYXN0KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdzIgPSBuZTIgPSBvYmo7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChzdzIubGF0ID49IHN3LmxhdCkgJiYgKG5lMi5sYXQgPD0gbmUubGF0KSAmJlxyXG5cdFx0ICAgICAgIChzdzIubG5nID49IHN3LmxuZykgJiYgKG5lMi5sbmcgPD0gbmUubG5nKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludGVyc2VjdHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGludGVyc2VjdHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBvdmVybGFwcyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgb3ZlcmxhcHMgdGhlIGdpdmVuIGJvdW5kcy4gVHdvIGJvdW5kcyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIgPSBib3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHQgICAgbmUyID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cclxuXHRcdCAgICBsYXRPdmVybGFwcyA9IChuZTIubGF0ID4gc3cubGF0KSAmJiAoc3cyLmxhdCA8IG5lLmxhdCksXHJcblx0XHQgICAgbG5nT3ZlcmxhcHMgPSAobmUyLmxuZyA+IHN3LmxuZykgJiYgKHN3Mi5sbmcgPCBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRPdmVybGFwcyAmJiBsbmdPdmVybGFwcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQkJveFN0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIGluIGEgJ3NvdXRod2VzdF9sbmcsc291dGh3ZXN0X2xhdCxub3J0aGVhc3RfbG5nLG5vcnRoZWFzdF9sYXQnIGZvcm1hdC4gVXNlZnVsIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIHdlYiBzZXJ2aWNlcyB0aGF0IHJldHVybiBnZW8gZGF0YS5cclxuXHR0b0JCb3hTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbdGhpcy5nZXRXZXN0KCksIHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0Tm9ydGgoKV0uam9pbignLCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXF1YWxzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gVE9ETyBJbnRlcm5hdGlvbmFsIGRhdGUgbGluZT9cclxuXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKHNvdXRoV2VzdDogTGF0TG5nLCBub3J0aEVhc3Q6IExhdExuZylcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBieSBkZWZpbmluZyBzb3V0aC13ZXN0IGFuZCBub3J0aC1lYXN0IGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzOiBMYXRMbmdbXSlcclxuLy8gQ3JlYXRlcyBhIGBMYXRMbmdCb3VuZHNgIG9iamVjdCBkZWZpbmVkIGJ5IHRoZSBnZW9ncmFwaGljYWwgcG9pbnRzIGl0IGNvbnRhaW5zLiBWZXJ5IHVzZWZ1bCBmb3Igem9vbWluZyB0aGUgbWFwIHRvIGZpdCBhIHBhcnRpY3VsYXIgc2V0IG9mIGxvY2F0aW9ucyB3aXRoIFtgZml0Qm91bmRzYF0oI21hcC1maXRib3VuZHMpLlxyXG5MLmxhdExuZ0JvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoYSwgYik7XHJcbn07XHJcblxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjMzOTVgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uID0ge307XHJcblxyXG5MLlByb2plY3Rpb24uTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IEwuYm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcblxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cclxuXHRSOiA2Mzc4MTM3LFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdFx0XHR0aGlzLlIgKiBsYXRsbmcubG5nICogZCxcclxuXHRcdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKFxyXG5cdFx0XHQoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55IC8gdGhpcy5SKSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQsXHJcblx0XHRcdHBvaW50LnggKiBkIC8gdGhpcy5SKTtcclxuXHR9LFxyXG5cclxuXHRib3VuZHM6IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZCA9IDYzNzgxMzcgKiBNYXRoLlBJO1xyXG5cdFx0cmV0dXJuIEwuYm91bmRzKFstZCwgLWRdLCBbZCwgZF0pO1xyXG5cdH0pKClcclxufTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgQ1JTXHJcbiAqIEBha2EgTC5DUlNcclxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBkZWZpbmVzIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbXMgZm9yIHByb2plY3RpbmdcclxuICogZ2VvZ3JhcGhpY2FsIHBvaW50cyBpbnRvIHBpeGVsIChzY3JlZW4pIGNvb3JkaW5hdGVzIGFuZCBiYWNrIChhbmQgdG9cclxuICogY29vcmRpbmF0ZXMgaW4gb3RoZXIgdW5pdHMgZm9yIFtXTVNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dlYl9NYXBfU2VydmljZSkgc2VydmljZXMpLiBTZWVcclxuICogW3NwYXRpYWwgcmVmZXJlbmNlIHN5c3RlbV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db29yZGluYXRlX3JlZmVyZW5jZV9zeXN0ZW0pLlxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlZmluZXMgdGhlIG1vc3QgdXN1YWwgQ1JTcyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0byB1c2UgYVxyXG4gKiBDUlMgbm90IGRlZmluZWQgYnkgZGVmYXVsdCwgdGFrZSBhIGxvb2sgYXQgdGhlXHJcbiAqIFtQcm9qNExlYWZsZXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJ0ZW5hL1Byb2o0TGVhZmxldCkgcGx1Z2luLlxyXG4gKi9cclxuXHJcbkwuQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gTC5ib3VuZHMobWluLCBtYXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBjb2RlOiBTdHJpbmdcclxuXHQvLyBTdGFuZGFyZCBjb2RlIG5hbWUgb2YgdGhlIENSUyBwYXNzZWQgaW50byBXTVMgc2VydmljZXMgKGUuZy4gYCdFUFNHOjM4NTcnYClcclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTG5nOiBOdW1iZXJbXVxyXG5cdC8vIEFuIGFycmF5IG9mIHR3byBudW1iZXJzIGRlZmluaW5nIHdoZXRoZXIgdGhlIGxvbmdpdHVkZSAoaG9yaXpvbnRhbCkgY29vcmRpbmF0ZVxyXG5cdC8vIGF4aXMgd3JhcHMgYXJvdW5kIGEgZ2l2ZW4gcmFuZ2UgYW5kIGhvdy4gRGVmYXVsdHMgdG8gYFstMTgwLCAxODBdYCBpbiBtb3N0XHJcblx0Ly8gZ2VvZ3JhcGhpY2FsIENSU3MuIElmIGB1bmRlZmluZWRgLCB0aGUgbG9uZ2l0dWRlIGF4aXMgZG9lcyBub3Qgd3JhcCBhcm91bmQuXHJcblx0Ly9cclxuXHQvLyBAcHJvcGVydHkgd3JhcExhdDogTnVtYmVyW11cclxuXHQvLyBMaWtlIGB3cmFwTG5nYCwgYnV0IGZvciB0aGUgbGF0aXR1ZGUgKHZlcnRpY2FsKSBheGlzLlxyXG5cclxuXHQvLyB3cmFwTG5nOiBbbWluLCBtYXhdLFxyXG5cdC8vIHdyYXBMYXQ6IFttaW4sIG1heF0sXHJcblxyXG5cdC8vIEBwcm9wZXJ0eSBpbmZpbml0ZTogQm9vbGVhblxyXG5cdC8vIElmIHRydWUsIHRoZSBjb29yZGluYXRlIHNwYWNlIHdpbGwgYmUgdW5ib3VuZGVkIChpbmZpbml0ZSBpbiBib3RoIGF4ZXMpXHJcblx0aW5maW5pdGU6IGZhbHNlLFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgbGF0IGFuZCBsbmcgaGFzIGJlZW4gd3JhcHBlZCBhY2NvcmRpbmcgdG8gdGhlXHJcblx0Ly8gQ1JTJ3MgYHdyYXBMYXRgIGFuZCBgd3JhcExuZ2AgcHJvcGVydGllcywgaWYgdGhleSBhcmUgb3V0c2lkZSB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBsbmcgPSB0aGlzLndyYXBMbmcgPyBMLlV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBMLlV0aWwud3JhcE51bShsYXRsbmcubGF0LCB0aGlzLndyYXBMYXQsIHRydWUpIDogbGF0bG5nLmxhdCxcclxuXHRcdCAgICBhbHQgPSBsYXRsbmcuYWx0O1xyXG5cclxuXHRcdHJldHVybiBMLmxhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9XHJcbn07XHJcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbkwuQ1JTLlNpbXBsZSA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTG9uTGF0LFxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcblx0fSxcblxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcblx0XHRyZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7XG5cdH0sXG5cblx0ZGlzdGFuY2U6IGZ1bmN0aW9uIChsYXRsbmcxLCBsYXRsbmcyKSB7XG5cdFx0dmFyIGR4ID0gbGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZyxcblx0XHQgICAgZHkgPSBsYXRsbmcyLmxhdCAtIGxhdGxuZzEubGF0O1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdH0sXG5cblx0aW5maW5pdGU6IHRydWVcbn0pO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbkwuQ1JTLkVhcnRoID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcblx0UjogNjM3MTAwMCxcblxuXHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgcG9pbnRzIHVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdCAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG5cdFx0ICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcblx0XHQgICAgYSA9IE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0MikgK1xuXHRcdCAgICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCk7XG5cblx0XHRyZXR1cm4gdGhpcy5SICogTWF0aC5hY29zKE1hdGgubWluKGEsIDEpKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzM4NTdcclxuICpcclxuICogVGhlIG1vc3QgY29tbW9uIENSUyBmb3Igb25saW5lIG1hcHMsIHVzZWQgYnkgYWxtb3N0IGFsbCBmcmVlIGFuZCBjb21tZXJjaWFsXHJcbiAqIHRpbGUgcHJvdmlkZXJzLiBVc2VzIFNwaGVyaWNhbCBNZXJjYXRvciBwcm9qZWN0aW9uLiBTZXQgaW4gYnkgZGVmYXVsdCBpblxyXG4gKiBNYXAncyBgY3JzYCBvcHRpb24uXHJcbiAqL1xyXG5cclxuTC5DUlMuRVBTRzM4NTcgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gbmV3IEwuVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5MLkNSUy5FUFNHOTAwOTEzID0gTC5leHRlbmQoe30sIEwuQ1JTLkVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0c0MzI2XHJcbiAqXHJcbiAqIEEgY29tbW9uIENSUyBhbW9uZyBHSVMgZW50aHVzaWFzdHMuIFVzZXMgc2ltcGxlIEVxdWlyZWN0YW5ndWxhciBwcm9qZWN0aW9uLlxyXG4gKi9cclxuXHJcbkwuQ1JTLkVQU0c0MzI2ID0gTC5leHRlbmQoe30sIEwuQ1JTLkVhcnRoLCB7XHJcblx0Y29kZTogJ0VQU0c6NDMyNicsXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLkxvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcblxuLypcclxuICogQGNsYXNzIE1hcFxyXG4gKiBAYWthIEwuTWFwXHJcbiAqIEBpbmhlcml0cyBFdmVudGVkXHJcbiAqXHJcbiAqIFRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkg4oCUIGl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgbWFwIG9uIGEgcGFnZSBhbmQgbWFuaXB1bGF0ZSBpdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogLy8gaW5pdGlhbGl6ZSB0aGUgbWFwIG9uIHRoZSBcIm1hcFwiIGRpdiB3aXRoIGEgZ2l2ZW4gY2VudGVyIGFuZCB6b29tXHJcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xyXG4gKiBcdGNlbnRlcjogWzUxLjUwNSwgLTAuMDldLFxyXG4gKiBcdHpvb206IDEzXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICovXHJcblxyXG5MLk1hcCA9IEwuRXZlbnRlZC5leHRlbmQoe1xyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAc2VjdGlvbiBNYXAgU3RhdGUgT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IEwuQ1JTLkVQU0czODU3XHJcblx0XHQvLyBUaGUgW0Nvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbV0oI2NycykgdG8gdXNlLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90XHJcblx0XHQvLyBzdXJlIHdoYXQgaXQgbWVhbnMuXHJcblx0XHRjcnM6IEwuQ1JTLkVQU0czODU3LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2VudGVyOiBMYXRMbmcgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgZ2VvZ3JhcGhpYyBjZW50ZXIgb2YgdGhlIG1hcFxyXG5cdFx0Y2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tOiBOdW1iZXIgPSB1bmRlZmluZWRcclxuXHRcdC8vIEluaXRpYWwgbWFwIHpvb20gbGV2ZWxcclxuXHRcdHpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIE92ZXJyaWRlcyBhbnkgYG1pblpvb21gIG9wdGlvbiBzZXQgb24gbWFwIGxheWVycy5cclxuXHRcdG1pblpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIE92ZXJyaWRlcyBhbnkgYG1heFpvb21gIG9wdGlvbiBzZXQgb24gbWFwIGxheWVycy5cclxuXHRcdG1heFpvb206IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogTGF5ZXJbXSA9IFtdXHJcblx0XHQvLyBBcnJheSBvZiBsYXllcnMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYXAgaW5pdGlhbGx5XHJcblx0XHRsYXllcnM6IFtdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Qm91bmRzOiBMYXRMbmdCb3VuZHMgPSBudWxsXHJcblx0XHQvLyBXaGVuIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIG1hcCByZXN0cmljdHMgdGhlIHZpZXcgdG8gdGhlIGdpdmVuXHJcblx0XHQvLyBnZW9ncmFwaGljYWwgYm91bmRzLCBib3VuY2luZyB0aGUgdXNlciBiYWNrIHdoZW4gaGUgdHJpZXMgdG8gcGFuXHJcblx0XHQvLyBvdXRzaWRlIHRoZSB2aWV3LiBUbyBzZXQgdGhlIHJlc3RyaWN0aW9uIGR5bmFtaWNhbGx5LCB1c2VcclxuXHRcdC8vIFtgc2V0TWF4Qm91bmRzYF0oI21hcC1zZXRtYXhib3VuZHMpIG1ldGhvZC5cclxuXHRcdG1heEJvdW5kczogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVuZGVyZXI6IFJlbmRlcmVyID0gKlxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBkcmF3aW5nIHZlY3RvciBsYXllcnMgb24gdGhlIG1hcC4gYEwuU1ZHYFxyXG5cdFx0Ly8gb3IgYEwuQ2FudmFzYCBieSBkZWZhdWx0IGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnQuXHJcblx0XHRyZW5kZXJlcjogdW5kZWZpbmVkLFxyXG5cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBmYWRlQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdGlsZSBmYWRlIGFuaW1hdGlvbiBpcyBlbmFibGVkLiBCeSBkZWZhdWx0IGl0J3MgZW5hYmxlZFxyXG5cdFx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0ZmFkZUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1hcmtlclpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIG1hcmtlcnMgYW5pbWF0ZSB0aGVpciB6b29tIHdpdGggdGhlIHpvb20gYW5pbWF0aW9uLCBpZiBkaXNhYmxlZFxyXG5cdFx0Ly8gdGhleSB3aWxsIGRpc2FwcGVhciBmb3IgdGhlIGxlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0J3NcclxuXHRcdC8vIGVuYWJsZWQgaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxyXG5cdFx0bWFya2VyWm9vbUFuaW1hdGlvbjogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYW5zZm9ybTNETGltaXQ6IE51bWJlciA9IDJeMjNcclxuXHRcdC8vIERlZmluZXMgdGhlIG1heGltdW0gc2l6ZSBvZiBhIENTUyB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0uIFRoZSBkZWZhdWx0XHJcblx0XHQvLyB2YWx1ZSBzaG91bGQgbm90IGJlIGNoYW5nZWQgdW5sZXNzIGEgd2ViIGJyb3dzZXIgcG9zaXRpb25zIGxheWVycyBpblxyXG5cdFx0Ly8gdGhlIHdyb25nIHBsYWNlIGFmdGVyIGRvaW5nIGEgbGFyZ2UgYHBhbkJ5YC5cclxuXHRcdHRyYW5zZm9ybTNETGltaXQ6IDgzODg2MDgsIC8vIFByZWNpc2lvbiBsaW1pdCBvZiBhIDMyLWJpdCBmbG9hdFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuXHRcdC8vIEBvcHRpb24gem9vbVNuYXA6IE51bWJlciA9IDFcclxuXHRcdC8vIEZvcmNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB0byBhbHdheXMgYmUgYSBtdWx0aXBsZSBvZiB0aGlzLCBwYXJ0aWN1bGFybHlcclxuXHRcdC8vIHJpZ2h0IGFmdGVyIGEgW2BmaXRCb3VuZHMoKWBdKCNtYXAtZml0Ym91bmRzKSBvciBhIHBpbmNoLXpvb20uXHJcblx0XHQvLyBCeSBkZWZhdWx0LCB0aGUgem9vbSBsZXZlbCBzbmFwcyB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyOyBsb3dlciB2YWx1ZXNcclxuXHRcdC8vIChlLmcuIGAwLjVgIG9yIGAwLjFgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS4gQSB2YWx1ZSBvZiBgMGBcclxuXHRcdC8vIG1lYW5zIHRoZSB6b29tIGxldmVsIHdpbGwgbm90IGJlIHNuYXBwZWQgYWZ0ZXIgYGZpdEJvdW5kc2Agb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0em9vbVNuYXA6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tRGVsdGE6IE51bWJlciA9IDFcclxuXHRcdC8vIENvbnRyb2xzIGhvdyBtdWNoIHRoZSBtYXAncyB6b29tIGxldmVsIHdpbGwgY2hhbmdlIGFmdGVyIGFcclxuXHRcdC8vIFtgem9vbUluKClgXSgjbWFwLXpvb21pbiksIFtgem9vbU91dCgpYF0oI21hcC16b29tb3V0KSwgcHJlc3NpbmcgYCtgXHJcblx0XHQvLyBvciBgLWAgb24gdGhlIGtleWJvYXJkLCBvciB1c2luZyB0aGUgW3pvb20gY29udHJvbHNdKCNjb250cm9sLXpvb20pLlxyXG5cdFx0Ly8gVmFsdWVzIHNtYWxsZXIgdGhhbiBgMWAgKGUuZy4gYDAuNWApIGFsbG93IGZvciBncmVhdGVyIGdyYW51bGFyaXR5LlxyXG5cdFx0em9vbURlbHRhOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhY2tSZXNpemU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgYXV0b21hdGljYWxseSBoYW5kbGVzIGJyb3dzZXIgd2luZG93IHJlc2l6ZSB0byB1cGRhdGUgaXRzZWxmLlxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKGlkKTtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHJcblx0XHQvLyBoYWNrIGZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8xOTgwXHJcblx0XHR0aGlzLl9vblJlc2l6ZSA9IEwuYmluZCh0aGlzLl9vblJlc2l6ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLnNldE1heEJvdW5kcyhvcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20ob3B0aW9ucy56b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5jZW50ZXIgJiYgb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zZXRWaWV3KEwubGF0TG5nKG9wdGlvbnMuY2VudGVyKSwgb3B0aW9ucy56b29tLCB7cmVzZXQ6IHRydWV9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmNhbGxJbml0SG9va3MoKTtcclxuXHJcblx0XHR0aGlzLl9hZGRMYXllcnModGhpcy5vcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRWaWV3KGNlbnRlcjogTGF0TG5nLCB6b29tOiBOdW1iZXIsIG9wdGlvbnM/OiBab29tL3BhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgd2l0aCB0aGUgZ2l2ZW5cclxuXHQvLyBhbmltYXRpb24gb3B0aW9ucy5cclxuXHRzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHQvLyByZXBsYWNlZCBieSBhbmltYXRpb24tcG93ZXJlZCBpbXBsZW1lbnRhdGlvbiBpbiBNYXAuUGFuQW5pbWF0aW9uLmpzXHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tO1xyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KEwubGF0TG5nKGNlbnRlciksIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tKHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoTC5Ccm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tICsgZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgem9vbU91dChkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBEZWNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tT3V0OiBmdW5jdGlvbiAoZGVsdGEsIG9wdGlvbnMpIHtcclxuXHRcdGRlbHRhID0gZGVsdGEgfHwgKEwuQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSAtIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb21Bcm91bmQobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgcG9pbnQgb24gdGhlIG1hcFxyXG5cdC8vIHN0YXRpb25hcnkgKGUuZy4gdXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGwgem9vbSBhbmQgZG91YmxlLWNsaWNrIHpvb20pLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChvZmZzZXQ6IFBvaW50LCB6b29tOiBOdW1iZXIsIG9wdGlvbnM6IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBab29tcyB0aGUgbWFwIHdoaWxlIGtlZXBpbmcgYSBzcGVjaWZpZWQgcGl4ZWwgb24gdGhlIG1hcCAocmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lcikgc3RhdGlvbmFyeS5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgTC5Qb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gTC5wb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IEwucG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdHZhciBwYWRkaW5nT2Zmc2V0ID0gcGFkZGluZ0JSLnN1YnRyYWN0KHBhZGRpbmdUTCkuZGl2aWRlQnkoMiksXHJcblxyXG5cdFx0ICAgIHN3UG9pbnQgPSB0aGlzLnByb2plY3QoYm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKSxcclxuXHRcdCAgICBuZVBvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgY2VudGVyID0gdGhpcy51bnByb2plY3Qoc3dQb2ludC5hZGQobmVQb2ludCkuZGl2aWRlQnkoMikuYWRkKHBhZGRpbmdPZmZzZXQpLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdEJvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9uczogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGdpdmVuIGdlb2dyYXBoaWNhbCBib3VuZHMgd2l0aCB0aGVcclxuXHQvLyBtYXhpbXVtIHpvb20gbGV2ZWwgcG9zc2libGUuXHJcblx0Zml0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAoIWJvdW5kcy5pc1ZhbGlkKCkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgYXJlIG5vdCB2YWxpZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0Qm91bmRzQ2VudGVyWm9vbShib3VuZHMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRXb3JsZChvcHRpb25zPzogZml0Qm91bmRzIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyBhIG1hcCB2aWV3IHRoYXQgbW9zdGx5IGNvbnRhaW5zIHRoZSB3aG9sZSB3b3JsZCB3aXRoIHRoZSBtYXhpbXVtXHJcblx0Ly8gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRXb3JsZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLmZpdEJvdW5kcyhbWy05MCwgLTE4MF0sIFs5MCwgMTgwXV0sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuVG8obGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gYSBnaXZlbiBjZW50ZXIuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5CeShvZmZzZXQ6IFBvaW50KTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCBieSBhIGdpdmVuIG51bWJlciBvZiBwaXhlbHMgKGFuaW1hdGVkKS5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCkgeyAvLyAoUG9pbnQpXHJcblx0XHQvLyByZXBsYWNlZCB3aXRoIGFuaW1hdGVkIHBhbkJ5IGluIE1hcC5QYW5BbmltYXRpb24uanNcclxuXHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XHJcblxyXG5cdFx0dGhpcy5fcmF3UGFuQnkoTC5wb2ludChvZmZzZXQpKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heEJvdW5kcyhib3VuZHM6IEJvdW5kcyk6IHRoaXNcclxuXHQvLyBSZXN0cmljdHMgdGhlIG1hcCB2aWV3IHRvIHRoZSBnaXZlbiBib3VuZHMgKHNlZSB0aGUgW21heEJvdW5kc10oI21hcC1tYXhib3VuZHMpIG9wdGlvbikuXHJcblx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gbnVsbDtcclxuXHRcdFx0cmV0dXJuIHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm1heEJvdW5kcykge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLm1heEJvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1pblpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIGxvd2VyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttaW5ab29tXSgjbWFwLW1pbnpvb20pIG9wdGlvbikuXHJcblx0c2V0TWluWm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIHRoaXMuZ2V0Wm9vbSgpIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHRoaXMub3B0aW9ucy5tYXhab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICh0aGlzLmdldFpvb20oKSA+IHRoaXMub3B0aW9ucy5tYXhab29tKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gUGFucyB0aGUgbWFwIHRvIHRoZSBjbG9zZXN0IHZpZXcgdGhhdCB3b3VsZCBsaWUgaW5zaWRlIHRoZSBnaXZlbiBib3VuZHMgKGlmIGl0J3Mgbm90IGFscmVhZHkpLCBjb250cm9sbGluZyB0aGUgYW5pbWF0aW9uIHVzaW5nIHRoZSBvcHRpb25zIHNwZWNpZmljLCBpZiBhbnkuXHJcblx0cGFuSW5zaWRlQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSB0cnVlO1xyXG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoY2VudGVyLCB0aGlzLl96b29tLCBMLmxhdExuZ0JvdW5kcyhib3VuZHMpKTtcclxuXHJcblx0XHRpZiAoIWNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkge1xyXG5cdFx0XHR0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5mb3JjaW5nQm91bmRzID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKG9wdGlvbnM6IFpvb20vUGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LiBJZiBgb3B0aW9ucy5wYW5gIGlzIGBmYWxzZWAsIHBhbm5pbmcgd2lsbCBub3Qgb2NjdXIuXHJcblx0Ly8gSWYgYG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kYCBpcyBgdHJ1ZWAsIGl0IHdpbGwgZGVsYXkgYG1vdmVlbmRgIGV2ZW50IHNvXHJcblx0Ly8gdGhhdCBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbiBldmVuIGlmIHRoZSBtZXRob2QgaXMgY2FsbGVkIG1hbnlcclxuXHQvLyB0aW1lcyBpbiBhIHJvdy5cclxuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBpbnZhbGlkYXRlU2l6ZShhbmltYXRlOiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIENoZWNrcyBpZiB0aGUgbWFwIGNvbnRhaW5lciBzaXplIGNoYW5nZWQgYW5kIHVwZGF0ZXMgdGhlIG1hcCBpZiBzbyDigJRcclxuXHQvLyBjYWxsIGl0IGFmdGVyIHlvdSd2ZSBjaGFuZ2VkIHRoZSBtYXAgc2l6ZSBkeW5hbWljYWxseSwgYWxzbyBhbmltYXRpbmdcclxuXHQvLyBwYW4gYnkgZGVmYXVsdC5cclxuXHRpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuZXh0ZW5kKHtcclxuXHRcdFx0YW5pbWF0ZTogZmFsc2UsXHJcblx0XHRcdHBhbjogdHJ1ZVxyXG5cdFx0fSwgb3B0aW9ucyA9PT0gdHJ1ZSA/IHthbmltYXRlOiB0cnVlfSA6IG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBvbGRTaXplID0gdGhpcy5nZXRTaXplKCk7XHJcblx0XHR0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gbnVsbDtcclxuXHJcblx0XHR2YXIgbmV3U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9sZENlbnRlciA9IG9sZFNpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSBuZXdTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgb2Zmc2V0ID0gb2xkQ2VudGVyLnN1YnRyYWN0KG5ld0NlbnRlcik7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdHRoaXMucGFuQnkob2Zmc2V0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAob3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmRlYm91bmNlTW92ZWVuZCkge1xyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3NpemVUaW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuZmlyZSwgdGhpcywgJ21vdmVlbmQnKSwgMjAwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcmVzaXplOiBSZXNpemVFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIHJlc2l6ZWQuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIG1vZGlmeWluZyBtYXAgc3RhdGVcclxuXHQvLyBAbWV0aG9kIHN0b3AoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHRoZSBjdXJyZW50bHkgcnVubmluZyBgcGFuVG9gIG9yIGBmbHlUb2AgYW5pbWF0aW9uLCBpZiBhbnkuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5zZXRab29tKHRoaXMuX2xpbWl0Wm9vbSh0aGlzLl96b29tKSk7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy56b29tU25hcCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX3N0b3AoKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gVE9ETyBoYW5kbGVyLmFkZFRvXHJcblx0Ly8gVE9ETyBBcHByb3BpYXRlIGRvY3Mgc2VjdGlvbj9cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblx0Ly8gQG1ldGhvZCBhZGRIYW5kbGVyKG5hbWU6IFN0cmluZywgSGFuZGxlckNsYXNzOiBGdW5jdGlvbik6IHRoaXNcclxuXHQvLyBBZGRzIGEgbmV3IGBIYW5kbGVyYCB0byB0aGUgbWFwLCBnaXZlbiBpdHMgbmFtZSBhbmQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0YWRkSGFuZGxlcjogZnVuY3Rpb24gKG5hbWUsIEhhbmRsZXJDbGFzcykge1xyXG5cdFx0aWYgKCFIYW5kbGVyQ2xhc3MpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IHRoaXNbbmFtZV0gPSBuZXcgSGFuZGxlckNsYXNzKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goaGFuZGxlcik7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG5cdFx0XHRoYW5kbGVyLmVuYWJsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlKCk6IHRoaXNcclxuXHQvLyBEZXN0cm95cyB0aGUgbWFwIGFuZCBjbGVhcnMgYWxsIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qZXNsaW50LWVuYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXJJZCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX21hcFBhbmUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHVubG9hZDogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGRlc3Ryb3llZCB3aXRoIFtyZW1vdmVdKCNtYXAtcmVtb3ZlKSBtZXRob2QuXHJcblx0XHRcdHRoaXMuZmlyZSgndW5sb2FkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fbGF5ZXJzW2ldLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGRyZW4gb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZHJlbiBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lciB8fCB0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAobmFtZSkge1xyXG5cdFx0XHR0aGlzLl9wYW5lc1tuYW1lXSA9IHBhbmU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBHZXR0aW5nIE1hcCBTdGF0ZVxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgY2VudGVyIG9mIHRoZSBtYXAgdmlld1xyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sYXN0Q2VudGVyICYmICF0aGlzLl9tb3ZlZCgpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9sYXN0Q2VudGVyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKHN3LCBuZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNaW5ab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtaW5ab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKSwgb3IgYDBgIGJ5IGRlZmF1bHQuXHJcblx0Z2V0TWluWm9vbTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9sYXllcnNNaW5ab29tIHx8IDAgOiB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE1heFpvb20oKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAgKGlmIHNldCBpbiB0aGUgYG1heFpvb21gIG9wdGlvbiBvZiB0aGUgbWFwIG9yIG9mIGFueSBsYXllcnMpLlxyXG5cdGdldE1heFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0KHRoaXMuX2xheWVyc01heFpvb20gPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogdGhpcy5fbGF5ZXJzTWF4Wm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kc1pvb20oYm91bmRzOiBMYXRMbmdCb3VuZHMsIGluc2lkZT86IEJvb2xlYW4pOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG5cdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcblx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHRcdHBhZGRpbmcgPSBMLnBvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcblx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG5cdFx0ICAgIGJvdW5kc1NpemUgPSB0aGlzLnByb2plY3Qoc2UsIHpvb20pLnN1YnRyYWN0KHRoaXMucHJvamVjdChudywgem9vbSkpLFxyXG5cdFx0ICAgIHNuYXAgPSBMLkJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxO1xyXG5cclxuXHRcdHZhciBzY2FsZSA9IE1hdGgubWluKHNpemUueCAvIGJvdW5kc1NpemUueCwgc2l6ZS55IC8gYm91bmRzU2l6ZS55KTtcclxuXHRcdHpvb20gPSB0aGlzLmdldFNjYWxlWm9vbShzY2FsZSwgem9vbSk7XHJcblxyXG5cdFx0aWYgKHNuYXApIHtcclxuXHRcdFx0em9vbSA9IE1hdGgucm91bmQoem9vbSAvIChzbmFwIC8gMTAwKSkgKiAoc25hcCAvIDEwMCk7IC8vIGRvbid0IGp1bXAgaWYgd2l0aGluIDElIG9mIGEgc25hcCBsZXZlbFxyXG5cdFx0XHR6b29tID0gaW5zaWRlID8gTWF0aC5jZWlsKHpvb20gLyBzbmFwKSAqIHNuYXAgOiBNYXRoLmZsb29yKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB6b29tKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBtYXAgY29udGFpbmVyIChpbiBwaXhlbHMpLlxyXG5cdGdldFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fc2l6ZSB8fCB0aGlzLl9zaXplQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IEwuUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoLFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xyXG5cclxuXHRcdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9zaXplLmNsb25lKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbEJvdW5kcygpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW4gcHJvamVjdGVkIHBpeGVsXHJcblx0Ly8gY29vcmRpbmF0ZXMgKHNvbWV0aW1lcyB1c2VmdWwgaW4gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbEJvdW5kczogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHRvcExlZnRQb2ludCA9IHRoaXMuX2dldFRvcExlZnRQb2ludChjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIG5ldyBMLkJvdW5kcyh0b3BMZWZ0UG9pbnQsIHRvcExlZnRQb2ludC5hZGQodGhpcy5nZXRTaXplKCkpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPOiBDaGVjayBzZW1hbnRpY3MgLSBpc24ndCB0aGUgcGl4ZWwgb3JpZ2luIHRoZSAwLDAgY29vcmQgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgbWFwIHBhbmU/IFwibGVmdCBwb2ludCBvZiB0aGUgbWFwIGxheWVyXCIgY2FuIGJlIGNvbmZ1c2luZywgc3BlY2lhbGx5XHJcblx0Ly8gc2luY2UgdGhlcmUgY2FuIGJlIG5lZ2F0aXZlIG9mZnNldHMuXHJcblx0Ly8gQG1ldGhvZCBnZXRQaXhlbE9yaWdpbigpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHByb2plY3RlZCBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgcG9pbnQgb2ZcclxuXHQvLyB0aGUgbWFwIGxheWVyICh1c2VmdWwgaW4gY3VzdG9tIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxPcmlnaW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHRcdHJldHVybiB0aGlzLl9waXhlbE9yaWdpbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsV29ybGRCb3VuZHMoem9vbT86IE51bWJlcik6IEJvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIHdvcmxkJ3MgYm91bmRzIGluIHBpeGVsIGNvb3JkaW5hdGVzIGZvciB6b29tIGxldmVsIGB6b29tYC5cclxuXHQvLyBJZiBgem9vbWAgaXMgb21pdHRlZCwgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyB1c2VkLlxyXG5cdGdldFBpeGVsV29ybGRCb3VuZHM6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5nZXRQcm9qZWN0ZWRCb3VuZHMoem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRab29tKCkgOiB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGFuZShwYW5lOiBTdHJpbmd8SFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgYSBbbWFwIHBhbmVdKCNtYXAtcGFuZSksIGdpdmVuIGl0cyBuYW1lIG9yIGl0cyBIVE1MIGVsZW1lbnQgKGl0cyBpZGVudGl0eSkuXHJcblx0Z2V0UGFuZTogZnVuY3Rpb24gKHBhbmUpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgcGFuZSA9PT0gJ3N0cmluZycgPyB0aGlzLl9wYW5lc1twYW5lXSA6IHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lcygpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCBbcGFuZXNdKCNtYXAtcGFuZSkgYXMga2V5cyBhbmRcclxuXHQvLyB0aGUgcGFuZXMgYXMgdmFsdWVzLlxyXG5cdGdldFBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcGFuZXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hcC5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIEBzZWN0aW9uIENvbnZlcnNpb24gTWV0aG9kc1xyXG5cclxuXHQvLyBAbWV0aG9kIGdldFpvb21TY2FsZSh0b1pvb206IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHNjYWxlIGZhY3RvciB0byBiZSBhcHBsaWVkIHRvIGEgbWFwIHRyYW5zaXRpb24gZnJvbSB6b29tIGxldmVsXHJcblx0Ly8gYGZyb21ab29tYCB0byBgdG9ab29tYC4gVXNlZCBpbnRlcm5hbGx5IHRvIGhlbHAgd2l0aCB6b29tIGFuaW1hdGlvbnMuXHJcblx0Z2V0Wm9vbVNjYWxlOiBmdW5jdGlvbiAodG9ab29tLCBmcm9tWm9vbSkge1xyXG5cdFx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHJldHVybiBjcnMuc2NhbGUodG9ab29tKSAvIGNycy5zY2FsZShmcm9tWm9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTY2FsZVpvb20oc2NhbGU6IE51bWJlciwgZnJvbVpvb206IE51bWJlcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIHpvb20gbGV2ZWwgdGhhdCB0aGUgbWFwIHdvdWxkIGVuZCB1cCBhdCwgaWYgaXQgaXMgYXQgYGZyb21ab29tYFxyXG5cdC8vIGxldmVsIGFuZCBldmVyeXRoaW5nIGlzIHNjYWxlZCBieSBhIGZhY3RvciBvZiBgc2NhbGVgLiBJbnZlcnNlIG9mXHJcblx0Ly8gW2BnZXRab29tU2NhbGVgXSgjbWFwLWdldFpvb21TY2FsZSkuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUsIGZyb21ab29tKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5vcHRpb25zLmNycztcclxuXHRcdGZyb21ab29tID0gZnJvbVpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiBmcm9tWm9vbTtcclxuXHRcdHZhciB6b29tID0gY3JzLnpvb20oc2NhbGUgKiBjcnMuc2NhbGUoZnJvbVpvb20pKTtcclxuXHRcdHJldHVybiBpc05hTih6b29tKSA/IEluZmluaXR5IDogem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcsIHpvb206IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUHJvamVjdHMgYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSBgTGF0TG5nYCBhY2NvcmRpbmcgdG8gdGhlIHByb2plY3Rpb25cclxuXHQvLyBvZiB0aGUgbWFwJ3MgQ1JTLCB0aGVuIHNjYWxlcyBpdCBhY2NvcmRpbmcgdG8gYHpvb21gIGFuZCB0aGUgQ1JTJ3NcclxuXHQvLyBgVHJhbnNmb3JtYXRpb25gLiBUaGUgcmVzdWx0IGlzIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgQ1JTIG9yaWdpbi5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nLCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KEwubGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCwgem9vbTogTnVtYmVyKTogTGF0TG5nXHJcblx0Ly8gSW52ZXJzZSBvZiBbYHByb2plY3RgXSgjbWFwLXByb2plY3QpLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5wb2ludFRvTGF0TG5nKEwucG9pbnQocG9pbnQpLCB6b29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBMYXRMbmdcclxuXHQvLyBHaXZlbiBhIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLFxyXG5cdC8vIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgKGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cclxuXHRsYXllclBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9MYXllclBvaW50KGxhdGxuZzogTGF0TG5nKTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGVcclxuXHQvLyByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0bGF0TG5nVG9MYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0aGlzLnByb2plY3QoTC5sYXRMbmcobGF0bG5nKSkuX3JvdW5kKCk7XHJcblx0XHRyZXR1cm4gcHJvamVjdGVkUG9pbnQuX3N1YnRyYWN0KHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nKGxhdGxuZzogTGF0TG5nKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdgIHdoZXJlIGBsYXRgIGFuZCBgbG5nYCBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBtYXAncyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZVxyXG5cdC8vIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBkYXRlbGluZSBzbyBpdHNcclxuXHQvLyB2YWx1ZSBpcyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKEwubGF0TG5nKGxhdGxuZykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2UobGF0bG5nMTogTGF0TG5nLCBsYXRsbmcyOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvXHJcblx0Ly8gdGhlIG1hcCdzIENSUy4gQnkgZGVmYXVsdCB0aGlzIG1lYXN1cmVzIGRpc3RhbmNlIGluIG1ldGVycy5cclxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmRpc3RhbmNlKEwubGF0TG5nKGxhdGxuZzEpLCBMLmxhdExuZyhsYXRsbmcyKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZ1xyXG5cdC8vIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pLlxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXllclBvaW50VG9Db250YWluZXJQb2ludChwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLlxyXG5cdGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLmFkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbmVyUG9pbnRUb0xhdExuZyhwb2ludDogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoTC5wb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQoTC5sYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50LmdldE1vdXNlUG9zaXRpb24oZSwgdGhpcy5fY29udGFpbmVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG9cclxuXHQvLyB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikgd2hlcmUgdGhlIGV2ZW50IHRvb2sgcGxhY2UuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvTGF0TG5nKGV2OiBNb3VzZUV2ZW50KTogTGF0TG5nXHJcblx0Ly8gR2l2ZW4gYSBNb3VzZUV2ZW50IG9iamVjdCwgcmV0dXJucyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSB3aGVyZSB0aGVcclxuXHQvLyBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xhdExuZzogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcodGhpcy5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gbWFwIGluaXRpYWxpemF0aW9uIG1ldGhvZHNcclxuXHJcblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5nZXQoaWQpO1xyXG5cclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBub3QgZm91bmQuJyk7XHJcblx0XHR9IGVsc2UgaWYgKGNvbnRhaW5lci5fbGVhZmxldF9pZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gTC5VdGlsLnN0YW1wKGNvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblxyXG5cdFx0dGhpcy5fZmFkZUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gJiYgTC5Ccm93c2VyLmFueTNkO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnRvdWNoID8gJyBsZWFmbGV0LXRvdWNoJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIucmV0aW5hID8gJyBsZWFmbGV0LXJldGluYScgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdChMLkJyb3dzZXIuc2FmYXJpID8gJyBsZWFmbGV0LXNhZmFyaScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5fZmFkZUFuaW1hdGVkID8gJyBsZWFmbGV0LWZhZGUtYW5pbScgOiAnJykpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRTdHlsZShjb250YWluZXIsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBMLlBvaW50KDAsIDApKTtcclxuXHJcblx0XHQvLyBAcGFuZSB0aWxlUGFuZTogSFRNTEVsZW1lbnQgPSAyMDBcclxuXHRcdC8vIFBhbmUgZm9yIGBHcmlkTGF5ZXJgcyBhbmQgYFRpbGVMYXllcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3RpbGVQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBvdmVybGF5UGFuZTogSFRNTEVsZW1lbnQgPSA0MDBcclxuXHRcdC8vIFBhbmUgZm9yIHZlY3RvciBvdmVybGF5cyAoYFBhdGhgcyksIGxpa2UgYFBvbHlsaW5lYHMgYW5kIGBQb2x5Z29uYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgnc2hhZG93UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgc2hhZG93UGFuZTogSFRNTEVsZW1lbnQgPSA1MDBcclxuXHRcdC8vIFBhbmUgZm9yIG92ZXJsYXkgc2hhZG93cyAoZS5nLiBgTWFya2VyYCBzaGFkb3dzKVxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdvdmVybGF5UGFuZScpO1xyXG5cdFx0Ly8gQHBhbmUgbWFya2VyUGFuZTogSFRNTEVsZW1lbnQgPSA2MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBJY29uYHMgb2YgYE1hcmtlcmBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ21hcmtlclBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHRvb2x0aXBQYW5lOiBIVE1MRWxlbWVudCA9IDY1MFxyXG5cdFx0Ly8gUGFuZSBmb3IgdG9vbHRpcC5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndG9vbHRpcFBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIHBvcHVwUGFuZTogSFRNTEVsZW1lbnQgPSA3MDBcclxuXHRcdC8vIFBhbmUgZm9yIGBQb3B1cGBzLlxyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdwb3B1cFBhbmUnKTtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBMLlBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkKVxyXG5cdFx0XHQuX21vdmUoY2VudGVyLCB6b29tKVxyXG5cdFx0XHQuX21vdmVFbmQoem9vbUNoYW5nZWQpO1xyXG5cclxuXHRcdC8vIEBldmVudCB2aWV3cmVzZXQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgbmVlZHMgdG8gcmVkcmF3IGl0cyBjb250ZW50ICh0aGlzIHVzdWFsbHkgaGFwcGVuc1xyXG5cdFx0Ly8gb24gbWFwIHpvb20gb3IgbG9hZCkuIFZlcnkgdXNlZnVsIGZvciBjcmVhdGluZyBjdXN0b20gb3ZlcmxheXMuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsb2FkOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIGlzIGluaXRpYWxpemVkICh3aGVuIGl0cyBjZW50ZXIgYW5kIHpvb20gYXJlIHNldFxyXG5cdFx0Ly8gZm9yIHRoZSBmaXJzdCB0aW1lKS5cclxuXHRcdGlmIChsb2FkaW5nKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9tb3ZlU3RhcnQ6IGZ1bmN0aW9uICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0Ly8gQGV2ZW50IHpvb21zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCB6b29tIGlzIGFib3V0IHRvIGNoYW5nZSAoZS5nLiBiZWZvcmUgem9vbSBhbmltYXRpb24pLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVzdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHZpZXcgb2YgdGhlIG1hcCBzdGFydHMgY2hhbmdpbmcgKGUuZy4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIG1hcCkuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tc3RhcnQnKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBkYXRhKSB7XHJcblx0XHRpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHpvb20gPSB0aGlzLl96b29tO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHpvb21DaGFuZ2VkID0gdGhpcy5fem9vbSAhPT0gem9vbTtcclxuXHJcblx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBjZW50ZXI7XHJcblx0XHR0aGlzLl9waXhlbE9yaWdpbiA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHpvb206IEV2ZW50XHJcblx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsIGluY2x1ZGluZyB6b29tXHJcblx0XHQvLyBhbmQgZmx5IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQgfHwgKGRhdGEgJiYgZGF0YS5waW5jaCkpIHtcdC8vIEFsd2F5cyBmaXJlICd6b29tJyBpZiBwaW5jaGluZyBiZWNhdXNlICMzNTMwXHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBtb3ZlOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsIGluY2x1ZGluZyBwYW4gYW5kXHJcblx0XHQvLyBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHR9LFxyXG5cclxuXHRfbW92ZUVuZDogZnVuY3Rpb24gKHpvb21DaGFuZ2VkKSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbWVuZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBoYXMgY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0b3BwZWRcclxuXHRcdC8vIGRyYWdnaW5nIHRoZSBtYXApLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2ZseVRvRnJhbWUpO1xyXG5cdFx0aWYgKHRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5zdG9wKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmF3UGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCB0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3Qob2Zmc2V0KSk7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21TcGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRNYXhab29tKCkgLSB0aGlzLmdldE1pblpvb20oKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuSW5zaWRlTWF4Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2VuZm9yY2luZ0JvdW5kcykge1xyXG5cdFx0XHR0aGlzLnBhbkluc2lkZUJvdW5kcyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkxvYWRlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTZXQgbWFwIGNlbnRlciBhbmQgem9vbSBmaXJzdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBET00gZXZlbnQgaGFuZGxpbmdcclxuXHJcblx0Ly8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gZXZlbnRzXHJcblx0X2luaXRFdmVudHM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHRcdGlmICghTC5Eb21FdmVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl90YXJnZXRzID0ge307XHJcblx0XHR0aGlzLl90YXJnZXRzW0wuc3RhbXAodGhpcy5fY29udGFpbmVyKV0gPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJztcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHdoaWxlIHRoZSBtYXAgaXMgZm9jdXNlZC5cclxuXHRcdEwuRG9tRXZlbnRbb25PZmZdKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwICcgK1xyXG5cdFx0XHQnbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlbW92ZSBjb250ZXh0bWVudSBrZXlwcmVzcycsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRbb25PZmZdKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdHRoaXNbb25PZmZdKCdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9yZXNpemVSZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIGZ1bmN0aW9uICgpIHsgdGhpcy5pbnZhbGlkYXRlU2l6ZSh7ZGVib3VuY2VNb3ZlZW5kOiB0cnVlfSk7IH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9vblNjcm9sbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCAgPSAwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnNjcm9sbExlZnQgPSAwO1xyXG5cdH0sXHJcblxyXG5cdF9vbk1vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9nZXRNYXBQYW5lUG9zKCk7XHJcblx0XHRpZiAoTWF0aC5tYXgoTWF0aC5hYnMocG9zLngpLCBNYXRoLmFicyhwb3MueSkpID49IHRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0KSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMDM4NzMgYnV0IFdlYmtpdCBhbHNvIGhhdmVcclxuXHRcdFx0Ly8gYSBwaXhlbCBvZmZzZXQgb24gdmVyeSBoaWdoIHZhbHVlcywgc2VlOiBodHRwOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW0wuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgIWUuX3NpbXVsYXRlZCAmJiB0aGlzLl9kcmFnZ2FibGVNb3ZlZCh0YXJnZXQpKSB7XHJcblx0XHRcdFx0Ly8gUHJldmVudCBmaXJpbmcgY2xpY2sgYWZ0ZXIgeW91IGp1c3QgZHJhZ2dlZCBhbiBvYmplY3QuXHJcblx0XHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgdGFyZ2V0Lmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRpZiAoaXNIb3ZlciAmJiAhTC5Eb21FdmVudC5faXNFeHRlcm5hbFRhcmdldChzcmMsIGUpKSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0dGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc3JjID09PSB0aGlzLl9jb250YWluZXIpIHsgYnJlYWs7IH1cclxuXHRcdFx0c3JjID0gc3JjLnBhcmVudE5vZGU7XHJcblx0XHR9XHJcblx0XHRpZiAoIXRhcmdldHMubGVuZ3RoICYmICFkcmFnZ2luZyAmJiAhaXNIb3ZlciAmJiBMLkRvbUV2ZW50Ll9pc0V4dGVybmFsVGFyZ2V0KHNyYywgZSkpIHtcclxuXHRcdFx0dGFyZ2V0cyA9IFt0aGlzXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVET01FdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IEwuRG9tRXZlbnQuX3NraXBwZWQoZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHR5cGUgPSBlLnR5cGUgPT09ICdrZXlwcmVzcycgJiYgZS5rZXlDb2RlID09PSAxMyA/ICdjbGljaycgOiBlLnR5cGU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcblx0XHRcdC8vIHByZXZlbnRzIG91dGxpbmUgd2hlbiBjbGlja2luZyBvbiBrZXlib2FyZC1mb2N1c2FibGUgZWxlbWVudFxyXG5cdFx0XHRMLkRvbVV0aWwucHJldmVudE91dGxpbmUoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9maXJlRE9NRXZlbnQoZSwgdHlwZSk7XHJcblx0fSxcclxuXHJcblx0X2ZpcmVET01FdmVudDogZnVuY3Rpb24gKGUsIHR5cGUsIHRhcmdldHMpIHtcclxuXHJcblx0XHRpZiAoZS50eXBlID09PSAnY2xpY2snKSB7XHJcblx0XHRcdC8vIEZpcmUgYSBzeW50aGV0aWMgJ3ByZWNsaWNrJyBldmVudCB3aGljaCBwcm9wYWdhdGVzIHVwIChtYWlubHkgZm9yIGNsb3NpbmcgcG9wdXBzKS5cclxuXHRcdFx0Ly8gQGV2ZW50IHByZWNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIGJlZm9yZSBtb3VzZSBjbGljayBvbiB0aGUgbWFwIChzb21ldGltZXMgdXNlZnVsIHdoZW4geW91XHJcblx0XHRcdC8vIHdhbnQgc29tZXRoaW5nIHRvIGhhcHBlbiBvbiBjbGljayBiZWZvcmUgYW55IGV4aXN0aW5nIGNsaWNrXHJcblx0XHRcdC8vIGhhbmRsZXJzIHN0YXJ0IHJ1bm5pbmcpLlxyXG5cdFx0XHR2YXIgc3ludGggPSBMLlV0aWwuZXh0ZW5kKHt9LCBlKTtcclxuXHRcdFx0c3ludGgudHlwZSA9ICdwcmVjbGljayc7XHJcblx0XHRcdHRoaXMuX2ZpcmVET01FdmVudChzeW50aCwgc3ludGgudHlwZSwgdGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUuX3N0b3BwZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgbGF5ZXIgdGhlIGV2ZW50IGlzIHByb3BhZ2F0aW5nIGZyb20gYW5kIGl0cyBwYXJlbnRzLlxyXG5cdFx0dGFyZ2V0cyA9ICh0YXJnZXRzIHx8IFtdKS5jb25jYXQodGhpcy5fZmluZEV2ZW50VGFyZ2V0cyhlLCB0eXBlKSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdGlmICh0eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGUudHlwZSAhPT0gJ2tleXByZXNzJykge1xyXG5cdFx0XHR2YXIgaXNNYXJrZXIgPSB0YXJnZXQgaW5zdGFuY2VvZiBMLk1hcmtlcjtcclxuXHRcdFx0ZGF0YS5jb250YWluZXJQb2ludCA9IGlzTWFya2VyID9cclxuXHRcdFx0XHRcdHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludCh0YXJnZXQuZ2V0TGF0TG5nKCkpIDogdGhpcy5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHRcdFx0ZGF0YS5sYXllclBvaW50ID0gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChkYXRhLmNvbnRhaW5lclBvaW50KTtcclxuXHRcdFx0ZGF0YS5sYXRsbmcgPSBpc01hcmtlciA/IHRhcmdldC5nZXRMYXRMbmcoKSA6IHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGRhdGEubGF5ZXJQb2ludCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRhcmdldHNbaV0uZmlyZSh0eXBlLCBkYXRhLCB0cnVlKTtcclxuXHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudC5fc3RvcHBlZCB8fFxyXG5cdFx0XHRcdCh0YXJnZXRzW2ldLm9wdGlvbnMubm9uQnViYmxpbmdFdmVudHMgJiYgTC5VdGlsLmluZGV4T2YodGFyZ2V0c1tpXS5vcHRpb25zLm5vbkJ1YmJsaW5nRXZlbnRzLCB0eXBlKSAhPT0gLTEpKSB7IHJldHVybjsgfVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmFnZ2FibGVNb3ZlZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0b2JqID0gb2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5lbmFibGVkKCkgPyBvYmogOiB0aGlzO1xyXG5cdFx0cmV0dXJuIChvYmouZHJhZ2dpbmcgJiYgb2JqLmRyYWdnaW5nLm1vdmVkKCkpIHx8ICh0aGlzLmJveFpvb20gJiYgdGhpcy5ib3hab29tLm1vdmVkKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dGhpcy5faGFuZGxlcnNbaV0uZGlzYWJsZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCB3aGVuUmVhZHkoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbmAgd2hlbiB0aGUgbWFwIGdldHMgaW5pdGlhbGl6ZWQgd2l0aFxyXG5cdC8vIGEgdmlldyAoY2VudGVyIGFuZCB6b29tKSBhbmQgYXQgbGVhc3Qgb25lIGxheWVyLCBvciBpbW1lZGlhdGVseVxyXG5cdC8vIGlmIGl0J3MgYWxyZWFkeSBpbml0aWFsaXplZCwgb3B0aW9uYWxseSBwYXNzaW5nIGEgZnVuY3Rpb24gY29udGV4dC5cclxuXHR3aGVuUmVhZHk6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQgfHwgdGhpcywge3RhcmdldDogdGhpc30pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgZm9yIGdldHRpbmcgbWFwIHN0YXRlXHJcblxyXG5cdF9nZXRNYXBQYW5lUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpIHx8IG5ldyBMLlBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBsYXllciBwb2ludCBvZiB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRfZ2V0Q2VudGVyTGF5ZXJQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBvZmZzZXQgb2YgdGhlIHNwZWNpZmllZCBwbGFjZSB0byB0aGUgY3VycmVudCBjZW50ZXIgaW4gcGl4ZWxzXHJcblx0X2dldENlbnRlck9mZnNldDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF0TG5nVG9MYXllclBvaW50KGxhdGxuZykuc3VidHJhY3QodGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBhZGp1c3QgY2VudGVyIGZvciB2aWV3IHRvIGdldCBpbnNpZGUgYm91bmRzXHJcblx0X2xpbWl0Q2VudGVyOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBib3VuZHMpIHtcclxuXHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gY2VudGVyOyB9XHJcblxyXG5cdFx0dmFyIGNlbnRlclBvaW50ID0gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSksXHJcblx0XHQgICAgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcclxuXHRcdCAgICB2aWV3Qm91bmRzID0gbmV3IEwuQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChvZmZzZXQucm91bmQoKS5lcXVhbHMoWzAsIDBdKSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEwuQm91bmRzKHZpZXdCb3VuZHMubWluLmFkZChvZmZzZXQpLCB2aWV3Qm91bmRzLm1heC5hZGQob2Zmc2V0KSk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldC5hZGQodGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KG5ld0JvdW5kcywgYm91bmRzKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gcmV0dXJucyBvZmZzZXQgbmVlZGVkIGZvciBweEJvdW5kcyB0byBnZXQgaW5zaWRlIG1heEJvdW5kcyBhdCBhIHNwZWNpZmllZCB6b29tXHJcblx0X2dldEJvdW5kc09mZnNldDogZnVuY3Rpb24gKHB4Qm91bmRzLCBtYXhCb3VuZHMsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRNYXhCb3VuZHMgPSBMLmJvdW5kcyhcclxuXHRcdCAgICAgICAgdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXROb3J0aEVhc3QoKSwgem9vbSksXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0U291dGhXZXN0KCksIHpvb20pXHJcblx0XHQgICAgKSxcclxuXHRcdCAgICBtaW5PZmZzZXQgPSBwcm9qZWN0ZWRNYXhCb3VuZHMubWluLnN1YnRyYWN0KHB4Qm91bmRzLm1pbiksXHJcblx0XHQgICAgbWF4T2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1heC5zdWJ0cmFjdChweEJvdW5kcy5tYXgpLFxyXG5cclxuXHRcdCAgICBkeCA9IHRoaXMuX3JlYm91bmQobWluT2Zmc2V0LngsIC1tYXhPZmZzZXQueCksXHJcblx0XHQgICAgZHkgPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC55LCAtbWF4T2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKSxcclxuXHRcdCAgICBzbmFwID0gTC5Ccm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuXHJcbi8vIEBmYWN0b3J5IEwubWFwKGlkOiBTdHJpbmcsIG9wdGlvbnM/OiBNYXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgbWFwIG9iamVjdCBnaXZlbiB0aGUgRE9NIElEIG9mIGEgYDxkaXY+YCBlbGVtZW50XHJcbi8vIGFuZCBvcHRpb25hbGx5IGFuIG9iamVjdCBsaXRlcmFsIHdpdGggYE1hcCBvcHRpb25zYC5cclxuLy9cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubWFwKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIGFuIGluc3RhbmNlIG9mIGEgYDxkaXY+YCBIVE1MIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG5MLm1hcCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5NYXAoaWQsIG9wdGlvbnMpO1xyXG59O1xyXG5cblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuTWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuTC5MYXllciA9IEwuRXZlbnRlZC5leHRlbmQoe1xuXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAnb3ZlcmxheVBhbmUnXG5cdFx0Ly8gQnkgZGVmYXVsdCB0aGUgbGF5ZXIgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwJ3MgW292ZXJsYXkgcGFuZV0oI21hcC1vdmVybGF5cGFuZSkuIE92ZXJyaWRpbmcgdGhpcyBvcHRpb24gd2lsbCBjYXVzZSB0aGUgbGF5ZXIgdG8gYmUgcGxhY2VkIG9uIGFub3RoZXIgcGFuZSBieSBkZWZhdWx0LlxuXHRcdHBhbmU6ICdvdmVybGF5UGFuZScsXG5cdFx0bm9uQnViYmxpbmdFdmVudHM6IFtdICAvLyBBcnJheSBvZiBldmVudHMgdGhhdCBzaG91bGQgbm90IGJlIGJ1YmJsZWQgdG8gRE9NIHBhcmVudHMgKGxpa2UgdGhlIG1hcClcblx0fSxcblxuXHQvKiBAc2VjdGlvblxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcblx0ICpcblx0ICogQG1ldGhvZCBhZGRUbyhtYXA6IE1hcCk6IHRoaXNcblx0ICogQWRkcyB0aGUgbGF5ZXIgdG8gdGhlIGdpdmVuIG1hcFxuXHQgKi9cblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcblx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgbWFwIGl0IGlzIGN1cnJlbnRseSBhY3RpdmUgb24uXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZUZyb20odGhpcy5fbWFwIHx8IHRoaXMuX21hcFRvQWRkKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20obWFwOiBNYXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIG1hcFxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tMLnN0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW0wuc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfbGF5ZXJBZGQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gY2hlY2sgaW4gY2FzZSBsYXllciBnZXRzIGFkZGVkIGFuZCB0aGVuIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXAgaXMgcmVhZHlcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSBtYXAuX3pvb21BbmltYXRlZDtcblxuXHRcdGlmICh0aGlzLmdldEV2ZW50cykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG5cdFx0XHRtYXAub24oZXZlbnRzLCB0aGlzKTtcblx0XHRcdHRoaXMub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRtYXAub2ZmKGV2ZW50cywgdGhpcyk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uQWRkKG1hcCk7XG5cblx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGlvbiAmJiB0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sKSB7XG5cdFx0XHR0aGlzLl9tYXAuYXR0cmlidXRpb25Db250cm9sLmFkZEF0dHJpYnV0aW9uKHRoaXMuZ2V0QXR0cmlidXRpb24oKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcblx0XHRtYXAuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IHRoaXN9KTtcblx0fVxufSk7XG5cbi8qIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG4gKiBAdW5pbmhlcml0YWJsZVxuICpcbiAqIEV2ZXJ5IGxheWVyIHNob3VsZCBleHRlbmQgZnJvbSBgTC5MYXllcmAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cbiAqXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gY29kZSB0aGF0IGNyZWF0ZXMgRE9NIGVsZW1lbnRzIGZvciB0aGUgbGF5ZXIsIGFkZHMgdGhlbSB0byBgbWFwIHBhbmVzYCB3aGVyZSB0aGV5IHNob3VsZCBiZWxvbmcgYW5kIHB1dHMgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuIENhbGxlZCBvbiBbYG1hcC5hZGRMYXllcihsYXllcilgXSgjbWFwLWFkZGxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKTogdGhpc1xuICogU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsYXllcidzIGVsZW1lbnRzIGZyb20gdGhlIERPTSBhbmQgcmVtb3ZlcyBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2xheWVyLW9uYWRkKS4gQ2FsbGVkIG9uIFtgbWFwLnJlbW92ZUxheWVyKGxheWVyKWBdKCNtYXAtcmVtb3ZlbGF5ZXIpLlxuICpcbiAqIEBtZXRob2QgZ2V0RXZlbnRzKCk6IE9iamVjdFxuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgbGlrZSBgeyB2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0IH1gIGZvciBbYGFkZEV2ZW50TGlzdGVuZXJgXSgjZXZlbnRlZC1hZGRldmVudGxpc3RlbmVyKS4gVGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoaXMgb2JqZWN0IHdpbGwgYmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgd2l0aCB5b3VyIGxheWVyLlxuICpcbiAqIEBtZXRob2QgZ2V0QXR0cmlidXRpb24oKTogU3RyaW5nXG4gKiBUaGlzIG9wdGlvbmFsIG1ldGhvZCBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgIHdoZW5ldmVyIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICpcbiAqIEBtZXRob2QgYmVmb3JlQWRkKG1hcDogTWFwKTogdGhpc1xuICogT3B0aW9uYWwgbWV0aG9kLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllciksIGJlZm9yZSB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIG1hcCwgYmVmb3JlIGV2ZW50cyBhcmUgaW5pdGlhbGl6ZWQsIHdpdGhvdXQgd2FpdGluZyB1bnRpbCB0aGUgbWFwIGlzIGluIGEgdXNhYmxlIHN0YXRlLiBVc2UgZm9yIGVhcmx5IGluaXRpYWxpemF0aW9uIG9ubHkuXG4gKi9cblxuXG4vKiBAbmFtZXNwYWNlIE1hcFxuICogQHNlY3Rpb24gTGF5ZXIgZXZlbnRzXG4gKlxuICogQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIGEgbmV3IGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGxheWVycmVtb3ZlOiBMYXllckV2ZW50XG4gKiBGaXJlZCB3aGVuIHNvbWUgbGF5ZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXBcbiAqXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG4gKi9cbkwuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcblx0Ly8gQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIG1hcFxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gTC5zdGFtcChsYXllcik7XG5cdFx0aWYgKHRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XG5cblx0XHRsYXllci5fbWFwVG9BZGQgPSB0aGlzO1xuXG5cdFx0aWYgKGxheWVyLmJlZm9yZUFkZCkge1xuXHRcdFx0bGF5ZXIuYmVmb3JlQWRkKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMud2hlblJlYWR5KGxheWVyLl9sYXllckFkZCwgbGF5ZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIG1hcC5cblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBpZCA9IEwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRsYXllci5vblJlbW92ZSh0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAobGF5ZXIuZ2V0QXR0cmlidXRpb24gJiYgdGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcblx0XHRcdHRoaXMuYXR0cmlidXRpb25Db250cm9sLnJlbW92ZUF0dHJpYnV0aW9uKGxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcblx0XHRcdGxheWVyLmZpcmUoJ3JlbW92ZScpO1xuXHRcdH1cblxuXHRcdGxheWVyLl9tYXAgPSBsYXllci5fbWFwVG9BZGQgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBoYXNMYXllcihsYXllcjogTGF5ZXIpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIG1hcFxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0cmV0dXJuICEhbGF5ZXIgJiYgKEwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XG5cdH0sXG5cblx0LyogQG1ldGhvZCBlYWNoTGF5ZXIoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xuXHQgKiBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIG1hcCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuXHQgKiBgYGBcblx0ICogbWFwLmVhY2hMYXllcihmdW5jdGlvbihsYXllcil7XG5cdCAqICAgICBsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XG5cdCAqIH0pO1xuXHQgKiBgYGBcblx0ICovXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfYWRkTGF5ZXJzOiBmdW5jdGlvbiAobGF5ZXJzKSB7XG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKEwuVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0X2FkZFpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKGlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tMLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gTC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXHR9XG59KTtcblxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gVGFrZXMgaW50byBhY2NvdW50IHRoYXQgRWFydGggaXMgYSBnZW9pZCwgbm90IGEgcGVyZmVjdCBzcGhlcmUuIFVzZWQgYnkgdGhlIEVQU0c6MzM5NSBDUlMuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLk1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogTC5ib3VuZHMoWy0yMDAzNzUwOC4zNDI3OSwgLTE1NDk2NTcwLjczOTcyXSwgWzIwMDM3NTA4LjM0Mjc5LCAxODc2NDY1Ni4yMzEzOF0pLFxyXG5cclxuXHRwcm9qZWN0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXHJcblx0XHQgICAgciA9IHRoaXMuUixcclxuXHRcdCAgICB5ID0gbGF0bG5nLmxhdCAqIGQsXHJcblx0XHQgICAgdG1wID0gdGhpcy5SX01JTk9SIC8gcixcclxuXHRcdCAgICBlID0gTWF0aC5zcXJ0KDEgLSB0bXAgKiB0bXApLFxyXG5cdFx0ICAgIGNvbiA9IGUgKiBNYXRoLnNpbih5KTtcclxuXHJcblx0XHR2YXIgdHMgPSBNYXRoLnRhbihNYXRoLlBJIC8gNCAtIHkgLyAyKSAvIE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0eSA9IC1yICogTWF0aC5sb2coTWF0aC5tYXgodHMsIDFFLTEwKSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhwaGkgKiBkLCBwb2ludC54ICogZCAvIHIpO1xyXG5cdH1cclxufTtcclxuXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czMzk1XHJcbiAqXHJcbiAqIFJhcmVseSB1c2VkIGJ5IHNvbWUgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gVXNlcyBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24uXHJcbiAqL1xyXG5cclxuTC5DUlMuRVBTRzMzOTUgPSBMLmV4dGVuZCh7fSwgTC5DUlMuRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTWVyY2F0b3IsXHJcblxyXG5cdHRyYW5zZm9ybWF0aW9uOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHNjYWxlID0gMC41IC8gKE1hdGguUEkgKiBMLlByb2plY3Rpb24uTWVyY2F0b3IuUik7XHJcblx0XHRyZXR1cm4gbmV3IEwuVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxuLypcbiAqIEBjbGFzcyBHcmlkTGF5ZXJcbiAqIEBpbmhlcml0cyBMYXllclxuICogQGFrYSBMLkdyaWRMYXllclxuICpcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIGhhbmRsaW5nIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzLiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgdGlsZSBsYXllcnMgYW5kIHJlcGxhY2VzIGBUaWxlTGF5ZXIuQ2FudmFzYC5cbiAqIEdyaWRMYXllciBjYW4gYmUgZXh0ZW5kZWQgdG8gY3JlYXRlIGEgdGlsZWQgZ3JpZCBvZiBIVE1MIGVsZW1lbnRzIGxpa2UgYDxjYW52YXM+YCwgYDxpbWc+YCBvciBgPGRpdj5gLiBHcmlkTGF5ZXIgd2lsbCBoYW5kbGUgY3JlYXRpbmcgYW5kIGFuaW1hdGluZyB0aGVzZSBET00gZWxlbWVudHMgZm9yIHlvdS5cbiAqXG4gKlxuICogQHNlY3Rpb24gU3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVG8gY3JlYXRlIGEgY3VzdG9tIGxheWVyLCBleHRlbmQgR3JpZExheWVyIGFuZCBpbXBsZW1lbnQgdGhlIGBjcmVhdGVUaWxlKClgIG1ldGhvZCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgYSBgUG9pbnRgIG9iamVjdCB3aXRoIHRoZSBgeGAsIGB5YCwgYW5kIGB6YCAoem9vbSBsZXZlbCkgY29vcmRpbmF0ZXMgdG8gZHJhdyB5b3VyIHRpbGUuXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzKXtcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZ2V0IGEgY2FudmFzIGNvbnRleHQgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0IHVzaW5nIGNvb3Jkcy54LCBjb29yZHMueSBhbmQgY29vcmRzLnpcbiAqICAgICAgICAgdmFyIGN0eCA9IHRpbGUuZ2V0Q29udGV4dCgnMmQnKTtcbiAqXG4gKiAgICAgICAgIC8vIHJldHVybiB0aGUgdGlsZSBzbyBpdCBjYW4gYmUgcmVuZGVyZWQgb24gc2NyZWVuXG4gKiAgICAgICAgIHJldHVybiB0aWxlO1xuICogICAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHNlY3Rpb24gQXN5bmNocm9ub3VzIHVzYWdlXG4gKiBAZXhhbXBsZVxuICpcbiAqIFRpbGUgY3JlYXRpb24gY2FuIGFsc28gYmUgYXN5bmNocm9ub3VzLCB0aGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGEgdGhpcmQtcGFydHkgZHJhd2luZyBsaWJyYXJ5LiBPbmNlIHRoZSB0aWxlIGlzIGZpbmlzaGVkIGRyYXdpbmcgaXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgYGRvbmUoKWAgY2FsbGJhY2suXG4gKlxuICogYGBganNcbiAqIHZhciBDYW52YXNMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG4gKiAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24oY29vcmRzLCBkb25lKXtcbiAqICAgICAgICAgdmFyIGVycm9yO1xuICpcbiAqICAgICAgICAgLy8gY3JlYXRlIGEgPGNhbnZhcz4gZWxlbWVudCBmb3IgZHJhd2luZ1xuICogICAgICAgICB2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcbiAqXG4gKiAgICAgICAgIC8vIHNldHVwIHRpbGUgd2lkdGggYW5kIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcbiAqICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG4gKiAgICAgICAgIHRpbGUud2lkdGggPSBzaXplLng7XG4gKiAgICAgICAgIHRpbGUuaGVpZ2h0ID0gc2l6ZS55O1xuICpcbiAqICAgICAgICAgLy8gZHJhdyBzb21ldGhpbmcgYXN5bmNocm9ub3VzbHkgYW5kIHBhc3MgdGhlIHRpbGUgdG8gdGhlIGRvbmUoKSBjYWxsYmFja1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgZG9uZShlcnJvciwgdGlsZSk7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvblxuICovXG5cblxuTC5HcmlkTGF5ZXIgPSBMLkxheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG5cdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuXHRcdHRpbGVTaXplOiAyNTYsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBkZXBlbmRzXG5cdFx0Ly8gSWYgYGZhbHNlYCwgbmV3IHRpbGVzIGFyZSBsb2FkZWQgZHVyaW5nIHBhbm5pbmcsIG90aGVyd2lzZSBvbmx5IGFmdGVyIGl0IChmb3IgYmV0dGVyIHBlcmZvcm1hbmNlKS4gYHRydWVgIGJ5IGRlZmF1bHQgb24gbW9iaWxlIGJyb3dzZXJzLCBvdGhlcndpc2UgYGZhbHNlYC5cblx0XHR1cGRhdGVXaGVuSWRsZTogTC5Ccm93c2VyLm1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIGF0dHJpYnV0aW9uOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gU3RyaW5nIHRvIGJlIHNob3duIGluIHRoZSBhdHRyaWJ1dGlvbiBjb250cm9sLCBkZXNjcmliZXMgdGhlIGxheWVyIGRhdGEsIGUuZy4gXCLCqSBNYXBib3hcIi5cblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXG5cdFx0Ly8gVGhlIGV4cGxpY2l0IHpJbmRleCBvZiB0aGUgdGlsZSBsYXllci5cblx0XHR6SW5kZXg6IDEsXG5cblx0XHQvLyBAb3B0aW9uIGJvdW5kczogTGF0TG5nQm91bmRzID0gdW5kZWZpbmVkXG5cdFx0Ly8gSWYgc2V0LCB0aWxlcyB3aWxsIG9ubHkgYmUgbG9hZGVkIGluc2lkZSB0aGUgc2V0IGBMYXRMbmdCb3VuZHNgLlxuXHRcdGJvdW5kczogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gMFxuXHRcdC8vIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgdGhhdCB0aWxlcyB3aWxsIGJlIGxvYWRlZCBhdC4gQnkgZGVmYXVsdCB0aGUgZW50aXJlIG1hcC5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHRoYXQgdGlsZXMgd2lsbCBiZSBsb2FkZWQgYXQuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBub1dyYXA6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIFdoZXRoZXIgdGhlIGxheWVyIGlzIHdyYXBwZWQgYXJvdW5kIHRoZSBhbnRpbWVyaWRpYW4uIElmIGB0cnVlYCwgdGhlXG5cdFx0Ly8gR3JpZExheWVyIHdpbGwgb25seSBiZSBkaXNwbGF5ZWQgb25jZSBhdCBsb3cgem9vbSBsZXZlbHMuIEhhcyBub1xuXHRcdC8vIGVmZmVjdCB3aGVuIHRoZSBbbWFwIENSU10oI21hcC1jcnMpIGRvZXNuJ3Qgd3JhcCBhcm91bmQuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cblx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fcmVzZXRWaWV3KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0XHRtYXAuX3JlbW92ZVpvb21MaW1pdCh0aGlzKTtcblx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuX3RpbGVab29tID0gbnVsbDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdEwuRG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjazogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0TC5Eb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1pbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0QXR0cmlidXRpb246IFN0cmluZ1xuXHQvLyBVc2VkIGJ5IHRoZSBgYXR0cmlidXRpb24gY29udHJvbGAsIHJldHVybnMgdGhlIFthdHRyaWJ1dGlvbiBvcHRpb25dKCNncmlkbGF5ZXItYXR0cmlidXRpb24pLlxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb247XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG5cdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG5cdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSB7XG5cdFx0XHR2aWV3cHJlcmVzZXQ6IHRoaXMuX2ludmFsaWRhdGVBbGwsXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0Vmlldyxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX29uTW92ZUVuZFxuXHRcdH07XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xuXHRcdFx0Ly8gdXBkYXRlIHRpbGVzIG9uIG1vdmUsIGJ1dCBub3QgbW9yZSBvZnRlbiB0aGFuIG9uY2UgcGVyIGdpdmVuIGludGVydmFsXG5cdFx0XHRpZiAoIXRoaXMuX29uTW92ZSkge1xuXHRcdFx0XHR0aGlzLl9vbk1vdmUgPSBMLlV0aWwudGhyb3R0bGUodGhpcy5fb25Nb3ZlRW5kLCB0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudHMubW92ZSA9IHRoaXMuX29uTW92ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uIEV4dGVuc2lvbiBtZXRob2RzXG5cdC8vIExheWVycyBleHRlbmRpbmcgYEdyaWRMYXllcmAgc2hhbGwgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXG5cdC8vIEBtZXRob2QgY3JlYXRlVGlsZShjb29yZHM6IE9iamVjdCwgZG9uZT86IEZ1bmN0aW9uKTogSFRNTEVsZW1lbnRcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgbXVzdCBiZSBvdmVycmlkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgTC5Qb2ludCA/IHMgOiBuZXcgTC5Qb2ludChzLCBzKTtcblx0fSxcblxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLnpJbmRleCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRBdXRvWkluZGV4OiBmdW5jdGlvbiAoY29tcGFyZSkge1xuXHRcdC8vIGdvIHRocm91Z2ggYWxsIG90aGVyIGxheWVycyBvZiB0aGUgc2FtZSBwYW5lLCBzZXQgekluZGV4IHRvIG1heCArIDEgKGZyb250KSBvciBtaW4gLSAxIChiYWNrKVxuXG5cdFx0dmFyIGxheWVycyA9IHRoaXMuZ2V0UGFuZSgpLmNoaWxkcmVuLFxuXHRcdCAgICBlZGdlWkluZGV4ID0gLWNvbXBhcmUoLUluZmluaXR5LCBJbmZpbml0eSk7IC8vIC1JbmZpbml0eSBmb3IgbWF4LCBJbmZpbml0eSBmb3IgbWluXG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aCwgekluZGV4OyBpIDwgbGVuOyBpKyspIHtcblxuXHRcdFx0ekluZGV4ID0gbGF5ZXJzW2ldLnN0eWxlLnpJbmRleDtcblxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyICYmIHpJbmRleCkge1xuXHRcdFx0XHRlZGdlWkluZGV4ID0gY29tcGFyZShlZGdlWkluZGV4LCArekluZGV4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNGaW5pdGUoZWRnZVpJbmRleCkpIHtcblx0XHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSBlZGdlWkluZGV4ICsgY29tcGFyZSgtMSwgMSk7XG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cblxuXHRcdC8vIElFIGRvZXNuJ3QgaW5oZXJpdCBmaWx0ZXIgb3BhY2l0eSBwcm9wZXJseSwgc28gd2UncmUgZm9yY2VkIHRvIHNldCBpdCBvbiB0aWxlc1xuXHRcdGlmIChMLkJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcblxuXHRcdHZhciBub3cgPSArbmV3IERhdGUoKSxcblx0XHQgICAgbmV4dEZyYW1lID0gZmFsc2UsXG5cdFx0ICAgIHdpbGxQcnVuZSA9IGZhbHNlO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG5cdFx0XHRpZiAoIXRpbGUuY3VycmVudCB8fCAhdGlsZS5sb2FkZWQpIHsgY29udGludWU7IH1cblxuXHRcdFx0dmFyIGZhZGUgPSBNYXRoLm1pbigxLCAobm93IC0gdGlsZS5sb2FkZWQpIC8gMjAwKTtcblxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGlsZS5lbCwgZmFkZSk7XG5cdFx0XHRpZiAoZmFkZSA8IDEpIHtcblx0XHRcdFx0bmV4dEZyYW1lID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aWxlLmFjdGl2ZSkgeyB3aWxsUHJ1bmUgPSB0cnVlOyB9XG5cdFx0XHRcdHRpbGUuYWN0aXZlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAod2lsbFBydW5lICYmICF0aGlzLl9ub1BydW5lKSB7IHRoaXMuX3BydW5lVGlsZXMoKTsgfVxuXG5cdFx0aWYgKG5leHRGcmFtZSkge1xuXHRcdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fdXBkYXRlT3BhY2l0eSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0aWYgKHRoaXMuX2xldmVsc1t6XS5lbC5jaGlsZHJlbi5sZW5ndGggfHwgeiA9PT0gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9sZXZlbHNbel0uZWwuc3R5bGUuekluZGV4ID0gbWF4Wm9vbSAtIE1hdGguYWJzKHpvb20gLSB6KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fbGV2ZWxzW3pdLmVsKTtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oeik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9sZXZlbHNbel07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAoIWxldmVsKSB7XG5cdFx0XHRsZXZlbCA9IHRoaXMuX2xldmVsc1t6b29tXSA9IHt9O1xuXG5cdFx0XHRsZXZlbC5lbCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0TC5VdGlsLmZhbHNlRm4obGV2ZWwuZWwub2Zmc2V0V2lkdGgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xldmVsID0gbGV2ZWw7XG5cblx0XHRyZXR1cm4gbGV2ZWw7XG5cdH0sXG5cblx0X3BydW5lVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBrZXksIHRpbGU7XG5cblx0XHR2YXIgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fFxuXHRcdFx0em9vbSA8IHRoaXMub3B0aW9ucy5taW5ab29tKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdHRpbGUucmV0YWluID0gdGlsZS5jdXJyZW50O1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRcdGlmICh0aWxlLmN1cnJlbnQgJiYgIXRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSB0aWxlLmNvb3Jkcztcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXRhaW5QYXJlbnQoY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogLSA1KSkge1xuXHRcdFx0XHRcdHRoaXMuX3JldGFpbkNoaWxkcmVuKGNvb3Jkcy54LCBjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy56ICsgMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLnJldGFpbikge1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVUaWxlc0F0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdGlmICh0aGlzLl90aWxlc1trZXldLmNvb3Jkcy56ICE9PSB6b29tKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlQWxsVGlsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHR9XG5cdH0sXG5cblx0X2ludmFsaWRhdGVBbGw6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gbnVsbDtcblx0fSxcblxuXHRfcmV0YWluUGFyZW50OiBmdW5jdGlvbiAoeCwgeSwgeiwgbWluWm9vbSkge1xuXHRcdHZhciB4MiA9IE1hdGguZmxvb3IoeCAvIDIpLFxuXHRcdCAgICB5MiA9IE1hdGguZmxvb3IoeSAvIDIpLFxuXHRcdCAgICB6MiA9IHogLSAxLFxuXHRcdCAgICBjb29yZHMyID0gbmV3IEwuUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBMLlBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHogKyAxO1xuXG5cdFx0XHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKSxcblx0XHRcdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0XHRcdGlmICh0aWxlICYmIHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0dGlsZS5yZXRhaW4gPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAodGlsZSAmJiB0aWxlLmxvYWRlZCkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6ICsgMSA8IG1heFpvb20pIHtcblx0XHRcdFx0XHR0aGlzLl9yZXRhaW5DaGlsZHJlbihpLCBqLCB6ICsgMSwgbWF4Wm9vbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgYW5pbWF0aW5nID0gZSAmJiAoZS5waW5jaCB8fCBlLmZseVRvKTtcblx0XHR0aGlzLl9zZXRWaWV3KHRoaXMuX21hcC5nZXRDZW50ZXIoKSwgdGhpcy5fbWFwLmdldFpvb20oKSwgYW5pbWF0aW5nLCBhbmltYXRpbmcpO1xuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl9zZXRWaWV3KGUuY2VudGVyLCBlLnpvb20sIHRydWUsIGUubm9VcGRhdGUpO1xuXHR9LFxuXG5cdF9zZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBub1BydW5lLCBub1VwZGF0ZSkge1xuXHRcdHZhciB0aWxlWm9vbSA9IE1hdGgucm91bmQoem9vbSk7XG5cdFx0aWYgKCh0aGlzLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHx8XG5cdFx0ICAgICh0aGlzLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHRpbGVab29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pKSB7XG5cdFx0XHR0aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR2YXIgdGlsZVpvb21DaGFuZ2VkID0gdGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nICYmICh0aWxlWm9vbSAhPT0gdGhpcy5fdGlsZVpvb20pO1xuXG5cdFx0aWYgKCFub1VwZGF0ZSB8fCB0aWxlWm9vbUNoYW5nZWQpIHtcblxuXHRcdFx0dGhpcy5fdGlsZVpvb20gPSB0aWxlWm9vbTtcblxuXHRcdFx0aWYgKHRoaXMuX2Fib3J0TG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9hYm9ydExvYWRpbmcoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fdXBkYXRlTGV2ZWxzKCk7XG5cdFx0XHR0aGlzLl9yZXNldEdyaWQoKTtcblxuXHRcdFx0aWYgKHRpbGVab29tICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGNlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghbm9QcnVuZSkge1xuXHRcdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZsYWcgdG8gcHJldmVudCBfdXBkYXRlT3BhY2l0eSBmcm9tIHBydW5pbmcgdGlsZXMgZHVyaW5nXG5cdFx0XHQvLyBhIHpvb20gYW5pbSBvciBhIHBpbmNoIGdlc3R1cmVcblx0XHRcdHRoaXMuX25vUHJ1bmUgPSAhIW5vUHJ1bmU7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXMoY2VudGVyLCB6b29tKTtcblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybXM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0dGhpcy5fc2V0Wm9vbVRyYW5zZm9ybSh0aGlzLl9sZXZlbHNbaV0sIGNlbnRlciwgem9vbSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tVHJhbnNmb3JtOiBmdW5jdGlvbiAobGV2ZWwsIGNlbnRlciwgem9vbSkge1xuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoem9vbSwgbGV2ZWwuem9vbSksXG5cdFx0ICAgIHRyYW5zbGF0ZSA9IGxldmVsLm9yaWdpbi5tdWx0aXBseUJ5KHNjYWxlKVxuXHRcdCAgICAgICAgLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSkucm91bmQoKTtcblxuXHRcdGlmIChMLkJyb3dzZXIuYW55M2QpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24obGV2ZWwuZWwsIHRyYW5zbGF0ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldEdyaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnMsXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIHRpbGVab29tID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHModGhpcy5fdGlsZVpvb20pO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHRoaXMuX2dsb2JhbFRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UoYm91bmRzKTtcblx0XHR9XG5cblx0XHR0aGlzLl93cmFwWCA9IGNycy53cmFwTG5nICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzBdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbMCwgY3JzLndyYXBMbmdbMV1dLCB0aWxlWm9vbSkueCAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0XHR0aGlzLl93cmFwWSA9IGNycy53cmFwTGF0ICYmICF0aGlzLm9wdGlvbnMubm9XcmFwICYmIFtcblx0XHRcdE1hdGguZmxvb3IobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzBdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS54KSxcblx0XHRcdE1hdGguY2VpbChtYXAucHJvamVjdChbY3JzLndyYXBMYXRbMV0sIDBdLCB0aWxlWm9vbSkueSAvIHRpbGVTaXplLnkpXG5cdFx0XTtcblx0fSxcblxuXHRfb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2dldFRpbGVkUGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBtYXBab29tID0gbWFwLl9hbmltYXRpbmdab29tID8gTWF0aC5tYXgobWFwLl9hbmltYXRlVG9ab29tLCBtYXAuZ2V0Wm9vbSgpKSA6IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNjYWxlID0gbWFwLmdldFpvb21TY2FsZShtYXBab29tLCB0aGlzLl90aWxlWm9vbSksXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gbWFwLnByb2plY3QoY2VudGVyLCB0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxcblx0XHQgICAgaGFsZlNpemUgPSBtYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KHNjYWxlICogMik7XG5cblx0XHRyZXR1cm4gbmV3IEwuQm91bmRzKHBpeGVsQ2VudGVyLnN1YnRyYWN0KGhhbGZTaXplKSwgcGl4ZWxDZW50ZXIuYWRkKGhhbGZTaXplKSk7XG5cdH0sXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2QgdG8gbG9hZCB0aWxlcyBpbiB0aGUgZ3JpZCdzIGFjdGl2ZSB6b29tIGxldmVsIGFjY29yZGluZyB0byBtYXAgYm91bmRzXG5cdF91cGRhdGU6IGZ1bmN0aW9uIChjZW50ZXIpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxuXHRcdHZhciB6b29tID0gbWFwLmdldFpvb20oKTtcblxuXHRcdGlmIChjZW50ZXIgPT09IHVuZGVmaW5lZCkgeyBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7IH1cblx0XHRpZiAodGhpcy5fdGlsZVpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cdC8vIGlmIG91dCBvZiBtaW56b29tL21heHpvb21cblxuXHRcdHZhciBwaXhlbEJvdW5kcyA9IHRoaXMuX2dldFRpbGVkUGl4ZWxCb3VuZHMoY2VudGVyKSxcblx0XHQgICAgdGlsZVJhbmdlID0gdGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShwaXhlbEJvdW5kcyksXG5cdFx0ICAgIHRpbGVDZW50ZXIgPSB0aWxlUmFuZ2UuZ2V0Q2VudGVyKCksXG5cdFx0ICAgIHF1ZXVlID0gW10sXG5cdFx0ICAgIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLFxuXHRcdCAgICBub1BydW5lUmFuZ2UgPSBuZXcgTC5Cb3VuZHModGlsZVJhbmdlLmdldEJvdHRvbUxlZnQoKS5zdWJ0cmFjdChbbWFyZ2luLCAtbWFyZ2luXSksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZVJhbmdlLmdldFRvcFJpZ2h0KCkuYWRkKFttYXJnaW4sIC1tYXJnaW5dKSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHZhciBjID0gdGhpcy5fdGlsZXNba2V5XS5jb29yZHM7XG5cdFx0XHRpZiAoYy56ICE9PSB0aGlzLl90aWxlWm9vbSB8fCAhbm9QcnVuZVJhbmdlLmNvbnRhaW5zKEwucG9pbnQoYy54LCBjLnkpKSkge1xuXHRcdFx0XHR0aGlzLl90aWxlc1trZXldLmN1cnJlbnQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBfdXBkYXRlIGp1c3QgbG9hZHMgbW9yZSB0aWxlcy4gSWYgdGhlIHRpbGUgem9vbSBsZXZlbCBkaWZmZXJzIHRvbyBtdWNoXG5cdFx0Ly8gZnJvbSB0aGUgbWFwJ3MsIGxldCBfc2V0VmlldyByZXNldCBsZXZlbHMgYW5kIHBydW5lIG9sZCB0aWxlcy5cblx0XHRpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMuX3RpbGVab29tKSA+IDEpIHsgdGhpcy5fc2V0VmlldyhjZW50ZXIsIHpvb20pOyByZXR1cm47IH1cblxuXHRcdC8vIGNyZWF0ZSBhIHF1ZXVlIG9mIGNvb3JkaW5hdGVzIHRvIGxvYWQgdGlsZXMgZnJvbVxuXHRcdGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluLnk7IGogPD0gdGlsZVJhbmdlLm1heC55OyBqKyspIHtcblx0XHRcdGZvciAodmFyIGkgPSB0aWxlUmFuZ2UubWluLng7IGkgPD0gdGlsZVJhbmdlLm1heC54OyBpKyspIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBMLlBvaW50KGksIGopO1xuXHRcdFx0XHRjb29yZHMueiA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0XHRcdGlmICghdGhpcy5faXNWYWxpZFRpbGUoY29vcmRzKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyldO1xuXHRcdFx0XHRpZiAodGlsZSkge1xuXHRcdFx0XHRcdHRpbGUuY3VycmVudCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjb29yZHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCB0aWxlIHF1ZXVlIHRvIGxvYWQgdGlsZXMgaW4gb3JkZXIgb2YgdGhlaXIgZGlzdGFuY2UgdG8gY2VudGVyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKSAtIGIuZGlzdGFuY2VUbyh0aWxlQ2VudGVyKTtcblx0XHR9KTtcblxuXHRcdGlmIChxdWV1ZS5sZW5ndGggIT09IDApIHtcblx0XHRcdC8vIGlmIGl0J3MgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcblx0XHRcdGlmICghdGhpcy5fbG9hZGluZykge1xuXHRcdFx0XHR0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0Ly8gQGV2ZW50IGxvYWRpbmc6IEV2ZW50XG5cdFx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgc3RhcnRzIGxvYWRpbmcgdGlsZXMuXG5cdFx0XHRcdHRoaXMuZmlyZSgnbG9hZGluZycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgRE9NIGZyYWdtZW50IHRvIGFwcGVuZCB0aWxlcyBpbiBvbmUgYmF0Y2hcblx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX2FkZFRpbGUocXVldWVbaV0sIGZyYWdtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGV2ZWwuZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfaXNWYWxpZFRpbGU6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzO1xuXG5cdFx0aWYgKCFjcnMuaW5maW5pdGUpIHtcblx0XHRcdC8vIGRvbid0IGxvYWQgdGlsZSBpZiBpdCdzIG91dCBvZiBib3VuZHMgYW5kIG5vdCB3cmFwcGVkXG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlO1xuXHRcdFx0aWYgKCghY3JzLndyYXBMbmcgJiYgKGNvb3Jkcy54IDwgYm91bmRzLm1pbi54IHx8IGNvb3Jkcy54ID4gYm91bmRzLm1heC54KSkgfHxcblx0XHRcdCAgICAoIWNycy53cmFwTGF0ICYmIChjb29yZHMueSA8IGJvdW5kcy5taW4ueSB8fCBjb29yZHMueSA+IGJvdW5kcy5tYXgueSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5vcHRpb25zLmJvdW5kcykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHRoZSBib3VuZHMgaW4gb3B0aW9uc1xuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3Jkcyk7XG5cdFx0cmV0dXJuIEwubGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cblx0XHQgICAgbndQb2ludCA9IGNvb3Jkcy5zY2FsZUJ5KHRpbGVTaXplKSxcblx0XHQgICAgc2VQb2ludCA9IG53UG9pbnQuYWRkKHRpbGVTaXplKSxcblxuXHRcdCAgICBudyA9IG1hcC51bnByb2plY3QobndQb2ludCwgY29vcmRzLnopLFxuXHRcdCAgICBzZSA9IG1hcC51bnByb2plY3Qoc2VQb2ludCwgY29vcmRzLnopO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRudyA9IG1hcC53cmFwTGF0TG5nKG53KTtcblx0XHRcdHNlID0gbWFwLndyYXBMYXRMbmcoc2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMobncsIHNlKTtcblx0fSxcblxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBMLlBvaW50KCtrWzBdLCAra1sxXSk7XG5cdFx0Y29vcmRzLnogPSAra1syXTtcblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9LFxuXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGlsZS5lbCk7XG5cblx0XHRkZWxldGUgdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdC8vIEBldmVudCB0aWxldW5sb2FkOiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZW1vdmVkIChlLmcuIHdoZW4gYSB0aWxlIGdvZXMgb2ZmIHRoZSBzY3JlZW4pLlxuXHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHtcblx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRjb29yZHM6IHRoaXMuX2tleVRvVGlsZUNvb3JkcyhrZXkpXG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBMLlV0aWwuZmFsc2VGbjtcblx0XHR0aWxlLm9ubW91c2Vtb3ZlID0gTC5VdGlsLmZhbHNlRm47XG5cblx0XHQvLyB1cGRhdGUgb3BhY2l0eSBvbiB0aWxlcyBpbiBJRTctOCBiZWNhdXNlIG9mIGZpbHRlciBpbmhlcml0YW5jZSBwcm9ibGVtc1xuXHRcdGlmIChMLkJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0fVxuXG5cdFx0Ly8gd2l0aG91dCB0aGlzIGhhY2ssIHRpbGVzIGRpc2FwcGVhciBhZnRlciB6b29tIG9uIENocm9tZSBmb3IgQW5kcm9pZFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwNzhcblx0XHRpZiAoTC5Ccm93c2VyLmFuZHJvaWQgJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMpIHtcblx0XHRcdHRpbGUuc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAoY29vcmRzLCBjb250YWluZXIpIHtcblx0XHR2YXIgdGlsZVBvcyA9IHRoaXMuX2dldFRpbGVQb3MoY29vcmRzKSxcblx0XHQgICAga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR2YXIgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZSh0aGlzLl93cmFwQ29vcmRzKGNvb3JkcyksIEwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcykpO1xuXG5cdFx0dGhpcy5faW5pdFRpbGUodGlsZSk7XG5cblx0XHQvLyBpZiBjcmVhdGVUaWxlIGlzIGRlZmluZWQgd2l0aCBhIHNlY29uZCBhcmd1bWVudCAoXCJkb25lXCIgY2FsbGJhY2spLFxuXHRcdC8vIHdlIGtub3cgdGhhdCB0aWxlIGlzIGFzeW5jIGFuZCB3aWxsIGJlIHJlYWR5IGxhdGVyOyBvdGhlcndpc2Vcblx0XHRpZiAodGhpcy5jcmVhdGVUaWxlLmxlbmd0aCA8IDIpIHtcblx0XHRcdC8vIG1hcmsgdGlsZSBhcyByZWFkeSwgYnV0IGRlbGF5IG9uZSBmcmFtZSBmb3Igb3BhY2l0eSBhbmltYXRpb24gdG8gaGFwcGVuXG5cdFx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShMLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMsIG51bGwsIHRpbGUpKTtcblx0XHR9XG5cblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cblx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcblx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0ZWw6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkcyxcblx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHR9O1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcblx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKGVycikge1xuXHRcdFx0Ly8gQGV2ZW50IHRpbGVlcnJvcjogVGlsZUVycm9yRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgbG9hZGluZyBhIHRpbGUuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVlcnJvcicsIHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0dGlsZTogdGlsZSxcblx0XHRcdFx0Y29vcmRzOiBjb29yZHNcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKTtcblxuXHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cblxuXHRcdHRpbGUubG9hZGVkID0gK25ldyBEYXRlKCk7XG5cdFx0aWYgKHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCAwKTtcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHR0aGlzLl9wcnVuZVRpbGVzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlcnIpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aWxlLmVsLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xuXG5cdFx0XHQvLyBAZXZlbnQgdGlsZWxvYWQ6IFRpbGVFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRpbGUgbG9hZHMuXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVsb2FkJywge1xuXHRcdFx0XHR0aWxlOiB0aWxlLmVsLFxuXHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX25vVGlsZXNUb0xvYWQoKSkge1xuXHRcdFx0dGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZSBncmlkIGxheWVyIGxvYWRlZCBhbGwgdmlzaWJsZSB0aWxlcy5cblx0XHRcdHRoaXMuZmlyZSgnbG9hZCcpO1xuXG5cdFx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBiaXQgbW9yZSB0aGFuIDAuMiBzZWNzICh0aGUgZHVyYXRpb24gb2YgdGhlIHRpbGUgZmFkZS1pbilcblx0XHRcdFx0Ly8gdG8gdHJpZ2dlciBhIHBydW5pbmcuXG5cdFx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3BydW5lVGlsZXMsIHRoaXMpLCAyNTApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMuc2NhbGVCeSh0aGlzLmdldFRpbGVTaXplKCkpLnN1YnRyYWN0KHRoaXMuX2xldmVsLm9yaWdpbik7XG5cdH0sXG5cblx0X3dyYXBDb29yZHM6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHR2YXIgbmV3Q29vcmRzID0gbmV3IEwuUG9pbnQoXG5cdFx0XHR0aGlzLl93cmFwWCA/IEwuVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gTC5VdGlsLndyYXBOdW0oY29vcmRzLnksIHRoaXMuX3dyYXBZKSA6IGNvb3Jkcy55KTtcblx0XHRuZXdDb29yZHMueiA9IGNvb3Jkcy56O1xuXHRcdHJldHVybiBuZXdDb29yZHM7XG5cdH0sXG5cblx0X3B4Qm91bmRzVG9UaWxlUmFuZ2U6IGZ1bmN0aW9uIChib3VuZHMpIHtcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0cmV0dXJuIG5ldyBMLkJvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4udW5zY2FsZUJ5KHRpbGVTaXplKS5mbG9vcigpLFxuXHRcdFx0Ym91bmRzLm1heC51bnNjYWxlQnkodGlsZVNpemUpLmNlaWwoKS5zdWJ0cmFjdChbMSwgMV0pKTtcblx0fSxcblxuXHRfbm9UaWxlc1RvTG9hZDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKCF0aGlzLl90aWxlc1trZXldLmxvYWRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLmdyaWRMYXllcihvcHRpb25zPzogR3JpZExheWVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEdyaWRMYXllciB3aXRoIHRoZSBzdXBwbGllZCBvcHRpb25zLlxuTC5ncmlkTGF5ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuR3JpZExheWVyKG9wdGlvbnMpO1xufTtcblxuLypcclxuICogQGNsYXNzIFRpbGVMYXllclxyXG4gKiBAaW5oZXJpdHMgR3JpZExheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXJcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYEdyaWRMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwudGlsZUxheWVyKCdodHRwOi8ve3N9LnRpbGUub3NtLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJ30pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAc2VjdGlvbiBVUkwgdGVtcGxhdGVcclxuICogQGV4YW1wbGVcclxuICpcclxuICogQSBzdHJpbmcgb2YgdGhlIGZvbGxvd2luZyBmb3JtOlxyXG4gKlxyXG4gKiBgYGBcclxuICogJ2h0dHA6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBAMnggdG8gdGhlIFVSTCB0byBsb2FkIHJldGluYSB0aWxlcy5cclxuICpcclxuICogWW91IGNhbiB1c2UgY3VzdG9tIGtleXMgaW4gdGhlIHRlbXBsYXRlLCB3aGljaCB3aWxsIGJlIFtldmFsdWF0ZWRdKCN1dGlsLXRlbXBsYXRlKSBmcm9tIFRpbGVMYXllciBvcHRpb25zLCBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBMLnRpbGVMYXllcignaHR0cDovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuTC5UaWxlTGF5ZXIgPSBMLkdyaWRMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcclxuXHRcdC8vIE1pbmltdW0gem9vbSBudW1iZXIuXHJcblx0XHRtaW5ab29tOiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWF4Wm9vbTogTnVtYmVyID0gMThcclxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIuXHJcblx0XHRtYXhab29tOiAxOCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heE5hdGl2ZVpvb206IE51bWJlciA9IG51bGxcclxuXHRcdC8vIE1heGltdW0gem9vbSBudW1iZXIgdGhlIHRpbGUgc291cmNlIGhhcyBhdmFpbGFibGUuIElmIGl0IGlzIHNwZWNpZmllZCxcclxuXHRcdC8vIHRoZSB0aWxlcyBvbiBhbGwgem9vbSBsZXZlbHMgaGlnaGVyIHRoYW4gYG1heE5hdGl2ZVpvb21gIHdpbGwgYmUgbG9hZGVkXHJcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXHJcblx0XHRtYXhOYXRpdmVab29tOiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc3ViZG9tYWluczogU3RyaW5nfFN0cmluZ1tdID0gJ2FiYydcclxuXHRcdC8vIFN1YmRvbWFpbnMgb2YgdGhlIHRpbGUgc2VydmljZS4gQ2FuIGJlIHBhc3NlZCBpbiB0aGUgZm9ybSBvZiBvbmUgc3RyaW5nICh3aGVyZSBlYWNoIGxldHRlciBpcyBhIHN1YmRvbWFpbiBuYW1lKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBlcnJvclRpbGVVcmw6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBVUkwgdG8gdGhlIHRpbGUgaW1hZ2UgdG8gc2hvdyBpbiBwbGFjZSBvZiB0aGUgdGlsZSB0aGF0IGZhaWxlZCB0byBsb2FkLlxyXG5cdFx0ZXJyb3JUaWxlVXJsOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIFRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIG9mZnNldCB3aXRoIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tT2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdG1zOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgaW52ZXJzZXMgWSBheGlzIG51bWJlcmluZyBmb3IgdGlsZXMgKHR1cm4gdGhpcyBvbiBmb3IgW1RNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlsZV9NYXBfU2VydmljZSkgc2VydmljZXMpLlxyXG5cdFx0dG1zOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21SZXZlcnNlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHNldCB0byB0cnVlLCB0aGUgem9vbSBudW1iZXIgdXNlZCBpbiB0aWxlIFVSTHMgd2lsbCBiZSByZXZlcnNlZCAoYG1heFpvb20gLSB6b29tYCBpbnN0ZWFkIG9mIGB6b29tYClcclxuXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGRldGVjdFJldGluYTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAgYW5kIHVzZXIgaXMgb24gYSByZXRpbmEgZGlzcGxheSwgaXQgd2lsbCByZXF1ZXN0IGZvdXIgdGlsZXMgb2YgaGFsZiB0aGUgc3BlY2lmaWVkIHNpemUgYW5kIGEgYmlnZ2VyIHpvb20gbGV2ZWwgaW4gcGxhY2Ugb2Ygb25lIHRvIHV0aWxpemUgdGhlIGhpZ2ggcmVzb2x1dGlvbi5cclxuXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjcm9zc09yaWdpbjogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiB0cnVlLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gJycuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHRjcm9zc09yaWdpbjogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tLS07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0LS07XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9wdGlvbnMubWluWm9vbSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzEzN1xyXG5cdFx0aWYgKCFMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHR0aGlzLm9uKCd0aWxldW5sb2FkJywgdGhpcy5fb25UaWxlUmVtb3ZlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZywgbm9SZWRyYXc/OiBCb29sZWFuKTogdGhpc1xyXG5cdC8vIFVwZGF0ZXMgdGhlIGxheWVyJ3MgVVJMIHRlbXBsYXRlIGFuZCByZWRyYXdzIGl0ICh1bmxlc3MgYG5vUmVkcmF3YCBpcyBzZXQgdG8gYHRydWVgKS5cclxuXHRzZXRVcmw6IGZ1bmN0aW9uICh1cmwsIG5vUmVkcmF3KSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9waWF0ZSBpbWFnZSBVUkwgZ2l2ZW4gYGNvb3Jkc2AuIFRoZSBgZG9uZWBcclxuXHQvLyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGlsZSBoYXMgYmVlbiBsb2FkZWQuXHJcblx0Y3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgZG9uZSkge1xyXG5cdFx0dmFyIHRpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRpbGUsICdsb2FkJywgTC5iaW5kKHRoaXMuX3RpbGVPbkxvYWQsIHRoaXMsIGRvbmUsIHRpbGUpKTtcclxuXHRcdEwuRG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgTC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbikge1xyXG5cdFx0XHR0aWxlLmNyb3NzT3JpZ2luID0gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCBBbHQgdGFnIGlzIHNldCB0byBlbXB0eSBzdHJpbmcgdG8ga2VlcCBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgVVJMIGFuZCBmb3IgY29tcGxpYW5jZSByZWFzb25zXHJcblx0XHQgaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0g2N1xyXG5cdFx0Ki9cclxuXHRcdHRpbGUuYWx0ID0gJyc7XHJcblxyXG5cdFx0dGlsZS5zcmMgPSB0aGlzLmdldFRpbGVVcmwoY29vcmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG5cdC8vIEB1bmluaGVyaXRhYmxlXHJcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgVGlsZUxheWVyYCBtaWdodCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuXHQvLyBAbWV0aG9kIGdldFRpbGVVcmwoY29vcmRzOiBPYmplY3QpOiBTdHJpbmdcclxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCByZXR1cm5zIHRoZSBVUkwgZm9yIGEgdGlsZSBnaXZlbiBpdHMgY29vcmRpbmF0ZXMuXHJcblx0Ly8gQ2xhc3NlcyBleHRlbmRpbmcgYFRpbGVMYXllcmAgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSBjdXN0b20gdGlsZSBVUkwgbmFtaW5nIHNjaGVtZXMuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdHI6IEwuQnJvd3Nlci5yZXRpbmEgPyAnQDJ4JyA6ICcnLFxyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4oY29vcmRzKSxcclxuXHRcdFx0eDogY29vcmRzLngsXHJcblx0XHRcdHk6IGNvb3Jkcy55LFxyXG5cdFx0XHR6OiB0aGlzLl9nZXRab29tRm9yVXJsKClcclxuXHRcdH07XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAub3B0aW9ucy5jcnMuaW5maW5pdGUpIHtcclxuXHRcdFx0dmFyIGludmVydGVkWSA9IHRoaXMuX2dsb2JhbFRpbGVSYW5nZS5tYXgueSAtIGNvb3Jkcy55O1xyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRtcykge1xyXG5cdFx0XHRcdGRhdGFbJ3knXSA9IGludmVydGVkWTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhWycteSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLlV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBMLmV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKGRvbmUsIHRoaXMsIG51bGwsIHRpbGUpLCAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRvbmUobnVsbCwgdGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoZG9uZSwgdGlsZSwgZSkge1xyXG5cdFx0dmFyIGVycm9yVXJsID0gdGhpcy5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IEwuR3JpZExheWVyLnByb3RvdHlwZS5nZXRUaWxlU2l6ZS5jYWxsKHRoaXMpLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl90aWxlWm9vbSArIHRoaXMub3B0aW9ucy56b29tT2Zmc2V0LFxyXG5cdFx0ICAgIHpvb21OID0gdGhpcy5vcHRpb25zLm1heE5hdGl2ZVpvb207XHJcblxyXG5cdFx0Ly8gaW5jcmVhc2UgdGlsZSBzaXplIHdoZW4gb3ZlcnNjYWxpbmdcclxuXHRcdHJldHVybiB6b29tTiAhPT0gbnVsbCAmJiB6b29tID4gem9vbU4gP1xyXG5cdFx0XHRcdHRpbGVTaXplLmRpdmlkZUJ5KG1hcC5nZXRab29tU2NhbGUoem9vbU4sIHpvb20pKS5yb3VuZCgpIDpcclxuXHRcdFx0XHR0aWxlU2l6ZTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcclxuXHRcdCAgICB6b29tID0gdGhpcy5fdGlsZVpvb207XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG9wdGlvbnMubWF4Wm9vbSAtIHpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0em9vbSArPSBvcHRpb25zLnpvb21PZmZzZXQ7XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnMubWF4TmF0aXZlWm9vbSAhPT0gbnVsbCA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4TmF0aXZlWm9vbSkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTdWJkb21haW46IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguYWJzKHRpbGVQb2ludC54ICsgdGlsZVBvaW50LnkpICUgdGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5zdWJkb21haW5zW2luZGV4XTtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9hYm9ydExvYWRpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLCB0aWxlO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGlmICh0aGlzLl90aWxlc1tpXS5jb29yZHMueiAhPT0gdGhpcy5fdGlsZVpvb20pIHtcclxuXHRcdFx0XHR0aWxlID0gdGhpcy5fdGlsZXNbaV0uZWw7XHJcblxyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gTC5VdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBMLlV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHRcdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5MLnRpbGVMYXllciA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIFRpbGVMYXllci5XTVNcclxuICogQGluaGVyaXRzIFRpbGVMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyLldNU1xyXG4gKiBVc2VkIHRvIGRpc3BsYXkgW1dNU10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV2ViX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcyBhcyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBUaWxlTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbmV4cmFkID0gTC50aWxlTGF5ZXIud21zKFwiaHR0cDovL21lc29uZXQuYWdyb24uaWFzdGF0ZS5lZHUvY2dpLWJpbi93bXMvbmV4cmFkL24wci5jZ2lcIiwge1xyXG4gKiBcdGxheWVyczogJ25leHJhZC1uMHItOTAwOTEzJyxcclxuICogXHRmb3JtYXQ6ICdpbWFnZS9wbmcnLFxyXG4gKiBcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gKiBcdGF0dHJpYnV0aW9uOiBcIldlYXRoZXIgZGF0YSDCqSAyMDEyIElFTSBOZXhyYWRcIlxyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5UaWxlTGF5ZXIuV01TID0gTC5UaWxlTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllci5XTVMgb3B0aW9uc1xyXG5cdC8vIElmIGFueSBjdXN0b20gb3B0aW9ucyBub3QgZG9jdW1lbnRlZCBoZXJlIGFyZSB1c2VkLCB0aGV5IHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQvLyBXTVMgc2VydmVyIGFzIGV4dHJhIHBhcmFtZXRlcnMgaW4gZWFjaCByZXF1ZXN0IFVSTC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxyXG5cdC8vIFtub24tc3RhbmRhcmQgdmVuZG9yIFdNUyBwYXJhbWV0ZXJzXShodHRwOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IEwuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRXbXNQYXJhbXMpO1xyXG5cclxuXHRcdC8vIGFsbCBrZXlzIHRoYXQgYXJlIG5vdCBUaWxlTGF5ZXIgb3B0aW9ucyBnbyB0byBXTVMgcGFyYW1zXHJcblx0XHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKCEoaSBpbiB0aGlzLm9wdGlvbnMpKSB7XHJcblx0XHRcdFx0d21zUGFyYW1zW2ldID0gb3B0aW9uc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0d21zUGFyYW1zLndpZHRoID0gd21zUGFyYW1zLmhlaWdodCA9IG9wdGlvbnMudGlsZVNpemUgKiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgTC5Ccm93c2VyLnJldGluYSA/IDIgOiAxKTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdEwuVGlsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGlsZVVybDogZnVuY3Rpb24gKGNvb3Jkcykge1xyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gdGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKGNvb3JkcyksXHJcblx0XHQgICAgbncgPSB0aGlzLl9jcnMucHJvamVjdCh0aWxlQm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICBzZSA9IHRoaXMuX2Nycy5wcm9qZWN0KHRpbGVCb3VuZHMuZ2V0U291dGhFYXN0KCkpLFxyXG5cclxuXHRcdCAgICBiYm94ID0gKHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zICYmIHRoaXMuX2NycyA9PT0gTC5DUlMuRVBTRzQzMjYgP1xyXG5cdFx0XHQgICAgW3NlLnksIG53LngsIG53LnksIHNlLnhdIDpcclxuXHRcdFx0ICAgIFtudy54LCBzZS55LCBzZS54LCBudy55XSkuam9pbignLCcpLFxyXG5cclxuXHRcdCAgICB1cmwgPSBMLlRpbGVMYXllci5wcm90b3R5cGUuZ2V0VGlsZVVybC5jYWxsKHRoaXMsIGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHVybCArXHJcblx0XHRcdEwuVXRpbC5nZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRMLmV4dGVuZCh0aGlzLndtc1BhcmFtcywgcGFyYW1zKTtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVMYXllci53bXMoYmFzZVVybDogU3RyaW5nLCBvcHRpb25zOiBUaWxlTGF5ZXIuV01TIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIFdNUyB0aWxlIGxheWVyIG9iamVjdCBnaXZlbiBhIGJhc2UgVVJMIG9mIHRoZSBXTVMgc2VydmljZSBhbmQgYSBXTVMgcGFyYW1ldGVycy9vcHRpb25zIG9iamVjdC5cclxuTC50aWxlTGF5ZXIud21zID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5UaWxlTGF5ZXIuV01TKHVybCwgb3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogQGNsYXNzIEltYWdlT3ZlcmxheVxyXG4gKiBAYWthIEwuSW1hZ2VPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKlxyXG4gKiBVc2VkIHRvIGxvYWQgYW5kIGRpc3BsYXkgYSBzaW5nbGUgaW1hZ2Ugb3ZlciBzcGVjaWZpYyBib3VuZHMgb2YgdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgaW1hZ2VVcmwgPSAnaHR0cDovL3d3dy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkltYWdlT3ZlcmxheSA9IEwuTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIEltYWdlT3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGFsdDogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBgYWx0YCBhdHRyaWJ1dGUgb2YgdGhlIGltYWdlICh1c2VmdWwgZm9yIGFjY2Vzc2liaWxpdHkpLlxyXG5cdFx0YWx0OiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGludGVyYWN0aXZlOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGltYWdlIG92ZXJsYXkgd2lsbCBlbWl0IFttb3VzZSBldmVudHNdKCNpbnRlcmFjdGl2ZS1sYXllcikgd2hlbiBjbGlja2VkIG9yIGhvdmVyZWQuXHJcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxyXG5cdFx0Ly8gQW4gb3B0aW9uYWwgc3RyaW5nIGNvbnRhaW5pbmcgSFRNTCB0byBiZSBzaG93biBvbiB0aGUgYEF0dHJpYnV0aW9uIGNvbnRyb2xgXHJcblx0XHRhdHRyaWJ1dGlvbjogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIHRydWUsIHRoZSBpbWFnZSB3aWxsIGhhdmUgaXRzIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBzZXQgdG8gJycuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5faW5pdEltYWdlKCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblx0XHRcdHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdEwuRG9tVXRpbC50b0Zyb250KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2soKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvQmFjayh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFVybCh1cmw6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBVUkwgb2YgdGhlIGltYWdlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHR0aGlzLl9pbWFnZS5zcmMgPSB1cmw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3Jlc2V0XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWcgPSB0aGlzLl9pbWFnZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2ltZycsXHJcblx0XHRcdFx0J2xlYWZsZXQtaW1hZ2UtbGF5ZXIgJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnbGVhZmxldC16b29tLWFuaW1hdGVkJyA6ICcnKSk7XHJcblxyXG5cdFx0aW1nLm9uc2VsZWN0c3RhcnQgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IEwuVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdGltZy5vbmxvYWQgPSBMLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nLnNyYyA9IHRoaXMuX3VybDtcclxuXHRcdGltZy5hbHQgPSB0aGlzLm9wdGlvbnMuYWx0O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCksIGUuem9vbSwgZS5jZW50ZXIpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5faW1hZ2UsIG9mZnNldCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgYm91bmRzID0gbmV3IEwuQm91bmRzKFxyXG5cdFx0ICAgICAgICB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldFNvdXRoRWFzdCgpKSksXHJcblx0XHQgICAgc2l6ZSA9IGJvdW5kcy5nZXRTaXplKCk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5MLmltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5JbWFnZU92ZXJsYXkodXJsLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBJY29uXHJcbiAqIEBha2EgTC5JY29uXHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGFuIGljb24gdG8gcHJvdmlkZSB3aGVuIGNyZWF0aW5nIGEgbWFya2VyLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgbXlJY29uID0gTC5pY29uKHtcclxuICogICAgIGljb25Vcmw6ICdteS1pY29uLnBuZycsXHJcbiAqICAgICBpY29uUmV0aW5hVXJsOiAnbXktaWNvbkAyeC5wbmcnLFxyXG4gKiAgICAgaWNvblNpemU6IFszOCwgOTVdLFxyXG4gKiAgICAgaWNvbkFuY2hvcjogWzIyLCA5NF0sXHJcbiAqICAgICBwb3B1cEFuY2hvcjogWy0zLCAtNzZdLFxyXG4gKiAgICAgc2hhZG93VXJsOiAnbXktaWNvbi1zaGFkb3cucG5nJyxcclxuICogICAgIHNoYWRvd1JldGluYVVybDogJ215LWljb24tc2hhZG93QDJ4LnBuZycsXHJcbiAqICAgICBzaGFkb3dTaXplOiBbNjgsIDk1XSxcclxuICogICAgIHNoYWRvd0FuY2hvcjogWzIyLCA5NF1cclxuICogfSk7XHJcbiAqXHJcbiAqIEwubWFya2VyKFs1MC41MDUsIDMwLjU3XSwge2ljb246IG15SWNvbn0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBgTC5JY29uLkRlZmF1bHRgIGV4dGVuZHMgYEwuSWNvbmAgYW5kIGlzIHRoZSBibHVlIGljb24gTGVhZmxldCB1c2VzIGZvciBtYXJrZXJzIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqL1xyXG5cclxuTC5JY29uID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIEBha2EgSWNvbiBvcHRpb25zXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25Vcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKiAqKihyZXF1aXJlZCkqKiBUaGUgVVJMIHRvIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyIHNjcmlwdCBwYXRoKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblJldGluYVVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gYSByZXRpbmEgc2l6ZWQgdmVyc2lvbiBvZiB0aGUgaWNvbiBpbWFnZSAoYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG8geW91clxyXG5cdCAqIHNjcmlwdCBwYXRoKS4gVXNlZCBmb3IgUmV0aW5hIHNjcmVlbiBkZXZpY2VzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uU2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgaWNvbiBpbWFnZSBpbiBwaXhlbHMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25BbmNob3I6IFBvaW50ID0gbnVsbFxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgXCJ0aXBcIiBvZiB0aGUgaWNvbiAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikuIFRoZSBpY29uXHJcblx0ICogd2lsbCBiZSBhbGlnbmVkIHNvIHRoYXQgdGhpcyBwb2ludCBpcyBhdCB0aGUgbWFya2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLiBDZW50ZXJlZFxyXG5cdCAqIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb3B1cEFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tIHdoaWNoIHBvcHVwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcblx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZUljb24ob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBpY29uIGhhcyB0byBiZSBzaG93biwgcmV0dXJucyBhIGA8aW1nPmAgSFRNTCBlbGVtZW50XHJcblx0Ly8gc3R5bGVkIGFjY29yZGluZyB0byB0aGUgb3B0aW9ucy5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ2ljb24nLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVNoYWRvdyhvbGRJY29uPzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudFxyXG5cdC8vIEFzIGBjcmVhdGVJY29uYCwgYnV0IGZvciB0aGUgc2hhZG93IGJlbmVhdGggaXQuXHJcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oJ3NoYWRvdycsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJY29uOiBmdW5jdGlvbiAobmFtZSwgb2xkSWNvbikge1xyXG5cdFx0dmFyIHNyYyA9IHRoaXMuX2dldEljb25VcmwobmFtZSk7XHJcblxyXG5cdFx0aWYgKCFzcmMpIHtcclxuXHRcdFx0aWYgKG5hbWUgPT09ICdpY29uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS4nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbiAmJiBvbGRJY29uLnRhZ05hbWUgPT09ICdJTUcnID8gb2xkSWNvbiA6IG51bGwpO1xyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhpbWcsIG5hbWUpO1xyXG5cclxuXHRcdHJldHVybiBpbWc7XHJcblx0fSxcclxuXHJcblx0X3NldEljb25TdHlsZXM6IGZ1bmN0aW9uIChpbWcsIG5hbWUpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdFx0dmFyIHNpemVPcHRpb24gPSBvcHRpb25zW25hbWUgKyAnU2l6ZSddO1xyXG5cclxuXHRcdGlmICh0eXBlb2Ygc2l6ZU9wdGlvbiA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0c2l6ZU9wdGlvbiA9IFtzaXplT3B0aW9uLCBzaXplT3B0aW9uXTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2l6ZSA9IEwucG9pbnQoc2l6ZU9wdGlvbiksXHJcblx0XHQgICAgYW5jaG9yID0gTC5wb2ludChuYW1lID09PSAnc2hhZG93JyAmJiBvcHRpb25zLnNoYWRvd0FuY2hvciB8fCBvcHRpb25zLmljb25BbmNob3IgfHxcclxuXHRcdCAgICAgICAgICAgIHNpemUgJiYgc2l6ZS5kaXZpZGVCeSgyLCB0cnVlKSk7XHJcblxyXG5cdFx0aW1nLmNsYXNzTmFtZSA9ICdsZWFmbGV0LW1hcmtlci0nICsgbmFtZSArICcgJyArIChvcHRpb25zLmNsYXNzTmFtZSB8fCAnJyk7XHJcblxyXG5cdFx0aWYgKGFuY2hvcikge1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luTGVmdCA9ICgtYW5jaG9yLngpICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpblRvcCAgPSAoLWFuY2hvci55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNpemUpIHtcclxuXHRcdFx0aW1nLnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVJbWc6IGZ1bmN0aW9uIChzcmMsIGVsKSB7XHJcblx0XHRlbCA9IGVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG5cdFx0ZWwuc3JjID0gc3JjO1xyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIEwuQnJvd3Nlci5yZXRpbmEgJiYgdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ10gfHwgdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmljb24ob3B0aW9uczogSWNvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGljb24gaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cclxuTC5pY29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuSWNvbihvcHRpb25zKTtcclxufTtcclxuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICovXG5cbkwuSWNvbi5EZWZhdWx0ID0gTC5JY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICghTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoKSB7XHQvLyBEZXByZWNhdGVkLCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBvbmx5XG5cdFx0XHRMLkljb24uRGVmYXVsdC5pbWFnZVBhdGggPSB0aGlzLl9kZXRlY3RJY29uUGF0aCgpO1xuXHRcdH1cblxuXHRcdC8vIEBvcHRpb24gaW1hZ2VQYXRoOiBTdHJpbmdcblx0XHQvLyBgTC5JY29uLkRlZmF1bHRgIHdpbGwgdHJ5IHRvIGF1dG8tZGV0ZWN0IHRoZSBhYnNvbHV0ZSBsb2NhdGlvbiBvZiB0aGVcblx0XHQvLyBibHVlIGljb24gaW1hZ2VzLiBJZiB5b3UgYXJlIHBsYWNpbmcgdGhlc2UgaW1hZ2VzIGluIGEgbm9uLXN0YW5kYXJkXG5cdFx0Ly8gd2F5LCBzZXQgdGhpcyBvcHRpb24gdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IGFic29sdXRlIHBhdGguXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuaW1hZ2VQYXRoIHx8IEwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aCkgKyBMLkljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgICdsZWFmbGV0LWRlZmF1bHQtaWNvbi1wYXRoJywgZG9jdW1lbnQuYm9keSk7XG5cdFx0dmFyIHBhdGggPSBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICdiYWNrZ3JvdW5kLWltYWdlJykgfHxcblx0XHQgICAgICAgICAgIEwuRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblxuXHRcdHJldHVybiBwYXRoLmluZGV4T2YoJ3VybCcpID09PSAwID9cblx0XHRcdHBhdGgucmVwbGFjZSgvXnVybFxcKFtcXFwiXFwnXT8vLCAnJykucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXFxcIlxcJ10/XFwpJC8sICcnKSA6ICcnO1xuXHR9XG59KTtcblxuLypcclxuICogQGNsYXNzIE1hcmtlclxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICogQGFrYSBMLk1hcmtlclxyXG4gKiBMLk1hcmtlciBpcyB1c2VkIHRvIGRpc3BsYXkgY2xpY2thYmxlL2RyYWdnYWJsZSBpY29ucyBvbiB0aGUgbWFwLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubWFya2VyKFs1MC41LCAzMC41XSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5NYXJrZXIgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBNYXJrZXIgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaWNvbjogSWNvbiA9ICpcclxuXHRcdC8vIEljb24gY2xhc3MgdG8gdXNlIGZvciByZW5kZXJpbmcgdGhlIG1hcmtlci4gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLiBJZiBub3Qgc3BlY2lmaWVkLCBhIG5ldyBgTC5JY29uLkRlZmF1bHRgIGlzIHVzZWQuXHJcblx0XHRpY29uOiBuZXcgTC5JY29uLkRlZmF1bHQoKSxcclxuXHJcblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXHJcblx0XHRpbnRlcmFjdGl2ZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGRyYWdnYWJsZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxyXG5cdFx0ZHJhZ2dhYmxlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGNhbiBiZSB0YWJiZWQgdG8gd2l0aCBhIGtleWJvYXJkIGFuZCBjbGlja2VkIGJ5IHByZXNzaW5nIGVudGVyLlxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0aXRsZTogU3RyaW5nID0gJydcclxuXHRcdC8vIFRleHQgZm9yIHRoZSBicm93c2VyIHRvb2x0aXAgdGhhdCBhcHBlYXIgb24gbWFya2VyIGhvdmVyIChubyB0b29sdGlwIGJ5IGRlZmF1bHQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6SW5kZXhPZmZzZXQ6IE51bWJlciA9IDBcclxuXHRcdC8vIEJ5IGRlZmF1bHQsIG1hcmtlciBpbWFnZXMgekluZGV4IGlzIHNldCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0cyBsYXRpdHVkZS4gVXNlIHRoaXMgb3B0aW9uIGlmIHlvdSB3YW50IHRvIHB1dCB0aGUgbWFya2VyIG9uIHRvcCBvZiBhbGwgb3RoZXJzIChvciBiZWxvdyksIHNwZWNpZnlpbmcgYSBoaWdoIHZhbHVlIGxpa2UgYDEwMDBgIChvciBoaWdoIG5lZ2F0aXZlIHZhbHVlLCByZXNwZWN0aXZlbHkpLlxyXG5cdFx0ekluZGV4T2Zmc2V0OiAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgbWFya2VyLlxyXG5cdFx0b3BhY2l0eTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHJpc2VPbkhvdmVyOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIG1hcmtlciB3aWxsIGdldCBvbiB0b3Agb2Ygb3RoZXJzIHdoZW4geW91IGhvdmVyIHRoZSBtb3VzZSBvdmVyIGl0LlxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9mZnNldDogTnVtYmVyID0gMjUwXHJcblx0XHQvLyBUaGUgei1pbmRleCBvZmZzZXQgdXNlZCBmb3IgdGhlIGByaXNlT25Ib3ZlcmAgZmVhdHVyZS5cclxuXHRcdHJpc2VPZmZzZXQ6IDI1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9ICdtYXJrZXJQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBpY29uIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAnbWFya2VyUGFuZScsXHJcblxyXG5cdFx0Ly8gRklYTUU6IHNoYWRvd1BhbmUgaXMgbm8gbG9uZ2VyIGEgdmFsaWQgb3B0aW9uXHJcblx0XHRub25CdWJibGluZ0V2ZW50czogWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXVxyXG5cdH0sXHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICpcclxuXHQgKiBJbiBhZGRpdGlvbiB0byBbc2hhcmVkIGxheWVyIG1ldGhvZHNdKCNMYXllcikgbGlrZSBgYWRkVG8oKWAgYW5kIGByZW1vdmUoKWAgYW5kIFtwb3B1cCBtZXRob2RzXSgjUG9wdXApIGxpa2UgYmluZFBvcHVwKCkgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdHRoaXMuX3JlbW92ZVNoYWRvdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0em9vbTogdGhpcy51cGRhdGUsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy51cGRhdGVcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcblx0Z2V0TGF0TG5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdGxuZzogTGF0TG5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gcG9pbnQuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgb2xkTGF0TG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRJY29uKGljb246IEljb24pOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIGljb24uXHJcblx0c2V0SWNvbjogZnVuY3Rpb24gKGljb24pIHtcclxuXHJcblx0XHR0aGlzLm9wdGlvbnMuaWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLmJpbmRQb3B1cCh0aGlzLl9wb3B1cCwgdGhpcy5fcG9wdXAub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ljb247XHJcblx0fSxcclxuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG9wdGlvbnMuYWx0KSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG5cdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdG1vdXNlb3ZlcjogdGhpcy5fYnJpbmdUb0Zyb250LFxyXG5cdFx0XHRcdG1vdXNlb3V0OiB0aGlzLl9yZXNldFpJbmRleFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmV3U2hhZG93ID0gb3B0aW9ucy5pY29uLmNyZWF0ZVNoYWRvdyh0aGlzLl9zaGFkb3cpLFxyXG5cdFx0ICAgIGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcblx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGlmIChhZGRJY29uKSB7XHJcblx0XHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2ljb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5faW5pdEludGVyYWN0aW9uKCk7XHJcblx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoJ3NoYWRvd1BhbmUnKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRtb3VzZW92ZXI6IHRoaXMuX2JyaW5nVG9Gcm9udCxcclxuXHRcdFx0XHRtb3VzZW91dDogdGhpcy5fcmVzZXRaSW5kZXhcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9pY29uKTtcclxuXHRcdHRoaXMucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbik7XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faWNvbiwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHJcblx0XHR0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdGlmIChMLkhhbmRsZXIuTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBMLkhhbmRsZXIuTWFya2VyRHJhZyh0aGlzKTtcclxuXHJcblx0XHRcdGlmIChkcmFnZ2FibGUpIHtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmVuYWJsZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRPcGFjaXR5KG9wYWNpdHk6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVPcGFjaXR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fc2hhZG93LCBvcGFjaXR5KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gZmFjdG9yeSBMLm1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz8gOiBNYXJrZXIgb3B0aW9ucylcclxuXHJcbi8vIEBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBNYXJrZXIgb2JqZWN0IGdpdmVuIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IGFuZCBvcHRpb25hbGx5IGFuIG9wdGlvbnMgb2JqZWN0LlxyXG5MLm1hcmtlciA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn07XHJcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbkwuRGl2SWNvbiA9IEwuSWNvbi5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQHNlY3Rpb25cblx0XHQvLyBAYWthIERpdkljb24gb3B0aW9uc1xuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXG5cblx0XHQvLyBpY29uQW5jaG9yOiAoUG9pbnQpLFxuXHRcdC8vIHBvcHVwQW5jaG9yOiAoUG9pbnQpLFxuXG5cdFx0Ly8gQG9wdGlvbiBodG1sOiBTdHJpbmcgPSAnJ1xuXHRcdC8vIEN1c3RvbSBIVE1MIGNvZGUgdG8gcHV0IGluc2lkZSB0aGUgZGl2IGVsZW1lbnQsIGVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXG5cdFx0aWYgKG9wdGlvbnMuYmdQb3MpIHtcblx0XHRcdHZhciBiZ1BvcyA9IEwucG9pbnQob3B0aW9ucy5iZ1Bvcyk7XG5cdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gKC1iZ1Bvcy54KSArICdweCAnICsgKC1iZ1Bvcy55KSArICdweCc7XG5cdFx0fVxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoZGl2LCAnaWNvbicpO1xuXG5cdFx0cmV0dXJuIGRpdjtcblx0fSxcblxuXHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZGl2SWNvbihvcHRpb25zOiBEaXZJY29uIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgYERpdkljb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5MLmRpdkljb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuRGl2SWNvbihvcHRpb25zKTtcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBMYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIHBvcHVwIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuTC5EaXZPdmVybGF5ID0gTC5MYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgRGl2T3ZlcmxheSBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgNylcclxuXHRcdC8vIFRoZSBvZmZzZXQgb2YgdGhlIHBvcHVwIHBvc2l0aW9uLiBVc2VmdWwgdG8gY29udHJvbCB0aGUgYW5jaG9yXHJcblx0XHQvLyBvZiB0aGUgcG9wdXAgd2hlbiBvcGVuaW5nIGl0IG9uIHNvbWUgb3ZlcmxheXMuXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCk7XHJcblx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAxKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJyaW5nVG9Gcm9udCgpO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKEwuRG9tVXRpbC5yZW1vdmUsIEwuRG9tVXRpbCwgdGhpcy5fY29udGFpbmVyKSwgMjAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiBwb3B1cC5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBwb3B1cCB3aWxsIG9wZW4uXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgcG9wdXAuXHJcblx0Z2V0Q29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRDb250ZW50KGh0bWxDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8RnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBwb3B1cC4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YCB0byBiZSB1c2VkIGluIHRoZSBwb3B1cC5cclxuXHRzZXRDb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdFx0dGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBBbGlhcyBmb3IgW2dldENvbnRlbnQoKV0oI3BvcHVwLWdldGNvbnRlbnQpXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIHBvcHVwIGNvbnRlbnQsIGxheW91dCBhbmQgcG9zaXRpb24uIFVzZWZ1bCBmb3IgdXBkYXRpbmcgdGhlIHBvcHVwIGFmdGVyIHNvbWV0aGluZyBpbnNpZGUgY2hhbmdlZCwgZS5nLiBpbWFnZSBsb2FkZWQuXHJcblx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZUxheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fdXBkYXRlUG9zaXRpb24sXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fdXBkYXRlUG9zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc09wZW46IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCB3aGVuIHRoZSBwb3B1cCBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgaW4gZnJvbnQgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdEwuRG9tVXRpbC50b0Zyb250KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgcG9wdXAgdG8gdGhlIGJhY2sgb2Ygb3RoZXIgcG9wdXBzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0TC5Eb21VdGlsLnRvQmFjayh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpcmUoJ2NvbnRlbnR1cGRhdGUnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXHJcblx0XHQgICAgb2Zmc2V0ID0gTC5wb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcclxuXHRcdCAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIHBvcHVwIGluIGNhc2UgdGhlIGhlaWdodCBvZiB0aGUgcG9wdXAgY2hhbmdlcyAoaW1hZ2VzIGxvYWRpbmcgZXRjKVxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9IGJvdHRvbSArICdweCc7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBbMCwgMF07XHJcblx0fVxyXG5cclxufSk7XHJcblxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICogSGVyZSdzIGEgbW9yZSBjb21wbGljYXRlZCB3YXkgdG8gb3BlbiBhIHBvcHVwIG9uIGEgbWFwOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5MLlBvcHVwID0gTC5EaXZPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBQb3B1cCBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMzAwXHJcblx0XHQvLyBNYXggd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtYXhXaWR0aDogMzAwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluV2lkdGg6IE51bWJlciA9IDUwXHJcblx0XHQvLyBNaW4gd2lkdGggb2YgdGhlIHBvcHVwLCBpbiBwaXhlbHMuXHJcblx0XHRtaW5XaWR0aDogNTAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhIZWlnaHQ6IE51bWJlciA9IG51bGxcclxuXHRcdC8vIElmIHNldCwgY3JlYXRlcyBhIHNjcm9sbGFibGUgY29udGFpbmVyIG9mIHRoZSBnaXZlbiBoZWlnaHRcclxuXHRcdC8vIGluc2lkZSBhIHBvcHVwIGlmIGl0cyBjb250ZW50IGV4Y2VlZHMgaXQuXHJcblx0XHRtYXhIZWlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgdGhlIG1hcCB0byBkbyBwYW5uaW5nIGFuaW1hdGlvblxyXG5cdFx0Ly8gdG8gZml0IHRoZSBvcGVuZWQgcG9wdXAuXHJcblx0XHRhdXRvUGFuOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG1hcFxyXG5cdFx0Ly8gdmlldyBhZnRlciBhdXRvcGFubmluZyB3YXMgcGVyZm9ybWVkLlxyXG5cdFx0YXV0b1BhblBhZGRpbmdUb3BMZWZ0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodDogUG9pbnQgPSBudWxsXHJcblx0XHQvLyBUaGUgbWFyZ2luIGJldHdlZW4gdGhlIHBvcHVwIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBudWxsLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNSwgNSlcclxuXHRcdC8vIEVxdWl2YWxlbnQgb2Ygc2V0dGluZyBib3RoIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgYXV0b3BhbiBwYWRkaW5nIHRvIHRoZSBzYW1lIHZhbHVlLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGtlZXBJblZpZXc6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBwcmV2ZW50IHVzZXJzIGZyb20gcGFubmluZyB0aGUgcG9wdXBcclxuXHRcdC8vIG9mZiBvZiB0aGUgc2NyZWVuIHdoaWxlIGl0IGlzIG9wZW4uXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlQnV0dG9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gQ29udHJvbHMgdGhlIHByZXNlbmNlIG9mIGEgY2xvc2UgYnV0dG9uIGluIHRoZSBwb3B1cC5cclxuXHRcdGNsb3NlQnV0dG9uOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b0Nsb3NlOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcclxuXHRcdC8vIHRoZSBwb3B1cCBjbG9zaW5nIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcCAoc2V0IGdsb2JhbGx5IGJ5XHJcblx0XHQvLyB0aGUgTWFwJ3MgW2Nsb3NlUG9wdXBPbkNsaWNrXSgjbWFwLWNsb3NlcG9wdXBvbmNsaWNrKSBvcHRpb24pLlxyXG5cdFx0YXV0b0Nsb3NlOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBwb3B1cC5cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHQvLyBAbmFtZXNwYWNlIFBvcHVwXHJcblx0Ly8gQG1ldGhvZCBvcGVuT24obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuIFRoZSBzYW1lIGFzIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub3BlblBvcHVwKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdEwuRGl2T3ZlcmxheS5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpcyBvcGVuZWQgaW4gdGhlIG1hcFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwb3BlbjogUG9wdXBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWRcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwb3BlbicsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHQvLyBGb3Igbm9uLXBhdGggbGF5ZXJzLCB3ZSB0b2dnbGUgdGhlIHBvcHVwIHdoZW4gY2xpY2tpbmdcclxuXHRcdFx0Ly8gYWdhaW4gdGhlIGxheWVyLCBzbyBwcmV2ZW50IHRoZSBtYXAgdG8gcmVvcGVuIGl0LlxyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBMLlBhdGgpKSB7XHJcblx0XHRcdFx0dGhpcy5fc291cmNlLm9uKCdwcmVjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBjbG9zZTogUG9wdXBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGluIHRoZSBtYXAgaXMgY2xvc2VkXHJcblx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxyXG5cdFx0XHQvLyBAc2VjdGlvbiBQb3B1cCBldmVudHNcclxuXHRcdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgY2xvc2VkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cGNsb3NlJywge3BvcHVwOiB0aGlzfSwgdHJ1ZSk7XHJcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEwuUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub2ZmKCdwcmVjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IEwuRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0aWYgKCdjbG9zZU9uQ2xpY2snIGluIHRoaXMub3B0aW9ucyA/IHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgOiB0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykge1xyXG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XHJcblx0XHRcdHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuX2Nsb3NlQnV0dG9uID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcclxuXHJcblx0XHRcdEwuRG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIHRoaXMuX29uQ2xvc2VCdXR0b25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHRcdC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih3cmFwcGVyKVxyXG5cdFx0XHQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKHRoaXMuX2NvbnRlbnROb2RlKVxyXG5cdFx0XHQub24od3JhcHBlciwgJ2NvbnRleHRtZW51JywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xyXG5cclxuXHRcdHRoaXMuX3RpcENvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcCcsIHRoaXMuX3RpcENvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCBwb3MuYWRkKGFuY2hvcikpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmF1dG9QYW4gfHwgKHRoaXMuX21hcC5fcGFuQW5pbSAmJiB0aGlzLl9tYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQoTC5Eb21VdGlsLmdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG5cdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcblx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgTC5Qb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRsYXllclBvcy5fYWRkKEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9zID0gbWFwLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KGxheWVyUG9zKSxcclxuXHRcdCAgICBwYWRkaW5nID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdUTCA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nVG9wTGVmdCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHNpemUgPSBtYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIGR4ID0gMCxcclxuXHRcdCAgICBkeSA9IDA7XHJcblxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggKyBwYWRkaW5nQlIueCA+IHNpemUueCkgeyAvLyByaWdodFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54ICsgY29udGFpbmVyV2lkdGggLSBzaXplLnggKyBwYWRkaW5nQlIueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueCAtIGR4IC0gcGFkZGluZ1RMLnggPCAwKSB7IC8vIGxlZnRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCAtIHBhZGRpbmdUTC54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0ICsgcGFkZGluZ0JSLnkgPiBzaXplLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgLSBzaXplLnkgKyBwYWRkaW5nQlIueTtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSAtIGR5IC0gcGFkZGluZ1RMLnkgPCAwKSB7IC8vIHRvcFxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55IC0gcGFkZGluZ1RMLnk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGF1dG9wYW5zdGFydDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgYXV0b3Bhbm5pbmcgd2hlbiBvcGVuaW5nIGEgcG9wdXAuXHJcblx0XHRpZiAoZHggfHwgZHkpIHtcclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnYXV0b3BhbnN0YXJ0JylcclxuXHRcdFx0ICAgIC5wYW5CeShbZHgsIGR5XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uQ2xvc2VCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX2Nsb3NlKCk7XHJcblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XHJcblx0fSxcclxuXHJcblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gV2hlcmUgc2hvdWxkIHdlIGFuY2hvciB0aGUgcG9wdXAgb24gdGhlIHNvdXJjZSBsYXllcj9cclxuXHRcdHJldHVybiBMLnBvaW50KHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yID8gdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcigpIDogWzAsIDBdKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9wdXBcclxuLy8gQGZhY3RvcnkgTC5wb3B1cChvcHRpb25zPzogUG9wdXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXHJcbi8vIEluc3RhbnRpYXRlcyBhIGBQb3B1cGAgb2JqZWN0IGdpdmVuIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uIGFuZCBhbiBvcHRpb25hbCBgc291cmNlYCBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHRhZyB0aGUgcG9wdXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxyXG5MLnBvcHVwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdHJldHVybiBuZXcgTC5Qb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChwb3B1cDogUG9wdXApOiB0aGlzXHJcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCBwb3B1cCB3aGlsZSBjbG9zaW5nIHRoZSBwcmV2aW91c2x5IG9wZW5lZCAodG8gbWFrZSBzdXJlIG9ubHkgb25lIGlzIG9wZW5lZCBhdCBvbmUgdGltZSBmb3IgdXNhYmlsaXR5KS5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDcmVhdGVzIGEgcG9wdXAgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQgYW5kIG9wdGlvbnMgYW5kIG9wZW5zIGl0IGluIHRoZSBnaXZlbiBwb2ludCBvbiBhIG1hcC5cclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHRpZiAoIShwb3B1cCBpbnN0YW5jZW9mIEwuUG9wdXApKSB7XHJcblx0XHRcdHBvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucykuc2V0Q29udGVudChwb3B1cCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRwb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihwb3B1cCkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwICYmIHRoaXMuX3BvcHVwLm9wdGlvbnMuYXV0b0Nsb3NlKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BvcHVwID0gcG9wdXA7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihwb3B1cCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKHBvcHVwPzogUG9wdXApOiB0aGlzXHJcblx0Ly8gQ2xvc2VzIHRoZSBwb3B1cCBwcmV2aW91c2x5IG9wZW5lZCB3aXRoIFtvcGVuUG9wdXBdKCNtYXAtb3BlbnBvcHVwKSAob3IgdGhlIGdpdmVuIG9uZSkuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKHBvcHVwKSB7XHJcblx0XHRpZiAoIXBvcHVwIHx8IHBvcHVwID09PSB0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHRwb3B1cCA9IHRoaXMuX3BvcHVwO1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZiAocG9wdXApIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihwb3B1cCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cbi8qXG4gKiBAbmFtZXNwYWNlIExheWVyXG4gKiBAc2VjdGlvbiBQb3B1cCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyBwb3B1cHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kUG9wdXAoJ0hpIFRoZXJlIScpLmFkZFRvKG1hcCk7XG4gKiBsYXllci5vcGVuUG9wdXAoKTtcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcbiAqIGBgYFxuICpcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxuICovXG5cbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcbkwuTGF5ZXIuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBiaW5kUG9wdXAoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9ufFBvcHVwLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucyk6IHRoaXNcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcblx0Ly8gbmVjY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIEwuUG9wdXApIHtcblx0XHRcdEwuc2V0T3B0aW9ucyhjb250ZW50LCBvcHRpb25zKTtcblx0XHRcdHRoaXMuX3BvcHVwID0gY29udGVudDtcblx0XHRcdGNvbnRlbnQuX3NvdXJjZSA9IHRoaXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5fcG9wdXAgfHwgb3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCkge1xuXHRcdFx0dGhpcy5vbih7XG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxuXHRcdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlUG9wdXBcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFBvcHVwKCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBib3VuZCB3aXRoIGBiaW5kUG9wdXBgLlxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xuXHRcdFx0dGhpcy5vZmYoe1xuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxuXHRcdFx0XHRyZW1vdmU6IHRoaXMuY2xvc2VQb3B1cCxcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Qb3B1cChsYXRsbmc/OiBMYXRMbmcpOiB0aGlzXG5cdC8vIE9wZW5zIHRoZSBib3VuZCBwb3B1cCBhdCB0aGUgc3BlY2lmaWNlZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChsYXllciwgbGF0bG5nKSB7XG5cdFx0aWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyKSkge1xuXHRcdFx0bGF0bG5nID0gbGF5ZXI7XG5cdFx0XHRsYXllciA9IHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5GZWF0dXJlR3JvdXApIHtcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbGF0bG5nKSB7XG5cdFx0XHRsYXRsbmcgPSBsYXllci5nZXRDZW50ZXIgPyBsYXllci5nZXRDZW50ZXIoKSA6IGxheWVyLmdldExhdExuZygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXApIHtcblx0XHRcdC8vIHNldCBwb3B1cCBzb3VyY2UgdG8gdGhpcyBsYXllclxuXHRcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IGxheWVyO1xuXG5cdFx0XHQvLyB1cGRhdGUgdGhlIHBvcHVwIChjb250ZW50LCBsYXlvdXQsIGVjdC4uLilcblx0XHRcdHRoaXMuX3BvcHVwLnVwZGF0ZSgpO1xuXG5cdFx0XHQvLyBvcGVuIHRoZSBwb3B1cCBvbiB0aGUgbWFwXG5cdFx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLCBsYXRsbmcpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cCgpOiB0aGlzXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpZiBpdCBpcyBvcGVuLlxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCB0b2dnbGVQb3B1cCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHRpZiAodGhpcy5fcG9wdXAuX21hcCkge1xuXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKHRhcmdldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNQb3B1cE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNQb3B1cE9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9wdXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRQb3B1cENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFBvcHVwKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBvcHVwKCk6IFBvcHVwXG5cdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xuXHR9LFxuXG5cdF9vcGVuUG9wdXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdGlmICghdGhpcy5fcG9wdXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXG5cdFx0TC5Eb21FdmVudC5zdG9wKGUpO1xuXG5cdFx0Ly8gaWYgdGhpcyBpbmhlcml0cyBmcm9tIFBhdGggaXRzIGEgdmVjdG9yIGFuZCB3ZSBjYW4ganVzdFxuXHRcdC8vIG9wZW4gdGhlIHBvcHVwIGF0IHRoZSBuZXcgbG9jYXRpb25cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLlBhdGgpIHtcblx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF5ZXIgfHwgZS50YXJnZXQsIGUubGF0bG5nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBvdGhlcndpc2UgdHJlYXQgaXQgbGlrZSBhIG1hcmtlciBhbmQgZmlndXJlIG91dFxuXHRcdC8vIGlmIHdlIHNob3VsZCB0b2dnbGUgaXQgb3Blbi9jbG9zZWRcblx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSAmJiB0aGlzLl9wb3B1cC5fc291cmNlID09PSBsYXllcikge1xuXHRcdFx0dGhpcy5jbG9zZVBvcHVwKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub3BlblBvcHVwKGxheWVyLCBlLmxhdGxuZyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKGUubGF0bG5nKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIFBvcHVwIGV4dGVuc2lvbiB0byBMLk1hcmtlciwgYWRkaW5nIHBvcHVwLXJlbGF0ZWQgbWV0aG9kcy5cclxuICovXHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHRfZ2V0UG9wdXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yIHx8IFswLCAwXTtcclxuXHR9XHJcbn0pO1xyXG5cbi8qXG4gKiBAY2xhc3MgVG9vbHRpcFxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAqIEBha2EgTC5Ub29sdGlwXG4gKiBVc2VkIHRvIGRpc3BsYXkgc21hbGwgdGV4dHMgb24gdG9wIG9mIG1hcCBsYXllcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmJpbmRUb29sdGlwKFwibXkgdG9vbHRpcCB0ZXh0XCIpLm9wZW5Ub29sdGlwKCk7XG4gKiBgYGBcbiAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICogZm9yIGNvbXB1dGluZyB0b29sdGlwIG9mZnNldGluZzpcbiAqIC0gdGhlIGBvZmZzZXRgIFRvb2x0aXAgb3B0aW9uOiBpdCBkZWZhdWx0cyB0byBbMCwgMF0sIGFuZCBpdCdzIHNwZWNpZmljIHRvIG9uZSB0b29sdGlwLlxuICogICBBZGQgYSBwb3NpdGl2ZSB4IG9mZnNldCB0byBtb3ZlIHRoZSB0b29sdGlwIHRvIHRoZSByaWdodCwgYW5kIGEgcG9zaXRpdmUgeSBvZmZzZXQgdG9cbiAqICAgbW92ZSBpdCB0byB0aGUgYm90dG9tLiBOZWdhdGl2ZXMgd2lsbCBtb3ZlIHRvIHRoZSBsZWZ0IGFuZCB0b3AuXG4gKiAtIHRoZSBgdG9vbHRpcEFuY2hvcmAgSWNvbiBvcHRpb246IHRoaXMgd2lsbCBvbmx5IGJlIGNvbnNpZGVyZWQgZm9yIE1hcmtlci4gWW91XG4gKiAgIHNob3VsZCBhZGFwdCB0aGlzIHZhbHVlIGlmIHlvdSB1c2UgYSBjdXN0b20gaWNvbi5cbiAqL1xuXG5cbi8vIEBuYW1lc3BhY2UgVG9vbHRpcFxuTC5Ub29sdGlwID0gTC5EaXZPdmVybGF5LmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBUb29sdGlwIG9wdGlvbnNcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3Rvb2x0aXBQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHRvb2x0aXAgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndG9vbHRpcFBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBvZmZzZXQ6IFBvaW50ID0gUG9pbnQoMCwgMClcblx0XHQvLyBPcHRpb25hbCBvZmZzZXQgb2YgdGhlIHRvb2x0aXAgcG9zaXRpb24uXG5cdFx0b2Zmc2V0OiBbMCwgMF0sXG5cblx0XHQvLyBAb3B0aW9uIGRpcmVjdGlvbjogU3RyaW5nID0gJ2F1dG8nXG5cdFx0Ly8gRGlyZWN0aW9uIHdoZXJlIHRvIG9wZW4gdGhlIHRvb2x0aXAuIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGByaWdodGAsIGBsZWZ0YCxcblx0XHQvLyBgdG9wYCwgYGJvdHRvbWAsIGBjZW50ZXJgLCBgYXV0b2AuXG5cdFx0Ly8gYGF1dG9gIHdpbGwgZHluYW1pY2FseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIHRydWUsIHRoZSB0b29sdGlwIHdpbGwgbGlzdGVuIHRvIHRoZSBmZWF0dXJlIGV2ZW50cy5cblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDAuOVxuXHRcdC8vIFRvb2x0aXAgY29udGFpbmVyIG9wYWNpdHkuXG5cdFx0b3BhY2l0eTogMC45XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHRMLkRpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcblx0XHRcdC8vIEBzZWN0aW9uIFRvb2x0aXAgZXZlbnRzXG5cdFx0XHQvLyBAZXZlbnQgdG9vbHRpcG9wZW46IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBvcGVuZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcG9wZW4nLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdEwuRGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjbG9zZWQuXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgndG9vbHRpcGNsb3NlJywge3Rvb2x0aXA6IHRoaXN9LCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IEwuRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoICYmICF0aGlzLm9wdGlvbnMucGVybWFuZW50KSB7XG5cdFx0XHRldmVudHMucHJlY2xpY2sgPSB0aGlzLl9jbG9zZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9LFxuXG5cdF9jbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcC5jbG9zZVRvb2x0aXAodGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXRvb2x0aXAnLFxuXHRcdCAgICBjbGFzc05hbWUgPSBwcmVmaXggKyAnICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykgKyAnIGxlYWZsZXQtem9vbS0nICsgKHRoaXMuX3pvb21BbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpO1xuXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gTC5wb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0cG9zID0gcG9zLmFkZChMLnBvaW50KC10b29sdGlwV2lkdGggLyAyICsgb2Zmc2V0LngsIC10b29sdGlwSGVpZ2h0ICsgb2Zmc2V0LnkgKyBhbmNob3IueSkpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0cG9zID0gcG9zLnN1YnRyYWN0KEwucG9pbnQodG9vbHRpcFdpZHRoIC8gMiAtIG9mZnNldC54LCAtb2Zmc2V0LnkpKTtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdChMLnBvaW50KHRvb2x0aXBXaWR0aCAvIDIgKyBvZmZzZXQueCwgdG9vbHRpcEhlaWdodCAvIDIgLSBhbmNob3IueSArIG9mZnNldC55KSk7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgfHwgZGlyZWN0aW9uID09PSAnYXV0bycgJiYgdG9vbHRpcFBvaW50LnggPCBjZW50ZXJQb2ludC54KSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAncmlnaHQnO1xuXHRcdFx0cG9zID0gcG9zLmFkZChbb2Zmc2V0LnggKyBhbmNob3IueCwgYW5jaG9yLnkgLSB0b29sdGlwSGVpZ2h0IC8gMiArIG9mZnNldC55XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpcmVjdGlvbiA9ICdsZWZ0Jztcblx0XHRcdHBvcyA9IHBvcy5zdWJ0cmFjdChMLnBvaW50KHRvb2x0aXBXaWR0aCArIGFuY2hvci54IC0gb2Zmc2V0LngsIHRvb2x0aXBIZWlnaHQgLyAyIC0gYW5jaG9yLnkgLSBvZmZzZXQueSkpO1xuXHRcdH1cblxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtcmlnaHQnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLXRvcCcpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LXRvb2x0aXAtYm90dG9tJyk7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBwb3MpO1xuXHR9LFxuXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fc2V0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcblxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgb3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLCBlLnpvb20sIGUuY2VudGVyKTtcblx0XHR0aGlzLl9zZXRQb3NpdGlvbihwb3MpO1xuXHR9LFxuXG5cdF9nZXRBbmNob3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSB0b29sdGlwIG9uIHRoZSBzb3VyY2UgbGF5ZXI/XG5cdFx0cmV0dXJuIEwucG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvciAmJiAhdGhpcy5vcHRpb25zLnN0aWNreSA/IHRoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpIDogWzAsIDBdKTtcblx0fVxuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBUb29sdGlwXG4vLyBAZmFjdG9yeSBMLnRvb2x0aXAob3B0aW9ucz86IFRvb2x0aXAgb3B0aW9ucywgc291cmNlPzogTGF5ZXIpXG4vLyBJbnN0YW50aWF0ZXMgYSBUb29sdGlwIG9iamVjdCBnaXZlbiBhbiBvcHRpb25hbCBgb3B0aW9uc2Agb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGl0cyBhcHBlYXJhbmNlIGFuZCBsb2NhdGlvbiBhbmQgYW4gb3B0aW9uYWwgYHNvdXJjZWAgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byB0YWcgdGhlIHRvb2x0aXAgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgTGF5ZXIgdG8gd2hpY2ggaXQgcmVmZXJzLlxuTC50b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IEwuVG9vbHRpcChvcHRpb25zLCBzb3VyY2UpO1xufTtcblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcbkwuTWFwLmluY2x1ZGUoe1xuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAodG9vbHRpcDogVG9vbHRpcCk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIHNwZWNpZmllZCB0b29sdGlwLlxuXHQvLyBAYWx0ZXJuYXRpdmVcblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnQsIGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBDcmVhdGVzIGEgdG9vbHRpcCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbiBpdC5cblx0b3BlblRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwLCBsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRpZiAoISh0b29sdGlwIGluc3RhbmNlb2YgTC5Ub29sdGlwKSkge1xuXHRcdFx0dG9vbHRpcCA9IG5ldyBMLlRvb2x0aXAob3B0aW9ucykuc2V0Q29udGVudCh0b29sdGlwKTtcblx0XHR9XG5cblx0XHRpZiAobGF0bG5nKSB7XG5cdFx0XHR0b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc0xheWVyKHRvb2x0aXApKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcih0b29sdGlwKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwPzogVG9vbHRpcCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGdpdmVuIGFzIHBhcmFtZXRlci5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAodG9vbHRpcCkge1xuXHRcdGlmICh0b29sdGlwKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRvb2x0aXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG59KTtcblxuLypcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcbiAqIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kcyBleGFtcGxlXG4gKlxuICogQWxsIGxheWVycyBzaGFyZSBhIHNldCBvZiBtZXRob2RzIGNvbnZlbmllbnQgZm9yIGJpbmRpbmcgdG9vbHRpcHMgdG8gaXQuXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwuUG9seWdvbihsYXRsbmdzKS5iaW5kVG9vbHRpcCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcbiAqIGxheWVyLm9wZW5Ub29sdGlwKCk7XG4gKiBsYXllci5jbG9zZVRvb2x0aXAoKTtcbiAqIGBgYFxuICovXG5cbi8vIEBzZWN0aW9uIFRvb2x0aXAgbWV0aG9kc1xuTC5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Nlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxuXHQvLyB0aGUgbGF5ZXIgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCBzaG91bGQgcmV0dXJuIGEgYFN0cmluZ2Agb3IgYEhUTUxFbGVtZW50YC5cblx0YmluZFRvb2x0aXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cblx0XHRpZiAoY29udGVudCBpbnN0YW5jZW9mIEwuVG9vbHRpcCkge1xuXHRcdFx0TC5zZXRPcHRpb25zKGNvbnRlbnQsIG9wdGlvbnMpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50Ll9zb3VyY2UgPSB0aGlzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3Rvb2x0aXAgfHwgb3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl90b29sdGlwID0gTC50b29sdGlwKG9wdGlvbnMsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlID0gdGhpcy5fbW92ZVRvb2x0aXA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoTC5Ccm93c2VyLnRvdWNoKSB7XG5cdFx0XHRcdGV2ZW50cy5jbGljayA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHMuYWRkID0gdGhpcy5fb3BlblRvb2x0aXA7XG5cdFx0fVxuXHRcdHRoaXNbb25PZmZdKGV2ZW50cyk7XG5cdFx0dGhpcy5fdG9vbHRpcEhhbmRsZXJzQWRkZWQgPSAhcmVtb3ZlO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgb3BlblRvb2x0aXAobGF0bG5nPzogTGF0TG5nKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgYm91bmQgdG9vbHRpcCBhdCB0aGUgc3BlY2lmaWNlZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF5ZXIsIGxhdGxuZykge1xuXHRcdGlmICghKGxheWVyIGluc3RhbmNlb2YgTC5MYXllcikpIHtcblx0XHRcdGxhdGxuZyA9IGxheWVyO1xuXHRcdFx0bGF5ZXIgPSB0aGlzO1xuXHRcdH1cblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuRmVhdHVyZUdyb3VwKSB7XG5cdFx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWxhdGxuZykge1xuXHRcdFx0bGF0bG5nID0gbGF5ZXIuZ2V0Q2VudGVyID8gbGF5ZXIuZ2V0Q2VudGVyKCkgOiBsYXllci5nZXRMYXRMbmcoKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdG9vbHRpcCAmJiB0aGlzLl9tYXApIHtcblxuXHRcdFx0Ly8gc2V0IHRvb2x0aXAgc291cmNlIHRvIHRoaXMgbGF5ZXJcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGxheWVyO1xuXG5cdFx0XHQvLyB1cGRhdGUgdGhlIHRvb2x0aXAgKGNvbnRlbnQsIGxheW91dCwgZWN0Li4uKVxuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGUoKTtcblxuXHRcdFx0Ly8gb3BlbiB0aGUgdG9vbHRpcCBvbiB0aGUgbWFwXG5cdFx0XHR0aGlzLl9tYXAub3BlblRvb2x0aXAodGhpcy5fdG9vbHRpcCwgbGF0bG5nKTtcblxuXHRcdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgbWF5IG5vdCBiZSBkZWZpbmVkIGlmIG5vdCBwZXJtYW5lbnQgYW5kIG5ldmVyXG5cdFx0XHQvLyBvcGVuZWQuXG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuX2Nsb3NlKCk7XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLmludGVyYWN0aXZlICYmIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lcikge1xuXHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLCAnbGVhZmxldC1jbGlja2FibGUnKTtcblx0XHRcdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHRvZ2dsZVRvb2x0aXAoKTogdGhpc1xuXHQvLyBPcGVucyBvciBjbG9zZXMgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG5cdHRvZ2dsZVRvb2x0aXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0aWYgKHRoaXMuX3Rvb2x0aXAuX21hcCkge1xuXHRcdFx0XHR0aGlzLmNsb3NlVG9vbHRpcCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcGVuVG9vbHRpcCh0YXJnZXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzVG9vbHRpcE9wZW4oKTogYm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGN1cnJlbnRseSBvcGVuLlxuXHRpc1Rvb2x0aXBPcGVuOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXAuaXNPcGVuKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRUb29sdGlwQ29udGVudChjb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnR8VG9vbHRpcCk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgY29udGVudCBvZiB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRzZXRUb29sdGlwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0XHRpZiAodGhpcy5fdG9vbHRpcCkge1xuXHRcdFx0dGhpcy5fdG9vbHRpcC5zZXRDb250ZW50KGNvbnRlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFRvb2x0aXAoKTogVG9vbHRpcFxuXHQvLyBSZXR1cm5zIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXG5cdGdldFRvb2x0aXA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fSxcblxuXHRfb3BlblRvb2x0aXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldDtcblxuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub3BlblRvb2x0aXAobGF5ZXIsIHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgPyBlLmxhdGxuZyA6IHVuZGVmaW5lZCk7XG5cdH0sXG5cblx0X21vdmVUb29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZywgY29udGFpbmVyUG9pbnQsIGxheWVyUG9pbnQ7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kgJiYgZS5vcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRjb250YWluZXJQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLm9yaWdpbmFsRXZlbnQpO1xuXHRcdFx0bGF5ZXJQb2ludCA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCk7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xuXHRcdH1cblx0XHR0aGlzLl90b29sdGlwLnNldExhdExuZyhsYXRsbmcpO1xuXHR9XG59KTtcblxuLypcclxuICogVG9vbHRpcCBleHRlbnNpb24gdG8gTC5NYXJrZXIsIGFkZGluZyB0b29sdGlwLXJlbGF0ZWQgbWV0aG9kcy5cclxuICovXHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHRfZ2V0VG9vbHRpcEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMudG9vbHRpcEFuY2hvciB8fCBbMCwgMF07XHJcblx0fVxyXG59KTtcclxuXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5MLkxheWVyR3JvdXAgPSBMLkxheWVyLmV4dGVuZCh7XHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdHZhciBpLCBsZW47XHJcblxyXG5cdFx0aWYgKGxheWVycykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmFkZExheWVyKGxheWVyc1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZExheWVyKGxheWVyOiBMYXllcik6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgZ3JvdXAuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGxheWVyIGZyb20gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIoaWQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRCBmcm9tIHRoZSBncm91cC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBsYXllciBpbiB0aGlzLl9sYXllcnMgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiB0aGlzLl9sYXllcnNbaWRdKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaWRdKTtcclxuXHRcdH1cclxuXHJcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbGF5ZXIgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gISFsYXllciAmJiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzIHx8IHRoaXMuZ2V0TGF5ZXJJZChsYXllcikgaW4gdGhpcy5fbGF5ZXJzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsZWFyTGF5ZXJzKCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFsbCB0aGUgbGF5ZXJzIGZyb20gdGhlIGdyb3VwLlxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGludm9rZShtZXRob2ROYW1lOiBTdHJpbmcsIOKApik6IHRoaXNcclxuXHQvLyBDYWxscyBgbWV0aG9kTmFtZWAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgYW55XHJcblx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBIYXMgbm8gZWZmZWN0IGlmIHRoZSBsYXllcnMgY29udGFpbmVkIGRvIG5vdFxyXG5cdC8vIGltcGxlbWVudCBgbWV0aG9kTmFtZWAuXHJcblx0aW52b2tlOiBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0ICAgIGksIGxheWVyO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaV07XHJcblxyXG5cdFx0XHRpZiAobGF5ZXJbbWV0aG9kTmFtZV0pIHtcclxuXHRcdFx0XHRsYXllclttZXRob2ROYW1lXS5hcHBseShsYXllciwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWFwLmFkZExheWVyKHRoaXMuX2xheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdG1hcC5yZW1vdmVMYXllcih0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBJdGVyYXRlcyBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIGdyb3VwLCBvcHRpb25hbGx5IHNwZWNpZnlpbmcgY29udGV4dCBvZiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24uXHJcblx0Ly8gYGBganNcclxuXHQvLyBncm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0Ly8gXHRsYXllci5iaW5kUG9wdXAoJ0hlbGxvJyk7XHJcblx0Ly8gfSk7XHJcblx0Ly8gYGBgXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcihpZDogTnVtYmVyKTogTGF5ZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBpbnRlcm5hbCBJRC5cclxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExheWVycygpOiBMYXllcltdXHJcblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGxheWVycyBhZGRlZCB0byB0aGUgZ3JvdXAuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXJzLnB1c2godGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRaSW5kZXgoekluZGV4OiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2FsbHMgYHNldFpJbmRleGAgb24gZXZlcnkgbGF5ZXIgY29udGFpbmVkIGluIHRoaXMgZ3JvdXAsIHBhc3NpbmcgdGhlIHotaW5kZXguXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcklkKGxheWVyOiBMYXllcik6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGludGVybmFsIElEIGZvciBhIGxheWVyXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gTC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxheWVyR3JvdXAobGF5ZXJzOiBMYXllcltdKVxyXG4vLyBDcmVhdGUgYSBsYXllciBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMuXHJcbkwubGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTGF5ZXJHcm91cChsYXllcnMpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuRmVhdHVyZUdyb3VwID0gTC5MYXllckdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5hZGRFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMLkxheWVyR3JvdXAucHJvdG90eXBlLmFkZExheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIGFkZGVkIHRvIHRoaXMgYEZlYXR1cmVHcm91cGBcclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiBsYXllcn0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghdGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyXTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXllci5yZW1vdmVFdmVudFBhcmVudCh0aGlzKTtcclxuXHJcblx0XHRMLkxheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdicmluZ1RvQmFjaycpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIFJldHVybnMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGUgRmVhdHVyZSBHcm91cCAoY3JlYXRlZCBmcm9tIGJvdW5kcyBhbmQgY29vcmRpbmF0ZXMgb2YgaXRzIGNoaWxkcmVuKS5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0dmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllci5nZXRCb3VuZHMgPyBsYXllci5nZXRCb3VuZHMoKSA6IGxheWVyLmdldExhdExuZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBmYWN0b3J5IEwuZmVhdHVyZUdyb3VwKGxheWVyczogTGF5ZXJbXSlcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMuXHJcbkwuZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycykge1xyXG5cdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxufTtcclxuXG4vKlxuICogQGNsYXNzIFJlbmRlcmVyXG4gKiBAaW5oZXJpdHMgTGF5ZXJcbiAqIEBha2EgTC5SZW5kZXJlclxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnMgKGBTVkdgLCBgQ2FudmFzYCkuIEhhbmRsZXMgdGhlXG4gKiBET00gY29udGFpbmVyIG9mIHRoZSByZW5kZXJlciwgaXRzIGJvdW5kcywgYW5kIGl0cyB6b29tIGFuaW1hdGlvbi5cbiAqXG4gKiBBIGBSZW5kZXJlcmAgd29ya3MgYXMgYW4gaW1wbGljaXQgbGF5ZXIgZ3JvdXAgZm9yIGFsbCBgUGF0aGBzIC0gdGhlIHJlbmRlcmVyXG4gKiBpdHNlbGYgY2FuIGJlIGFkZGVkIG9yIHJlbW92ZWQgdG8gdGhlIG1hcC4gQWxsIHBhdGhzIHVzZSBhIHJlbmRlcmVyLCB3aGljaCBjYW5cbiAqIGJlIGltcGxpY2l0ICh0aGUgbWFwIHdpbGwgZGVjaWRlIHRoZSB0eXBlIG9mIHJlbmRlcmVyIGFuZCB1c2UgaXQgYXV0b21hdGljYWxseSlcbiAqIG9yIGV4cGxpY2l0ICh1c2luZyB0aGUgW2ByZW5kZXJlcmBdKCNwYXRoLXJlbmRlcmVyKSBvcHRpb24gb2YgdGhlIHBhdGgpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgdXNlIGBTVkdgIGFuZCBgQ2FudmFzYCBpbnN0ZWFkLlxuICpcbiAqIEBldmVudCB1cGRhdGU6IEV2ZW50XG4gKiBGaXJlZCB3aGVuIHRoZSByZW5kZXJlciB1cGRhdGVzIGl0cyBib3VuZHMsIGNlbnRlciBhbmQgem9vbSwgZm9yIGV4YW1wbGUgd2hlblxuICogaXRzIG1hcCBoYXMgbW92ZWRcbiAqL1xuXG5MLlJlbmRlcmVyID0gTC5MYXllci5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUmVuZGVyZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYWRkaW5nOiBOdW1iZXIgPSAwLjFcblx0XHQvLyBIb3cgbXVjaCB0byBleHRlbmQgdGhlIGNsaXAgYXJlYSBhcm91bmQgdGhlIG1hcCB2aWV3IChyZWxhdGl2ZSB0byBpdHMgc2l6ZSlcblx0XHQvLyBlLmcuIDAuMSB3b3VsZCBiZSAxMCUgb2YgbWFwIHZpZXcgaW4gZWFjaCBkaXJlY3Rpb25cblx0XHRwYWRkaW5nOiAwLjFcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRMLnN0YW1wKHRoaXMpO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZVxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICBwb3NpdGlvbiA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIpLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cdFx0ICAgIGRlc3RDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGNlbnRlciwgem9vbSksXG5cdFx0ICAgIGNlbnRlck9mZnNldCA9IGRlc3RDZW50ZXJQb2ludC5zdWJ0cmFjdChjdXJyZW50Q2VudGVyUG9pbnQpLFxuXG5cdFx0ICAgIHRvcExlZnRPZmZzZXQgPSB2aWV3SGFsZi5tdWx0aXBseUJ5KC1zY2FsZSkuYWRkKHBvc2l0aW9uKS5hZGQodmlld0hhbGYpLnN1YnRyYWN0KGNlbnRlck9mZnNldCk7XG5cblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyLCB0b3BMZWZ0T2Zmc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX2NlbnRlciwgdGhpcy5fem9vbSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFVwZGF0ZSBwaXhlbCBib3VuZHMgb2YgcmVuZGVyZXIgY29udGFpbmVyIChmb3IgcG9zaXRpb25pbmcvc2l6aW5nL2NsaXBwaW5nIGxhdGVyKVxuXHRcdC8vIFN1YmNsYXNzZXMgYXJlIHJlc3BvbnNpYmxlIG9mIGZpcmluZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXG5cdFx0dmFyIHAgPSB0aGlzLm9wdGlvbnMucGFkZGluZyxcblx0XHQgICAgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCksXG5cdFx0ICAgIG1pbiA9IHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChzaXplLm11bHRpcGx5QnkoLXApKS5yb3VuZCgpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuQm91bmRzKG1pbiwgbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKSkucm91bmQoKSk7XG5cblx0XHR0aGlzLl9jZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCk7XG5cdFx0dGhpcy5fem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdH1cbn0pO1xuXG5cbkwuTWFwLmluY2x1ZGUoe1xuXHQvLyBAbmFtZXNwYWNlIE1hcDsgQG1ldGhvZCBnZXRSZW5kZXJlcihsYXllcjogUGF0aCk6IFJlbmRlcmVyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuXG5cdC8vIGBQYXRoYC4gSXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgYHJlbmRlcmVyYCBvcHRpb25zIG9mIHRoZSBtYXAgYW5kIHBhdGhzXG5cdC8vIGFyZSByZXNwZWN0ZWQsIGFuZCB0aGF0IHRoZSByZW5kZXJlcnMgZG8gZXhpc3Qgb24gdGhlIG1hcC5cblx0Z2V0UmVuZGVyZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aDsgQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXJcblx0XHQvLyBVc2UgdGhpcyBzcGVjaWZpYyBpbnN0YW5jZSBvZiBgUmVuZGVyZXJgIGZvciB0aGlzIHBhdGguIFRha2VzXG5cdFx0Ly8gcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXAncyBbZGVmYXVsdCByZW5kZXJlcl0oI21hcC1yZW5kZXJlcikuXG5cdFx0dmFyIHJlbmRlcmVyID0gbGF5ZXIub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9nZXRQYW5lUmVuZGVyZXIobGF5ZXIub3B0aW9ucy5wYW5lKSB8fCB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgdGhpcy5fcmVuZGVyZXI7XG5cblx0XHRpZiAoIXJlbmRlcmVyKSB7XG5cdFx0XHQvLyBAbmFtZXNwYWNlIE1hcDsgQG9wdGlvbiBwcmVmZXJDYW52YXM6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdFx0Ly8gV2hldGhlciBgUGF0aGBzIHNob3VsZCBiZSByZW5kZXJlZCBvbiBhIGBDYW52YXNgIHJlbmRlcmVyLlxuXHRcdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyID0gKHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMgJiYgTC5jYW52YXMoKSkgfHwgTC5zdmcoKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIocmVuZGVyZXIpKSB7XG5cdFx0XHR0aGlzLmFkZExheWVyKHJlbmRlcmVyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbmRlcmVyO1xuXHR9LFxuXG5cdF9nZXRQYW5lUmVuZGVyZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICdvdmVybGF5UGFuZScgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gdGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXTtcblx0XHRpZiAocmVuZGVyZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVuZGVyZXIgPSAoTC5TVkcgJiYgTC5zdmcoe3BhbmU6IG5hbWV9KSkgfHwgKEwuQ2FudmFzICYmIEwuY2FudmFzKHtwYW5lOiBuYW1lfSkpO1xuXHRcdFx0dGhpcy5fcGFuZVJlbmRlcmVyc1tuYW1lXSA9IHJlbmRlcmVyO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH1cbn0pO1xuXG4vKlxuICogQGNsYXNzIFBhdGhcbiAqIEBha2EgTC5QYXRoXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcbiAqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGNvbnRhaW5zIG9wdGlvbnMgYW5kIGNvbnN0YW50cyBzaGFyZWQgYmV0d2VlbiB2ZWN0b3JcbiAqIG92ZXJsYXlzIChQb2x5Z29uLCBQb2x5bGluZSwgQ2lyY2xlKS4gRG8gbm90IHVzZSBpdCBkaXJlY3RseS4gRXh0ZW5kcyBgTGF5ZXJgLlxuICovXG5cbkwuUGF0aCA9IEwuTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWVcblx0fSxcblxuXHRiZWZvcmVBZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHQvLyBSZW5kZXJlciBpcyBzZXQgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCByZW5kZXJlci5nZXRFdmVudHNcblx0XHQvLyBiZWZvcmUgdGhpcy5nZXRFdmVudHMuXG5cdFx0dGhpcy5fcmVuZGVyZXIgPSBtYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5faW5pdFBhdGgodGhpcyk7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0XHR0aGlzLl9yZW5kZXJlci5fYWRkUGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZW5kZXJlci5vbigndXBkYXRlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9yZW1vdmVQYXRoKHRoaXMpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0em9vbWVuZDogdGhpcy5fcHJvamVjdCxcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3KCk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgbGF5ZXIuIFNvbWV0aW1lcyB1c2VmdWwgYWZ0ZXIgeW91IGNoYW5nZWQgdGhlIGNvb3JkaW5hdGVzIHRoYXQgdGhlIHBhdGggdXNlcy5cblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBhdGgodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoc3R5bGU6IFBhdGggb3B0aW9ucyk6IHRoaXNcblx0Ly8gQ2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhIFBhdGggYmFzZWQgb24gdGhlIG9wdGlvbnMgaW4gdGhlIGBQYXRoIG9wdGlvbnNgIG9iamVjdC5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBzdHlsZSk7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250KCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgdG9wIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0Zyb250KHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSBsYXllciB0byB0aGUgYm90dG9tIG9mIGFsbCBwYXRoIGxheWVycy5cblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRlZmluZWQgaW4gY2hpbGRyZW4gY2xhc3Nlc1xuXHRcdHRoaXMuX3Byb2plY3QoKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfY2xpY2tUb2xlcmFuY2U6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB1c2VkIHdoZW4gZG9pbmcgaGl0IGRldGVjdGlvbiBmb3IgQ2FudmFzIGxheWVyc1xuXHRcdHJldHVybiAodGhpcy5vcHRpb25zLnN0cm9rZSA/IHRoaXMub3B0aW9ucy53ZWlnaHQgLyAyIDogMCkgKyAoTC5Ccm93c2VyLnRvdWNoID8gMTAgOiAwKTtcblx0fVxufSk7XG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGluZVV0aWxcclxuICpcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuTC5MaW5lVXRpbCA9IHtcclxuXHJcblx0Ly8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcblx0Ly8gSW1wcm92ZXMgcmVuZGVyaW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSBieSBsZXNzZW5pbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdG8gZHJhdy5cclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50czogUG9pbnRbXSwgdG9sZXJhbmNlOiBOdW1iZXIpOiBQb2ludFtdXHJcblx0Ly8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuXHQvLyBpdHMgc2hhcGUgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2ltcGxpZmllZCBwb2ludHMsIHVzaW5nIHRoZVxyXG5cdC8vIFtEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG5cdC8vIFVzZWQgZm9yIGEgaHVnZSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIHByb2Nlc3NpbmcvZGlzcGxheWluZyBMZWFmbGV0IHBvbHlsaW5lcyBmb3JcclxuXHQvLyBlYWNoIHpvb20gbGV2ZWwgYW5kIGFsc28gcmVkdWNpbmcgdmlzdWFsIG5vaXNlLiB0b2xlcmFuY2UgYWZmZWN0cyB0aGUgYW1vdW50IG9mXHJcblx0Ly8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuXHQvLyBBbHNvIHJlbGVhc2VkIGFzIGEgc2VwYXJhdGVkIG1pY3JvLWxpYnJhcnkgW1NpbXBsaWZ5LmpzXShodHRwOi8vbW91cm5lci5naXRodWIuY29tL3NpbXBsaWZ5LWpzLykuXHJcblx0c2ltcGxpZnk6IGZ1bmN0aW9uIChwb2ludHMsIHRvbGVyYW5jZSkge1xyXG5cdFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0XHQvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0XHRwb2ludHMgPSB0aGlzLl9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0Ly8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0XHRwb2ludHMgPSB0aGlzLl9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIHBvaW50VG9TZWdtZW50RGlzdGFuY2UocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5cdHBvaW50VG9TZWdtZW50RGlzdGFuY2U6ICBmdW5jdGlvbiAocCwgcDEsIHAyKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMiwgdHJ1ZSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocDogUG9pbnQsIHAxOiBQb2ludCwgcDI6IFBvaW50KTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcblx0Y2xvc2VzdFBvaW50T25TZWdtZW50OiBmdW5jdGlvbiAocCwgcDEsIHAyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cclxuXHRfc2ltcGxpZnlEUDogZnVuY3Rpb24gKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0XHR2YXIgbGVuID0gcG9pbnRzLmxlbmd0aCxcclxuXHRcdCAgICBBcnJheUNvbnN0cnVjdG9yID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IHVuZGVmaW5lZCArICcnID8gVWludDhBcnJheSA6IEFycmF5LFxyXG5cdFx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHRcdG1hcmtlcnNbMF0gPSBtYXJrZXJzW2xlbiAtIDFdID0gMTtcclxuXHJcblx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCAwLCBsZW4gLSAxKTtcclxuXHJcblx0XHR2YXIgaSxcclxuXHRcdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKG1hcmtlcnNbaV0pIHtcclxuXHRcdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld1BvaW50cztcclxuXHR9LFxyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXA6IGZ1bmN0aW9uIChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgbGFzdCkge1xyXG5cclxuXHRcdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdFx0ICAgIGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdFx0Zm9yIChpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3QgLSAxOyBpKyspIHtcclxuXHRcdFx0c3FEaXN0ID0gdGhpcy5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdFx0aWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xyXG5cdFx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0bWFya2Vyc1tpbmRleF0gPSAxO1xyXG5cclxuXHRcdFx0dGhpcy5fc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdFx0dGhpcy5fc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgaW5kZXgsIGxhc3QpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIHJlZHVjZSBwb2ludHMgdGhhdCBhcmUgdG9vIGNsb3NlIHRvIGVhY2ggb3RoZXIgdG8gYSBzaW5nbGUgcG9pbnRcclxuXHRfcmVkdWNlUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdFx0dmFyIHJlZHVjZWRQb2ludHMgPSBbcG9pbnRzWzBdXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMSwgcHJldiA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fc3FEaXN0KHBvaW50c1tpXSwgcG9pbnRzW3ByZXZdKSA+IHNxVG9sZXJhbmNlKSB7XHJcblx0XHRcdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdFx0cHJldiA9IGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDFdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY2xpcFNlZ21lbnQoYTogUG9pbnQsIGI6IFBvaW50LCBib3VuZHM6IEJvdW5kcywgdXNlTGFzdENvZGU/OiBCb29sZWFuLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdfEJvb2xlYW5cclxuXHQvLyBDbGlwcyB0aGUgc2VnbWVudCBhIHRvIGIgYnkgcmVjdGFuZ3VsYXIgYm91bmRzIHdpdGggdGhlXHJcblx0Ly8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG5cdC8vIChtb2RpZnlpbmcgdGhlIHNlZ21lbnQgcG9pbnRzIGRpcmVjdGx5ISkuIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWxpbmVcclxuXHQvLyBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxyXG5cdGNsaXBTZWdtZW50OiBmdW5jdGlvbiAoYSwgYiwgYm91bmRzLCB1c2VMYXN0Q29kZSwgcm91bmQpIHtcclxuXHRcdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gdGhpcy5fbGFzdENvZGUgOiB0aGlzLl9nZXRCaXRDb2RlKGEsIGJvdW5kcyksXHJcblx0XHQgICAgY29kZUIgPSB0aGlzLl9nZXRCaXRDb2RlKGIsIGJvdW5kcyksXHJcblxyXG5cdFx0ICAgIGNvZGVPdXQsIHAsIG5ld0NvZGU7XHJcblxyXG5cdFx0Ly8gc2F2ZSAybmQgY29kZSB0byBhdm9pZCBjYWxjdWxhdGluZyBpdCBvbiB0aGUgbmV4dCBzZWdtZW50XHJcblx0XHR0aGlzLl9sYXN0Q29kZSA9IGNvZGVCO1xyXG5cclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdFx0aWYgKCEoY29kZUEgfCBjb2RlQikpIHtcclxuXHRcdFx0XHRyZXR1cm4gW2EsIGJdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpZiBhLGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKHRyaXZpYWwgcmVqZWN0KVxyXG5cdFx0XHRpZiAoY29kZUEgJiBjb2RlQikge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gb3RoZXIgY2FzZXNcclxuXHRcdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0XHRwID0gdGhpcy5fZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMsIHJvdW5kKTtcclxuXHRcdFx0bmV3Q29kZSA9IHRoaXMuX2dldEJpdENvZGUocCwgYm91bmRzKTtcclxuXHJcblx0XHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRcdGEgPSBwO1xyXG5cdFx0XHRcdGNvZGVBID0gbmV3Q29kZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRiID0gcDtcclxuXHRcdFx0XHRjb2RlQiA9IG5ld0NvZGU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0RWRnZUludGVyc2VjdGlvbjogZnVuY3Rpb24gKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHRcdHZhciBkeCA9IGIueCAtIGEueCxcclxuXHRcdCAgICBkeSA9IGIueSAtIGEueSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgeCwgeTtcclxuXHJcblx0XHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHRcdHggPSBhLnggKyBkeCAqIChtYXgueSAtIGEueSkgLyBkeTtcclxuXHRcdFx0eSA9IG1heC55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHRcdHggPSBhLnggKyBkeCAqIChtaW4ueSAtIGEueSkgLyBkeTtcclxuXHRcdFx0eSA9IG1pbi55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdFx0eCA9IG1heC54O1xyXG5cdFx0XHR5ID0gYS55ICsgZHkgKiAobWF4LnggLSBhLngpIC8gZHg7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHRcdHggPSBtaW4ueDtcclxuXHRcdFx0eSA9IGEueSArIGR5ICogKG1pbi54IC0gYS54KSAvIGR4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5LCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0X2dldEJpdENvZGU6IGZ1bmN0aW9uIChwLCBib3VuZHMpIHtcclxuXHRcdHZhciBjb2RlID0gMDtcclxuXHJcblx0XHRpZiAocC54IDwgYm91bmRzLm1pbi54KSB7IC8vIGxlZnRcclxuXHRcdFx0Y29kZSB8PSAxO1xyXG5cdFx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdFx0Y29kZSB8PSAyO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGNvZGUgfD0gNDtcclxuXHRcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0XHRjb2RlIHw9IDg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvZGU7XHJcblx0fSxcclxuXHJcblx0Ly8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcblx0X3NxRGlzdDogZnVuY3Rpb24gKHAxLCBwMikge1xyXG5cdFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0XHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuXHRfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uIChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdFx0dmFyIHggPSBwMS54LFxyXG5cdFx0ICAgIHkgPSBwMS55LFxyXG5cdFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0XHQgICAgZHkgPSBwMi55IC0geSxcclxuXHRcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHRcdCAgICB0O1xyXG5cclxuXHRcdGlmIChkb3QgPiAwKSB7XHJcblx0XHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0XHR5ID0gcDIueTtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZHggPSBwLnggLSB4O1xyXG5cdFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBMLlBvaW50KHgsIHkpO1xyXG5cdH1cclxufTtcclxuXG4vKlxuICogQGNsYXNzIFBvbHlsaW5lXG4gKiBAYWthIEwuUG9seWxpbmVcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5bGluZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUGF0aGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlsaW5lIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFstMTIyLjY4LCA0NS41MV0sXG4gKiBcdFstMTIyLjQzLCAzNy43N10sXG4gKiBcdFstMTE4LjIsIDM0LjA0XVxuICogXTtcbiAqXG4gKiB2YXIgcG9seWxpbmUgPSBMLnBvbHlsaW5lKGxhdGxuZ3MsIHtjb2xvcjogJ3JlZCd9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcG9seWxpbmVcbiAqIG1hcC5maXRCb3VuZHMocG9seWxpbmUuZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSB0byByZXByZXNlbnQgYSBgTXVsdGlQb2x5bGluZWAgc2hhcGU6XG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIGFycmF5cyBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqIFx0W1stMTIyLjY4LCA0NS41MV0sXG4gKiBcdCBbLTEyMi40MywgMzcuNzddLFxuICogXHQgWy0xMTguMiwgMzQuMDRdXSxcbiAqIFx0W1stNzMuOTEsIDQwLjc4XSxcbiAqIFx0IFstODcuNjIsIDQxLjgzXSxcbiAqIFx0IFstOTYuNzIsIDMyLjc2XV1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5MLlBvbHlsaW5lID0gTC5QYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBQb2x5bGluZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHNtb290aEZhY3RvcjogTnVtYmVyID0gMS4wXG5cdFx0Ly8gSG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbC4gTW9yZSBtZWFuc1xuXHRcdC8vIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgYW5kIGxlc3MgbWVhbnMgbW9yZSBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbi5cblx0XHRzbW9vdGhGYWN0b3I6IDEuMCxcblxuXHRcdC8vIEBvcHRpb24gbm9DbGlwOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBEaXNhYmxlIHBvbHlsaW5lIGNsaXBwaW5nLlxuXHRcdG5vQ2xpcDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5ncygpOiBMYXRMbmdbXVxuXHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBwb2ludHMgaW4gdGhlIHBhdGgsIG9yIG5lc3RlZCBhcnJheXMgb2YgcG9pbnRzIGluIGNhc2Ugb2YgbXVsdGktcG9seWxpbmUuXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5ncztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldExhdExuZ3MobGF0bG5nczogTGF0TG5nW10pOiB0aGlzXG5cdC8vIFJlcGxhY2VzIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBwb2x5bGluZSB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzLlxuXHRzZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX3NldExhdExuZ3MobGF0bG5ncyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc0VtcHR5KCk6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFBvbHlsaW5lIGhhcyBubyBMYXRMbmdzLlxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aDtcblx0fSxcblxuXHRjbG9zZXN0TGF5ZXJQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSxcblx0XHQgICAgbWluUG9pbnQgPSBudWxsLFxuXHRcdCAgICBjbG9zZXN0ID0gTC5MaW5lVXRpbC5fc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQsXG5cdFx0ICAgIHAxLCBwMjtcblxuXHRcdGZvciAodmFyIGogPSAwLCBqTGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5fcGFydHNbal07XG5cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0XHRwMiA9IHBvaW50c1tpXTtcblxuXHRcdFx0XHR2YXIgc3FEaXN0ID0gY2xvc2VzdChwLCBwMSwgcDIsIHRydWUpO1xuXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xuXHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gc3FEaXN0O1xuXHRcdFx0XHRcdG1pblBvaW50ID0gY2xvc2VzdChwLCBwMSwgcDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtaW5Qb2ludCkge1xuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluUG9pbnQ7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciAoW2NlbnRyb2lkXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGksIGhhbGZEaXN0LCBzZWdEaXN0LCBkaXN0LCBwMSwgcDIsIHJhdGlvLFxuXHRcdCAgICBwb2ludHMgPSB0aGlzLl9yaW5nc1swXSxcblx0XHQgICAgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybiBudWxsOyB9XG5cblx0XHQvLyBwb2x5bGluZSBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGZvciAoaSA9IDAsIGhhbGZEaXN0ID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuXHRcdFx0aGFsZkRpc3QgKz0gcG9pbnRzW2ldLmRpc3RhbmNlVG8ocG9pbnRzW2kgKyAxXSkgLyAyO1xuXHRcdH1cblxuXHRcdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cblx0XHRpZiAoaGFsZkRpc3QgPT09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50c1swXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcblx0XHRcdHAxID0gcG9pbnRzW2ldO1xuXHRcdFx0cDIgPSBwb2ludHNbaSArIDFdO1xuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdFx0ZGlzdCArPSBzZWdEaXN0O1xuXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XG5cdFx0XHRcdHJhdGlvID0gKGRpc3QgLSBoYWxmRGlzdCkgLyBzZWdEaXN0O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhbXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcblx0XHRcdFx0XHRwMi55IC0gcmF0aW8gKiAocDIueSAtIHAxLnkpXG5cdFx0XHRcdF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/IExhdExuZ1tdKTogdGhpc1xuXHQvLyBBZGRzIGEgZ2l2ZW4gcG9pbnQgdG8gdGhlIHBvbHlsaW5lLiBCeSBkZWZhdWx0LCBhZGRzIHRvIHRoZSBmaXJzdCByaW5nIG9mXG5cdC8vIHRoZSBwb2x5bGluZSBpbiBjYXNlIG9mIGEgbXVsdGktcG9seWxpbmUsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nXG5cdC8vIGEgc3BlY2lmaWMgcmluZyBhcyBhIExhdExuZyBhcnJheSAodGhhdCB5b3UgY2FuIGVhcmxpZXIgYWNjZXNzIHdpdGggW2BnZXRMYXRMbmdzYF0oI3BvbHlsaW5lLWdldGxhdGxuZ3MpKS5cblx0YWRkTGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nLCBsYXRsbmdzKSB7XG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fZGVmYXVsdFNoYXBlKCk7XG5cdFx0bGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHRsYXRsbmdzLnB1c2gobGF0bG5nKTtcblx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0X3NldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cdFx0dGhpcy5fbGF0bG5ncyA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3MpO1xuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKSA/IHRoaXMuX2xhdGxuZ3MgOiB0aGlzLl9sYXRsbmdzWzBdO1xuXHR9LFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGNvbnZlcnQgbGF0bG5ncyBpbnB1dCBpbnRvIGFjdHVhbCBMYXRMbmcgaW5zdGFuY2VzOyBjYWxjdWxhdGUgYm91bmRzIGFsb25nIHRoZSB3YXlcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHQgICAgZmxhdCA9IEwuUG9seWxpbmUuX2ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gTC5sYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgTC5Cb3VuZHMoKTtcblx0XHR0aGlzLl9yaW5ncyA9IFtdO1xuXHRcdHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsIHRoaXMuX3JpbmdzLCBweEJvdW5kcyk7XG5cblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgTC5Qb2ludCh3LCB3KTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHMuaXNWYWxpZCgpICYmIHB4Qm91bmRzLmlzVmFsaWQoKSkge1xuXHRcdFx0cHhCb3VuZHMubWluLl9zdWJ0cmFjdChwKTtcblx0XHRcdHB4Qm91bmRzLm1heC5fYWRkKHApO1xuXHRcdFx0dGhpcy5fcHhCb3VuZHMgPSBweEJvdW5kcztcblx0XHR9XG5cdH0sXG5cblx0Ly8gcmVjdXJzaXZlbHkgdHVybnMgbGF0bG5ncyBpbnRvIGEgc2V0IG9mIHJpbmdzIHdpdGggcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdF9wcm9qZWN0TGF0bG5nczogZnVuY3Rpb24gKGxhdGxuZ3MsIHJlc3VsdCwgcHJvamVjdGVkQm91bmRzKSB7XG5cdFx0dmFyIGZsYXQgPSBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTC5MYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTC5MaW5lVXRpbC5jbGlwU2VnbWVudChwb2ludHNbal0sIHBvaW50c1tqICsgMV0sIGJvdW5kcywgaiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKCFzZWdtZW50KSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcblx0XHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcblxuXHRcdFx0XHQvLyBpZiBzZWdtZW50IGdvZXMgb3V0IG9mIHNjcmVlbiwgb3IgaXQncyB0aGUgbGFzdCBvbmUsIGl0J3MgdGhlIGVuZCBvZiB0aGUgbGluZSBwYXJ0XG5cdFx0XHRcdGlmICgoc2VnbWVudFsxXSAhPT0gcG9pbnRzW2ogKyAxXSkgfHwgKGogPT09IGxlbjIgLSAyKSkge1xuXHRcdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFsxXSk7XG5cdFx0XHRcdFx0aysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZSBmb3IgcGVyZm9ybWFuY2Vcblx0X3NpbXBsaWZ5UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXG5cdFx0ICAgIHRvbGVyYW5jZSA9IHRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3I7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnRzW2ldID0gTC5MaW5lVXRpbC5zaW1wbGlmeShwYXJ0c1tpXSwgdG9sZXJhbmNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xuXHRcdHRoaXMuX3NpbXBsaWZ5UG9pbnRzKCk7XG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcyk7XG5cdH1cbn0pO1xuXG4vLyBAZmFjdG9yeSBMLnBvbHlsaW5lKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIHBvbHlsaW5lIG9iamVjdCBnaXZlbiBhbiBhcnJheSBvZiBnZW9ncmFwaGljYWwgcG9pbnRzIGFuZFxuLy8gb3B0aW9uYWxseSBhbiBvcHRpb25zIG9iamVjdC4gWW91IGNhbiBjcmVhdGUgYSBgUG9seWxpbmVgIG9iamVjdCB3aXRoXG4vLyBtdWx0aXBsZSBzZXBhcmF0ZSBsaW5lcyAoYE11bHRpUG9seWxpbmVgKSBieSBwYXNzaW5nIGFuIGFycmF5IG9mIGFycmF5c1xuLy8gb2YgZ2VvZ3JhcGhpYyBwb2ludHMuXG5MLnBvbHlsaW5lID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLlBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpO1xufTtcblxuTC5Qb2x5bGluZS5fZmxhdCA9IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdC8vIHRydWUgaWYgaXQncyBhIGZsYXQgYXJyYXkgb2YgbGF0bG5nczsgZmFsc2UgaWYgbmVzdGVkXG5cdHJldHVybiAhTC5VdGlsLmlzQXJyYXkobGF0bG5nc1swXSkgfHwgKHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ3VuZGVmaW5lZCcpO1xufTtcblxuLypcclxuICogQG5hbWVzcGFjZSBQb2x5VXRpbFxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29uIGdlb21ldHJpZXMuXHJcbiAqL1xyXG5cclxuTC5Qb2x5VXRpbCA9IHt9O1xyXG5cclxuLyogQGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvaW50czogUG9pbnRbXSwgYm91bmRzOiBCb3VuZHMsIHJvdW5kPzogQm9vbGVhbik6IFBvaW50W11cclxuICogQ2xpcHMgdGhlIHBvbHlnb24gZ2VvbWV0cnkgZGVmaW5lZCBieSB0aGUgZ2l2ZW4gYHBvaW50c2AgYnkgdGhlIGdpdmVuIGJvdW5kcyAodXNpbmcgdGhlIFtTdXRoZXJsYW5kLUhvZGdlbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGVyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5MLlBvbHlVdGlsLmNsaXBQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cywgYm91bmRzLCByb3VuZCkge1xyXG5cdHZhciBjbGlwcGVkUG9pbnRzLFxyXG5cdCAgICBlZGdlcyA9IFsxLCA0LCAyLCA4XSxcclxuXHQgICAgaSwgaiwgayxcclxuXHQgICAgYSwgYixcclxuXHQgICAgbGVuLCBlZGdlLCBwLFxyXG5cdCAgICBsdSA9IEwuTGluZVV0aWw7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gbHUuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IGx1Ll9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IGx1Ll9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IGx1Ll9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn07XHJcblxuLypcbiAqIEBjbGFzcyBQb2x5Z29uXG4gKiBAYWthIEwuUG9seWdvblxuICogQGluaGVyaXRzIFBvbHlsaW5lXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBwb2x5Z29uIG92ZXJsYXlzIG9uIGEgbWFwLiBFeHRlbmRzIGBQb2x5bGluZWAuXG4gKlxuICogTm90ZSB0aGF0IHBvaW50cyB5b3UgcGFzcyB3aGVuIGNyZWF0aW5nIGEgcG9seWdvbiBzaG91bGRuJ3QgaGF2ZSBhbiBhZGRpdGlvbmFsIGxhc3QgcG9pbnQgZXF1YWwgdG8gdGhlIGZpcnN0IG9uZSDigJQgaXQncyBiZXR0ZXIgdG8gZmlsdGVyIG91dCBzdWNoIHBvaW50cy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gY3JlYXRlIGEgcmVkIHBvbHlnb24gZnJvbSBhbiBhcnJheSBvZiBMYXRMbmcgcG9pbnRzXG4gKiB2YXIgbGF0bG5ncyA9IFtbLTExMS4wMywgNDFdLFstMTExLjA0LCA0NV0sWy0xMDQuMDUsIDQ1XSxbLTEwNC4wNSwgNDFdXTtcbiAqXG4gKiB2YXIgcG9seWdvbiA9IEwucG9seWdvbihsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlnb25cbiAqIG1hcC5maXRCb3VuZHMocG9seWdvbi5nZXRCb3VuZHMoKSk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgbGF0bG5ncywgd2l0aCB0aGUgZmlyc3QgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvdXRlciBzaGFwZSBhbmQgdGhlIG90aGVyIGFycmF5cyByZXByZXNlbnRpbmcgaG9sZXMgaW4gdGhlIG91dGVyIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgW1stMTExLjAzLCA0MV0sWy0xMTEuMDQsIDQ1XSxbLTEwNC4wNSwgNDVdLFstMTA0LjA1LCA0MV1dLCAvLyBvdXRlciByaW5nXG4gKiAgIFtbLTEwOC41OCwzNy4yOV0sWy0xMDguNTgsNDAuNzFdLFstMTAyLjUwLDQwLjcxXSxbLTEwMi41MCwzNy4yOV1dIC8vIGhvbGVcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcGFzcyBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IHRvIHJlcHJlc2VudCBhIE11bHRpUG9seWdvbiBzaGFwZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFsgLy8gZmlyc3QgcG9seWdvblxuICogICAgIFtbLTExMS4wMywgNDFdLFstMTExLjA0LCA0NV0sWy0xMDQuMDUsIDQ1XSxbLTEwNC4wNSwgNDFdXSwgLy8gb3V0ZXIgcmluZ1xuICogICAgIFtbLTEwOC41OCwzNy4yOV0sWy0xMDguNTgsNDAuNzFdLFstMTAyLjUwLDQwLjcxXSxbLTEwMi41MCwzNy4yOV1dIC8vIGhvbGVcbiAqICAgXSxcbiAqICAgWyAvLyBzZWNvbmQgcG9seWdvblxuICogICAgIFtbLTEwOS4wNSwgMzddLFstMTA5LjAzLCA0MV0sWy0xMDIuMDUsIDQxXSxbLTEwMi4wNCwgMzddLFstMTA5LjA1LCAzOF1dXG4gKiAgIF1cbiAqIF07XG4gKiBgYGBcbiAqL1xuXG5MLlBvbHlnb24gPSBMLlBvbHlsaW5lLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGZpbGw6IHRydWVcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9sYXRsbmdzLmxlbmd0aCB8fCAhdGhpcy5fbGF0bG5nc1swXS5sZW5ndGg7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblxuXHRcdHZhciBpLCBqLCBwMSwgcDIsIGYsIGFyZWEsIHgsIHksIGNlbnRlcixcblx0XHQgICAgcG9pbnRzID0gdGhpcy5fcmluZ3NbMF0sXG5cdFx0ICAgIGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIWxlbikgeyByZXR1cm4gbnVsbDsgfVxuXG5cdFx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07IG9ubHkgdXNlcyB0aGUgZmlyc3QgcmluZyBpZiB0aGVyZSBhcmUgbXVsdGlwbGVcblxuXHRcdGFyZWEgPSB4ID0geSA9IDA7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cdFx0XHRwMiA9IHBvaW50c1tqXTtcblxuXHRcdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XG5cdFx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xuXHRcdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcblx0XHRcdGFyZWEgKz0gZiAqIDM7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZWEgPT09IDApIHtcblx0XHRcdC8vIFBvbHlnb24gaXMgc28gc21hbGwgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiBzYW1lIHBpeGVsLlxuXHRcdFx0Y2VudGVyID0gcG9pbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIgPSBbeCAvIGFyZWEsIHkgLyBhcmVhXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoY2VudGVyKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IEwuUG9seWxpbmUucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpLFxuXHRcdCAgICBsZW4gPSByZXN1bHQubGVuZ3RoO1xuXG5cdFx0Ly8gcmVtb3ZlIGxhc3QgcG9pbnQgaWYgaXQgZXF1YWxzIGZpcnN0IG9uZVxuXHRcdGlmIChsZW4gPj0gMiAmJiByZXN1bHRbMF0gaW5zdGFuY2VvZiBMLkxhdExuZyAmJiByZXN1bHRbMF0uZXF1YWxzKHJlc3VsdFtsZW4gLSAxXSkpIHtcblx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRfc2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHRMLlBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpKSB7XG5cdFx0XHR0aGlzLl9sYXRsbmdzID0gW3RoaXMuX2xhdGxuZ3NdO1xuXHRcdH1cblx0fSxcblxuXHRfZGVmYXVsdFNoYXBlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEwuUG9seWxpbmUuX2ZsYXQodGhpcy5fbGF0bG5nc1swXSkgPyB0aGlzLl9sYXRsbmdzWzBdIDogdGhpcy5fbGF0bG5nc1swXVswXTtcblx0fSxcblxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdC8vIHBvbHlnb25zIG5lZWQgYSBkaWZmZXJlbnQgY2xpcHBpbmcgYWxnb3JpdGhtIHNvIHdlIHJlZGVmaW5lIHRoYXRcblxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9yZW5kZXJlci5fYm91bmRzLFxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCxcblx0XHQgICAgcCA9IG5ldyBMLlBvaW50KHcsIHcpO1xuXG5cdFx0Ly8gaW5jcmVhc2UgY2xpcCBwYWRkaW5nIGJ5IHN0cm9rZSB3aWR0aCB0byBhdm9pZCBzdHJva2Ugb24gY2xpcCBlZGdlc1xuXHRcdGJvdW5kcyA9IG5ldyBMLkJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IEwuUG9seVV0aWwuY2xpcFBvbHlnb24odGhpcy5fcmluZ3NbaV0sIGJvdW5kcywgdHJ1ZSk7XG5cdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5fcGFydHMucHVzaChjbGlwcGVkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCB0cnVlKTtcblx0fVxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbkwucG9seWdvbiA9IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufTtcblxuLypcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXG4gKi9cblxuLypcbiAqIEBjbGFzcyBSZWN0YW5nbGVcbiAqIEBha2EgTC5SZXRhbmdsZVxuICogQGluaGVyaXRzIFBvbHlnb25cbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICogYGBgXG4gKlxuICovXG5cblxuTC5SZWN0YW5nbGUgPSBMLlBvbHlnb24uZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xuXHRcdEwuUG9seWdvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMuX2JvdW5kc1RvTGF0TG5ncyhsYXRMbmdCb3VuZHMpLCBvcHRpb25zKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldEJvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcyk6IHRoaXNcblx0Ly8gUmVkcmF3cyB0aGUgcmVjdGFuZ2xlIHdpdGggdGhlIHBhc3NlZCBib3VuZHMuXG5cdHNldEJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xuXHR9LFxuXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcblx0XHRsYXRMbmdCb3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhsYXRMbmdCb3VuZHMpO1xuXHRcdHJldHVybiBbXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcblx0XHRdO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLnJlY3RhbmdsZShsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG5MLnJlY3RhbmdsZSA9IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBMLlJlY3RhbmdsZShsYXRMbmdCb3VuZHMsIG9wdGlvbnMpO1xufTtcblxuLypcbiAqIEBjbGFzcyBDaXJjbGVNYXJrZXJcbiAqIEBha2EgTC5DaXJjbGVNYXJrZXJcbiAqIEBpbmhlcml0cyBQYXRoXG4gKlxuICogQSBjaXJjbGUgb2YgYSBmaXhlZCBzaXplIHdpdGggcmFkaXVzIHNwZWNpZmllZCBpbiBwaXhlbHMuIEV4dGVuZHMgYFBhdGhgLlxuICovXG5cbkwuQ2lyY2xlTWFya2VyID0gTC5QYXRoLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBDaXJjbGVNYXJrZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXIgPSAxMFxuXHRcdC8vIFJhZGl1cyBvZiB0aGUgY2lyY2xlIG1hcmtlciwgaW4gcGl4ZWxzXG5cdFx0cmFkaXVzOiAxMFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcblx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLm9wdGlvbnMucmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0TGF0TG5nKGxhdExuZzogTGF0TG5nKTogdGhpc1xuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiBhIGNpcmNsZSBtYXJrZXIgdG8gYSBuZXcgbG9jYXRpb24uXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge2xhdGxuZzogdGhpcy5fbGF0bG5nfSk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmcoKTogTGF0TG5nXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgZ2VvZ3JhcGhpY2FsIHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSBtYXJrZXIuIFVuaXRzIGFyZSBpbiBwaXhlbHMuXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xuXHRcdHRoaXMub3B0aW9ucy5yYWRpdXMgPSB0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRSYWRpdXMoKTogTnVtYmVyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcblx0fSxcblxuXHRzZXRTdHlsZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0dmFyIHJhZGl1cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yYWRpdXMgfHwgdGhpcy5fcmFkaXVzO1xuXHRcdEwuUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLnNldFJhZGl1cyhyYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdH0sXG5cblx0X3VwZGF0ZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByID0gdGhpcy5fcmFkaXVzLFxuXHRcdCAgICByMiA9IHRoaXMuX3JhZGl1c1kgfHwgcixcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBbciArIHcsIHIyICsgd107XG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgTC5Cb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY2lyY2xlTWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogQ2lyY2xlTWFya2VyIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBjaXJjbGUgbWFya2VyIG9iamVjdCBnaXZlbiBhIGdlb2dyYXBoaWNhbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuTC5jaXJjbGVNYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5DaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbn07XG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAYWthIEwuQ2lyY2xlXG4gKiBAaW5oZXJpdHMgQ2lyY2xlTWFya2VyXG4gKlxuICogQSBjbGFzcyBmb3IgZHJhd2luZyBjaXJjbGUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYENpcmNsZU1hcmtlcmAuXG4gKlxuICogSXQncyBhbiBhcHByb3hpbWF0aW9uIGFuZCBzdGFydHMgdG8gZGl2ZXJnZSBmcm9tIGEgcmVhbCBjaXJjbGUgY2xvc2VyIHRvIHBvbGVzIChkdWUgdG8gcHJvamVjdGlvbiBkaXN0b3J0aW9uKS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNpcmNsZShbNTAuNSwgMzAuNV0sIHtyYWRpdXM6IDIwMH0pLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5MLkNpcmNsZSA9IEwuQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IEwuZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nQm91bmRzKFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5zdWJ0cmFjdChoYWxmKSksXG5cdFx0XHR0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3BvaW50LmFkZChoYWxmKSkpO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBMLlBhdGgucHJvdG90eXBlLnNldFN0eWxlLFxuXG5cdF9wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbG5nID0gdGhpcy5fbGF0bG5nLmxuZyxcblx0XHQgICAgbGF0ID0gdGhpcy5fbGF0bG5nLmxhdCxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBjcnMgPSBtYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoY3JzLmRpc3RhbmNlID09PSBMLkNSUy5FYXJ0aC5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0ICAgIGxhdFIgPSAodGhpcy5fbVJhZGl1cyAvIEwuQ1JTLkVhcnRoLlIpIC8gZCxcblx0XHRcdCAgICB0b3AgPSBtYXAucHJvamVjdChbbGF0ICsgbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgYm90dG9tID0gbWFwLnByb2plY3QoW2xhdCAtIGxhdFIsIGxuZ10pLFxuXHRcdFx0ICAgIHAgPSB0b3AuYWRkKGJvdHRvbSkuZGl2aWRlQnkoMiksXG5cdFx0XHQgICAgbGF0MiA9IG1hcC51bnByb2plY3QocCkubGF0LFxuXHRcdFx0ICAgIGxuZ1IgPSBNYXRoLmFjb3MoKE1hdGguY29zKGxhdFIgKiBkKSAtIE1hdGguc2luKGxhdCAqIGQpICogTWF0aC5zaW4obGF0MiAqIGQpKSAvXG5cdFx0XHQgICAgICAgICAgICAoTWF0aC5jb3MobGF0ICogZCkgKiBNYXRoLmNvcyhsYXQyICogZCkpKSAvIGQ7XG5cblx0XHRcdGlmIChpc05hTihsbmdSKSB8fCBsbmdSID09PSAwKSB7XG5cdFx0XHRcdGxuZ1IgPSBsYXRSIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDE4MCAqIGxhdCk7IC8vIEZhbGxiYWNrIGZvciBlZGdlIGNhc2UsICMyNDI1XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3BvaW50ID0gcC5zdWJ0cmFjdChtYXAuZ2V0UGl4ZWxPcmlnaW4oKSk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSBpc05hTihsbmdSKSA/IDAgOiBNYXRoLm1heChNYXRoLnJvdW5kKHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueCksIDEpO1xuXHRcdFx0dGhpcy5fcmFkaXVzWSA9IE1hdGgubWF4KE1hdGgucm91bmQocC55IC0gdG9wLnkpLCAxKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuTC5jaXJjbGUgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKSB7XG5cdHJldHVybiBuZXcgTC5DaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn07XG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKiBAaW5oZXJpdHMgUmVuZGVyZXJcbiAqIEBha2EgTC5TVkdcbiAqXG4gKiBBbGxvd3MgdmVjdG9yIGxheWVycyB0byBiZSBkaXNwbGF5ZWQgd2l0aCBbU1ZHXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9TVkcpLlxuICogSW5oZXJpdHMgYFJlbmRlcmVyYC5cbiAqXG4gKiBEdWUgdG8gW3RlY2huaWNhbCBsaW1pdGF0aW9uc10oaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9c3ZnKSwgU1ZHIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAqIHRoaXMgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbkwuU1ZHID0gTC5SZW5kZXJlci5leHRlbmQoe1xuXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudHMgPSBMLlJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMuem9vbXN0YXJ0ID0gdGhpcy5fb25ab29tU3RhcnQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuU1ZHLmNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBMLlNWRy5jcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfb25ab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBEcmFnLXRoZW4tcGluY2ggaW50ZXJhY3Rpb25zIG1pZ2h0IG1lc3MgdXAgdGhlIGNlbnRlciBhbmQgem9vbS5cblx0XHQvLyBJbiB0aGlzIGNhc2UsIHRoZSBlYXNpZXN0IHdheSB0byBwcmV2ZW50IHRoaXMgaXMgcmUtZG8gdGhlIHJlbmRlcmVyXG5cdFx0Ly8gICBib3VuZHMgYW5kIHBhZGRpbmcgd2hlbiB0aGUgem9vbWluZyBzdGFydHMuXG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0TC5SZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuXG5cdFx0Ly8gc2V0IHNpemUgb2Ygc3ZnLWNvbnRhaW5lciBpZiBjaGFuZ2VkXG5cdFx0aWYgKCF0aGlzLl9zdmdTaXplIHx8ICF0aGlzLl9zdmdTaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dGhpcy5fc3ZnU2l6ZSA9IHNpemU7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUueCk7XG5cdFx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplLnkpO1xuXHRcdH1cblxuXHRcdC8vIG1vdmVtZW50OiB1cGRhdGUgY29udGFpbmVyIHZpZXdCb3ggc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSBjb29yZGluYXRlcyBvZiBpbmRpdmlkdWFsIGxheWVyc1xuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBMLlNWRy5jcmVhdGUoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCBsYXllci5vcHRpb25zLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYXRoLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKGxheWVyKTtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcm9vdEdyb3VwLmFwcGVuZENoaWxkKGxheWVyLl9wYXRoKTtcblx0XHRsYXllci5hZGRJbnRlcmFjdGl2ZVRhcmdldChsYXllci5fcGF0aCk7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmUobGF5ZXIuX3BhdGgpO1xuXHRcdGxheWVyLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgTC5TVkcucG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBsYXllci5fcmFkaXVzLFxuXHRcdCAgICByMiA9IGxheWVyLl9yYWRpdXNZIHx8IHIsXG5cdFx0ICAgIGFyYyA9ICdhJyArIHIgKyAnLCcgKyByMiArICcgMCAxLDAgJztcblxuXHRcdC8vIGRyYXdpbmcgYSBjaXJjbGUgd2l0aCB0d28gaGFsZi1hcmNzXG5cdFx0dmFyIGQgPSBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRcdGFyYyArIChyICogMikgKyAnLDAgJyArXG5cdFx0XHRcdGFyYyArICgtciAqIDIpICsgJywwICc7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBkKTtcblx0fSxcblxuXHRfc2V0UGF0aDogZnVuY3Rpb24gKGxheWVyLCBwYXRoKSB7XG5cdFx0bGF5ZXIuX3BhdGguc2V0QXR0cmlidXRlKCdkJywgcGF0aCk7XG5cdH0sXG5cblx0Ly8gU1ZHIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgekluZGV4IHNvIHdlIHJlc29ydCB0byBjaGFuZ2luZyB0aGUgRE9NIG9yZGVyIG9mIGVsZW1lbnRzXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0JhY2sobGF5ZXIuX3BhdGgpO1xuXHR9XG59KTtcblxuXG4vLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5MLmV4dGVuZChMLlNWRywge1xuXHQvLyBAZnVuY3Rpb24gY3JlYXRlKG5hbWU6IFN0cmluZyk6IFNWR0VsZW1lbnRcblx0Ly8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG5cdC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWUgcGFzc2VkLiBGb3IgZXhhbXBsZSwgdXNpbmcgJ2xpbmUnIHdpbGwgcmV0dXJuXG5cdC8vIGFuIGluc3RhbmNlIG9mIFtTVkdMaW5lRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL1NWR0xpbmVFbGVtZW50KS5cblx0Y3JlYXRlOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG5cdH0sXG5cblx0Ly8gQGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5nczogUG9pbnRbXSwgY2xvc2VkOiBCb29sZWFuKTogU3RyaW5nXG5cdC8vIEdlbmVyYXRlcyBhIFNWRyBwYXRoIHN0cmluZyBmb3IgbXVsdGlwbGUgcmluZ3MsIHdpdGggZWFjaCByaW5nIHR1cm5pbmdcblx0Ly8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuXHRwb2ludHNUb1BhdGg6IGZ1bmN0aW9uIChyaW5ncywgY2xvc2VkKSB7XG5cdFx0dmFyIHN0ciA9ICcnLFxuXHRcdCAgICBpLCBqLCBsZW4sIGxlbjIsIHBvaW50cywgcDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcblx0XHRcdFx0cCA9IHBvaW50c1tqXTtcblx0XHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2xvc2VzIHRoZSByaW5nIGZvciBwb2x5Z29uczsgXCJ4XCIgaXMgVk1MIHN5bnRheFxuXHRcdFx0c3RyICs9IGNsb3NlZCA/IChMLkJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKSA6ICcnO1xuXHRcdH1cblxuXHRcdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdFx0cmV0dXJuIHN0ciB8fCAnTTAgMCc7XG5cdH1cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIEJyb3dzZXI7IEBwcm9wZXJ0eSBzdmc6IEJvb2xlYW5cbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXG5MLkJyb3dzZXIuc3ZnID0gISEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIEwuU1ZHLmNyZWF0ZSgnc3ZnJykuY3JlYXRlU1ZHUmVjdCk7XG5cblxuLy8gQG5hbWVzcGFjZSBTVkdcbi8vIEBmYWN0b3J5IEwuc3ZnKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIFNWRyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuTC5zdmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gTC5Ccm93c2VyLnN2ZyB8fCBMLkJyb3dzZXIudm1sID8gbmV3IEwuU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn07XG5cbi8qXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxuICovXG5cbi8qXG4gKiBAY2xhc3MgU1ZHXG4gKlxuICogQWx0aG91Z2ggU1ZHIGlzIG5vdCBhdmFpbGFibGUgb24gSUU3IGFuZCBJRTgsIHRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSksIGFuZCB0aGUgU1ZHIHJlbmRlcmVyIHdpbGwgZmFsbCBiYWNrIHRvIFZNTCBpbiB0aGlzIGNhc2UuXG4gKlxuICogVk1MIHdhcyBkZXByZWNhdGVkIGluIDIwMTIsIHdoaWNoIG1lYW5zIFZNTCBmdW5jdGlvbmFsaXR5IGV4aXN0cyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICogd2l0aCBvbGQgdmVyc2lvbnMgb2YgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBCcm93c2VyOyBAcHJvcGVydHkgdm1sOiBCb29sZWFuXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXG5MLkJyb3dzZXIudm1sID0gIUwuQnJvd3Nlci5zdmcgJiYgKGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0ZGl2LmlubmVySFRNTCA9ICc8djpzaGFwZSBhZGo9XCIxXCIvPic7XG5cblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcblx0XHRzaGFwZS5zdHlsZS5iZWhhdmlvciA9ICd1cmwoI2RlZmF1bHQjVk1MKSc7XG5cblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcblxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KCkpO1xuXG4vLyByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuTC5TVkcuaW5jbHVkZSghTC5Ccm93c2VyLnZtbCA/IHt9IDoge1xuXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtdm1sLWNvbnRhaW5lcicpO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXHRcdEwuUmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSBMLlNWRy5jcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC12bWwtc2hhcGUgJyArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSk7XG5cblx0XHRjb250YWluZXIuY29vcmRzaXplID0gJzEgMSc7XG5cblx0XHRsYXllci5fcGF0aCA9IEwuU1ZHLmNyZWF0ZSgncGF0aCcpO1xuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cblx0XHR0aGlzLl91cGRhdGVTdHlsZShsYXllcik7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcblx0XHRcdGxheWVyLmFkZEludGVyYWN0aXZlVGFyZ2V0KGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lcjtcblx0XHRMLkRvbVV0aWwucmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zLFxuXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG5cdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuXHRcdGNvbnRhaW5lci5maWxsZWQgPSAhIW9wdGlvbnMuZmlsbDtcblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0aWYgKCFzdHJva2UpIHtcblx0XHRcdFx0c3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSA9IEwuU1ZHLmNyZWF0ZSgnc3Ryb2tlJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gTC5VdGlsLmlzQXJyYXkob3B0aW9ucy5kYXNoQXJyYXkpID9cblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csICcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XG5cdFx0XHR9XG5cdFx0XHRzdHJva2UuZW5kY2FwID0gb3B0aW9ucy5saW5lQ2FwLnJlcGxhY2UoJ2J1dHQnLCAnZmxhdCcpO1xuXHRcdFx0c3Ryb2tlLmpvaW5zdHlsZSA9IG9wdGlvbnMubGluZUpvaW47XG5cblx0XHR9IGVsc2UgaWYgKHN0cm9rZSkge1xuXHRcdFx0Y29udGFpbmVyLnJlbW92ZUNoaWxkKHN0cm9rZSk7XG5cdFx0XHRsYXllci5fc3Ryb2tlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XG5cdFx0XHRpZiAoIWZpbGwpIHtcblx0XHRcdFx0ZmlsbCA9IGxheWVyLl9maWxsID0gTC5TVkcuY3JlYXRlKCdmaWxsJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsbCk7XG5cdFx0XHRmaWxsLmNvbG9yID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGZpbGwub3BhY2l0eSA9IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cblx0XHR9IGVsc2UgaWYgKGZpbGwpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChmaWxsKTtcblx0XHRcdGxheWVyLl9maWxsID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQucm91bmQoKSxcblx0XHQgICAgciA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1cyksXG5cdFx0ICAgIHIyID0gTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSB8fCByKTtcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdFx0J0FMICcgKyBwLnggKyAnLCcgKyBwLnkgKyAnICcgKyByICsgJywnICsgcjIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCkpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC52ID0gcGF0aDtcblx0fSxcblxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRMLkRvbVV0aWwudG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdEwuRG9tVXRpbC50b0JhY2sobGF5ZXIuX2NvbnRhaW5lcik7XG5cdH1cbn0pO1xuXG5pZiAoTC5Ccm93c2VyLnZtbCkge1xuXHRMLlNWRy5jcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRkb2N1bWVudC5uYW1lc3BhY2VzLmFkZCgnbHZtbCcsICd1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbCcpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPCcgKyBuYW1lICsgJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSkoKTtcbn1cblxuLypcbiAqIEBjbGFzcyBDYW52YXNcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLkNhbnZhc1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1jYW52YXMpLCBDYW52YXMgaXMgbm90XG4gKiBhdmFpbGFibGUgaW4gYWxsIHdlYiBicm93c2Vycywgbm90YWJseSBJRTgsIGFuZCBvdmVybGFwcGluZyBnZW9tZXRyaWVzIG1pZ2h0XG4gKiBub3QgZGlzcGxheSBwcm9wZXJseSBpbiBzb21lIGVkZ2UgY2FzZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBVc2UgQ2FudmFzIGJ5IGRlZmF1bHQgZm9yIGFsbCBwYXRocyBpbiB0aGUgbWFwOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAqIFx0cmVuZGVyZXI6IEwuY2FudmFzKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogVXNlIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggZXh0cmEgcGFkZGluZyBmb3Igc3BlY2lmaWMgdmVjdG9yIGdlb21ldHJpZXM6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJyk7XG4gKiB2YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHsgcGFkZGluZzogMC41IH0pO1xuICogdmFyIGxpbmUgPSBMLnBvbHlsaW5lKCBjb29yZGluYXRlcywgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiB2YXIgY2lyY2xlID0gTC5jaXJjbGUoIGNlbnRlciwgeyByZW5kZXJlcjogbXlSZW5kZXJlciB9ICk7XG4gKiBgYGBcbiAqL1xuXG5MLkNhbnZhcyA9IEwuUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdEwuUmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLl9sYXllcnMgPSB0aGlzLl9sYXllcnMgfHwge307XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0XHQub24oY29udGFpbmVyLCAnbW91c2Vtb3ZlJywgTC5VdGlsLnRocm90dGxlKHRoaXMuX29uTW91c2VNb3ZlLCAzMiwgdGhpcyksIHRoaXMpXG5cdFx0XHQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKVxuXHRcdFx0Lm9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5faGFuZGxlTW91c2VPdXQsIHRoaXMpO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20gJiYgdGhpcy5fYm91bmRzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZHJhd25MYXllcnMgPSB7fTtcblxuXHRcdEwuUmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuXHRcdHZhciBiID0gdGhpcy5fYm91bmRzLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsXG5cdFx0ICAgIHNpemUgPSBiLmdldFNpemUoKSxcblx0XHQgICAgbSA9IEwuQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblxuXHRcdC8vIHNldCBjYW52YXMgc2l6ZSAoYWxzbyBjbGVhcmluZyBpdCk7IHVzZSBkb3VibGUgc2l6ZSBvbiByZXRpbmFcblx0XHRjb250YWluZXIud2lkdGggPSBtICogc2l6ZS54O1xuXHRcdGNvbnRhaW5lci5oZWlnaHQgPSBtICogc2l6ZS55O1xuXHRcdGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XG5cdFx0Y29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cblx0XHRpZiAoTC5Ccm93c2VyLnJldGluYSkge1xuXHRcdFx0dGhpcy5fY3R4LnNjYWxlKDIsIDIpO1xuXHRcdH1cblxuXHRcdC8vIHRyYW5zbGF0ZSBzbyB3ZSB1c2UgdGhlIHNhbWUgcGF0aCBjb29yZGluYXRlcyBhZnRlciBjYW52YXMgZWxlbWVudCBtb3Zlc1xuXHRcdHRoaXMuX2N0eC50cmFuc2xhdGUoLWIubWluLngsIC1iLm1pbi55KTtcblxuXHRcdC8vIFRlbGwgcGF0aHMgdG8gcmVkcmF3IHRoZW1zZWx2ZXNcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbTC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IEwuVXRpbC5mYWxzZUZuLFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRsYXllci5fcmVtb3ZlZCA9IHRydWU7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IGxheWVyLl9weEJvdW5kcztcblx0XHR0aGlzLl9kcmF3KHRydWUpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX2RyYXcoKTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdHZhciBwYXJ0cyA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5LnNwbGl0KCcsJyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkYXNoQXJyYXkucHVzaChOdW1iZXIocGFydHNbaV0pKTtcblx0XHRcdH1cblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGRhc2hBcnJheTtcblx0XHR9XG5cdH0sXG5cblx0X3JlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBhZGRpbmcgPSAobGF5ZXIub3B0aW9ucy53ZWlnaHQgfHwgMCkgKyAxO1xuXHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgTC5Cb3VuZHMoKTtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzLmV4dGVuZChsYXllci5fcHhCb3VuZHMubWF4LmFkZChbcGFkZGluZywgcGFkZGluZ10pKTtcblxuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3JlZHJhdywgdGhpcyk7XG5cdH0sXG5cblx0X3JlZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSBudWxsO1xuXG5cdFx0dGhpcy5fZHJhdyh0cnVlKTsgLy8gY2xlYXIgbGF5ZXJzIGluIHJlZHJhdyBib3VuZHNcblx0XHR0aGlzLl9kcmF3KCk7IC8vIGRyYXcgbGF5ZXJzXG5cblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbiAoY2xlYXIpIHtcblx0XHR0aGlzLl9jbGVhciA9IGNsZWFyO1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCwgYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpZF07XG5cdFx0XHRpZiAoIWJvdW5kcyB8fCAobGF5ZXIuX3B4Qm91bmRzICYmIGxheWVyLl9weEJvdW5kcy5pbnRlcnNlY3RzKGJvdW5kcykpKSB7XG5cdFx0XHRcdGxheWVyLl91cGRhdGVQYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xlYXIgJiYgbGF5ZXIuX3JlbW92ZWQpIHtcblx0XHRcdFx0ZGVsZXRlIGxheWVyLl9yZW1vdmVkO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY3R4LnJlc3RvcmUoKTsgIC8vIFJlc3RvcmUgc3RhdGUgYmVmb3JlIGNsaXBwaW5nLlxuXHR9LFxuXG5cdF91cGRhdGVQb2x5OiBmdW5jdGlvbiAobGF5ZXIsIGNsb3NlZCkge1xuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnRzW2ldLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuXHRcdFx0XHRwID0gcGFydHNbaV1bal07XG5cdFx0XHRcdGN0eFtqID8gJ2xpbmVUbycgOiAnbW92ZVRvJ10ocC54LCBwLnkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlsbFN0cm9rZShjdHgsIGxheWVyKTtcblxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKGxheWVyLl9lbXB0eSgpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eCxcblx0XHQgICAgciA9IGxheWVyLl9yYWRpdXMsXG5cdFx0ICAgIHMgPSAobGF5ZXIuX3JhZGl1c1kgfHwgcikgLyByO1xuXG5cdFx0dGhpcy5fZHJhd25MYXllcnNbbGF5ZXIuX2xlYWZsZXRfaWRdID0gbGF5ZXI7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zY2FsZSgxLCBzKTtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyhwLngsIHAueSAvIHMsIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG5cblx0XHRpZiAocyAhPT0gMSkge1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXHR9LFxuXG5cdF9maWxsU3Ryb2tlOiBmdW5jdGlvbiAoY3R4LCBsYXllcikge1xuXHRcdHZhciBjbGVhciA9IHRoaXMuX2NsZWFyLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjbGVhciA/ICdkZXN0aW5hdGlvbi1vdXQnIDogJ3NvdXJjZS1vdmVyJztcblxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IGNsZWFyID8gMSA6IG9wdGlvbnMuZmlsbE9wYWNpdHk7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5maWxsQ29sb3IgfHwgb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5maWxsKG9wdGlvbnMuZmlsbFJ1bGUgfHwgJ2V2ZW5vZGQnKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zdHJva2UgJiYgb3B0aW9ucy53ZWlnaHQgIT09IDApIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IGNsZWFyID8gMSA6IG9wdGlvbnMub3BhY2l0eTtcblxuXHRcdFx0Ly8gaWYgY2xlYXJpbmcgc2hhcGUsIGRvIGl0IHdpdGggdGhlIHByZXZpb3VzbHkgZHJhd24gbGluZSB3aWR0aFxuXHRcdFx0bGF5ZXIuX3ByZXZXZWlnaHQgPSBjdHgubGluZVdpZHRoID0gY2xlYXIgPyBsYXllci5fcHJldldlaWdodCArIDEgOiBvcHRpb25zLndlaWdodDtcblxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllcnMgPSBbXSwgbGF5ZXI7XG5cblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSAmJiAhdGhpcy5fbWFwLl9kcmFnZ2FibGVNb3ZlZChsYXllcikpIHtcblx0XHRcdFx0TC5Eb21FdmVudC5fZmFrZVN0b3AoZSk7XG5cdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGxheWVycy5sZW5ndGgpICB7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQobGF5ZXJzLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZpbmcoKSB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcblx0XHR0aGlzLl9oYW5kbGVNb3VzZU91dChlLCBwb2ludCk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2hvdmVyZWRMYXllcjtcblx0XHRpZiAobGF5ZXIgJiYgKGUudHlwZSA9PT0gJ21vdXNlb3V0JyB8fCAhbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSkge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0XHR0aGlzLl9maXJlRXZlbnQoW2xheWVyXSwgZSwgJ21vdXNlb3V0Jyk7XG5cdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfaGFuZGxlTW91c2VIb3ZlcjogZnVuY3Rpb24gKGUsIHBvaW50KSB7XG5cdFx0dmFyIGlkLCBsYXllcjtcblxuXHRcdGZvciAoaWQgaW4gdGhpcy5fZHJhd25MYXllcnMpIHtcblx0XHRcdGxheWVyID0gdGhpcy5fZHJhd25MYXllcnNbaWRdO1xuXHRcdFx0aWYgKGxheWVyLm9wdGlvbnMuaW50ZXJhY3RpdmUgJiYgbGF5ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7IC8vIGNoYW5nZSBjdXJzb3Jcblx0XHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW92ZXInKTtcblx0XHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2hvdmVyZWRMYXllcikge1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFt0aGlzLl9ob3ZlcmVkTGF5ZXJdLCBlKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdC8vIFRPRE8gX2JyaW5nVG9Gcm9udCAmIF9icmluZ1RvQmFjaywgcHJldHR5IHRyaWNreVxuXG5cdF9icmluZ1RvRnJvbnQ6IEwuVXRpbC5mYWxzZUZuLFxuXHRfYnJpbmdUb0JhY2s6IEwuVXRpbC5mYWxzZUZuXG59KTtcblxuLy8gQG5hbWVzcGFjZSBCcm93c2VyOyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXG4vLyBgdHJ1ZWAgd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyBbYDxjYW52YXM+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkpLlxuTC5Ccm93c2VyLmNhbnZhcyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XG59KCkpO1xuXG4vLyBAbmFtZXNwYWNlIENhbnZhc1xuLy8gQGZhY3RvcnkgTC5jYW52YXMob3B0aW9ucz86IFJlbmRlcmVyIG9wdGlvbnMpXG4vLyBDcmVhdGVzIGEgQ2FudmFzIHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5MLmNhbnZhcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdHJldHVybiBMLkJyb3dzZXIuY2FudmFzID8gbmV3IEwuQ2FudmFzKG9wdGlvbnMpIDogbnVsbDtcbn07XG5cbkwuUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xuXHR2YXIgaSwgaiwgaywgbGVuLCBsZW4yLCBwYXJ0LFxuXHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0aWYgKCF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBoaXQgZGV0ZWN0aW9uIGZvciBwb2x5bGluZXNcblx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdGlmICghY2xvc2VkICYmIChqID09PSAwKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRpZiAoTC5MaW5lVXRpbC5wb2ludFRvU2VnbWVudERpc3RhbmNlKHAsIHBhcnRba10sIHBhcnRbal0pIDw9IHcpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbkwuUG9seWdvbi5wcm90b3R5cGUuX2NvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAocCkge1xuXHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdCAgICBwYXJ0LCBwMSwgcDIsIGksIGosIGssIGxlbiwgbGVuMjtcblxuXHRpZiAoIXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cblx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcblx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdHAyID0gcGFydFtrXTtcblxuXHRcdFx0aWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcblx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBhbHNvIGNoZWNrIGlmIGl0J3Mgb24gcG9seWdvbiBzdHJva2Vcblx0cmV0dXJuIGluc2lkZSB8fCBMLlBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpO1xufTtcblxuTC5DaXJjbGVNYXJrZXIucHJvdG90eXBlLl9jb250YWluc1BvaW50ID0gZnVuY3Rpb24gKHApIHtcblx0cmV0dXJuIHAuZGlzdGFuY2VUbyh0aGlzLl9wb2ludCkgPD0gdGhpcy5fcmFkaXVzICsgdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuTC5HZW9KU09OID0gTC5GZWF0dXJlR3JvdXAuZXh0ZW5kKHtcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBAYWthIEdlb0pTT04gb3B0aW9uc1xyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBwb2ludFRvTGF5ZXI6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyBob3cgR2VvSlNPTiBwb2ludHMgc3Bhd24gTGVhZmxldCBsYXllcnMuIEl0IGlzIGludGVybmFsbHlcclxuXHQgKiBjYWxsZWQgd2hlbiBkYXRhIGlzIGFkZGVkLCBwYXNzaW5nIHRoZSBHZW9KU09OIHBvaW50IGZlYXR1cmUgYW5kIGl0cyBgTGF0TG5nYC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBzcGF3biBhIGRlZmF1bHQgYE1hcmtlcmA6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbihnZW9Kc29uUG9pbnQsIGxhdGxuZykge1xyXG5cdCAqIFx0cmV0dXJuIEwubWFya2VyKGxhdGxuZyk7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzdHlsZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIGRlZmluaW5nIHRoZSBgUGF0aCBvcHRpb25zYCBmb3Igc3R5bGluZyBHZW9KU09OIGxpbmVzIGFuZCBwb2x5Z29ucyxcclxuXHQgKiBjYWxsZWQgaW50ZXJuYWxseSB3aGVuIGRhdGEgaXMgYWRkZWQuXHJcblx0ICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgdG8gbm90IG92ZXJyaWRlIGFueSBkZWZhdWx0czpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHt9XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBvbkVhY2hGZWF0dXJlOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNyZWF0ZWQgYEZlYXR1cmVgLCBhZnRlciBpdCBoYXNcclxuXHQgKiBiZWVuIGNyZWF0ZWQgYW5kIHN0eWxlZC4gVXNlZnVsIGZvciBhdHRhY2hpbmcgZXZlbnRzIGFuZCBwb3B1cHMgdG8gZmVhdHVyZXMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gZG8gbm90aGluZyB3aXRoIHRoZSBuZXdseSBjcmVhdGVkIGxheWVyczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChmZWF0dXJlLCBsYXllcikge31cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gZmlsdGVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG8gaW5jbHVkZSBhIGZlYXR1cmUgb3Igbm90LlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGluY2x1ZGUgYWxsIGZlYXR1cmVzOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24gKGdlb0pzb25GZWF0dXJlKSB7XHJcblx0ICogXHRyZXR1cm4gdHJ1ZTtcclxuXHQgKiB9XHJcblx0ICogYGBgXHJcblx0ICogTm90ZTogZHluYW1pY2FsbHkgY2hhbmdpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbiB3aWxsIGhhdmUgZWZmZWN0IG9ubHkgb24gbmV3bHlcclxuXHQgKiBhZGRlZCBkYXRhLiBJdCB3aWxsIF9ub3RfIHJlLWV2YWx1YXRlIGFscmVhZHkgaW5jbHVkZWQgZmVhdHVyZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGNvb3Jkc1RvTGF0TG5nOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgR2VvSlNPTiBjb29yZGluYXRlcyB0byBgTGF0TG5nYHMuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdGhlIGBjb29yZHNUb0xhdExuZ2Agc3RhdGljIG1ldGhvZC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHRpZiAoZ2VvanNvbikge1xyXG5cdFx0XHR0aGlzLmFkZERhdGEoZ2VvanNvbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGREYXRhKCA8R2VvSlNPTj4gZGF0YSApOiBMYXllclxyXG5cdC8vIEFkZHMgYSBHZW9KU09OIG9iamVjdCB0byB0aGUgbGF5ZXIuXHJcblx0YWRkRGF0YTogZnVuY3Rpb24gKGdlb2pzb24pIHtcclxuXHRcdHZhciBmZWF0dXJlcyA9IEwuVXRpbC5pc0FycmF5KGdlb2pzb24pID8gZ2VvanNvbiA6IGdlb2pzb24uZmVhdHVyZXMsXHJcblx0XHQgICAgaSwgbGVuLCBmZWF0dXJlO1xyXG5cclxuXHRcdGlmIChmZWF0dXJlcykge1xyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdC8vIG9ubHkgYWRkIHRoaXMgaWYgZ2VvbWV0cnkgb3IgZ2VvbWV0cmllcyBhcmUgc2V0IGFuZCBub3QgbnVsbFxyXG5cdFx0XHRcdGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcclxuXHRcdFx0XHRpZiAoZmVhdHVyZS5nZW9tZXRyaWVzIHx8IGZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5mZWF0dXJlcyB8fCBmZWF0dXJlLmNvb3JkaW5hdGVzKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERhdGEoZmVhdHVyZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgbGF5ZXIgPSBMLkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyKGdlb2pzb24sIG9wdGlvbnMpO1xyXG5cdFx0aWYgKCFsYXllcikge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGxheWVyLmZlYXR1cmUgPSBMLkdlb0pTT04uYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllciApOiBMYXllclxyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHRyZXNldFN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gTC5VdGlsLmV4dGVuZCh7fSwgbGF5ZXIuZGVmYXVsdE9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fc2V0TGF5ZXJTdHlsZShsYXllciwgdGhpcy5vcHRpb25zLnN0eWxlKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0U3R5bGUoIDxGdW5jdGlvbj4gc3R5bGUgKTogTGF5ZXJcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcbkwuZXh0ZW5kKEwuR2VvSlNPTiwge1xyXG5cdC8vIEBmdW5jdGlvbiBnZW9tZXRyeVRvTGF5ZXIoZmVhdHVyZURhdGE6IE9iamVjdCwgb3B0aW9ucz86IEdlb0pTT04gb3B0aW9ucyk6IExheWVyXHJcblx0Ly8gQ3JlYXRlcyBhIGBMYXllcmAgZnJvbSBhIGdpdmVuIEdlb0pTT04gZmVhdHVyZS4gQ2FuIHVzZSBhIGN1c3RvbVxyXG5cdC8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG5cdC8vIGZ1bmN0aW9ucyBpZiBwcm92aWRlZCBhcyBvcHRpb25zLlxyXG5cdGdlb21ldHJ5VG9MYXllcjogZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdFx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdFx0ICAgIGxheWVycyA9IFtdLFxyXG5cdFx0ICAgIHBvaW50VG9MYXllciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludFRvTGF5ZXIsXHJcblx0XHQgICAgY29vcmRzVG9MYXRMbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZyxcclxuXHRcdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0XHRpZiAoIWNvb3JkcyAmJiAhZ2VvbWV0cnkpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0c3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XHJcblx0XHRjYXNlICdQb2ludCc6XHJcblx0XHRcdGxhdGxuZyA9IGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcyk7XHJcblx0XHRcdHJldHVybiBwb2ludFRvTGF5ZXIgPyBwb2ludFRvTGF5ZXIoZ2VvanNvbiwgbGF0bG5nKSA6IG5ldyBMLk1hcmtlcihsYXRsbmcpO1xyXG5cclxuXHRcdGNhc2UgJ011bHRpUG9pbnQnOlxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBjb29yZHNUb0xhdExuZyhjb29yZHNbaV0pO1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IEwuTWFya2VyKGxhdGxuZykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0XHRjYXNlICdMaW5lU3RyaW5nJzpcclxuXHRcdGNhc2UgJ011bHRpTGluZVN0cmluZyc6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IDAgOiAxLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdQb2x5Z29uJzpcclxuXHRcdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IDEgOiAyLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLmdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSxcclxuXHRcdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0XHRpZiAobGF5ZXIpIHtcclxuXHRcdFx0XHRcdGxheWVycy5wdXNoKGxheWVyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG5cdC8vIENyZWF0ZXMgYSBgTGF0TG5nYCBvYmplY3QgZnJvbSBhbiBhcnJheSBvZiAyIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUpXHJcblx0Ly8gb3IgMyBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZSkgdXNlZCBpbiBHZW9KU09OIGZvciBwb2ludHMuXHJcblx0Y29vcmRzVG9MYXRMbmc6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoY29vcmRzWzFdLCBjb29yZHNbMF0sIGNvb3Jkc1syXSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5ncyhjb29yZHM6IEFycmF5LCBsZXZlbHNEZWVwPzogTnVtYmVyLCBjb29yZHNUb0xhdExuZz86IEZ1bmN0aW9uKTogQXJyYXlcclxuXHQvLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcblx0Ly8gYGxldmVsc0RlZXBgIHNwZWNpZmllcyB0aGUgbmVzdGluZyBsZXZlbCAoMCBpcyBmb3IgYW4gYXJyYXkgb2YgcG9pbnRzLCAxIGZvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgcG9pbnRzLCBldGMuLCAwIGJ5IGRlZmF1bHQpLlxyXG5cdC8vIENhbiB1c2UgYSBjdXN0b20gW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKSBmdW5jdGlvbi5cclxuXHRjb29yZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChjb29yZHMsIGxldmVsc0RlZXAsIGNvb3Jkc1RvTGF0TG5nKSB7XHJcblx0XHR2YXIgbGF0bG5ncyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoLCBsYXRsbmc7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0ICAgICAgICB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHNbaV0sIGxldmVsc0RlZXAgLSAxLCBjb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQgICAgICAgIChjb29yZHNUb0xhdExuZyB8fCB0aGlzLmNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxhdGxuZ3M7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZzogTGF0TG5nKTogQXJyYXlcclxuXHQvLyBSZXZlcnNlIG9mIFtgY29vcmRzVG9MYXRMbmdgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZylcclxuXHRsYXRMbmdUb0Nvb3JkczogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIGxhdGxuZy5hbHQgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdFx0W2xhdGxuZy5sbmcsIGxhdGxuZy5sYXQsIGxhdGxuZy5hbHRdIDpcclxuXHRcdFx0XHRbbGF0bG5nLmxuZywgbGF0bG5nLmxhdF07XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzOiBBcnJheSwgbGV2ZWxzRGVlcD86IE51bWJlciwgY2xvc2VkPzogQm9vbGVhbik6IEFycmF5XHJcblx0Ly8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nc2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5ncylcclxuXHQvLyBgY2xvc2VkYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGZpcnN0IHBvaW50IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSB0byBjbG9zZSB0aGUgZmVhdHVyZSwgb25seSB1c2VkIHdoZW4gYGxldmVsc0RlZXBgIGlzIDAuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcblx0bGF0TG5nc1RvQ29vcmRzOiBmdW5jdGlvbiAobGF0bG5ncywgbGV2ZWxzRGVlcCwgY2xvc2VkKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGV2ZWxzRGVlcCA/XHJcblx0XHRcdFx0TC5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyhsYXRsbmdzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY2xvc2VkKSA6XHJcblx0XHRcdFx0TC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKGxhdGxuZ3NbaV0pKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWxldmVsc0RlZXAgJiYgY2xvc2VkKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvb3JkcztcclxuXHR9LFxyXG5cclxuXHRnZXRGZWF0dXJlOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0dlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbGF5ZXIuZmVhdHVyZSA/XHJcblx0XHRcdFx0TC5leHRlbmQoe30sIGxheWVyLmZlYXR1cmUsIHtnZW9tZXRyeTogbmV3R2VvbWV0cnl9KSA6XHJcblx0XHRcdFx0TC5HZW9KU09OLmFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuXHQvLyBOb3JtYWxpemUgR2VvSlNPTiBnZW9tZXRyaWVzL2ZlYXR1cmVzIGludG8gR2VvSlNPTiBmZWF0dXJlcy5cclxuXHRhc0ZlYXR1cmU6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHRpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIHtcclxuXHRcdFx0cmV0dXJuIGdlb2pzb247XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRwcm9wZXJ0aWVzOiB7fSxcclxuXHRcdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbnZhciBQb2ludFRvR2VvSlNPTiA9IHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBMLkdlb0pTT04ubGF0TG5nVG9Db29yZHModGhpcy5nZXRMYXRMbmcoKSlcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBDaXJjbGVNYXJrZXJcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaXJjbGUgbWFya2VyIChhcyBhIEdlb0pTT04gYFBvaW50YCBGZWF0dXJlKS5cclxuTC5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkwuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5bGluZSAoYXMgYSBHZW9KU09OIGBMaW5lU3RyaW5nYCBvciBgTXVsdGlMaW5lU3RyaW5nYCBGZWF0dXJlKS5cclxuTC5Qb2x5bGluZS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBtdWx0aSA9ICFMLlBvbHlsaW5lLl9mbGF0KHRoaXMuX2xhdGxuZ3MpO1xyXG5cclxuXHR2YXIgY29vcmRzID0gTC5HZW9KU09OLmxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwKTtcclxuXHJcblx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0fSk7XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04oKTogT2JqZWN0XHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2x5Z29uIChhcyBhIEdlb0pTT04gYFBvbHlnb25gIG9yIGBNdWx0aVBvbHlnb25gIEZlYXR1cmUpLlxyXG5MLlBvbHlnb24ucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgaG9sZXMgPSAhTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzKSxcclxuXHQgICAgbXVsdGkgPSBob2xlcyAmJiAhTC5Qb2x5bGluZS5fZmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0dmFyIGNvb3JkcyA9IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5fbGF0bG5ncywgbXVsdGkgPyAyIDogaG9sZXMgPyAxIDogMCwgdHJ1ZSk7XHJcblxyXG5cdGlmICghaG9sZXMpIHtcclxuXHRcdGNvb3JkcyA9IFtjb29yZHNdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkwuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHR0b011bHRpUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIEwuR2VvSlNPTi5nZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTigpOiBPYmplY3RcclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbGF5ZXIgZ3JvdXAgKGFzIGEgR2VvSlNPTiBgR2VvbWV0cnlDb2xsZWN0aW9uYCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKCk7XHJcblx0XHRcdFx0anNvbnMucHVzaChpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGpzb24uZ2VvbWV0cnkgOiBMLkdlb0pTT04uYXNGZWF0dXJlKGpzb24pKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbidcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuXHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIEdlb0pTT05cclxuLy8gQGZhY3RvcnkgTC5nZW9KU09OKGdlb2pzb24/OiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYSBHZW9KU09OIGxheWVyLiBPcHRpb25hbGx5IGFjY2VwdHMgYW4gb2JqZWN0IGluXHJcbi8vIFtHZW9KU09OIGZvcm1hdF0oaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sKSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuTC5nZW9KU09OID0gZnVuY3Rpb24gKGdlb2pzb24sIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufTtcclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuTC5nZW9Kc29uID0gTC5nZW9KU09OO1xyXG5cbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuXHJcblxyXG52YXIgZXZlbnRzS2V5ID0gJ19sZWFmbGV0X2V2ZW50cyc7XHJcblxyXG5MLkRvbUV2ZW50ID0ge1xyXG5cclxuXHQvLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIChgZm5gKSB0byBhIHBhcnRpY3VsYXIgRE9NIGV2ZW50IHR5cGUgb2YgdGhlXHJcblx0Ly8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuXHQvLyAob2JqZWN0IHRoZSBgdGhpc2Aga2V5d29yZCB3aWxsIHBvaW50IHRvKS4gWW91IGNhbiBhbHNvIHBhc3Mgc2V2ZXJhbFxyXG5cdC8vIHNwYWNlLXNlcGFyYXRlZCB0eXBlcyAoZS5nLiBgJ2NsaWNrIGRibGNsaWNrJ2ApLlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAZnVuY3Rpb24gb24oZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIEFkZHMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHRvbjogZnVuY3Rpb24gKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdHRoaXMuX29uKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbihvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLiBJZiBubyBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsXHJcblx0Ly8gaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIERPTSBldmVudCBmcm9tIHRoZSBlbGVtZW50LlxyXG5cdC8vIE5vdGUgdGhhdCBpZiB5b3UgcGFzc2VkIGEgY3VzdG9tIGNvbnRleHQgdG8gb24sIHlvdSBtdXN0IHBhc3MgdGhlIHNhbWVcclxuXHQvLyBjb250ZXh0IHRvIGBvZmZgIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCBldmVudE1hcDogT2JqZWN0LCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYSBzZXQgb2YgdHlwZS9saXN0ZW5lciBwYWlycywgZS5nLiBge2NsaWNrOiBvbkNsaWNrLCBtb3VzZW1vdmU6IG9uTW91c2VNb3ZlfWBcclxuXHRvZmY6IGZ1bmN0aW9uIChvYmosIHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0XHR0aGlzLl9vZmYob2JqLCB0eXBlLCB0eXBlc1t0eXBlXSwgZm4pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29mZihvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb246IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgaWQgPSB0eXBlICsgTC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIEwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdFx0aWYgKG9ialtldmVudHNLZXldICYmIG9ialtldmVudHNLZXldW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0XHR0aGlzLmFkZFBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIsIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKEwuQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgdGhpcy5hZGREb3VibGVUYXBMaXN0ZW5lcikge1xyXG5cdFx0XHR0aGlzLmFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKCdvbndoZWVsJyBpbiBvYmogPyAnd2hlZWwnIDogJ21vdXNld2hlZWwnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCh0eXBlID09PSAnbW91c2VlbnRlcicpIHx8ICh0eXBlID09PSAnbW91c2VsZWF2ZScpKSB7XHJcblx0XHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRcdFx0XHRpZiAoTC5Eb21FdmVudC5faXNFeHRlcm5hbFRhcmdldChvYmosIGUpKSB7XHJcblx0XHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0JywgaGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJyAmJiBMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBMLkRvbUV2ZW50Ll9maWx0ZXJDbGljayhlLCBvcmlnaW5hbEhhbmRsZXIpO1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9ialtldmVudHNLZXldID0gb2JqW2V2ZW50c0tleV0gfHwge307XHJcblx0XHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBoYW5kbGVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vZmY6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0dmFyIGlkID0gdHlwZSArIEwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBMLnN0YW1wKGNvbnRleHQpIDogJycpLFxyXG5cdFx0ICAgIGhhbmRsZXIgPSBvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF07XHJcblxyXG5cdFx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKEwuQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgdGhpcy5yZW1vdmVEb3VibGVUYXBMaXN0ZW5lcikge1xyXG5cdFx0XHR0aGlzLnJlbW92ZURvdWJsZVRhcExpc3RlbmVyKG9iaiwgaWQpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXdoZWVsJykge1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdvbndoZWVsJyBpbiBvYmogPyAnd2hlZWwnIDogJ21vdXNld2hlZWwnLCBoYW5kbGVyLCBmYWxzZSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG5cdFx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOlxyXG5cdFx0XHRcdFx0dHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBvYmopIHtcclxuXHRcdFx0b2JqLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXY6IERPTUV2ZW50KTogdGhpc1xyXG5cdC8vIFN0b3AgdGhlIGdpdmVuIGV2ZW50IGZyb20gcHJvcGFnYXRpb24gdG8gcGFyZW50IGVsZW1lbnRzLiBVc2VkIGluc2lkZSB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zOlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gTC5Eb21FdmVudC5vbihkaXYsICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG5cdC8vIFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZXYpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHRpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7ICAvLyBJbiBjYXNlIG9mIExlYWZsZXQgZXZlbnQuXHJcblx0XHRcdGUub3JpZ2luYWxFdmVudC5fc3RvcHBlZCA9IHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRMLkRvbUV2ZW50Ll9za2lwcGVkKGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG5cdC8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ21vdXNld2hlZWwnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcblx0ZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50Lm9uKGVsLCAnbW91c2V3aGVlbCcsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAZnVuY3Rpb24gZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG5cdC8vIEFkZHMgYHN0b3BQcm9wYWdhdGlvbmAgdG8gdGhlIGVsZW1lbnQncyBgJ2NsaWNrJ2AsIGAnZG91YmxlY2xpY2snYCxcclxuXHQvLyBgJ21vdXNlZG93bidgIGFuZCBgJ3RvdWNoc3RhcnQnYCBldmVudHMgKHBsdXMgYnJvd3NlciB2YXJpYW50cykuXHJcblx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0dmFyIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKGVsLCBMLkRyYWdnYWJsZS5TVEFSVC5qb2luKCcgJyksIHN0b3ApO1xyXG5cclxuXHRcdHJldHVybiBMLkRvbUV2ZW50Lm9uKGVsLCB7XHJcblx0XHRcdGNsaWNrOiBMLkRvbUV2ZW50Ll9mYWtlU3RvcCxcclxuXHRcdFx0ZGJsY2xpY2s6IHN0b3BcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcblx0Ly8gUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIG9mIHRoZSBET00gRXZlbnQgYGV2YCBmcm9tIGhhcHBlbmluZyAoc3VjaCBhc1xyXG5cdC8vIGZvbGxvd2luZyBhIGxpbmsgaW4gdGhlIGhyZWYgb2YgdGhlIGEgZWxlbWVudCwgb3IgZG9pbmcgYSBQT1NUIHJlcXVlc3RcclxuXHQvLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG5cdC8vIFVzZSBpdCBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdGlmIChlLnByZXZlbnREZWZhdWx0KSB7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBmdW5jdGlvbiBzdG9wKGV2KTogdGhpc1xyXG5cdC8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIEwuRG9tRXZlbnRcclxuXHRcdFx0LnByZXZlbnREZWZhdWx0KGUpXHJcblx0XHRcdC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcblx0Ly8gR2V0cyBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGZyb20gYSBET00gZXZlbnQgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gYGNvbnRhaW5lcmAgb3IgdG8gdGhlIHdob2xlIHBhZ2UgaWYgbm90IHNwZWNpZmllZC5cclxuXHRnZXRNb3VzZVBvc2l0aW9uOiBmdW5jdGlvbiAoZSwgY29udGFpbmVyKSB7XHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdFx0ZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHRcdGUuY2xpZW50WSAtIHJlY3QudG9wIC0gY29udGFpbmVyLmNsaWVudFRvcCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQ2hyb21lIG9uIFdpbiBzY3JvbGxzIGRvdWJsZSB0aGUgcGl4ZWxzIGFzIGluIG90aGVyIHBsYXRmb3JtcyAoc2VlICM0NTM4KSxcclxuXHQvLyBhbmQgRmlyZWZveCBzY3JvbGxzIGRldmljZSBwaXhlbHMsIG5vdCBDU1MgcGl4ZWxzXHJcblx0X3doZWVsUHhGYWN0b3I6IChMLkJyb3dzZXIud2luICYmIEwuQnJvd3Nlci5jaHJvbWUpID8gMiA6XHJcblx0ICAgICAgICAgICAgICAgIEwuQnJvd3Nlci5nZWNrbyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHQgICAgICAgICAgICAgICAgMSxcclxuXHJcblx0Ly8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcblx0Ly8gR2V0cyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIGZyb20gYSBtb3VzZXdoZWVsIERPTSBldmVudCwgaW4gdmVydGljYWxcclxuXHQvLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuXHQvLyBFdmVudHMgZnJvbSBwb2ludGluZyBkZXZpY2VzIHdpdGhvdXQgcHJlY2lzZSBzY3JvbGxpbmcgYXJlIG1hcHBlZCB0b1xyXG5cdC8vIGEgYmVzdCBndWVzcyBvZiA2MCBwaXhlbHMuXHJcblx0Z2V0V2hlZWxEZWx0YTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiAoTC5Ccm93c2VyLmVkZ2UpID8gZS53aGVlbERlbHRhWSAvIDIgOiAvLyBEb24ndCB0cnVzdCB3aW5kb3ctZ2VvbWV0cnktYmFzZWQgZGVsdGFcclxuXHRcdCAgICAgICAoZS5kZWx0YVkgJiYgZS5kZWx0YU1vZGUgPT09IDApID8gLWUuZGVsdGFZIC8gTC5Eb21FdmVudC5fd2hlZWxQeEZhY3RvciA6IC8vIFBpeGVsc1xyXG5cdFx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcblx0XHQgICAgICAgKGUuZGVsdGFZICYmIGUuZGVsdGFNb2RlID09PSAyKSA/IC1lLmRlbHRhWSAqIDYwIDogLy8gUGFnZXNcclxuXHRcdCAgICAgICAoZS5kZWx0YVggfHwgZS5kZWx0YVopID8gMCA6XHQvLyBTa2lwIGhvcml6b250YWwvZGVwdGggd2hlZWwgZXZlbnRzXHJcblx0XHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcblx0XHQgICAgICAgKGUuZGV0YWlsICYmIE1hdGguYWJzKGUuZGV0YWlsKSA8IDMyNzY1KSA/IC1lLmRldGFpbCAqIDIwIDogLy8gTGVnYWN5IE1veiBsaW5lc1xyXG5cdFx0ICAgICAgIGUuZGV0YWlsID8gZS5kZXRhaWwgLyAtMzI3NjUgKiA2MCA6IC8vIExlZ2FjeSBNb3ogcGFnZXNcclxuXHRcdCAgICAgICAwO1xyXG5cdH0sXHJcblxyXG5cdF9za2lwRXZlbnRzOiB7fSxcclxuXHJcblx0X2Zha2VTdG9wOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gZmFrZXMgc3RvcFByb3BhZ2F0aW9uIGJ5IHNldHRpbmcgYSBzcGVjaWFsIGV2ZW50IGZsYWcsIGNoZWNrZWQvcmVzZXQgd2l0aCBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpXHJcblx0XHRMLkRvbUV2ZW50Ll9za2lwRXZlbnRzW2UudHlwZV0gPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9za2lwcGVkOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNraXBwZWQgPSB0aGlzLl9za2lwRXZlbnRzW2UudHlwZV07XHJcblx0XHQvLyByZXNldCB3aGVuIGNoZWNraW5nLCBhcyBpdCdzIG9ubHkgdXNlZCBpbiBtYXAgY29udGFpbmVyIGFuZCBwcm9wYWdhdGVzIG91dHNpZGUgb2YgdGhlIG1hcFxyXG5cdFx0dGhpcy5fc2tpcEV2ZW50c1tlLnR5cGVdID0gZmFsc2U7XHJcblx0XHRyZXR1cm4gc2tpcHBlZDtcclxuXHR9LFxyXG5cclxuXHQvLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuXHRfaXNFeHRlcm5hbFRhcmdldDogZnVuY3Rpb24gKGVsLCBlKSB7XHJcblxyXG5cdFx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdFx0aWYgKCFyZWxhdGVkKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRcdHJlbGF0ZWQgPSByZWxhdGVkLnBhcmVudE5vZGU7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxuXHR9LFxyXG5cclxuXHQvLyB0aGlzIGlzIGEgaG9ycmlibGUgd29ya2Fyb3VuZCBmb3IgYSBidWcgaW4gQW5kcm9pZCB3aGVyZSBhIHNpbmdsZSB0b3VjaCB0cmlnZ2VycyB0d28gY2xpY2sgZXZlbnRzXHJcblx0X2ZpbHRlckNsaWNrOiBmdW5jdGlvbiAoZSwgaGFuZGxlcikge1xyXG5cdFx0dmFyIHRpbWVTdGFtcCA9IChlLnRpbWVTdGFtcCB8fCAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC50aW1lU3RhbXApKSxcclxuXHRcdCAgICBlbGFwc2VkID0gTC5Eb21FdmVudC5fbGFzdENsaWNrICYmICh0aW1lU3RhbXAgLSBMLkRvbUV2ZW50Ll9sYXN0Q2xpY2spO1xyXG5cclxuXHRcdC8vIGFyZSB0aGV5IGNsb3NlciB0b2dldGhlciB0aGFuIDUwMG1zIHlldCBtb3JlIHRoYW4gMTAwbXM/XHJcblx0XHQvLyBBbmRyb2lkIHR5cGljYWxseSB0cmlnZ2VycyB0aGVtIH4zMDBtcyBhcGFydCB3aGlsZSBtdWx0aXBsZSBsaXN0ZW5lcnNcclxuXHRcdC8vIG9uIHRoZSBzYW1lIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgZmFyIGZhc3RlcjtcclxuXHRcdC8vIG9yIGNoZWNrIGlmIGNsaWNrIGlzIHNpbXVsYXRlZCBvbiB0aGUgZWxlbWVudCwgYW5kIGlmIGl0IGlzLCByZWplY3QgYW55IG5vbi1zaW11bGF0ZWQgZXZlbnRzXHJcblxyXG5cdFx0aWYgKChlbGFwc2VkICYmIGVsYXBzZWQgPiAxMDAgJiYgZWxhcHNlZCA8IDUwMCkgfHwgKGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayAmJiAhZS5fc2ltdWxhdGVkKSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdEwuRG9tRXZlbnQuX2xhc3RDbGljayA9IHRpbWVTdGFtcDtcclxuXHJcblx0XHRoYW5kbGVyKGUpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBhZGRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vbmBdKCNkb21ldmVudC1vbilcclxuTC5Eb21FdmVudC5hZGRMaXN0ZW5lciA9IEwuRG9tRXZlbnQub247XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYEwuRG9tRXZlbnQub2ZmYF0oI2RvbWV2ZW50LW9mZilcclxuTC5Eb21FdmVudC5yZW1vdmVMaXN0ZW5lciA9IEwuRG9tRXZlbnQub2ZmO1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQGFrYSBMLkRyYWdnYWJsZVxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBBIGNsYXNzIGZvciBtYWtpbmcgRE9NIGVsZW1lbnRzIGRyYWdnYWJsZSAoaW5jbHVkaW5nIHRvdWNoIHN1cHBvcnQpLlxyXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIG1hcCBhbmQgbWFya2VyIGRyYWdnaW5nLiBPbmx5IHdvcmtzIGZvciBlbGVtZW50c1xyXG4gKiB0aGF0IHdlcmUgcG9zaXRpb25lZCB3aXRoIFtgTC5Eb21VdGlsLnNldFBvc2l0aW9uYF0oI2RvbXV0aWwtc2V0cG9zaXRpb24pLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGVsZW1lbnRUb0RyYWcpO1xyXG4gKiBkcmFnZ2FibGUuZW5hYmxlKCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbkwuRHJhZ2dhYmxlID0gTC5FdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY2xpY2tUb2xlcmFuY2U6IE51bWJlciA9IDNcclxuXHRcdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGNsaWNrXHJcblx0XHQvLyBmb3IgaXQgdG8gYmUgY29uc2lkZXJlZCBhIHZhbGlkIGNsaWNrIChhcyBvcHBvc2VkIHRvIGEgbW91c2UgZHJhZykuXHJcblx0XHRjbGlja1RvbGVyYW5jZTogM1xyXG5cdH0sXHJcblxyXG5cdHN0YXRpY3M6IHtcclxuXHRcdFNUQVJUOiBMLkJyb3dzZXIudG91Y2ggPyBbJ3RvdWNoc3RhcnQnLCAnbW91c2Vkb3duJ10gOiBbJ21vdXNlZG93biddLFxyXG5cdFx0RU5EOiB7XHJcblx0XHRcdG1vdXNlZG93bjogJ21vdXNldXAnLFxyXG5cdFx0XHR0b3VjaHN0YXJ0OiAndG91Y2hlbmQnLFxyXG5cdFx0XHRwb2ludGVyZG93bjogJ3RvdWNoZW5kJyxcclxuXHRcdFx0TVNQb2ludGVyRG93bjogJ3RvdWNoZW5kJ1xyXG5cdFx0fSxcclxuXHRcdE1PVkU6IHtcclxuXHRcdFx0bW91c2Vkb3duOiAnbW91c2Vtb3ZlJyxcclxuXHRcdFx0dG91Y2hzdGFydDogJ3RvdWNobW92ZScsXHJcblx0XHRcdHBvaW50ZXJkb3duOiAndG91Y2htb3ZlJyxcclxuXHRcdFx0TVNQb2ludGVyRG93bjogJ3RvdWNobW92ZSdcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lOiBCb29sZWFuKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcclxuXHRcdHRoaXMuX2RyYWdTdGFydFRhcmdldCA9IGRyYWdTdGFydFRhcmdldCB8fCBlbGVtZW50O1xyXG5cdFx0dGhpcy5fcHJldmVudE91dGxpbmUgPSBwcmV2ZW50T3V0bGluZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpXHJcblx0Ly8gRW5hYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIEwuRHJhZ2dhYmxlLlNUQVJULmpvaW4oJyAnKSwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKVxyXG5cdC8vIERpc2FibGVzIHRoZSBkcmFnZ2luZyBhYmlsaXR5XHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgTC5EcmFnZ2FibGUuU1RBUlQuam9pbignICcpLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSBzaW11bGF0ZWQgZXZlbnRzLCBzaW5jZSB3ZSBoYW5kbGUgYm90aCB0b3VjaCBhbmRcclxuXHRcdC8vIG1vdXNlIGV4cGxpY2l0bHk7IG90aGVyd2lzZSB3ZSByaXNrIGdldHRpbmcgZHVwbGljYXRlcyBvZlxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzLCBzZWUgIzQzMTUuXHJcblx0XHQvLyBBbHNvIGlnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmIChlLl9zaW11bGF0ZWQgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKHRoaXMuX2VsZW1lbnQsICdsZWFmbGV0LXpvb20tYW5pbScpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgfHwgZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkgJiYgIWUudG91Y2hlcykgfHwgIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHRMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSB0cnVlOyAgLy8gUHJldmVudCBkcmFnZ2luZyBtdWx0aXBsZSBvYmplY3RzIGF0IG9uY2UuXHJcblxyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRPdXRsaW5lKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21vdmluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBAZXZlbnQgZG93bjogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBkcmFnIGlzIGFib3V0IHRvIHN0YXJ0LlxyXG5cdFx0dGhpcy5maXJlKCdkb3duJyk7XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0XHQub24oZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbZS50eXBlXSwgdGhpcy5fb25Nb3ZlLCB0aGlzKVxyXG5cdFx0XHQub24oZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLkVORFtlLnR5cGVdLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG5ld1BvaW50ID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbmV3UG9pbnQuc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCkuc3VidHJhY3Qob2Zmc2V0KTtcclxuXHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnbGVhZmxldC1kcmFnZ2luZycpO1xyXG5cclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcclxuXHRcdFx0Ly8gSUUgYW5kIEVkZ2UgZG8gbm90IGdpdmUgdGhlIDx1c2U+IGVsZW1lbnQsIHNvIGZldGNoIGl0XHJcblx0XHRcdC8vIGlmIG5lY2Vzc2FyeVxyXG5cdFx0XHRpZiAoKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpICYmICh0aGlzLl9sYXN0VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlKSkge1xyXG5cdFx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSB0aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX25ld1BvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xyXG5cdFx0dGhpcy5fbW92aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBlID0ge29yaWdpbmFsRXZlbnQ6IHRoaXMuX2xhc3RFdmVudH07XHJcblxyXG5cdFx0Ly8gQGV2ZW50IHByZWRyYWc6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCBjb250aW51b3VzbHkgZHVyaW5nIGRyYWdnaW5nICpiZWZvcmUqIGVhY2ggY29ycmVzcG9uZGluZ1xyXG5cdFx0Ly8gdXBkYXRlIG9mIHRoZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWRyYWcnLCBlKTtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gSWdub3JlIHNpbXVsYXRlZCBldmVudHMsIHNpbmNlIHdlIGhhbmRsZSBib3RoIHRvdWNoIGFuZFxyXG5cdFx0Ly8gbW91c2UgZXhwbGljaXRseTsgb3RoZXJ3aXNlIHdlIHJpc2sgZ2V0dGluZyBkdXBsaWNhdGVzIG9mXHJcblx0XHQvLyB0b3VjaCBldmVudHMsIHNlZSAjNDMxNS5cclxuXHRcdC8vIEFsc28gaWdub3JlIHRoZSBldmVudCBpZiBkaXNhYmxlZDsgdGhpcyBoYXBwZW5zIGluIElFMTFcclxuXHRcdC8vIHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgc2VlICMzNjY2LlxyXG5cdFx0aWYgKGUuX3NpbXVsYXRlZCB8fCAhdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdFRhcmdldCkge1xyXG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbGFzdFRhcmdldCwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdFx0dGhpcy5fbGFzdFRhcmdldCA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBMLkRyYWdnYWJsZS5NT1ZFKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQub2ZmKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5NT1ZFW2ldLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHRcdFx0Lm9mZihkb2N1bWVudCwgTC5EcmFnZ2FibGUuRU5EW2ldLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZlZCAmJiB0aGlzLl9tb3ZpbmcpIHtcclxuXHRcdFx0Ly8gZW5zdXJlIGRyYWcgaXMgbm90IGZpcmVkIGFmdGVyIGRyYWdlbmRcclxuXHRcdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0XHRMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHR9XHJcbn0pO1xyXG5cbi8qXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XG5cdGludGVyYWN0aW9uIGZlYXR1cmVzIGxpa2UgZHJhZ2dpbmcgdG8gY2xhc3NlcyBsaWtlIE1hcCBhbmQgTWFya2VyLlxuKi9cblxuLy8gQGNsYXNzIEhhbmRsZXJcbi8vIEBha2EgTC5IYW5kbGVyXG4vLyBBYnN0cmFjdCBjbGFzcyBmb3IgbWFwIGludGVyYWN0aW9uIGhhbmRsZXJzXG5cbkwuSGFuZGxlciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcERyYWcgaXMgdXNlZCB0byBtYWtlIHRoZSBtYXAgZHJhZ2dhYmxlICh3aXRoIHBhbm5pbmcgaW5lcnRpYSksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBkcmFnZ2luZzogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGJlIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cblx0ZHJhZ2dpbmc6IHRydWUsXG5cblx0Ly8gQHNlY3Rpb24gUGFubmluZyBJbmVydGlhIE9wdGlvbnNcblx0Ly8gQG9wdGlvbiBpbmVydGlhOiBCb29sZWFuID0gKlxuXHQvLyBJZiBlbmFibGVkLCBwYW5uaW5nIG9mIHRoZSBtYXAgd2lsbCBoYXZlIGFuIGluZXJ0aWEgZWZmZWN0IHdoZXJlXG5cdC8vIHRoZSBtYXAgYnVpbGRzIG1vbWVudHVtIHdoaWxlIGRyYWdnaW5nIGFuZCBjb250aW51ZXMgbW92aW5nIGluXG5cdC8vIHRoZSBzYW1lIGRpcmVjdGlvbiBmb3Igc29tZSB0aW1lLiBGZWVscyBlc3BlY2lhbGx5IG5pY2Ugb24gdG91Y2hcblx0Ly8gZGV2aWNlcy4gRW5hYmxlZCBieSBkZWZhdWx0IHVubGVzcyBydW5uaW5nIG9uIG9sZCBBbmRyb2lkIGRldmljZXMuXG5cdGluZXJ0aWE6ICFMLkJyb3dzZXIuYW5kcm9pZDIzLFxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYURlY2VsZXJhdGlvbjogTnVtYmVyID0gMzAwMFxuXHQvLyBUaGUgcmF0ZSB3aXRoIHdoaWNoIHRoZSBpbmVydGlhbCBtb3ZlbWVudCBzbG93cyBkb3duLCBpbiBwaXhlbHMvc2Vjb25kwrIuXG5cdGluZXJ0aWFEZWNlbGVyYXRpb246IDM0MDAsIC8vIHB4L3NeMlxuXG5cdC8vIEBvcHRpb24gaW5lcnRpYU1heFNwZWVkOiBOdW1iZXIgPSBJbmZpbml0eVxuXHQvLyBNYXggc3BlZWQgb2YgdGhlIGluZXJ0aWFsIG1vdmVtZW50LCBpbiBwaXhlbHMvc2Vjb25kLlxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXG5cblx0Ly8gQG9wdGlvbiBlYXNlTGluZWFyaXR5OiBOdW1iZXIgPSAwLjJcblx0ZWFzZUxpbmVhcml0eTogMC4yLFxuXG5cdC8vIFRPRE8gcmVmYWN0b3IsIG1vdmUgdG8gQ1JTXG5cdC8vIEBvcHRpb24gd29ybGRDb3B5SnVtcDogQm9vbGVhbiA9IGZhbHNlXG5cdC8vIFdpdGggdGhpcyBvcHRpb24gZW5hYmxlZCwgdGhlIG1hcCB0cmFja3Mgd2hlbiB5b3UgcGFuIHRvIGFub3RoZXIgXCJjb3B5XCJcblx0Ly8gb2YgdGhlIHdvcmxkIGFuZCBzZWFtbGVzc2x5IGp1bXBzIHRvIHRoZSBvcmlnaW5hbCBvbmUgc28gdGhhdCBhbGwgb3ZlcmxheXNcblx0Ly8gbGlrZSBtYXJrZXJzIGFuZCB2ZWN0b3IgbGF5ZXJzIGFyZSBzdGlsbCB2aXNpYmxlLlxuXHR3b3JsZENvcHlKdW1wOiBmYWxzZSxcblxuXHQvLyBAb3B0aW9uIG1heEJvdW5kc1Zpc2Nvc2l0eTogTnVtYmVyID0gMC4wXG5cdC8vIElmIGBtYXhCb3VuZHNgIGlzIHNldCwgdGhpcyBvcHRpb24gd2lsbCBjb250cm9sIGhvdyBzb2xpZCB0aGUgYm91bmRzXG5cdC8vIGFyZSB3aGVuIGRyYWdnaW5nIHRoZSBtYXAgYXJvdW5kLiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBgMC4wYCBhbGxvd3MgdGhlXG5cdC8vIHVzZXIgdG8gZHJhZyBvdXRzaWRlIHRoZSBib3VuZHMgYXQgbm9ybWFsIHNwZWVkLCBoaWdoZXIgdmFsdWVzIHdpbGxcblx0Ly8gc2xvdyBkb3duIG1hcCBkcmFnZ2luZyBvdXRzaWRlIGJvdW5kcywgYW5kIGAxLjBgIG1ha2VzIHRoZSBib3VuZHMgZnVsbHlcblx0Ly8gc29saWQsIHByZXZlbnRpbmcgdGhlIHVzZXIgZnJvbSBkcmFnZ2luZyBvdXRzaWRlIHRoZSBib3VuZHMuXG5cdG1heEJvdW5kc1Zpc2Nvc2l0eTogMC4wXG59KTtcblxuTC5NYXAuRHJhZyA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgTC5EcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRcdGRvd246IHRoaXMuX29uRG93bixcblx0XHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0XHRkcmFnZW5kOiB0aGlzLl9vbkRyYWdFbmRcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdMaW1pdCwgdGhpcyk7XG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnZ2FibGUub24oJ3ByZWRyYWcnLCB0aGlzLl9vblByZURyYWdXcmFwLCB0aGlzKTtcblx0XHRcdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fb25ab29tRW5kLCB0aGlzKTtcblxuXHRcdFx0XHRtYXAud2hlblJlYWR5KHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYiBsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XG5cdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0dGhpcy5fdGltZXMgPSBbXTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZS5fbW92ZWQ7XG5cdH0sXG5cblx0bW92aW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmluZztcblx0fSxcblxuXHRfb25Eb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLl9zdG9wKCk7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gTC5sYXRMbmdCb3VuZHModGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0dGhpcy5fb2Zmc2V0TGltaXQgPSBMLmJvdW5kcyhcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldE5vcnRoV2VzdCgpKS5tdWx0aXBseUJ5KC0xKSxcblx0XHRcdFx0dGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoYm91bmRzLmdldFNvdXRoRWFzdCgpKS5tdWx0aXBseUJ5KC0xKVxuXHRcdFx0XHRcdC5hZGQodGhpcy5fbWFwLmdldFNpemUoKSkpO1xuXG5cdFx0XHR0aGlzLl92aXNjb3NpdHkgPSBNYXRoLm1pbigxLjAsIE1hdGgubWF4KDAuMCwgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRtYXBcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcblxuXHRcdGlmIChtYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHRcdHRoaXMuX3RpbWVzID0gW107XG5cdFx0fVxuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLmluZXJ0aWEpIHtcblx0XHRcdHZhciB0aW1lID0gdGhpcy5fbGFzdFRpbWUgPSArbmV3IERhdGUoKSxcblx0XHRcdCAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgfHwgdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XG5cblx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5wdXNoKHBvcyk7XG5cdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xuXG5cdFx0XHRpZiAodGltZSAtIHRoaXMuX3RpbWVzWzBdID4gNTApIHtcblx0XHRcdFx0dGhpcy5fcG9zaXRpb25zLnNoaWZ0KCk7XG5cdFx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHB4Q2VudGVyID0gdGhpcy5fbWFwLmdldFNpemUoKS5kaXZpZGVCeSgyKSxcblx0XHQgICAgcHhXb3JsZENlbnRlciA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoWzAsIDBdKTtcblxuXHRcdHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCA9IHB4V29ybGRDZW50ZXIuc3VidHJhY3QocHhDZW50ZXIpLng7XG5cdFx0dGhpcy5fd29ybGRXaWR0aCA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLng7XG5cdH0sXG5cblx0X3Zpc2NvdXNMaW1pdDogZnVuY3Rpb24gKHZhbHVlLCB0aHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gdmFsdWUgLSAodmFsdWUgLSB0aHJlc2hvbGQpICogdGhpcy5fdmlzY29zaXR5O1xuXHR9LFxuXG5cdF9vblByZURyYWdMaW1pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fdmlzY29zaXR5IHx8ICF0aGlzLl9vZmZzZXRMaW1pdCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zKTtcblxuXHRcdHZhciBsaW1pdCA9IHRoaXMuX29mZnNldExpbWl0O1xuXHRcdGlmIChvZmZzZXQueCA8IGxpbWl0Lm1pbi54KSB7IG9mZnNldC54ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC54LCBsaW1pdC5taW4ueCk7IH1cblx0XHRpZiAob2Zmc2V0LnkgPCBsaW1pdC5taW4ueSkgeyBvZmZzZXQueSA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueSwgbGltaXQubWluLnkpOyB9XG5cdFx0aWYgKG9mZnNldC54ID4gbGltaXQubWF4LngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1heC54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA+IGxpbWl0Lm1heC55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5tYXgueSk7IH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcblx0fSxcblxuXHRfb25QcmVEcmFnV3JhcDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRPRE8gcmVmYWN0b3IgdG8gYmUgYWJsZSB0byBhZGp1c3QgbWFwIHBhbmUgcG9zaXRpb24gYWZ0ZXIgem9vbVxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcblx0XHQgICAgaGFsZldpZHRoID0gTWF0aC5yb3VuZCh3b3JsZFdpZHRoIC8gMiksXG5cdFx0ICAgIGR4ID0gdGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0LFxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcblx0XHQgICAgbmV3WDEgPSAoeCAtIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggKyBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WDIgPSAoeCArIGhhbGZXaWR0aCArIGR4KSAlIHdvcmxkV2lkdGggLSBoYWxmV2lkdGggLSBkeCxcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy5jbG9uZSgpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xuXHR9LFxuXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgb3B0aW9ucyA9IG1hcC5vcHRpb25zLFxuXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgdGhpcy5fdGltZXMubGVuZ3RoIDwgMjtcblxuXHRcdG1hcC5maXJlKCdkcmFnZW5kJywgZSk7XG5cblx0XHRpZiAobm9JbmVydGlhKSB7XG5cdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcblx0XHRcdCAgICBkdXJhdGlvbiA9ICh0aGlzLl9sYXN0VGltZSAtIHRoaXMuX3RpbWVzWzBdKSAvIDEwMDAsXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcblxuXHRcdFx0ICAgIHNwZWVkVmVjdG9yID0gZGlyZWN0aW9uLm11bHRpcGx5QnkoZWFzZSAvIGR1cmF0aW9uKSxcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcblxuXHRcdFx0ICAgIGxpbWl0ZWRTcGVlZCA9IE1hdGgubWluKG9wdGlvbnMuaW5lcnRpYU1heFNwZWVkLCBzcGVlZCksXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXG5cblx0XHRcdCAgICBkZWNlbGVyYXRpb25EdXJhdGlvbiA9IGxpbWl0ZWRTcGVlZCAvIChvcHRpb25zLmluZXJ0aWFEZWNlbGVyYXRpb24gKiBlYXNlKSxcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xuXG5cdFx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcblxuXHRcdFx0XHRMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcblx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4vLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZHJhZ2dpbmcnLCBMLk1hcC5EcmFnKTtcblxuLypcbiAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuTC5NYXAuRG91YmxlQ2xpY2tab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnZG91YmxlQ2xpY2tab29tJywgTC5NYXAuRG91YmxlQ2xpY2tab29tKTtcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gTW91c2V3aGVlbCBvcHRpb25zXG5cdC8vIEBvcHRpb24gc2Nyb2xsV2hlZWxab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgYnkgdXNpbmcgdGhlIG1vdXNlIHdoZWVsLiBJZiBwYXNzZWQgYCdjZW50ZXInYCxcblx0Ly8gaXQgd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgcmVnYXJkbGVzcyBvZiB3aGVyZSB0aGUgbW91c2Ugd2FzLlxuXHRzY3JvbGxXaGVlbFpvb206IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB3aGVlbERlYm91bmNlVGltZTogTnVtYmVyID0gNDBcblx0Ly8gTGltaXRzIHRoZSByYXRlIGF0IHdoaWNoIGEgd2hlZWwgY2FuIGZpcmUgKGluIG1pbGxpc2Vjb25kcykuIEJ5IGRlZmF1bHRcblx0Ly8gdXNlciBjYW4ndCB6b29tIHZpYSB3aGVlbCBtb3JlIG9mdGVuIHRoYW4gb25jZSBwZXIgNDAgbXMuXG5cdHdoZWVsRGVib3VuY2VUaW1lOiA0MCxcblxuXHQvLyBAb3B0aW9uIHdoZWVsUHhQZXJab29tTGV2ZWw6IE51bWJlciA9IDYwXG5cdC8vIEhvdyBtYW55IHNjcm9sbCBwaXhlbHMgKGFzIHJlcG9ydGVkIGJ5IFtMLkRvbUV2ZW50LmdldFdoZWVsRGVsdGFdKCNkb21ldmVudC1nZXR3aGVlbGRlbHRhKSlcblx0Ly8gbWVhbiBhIGNoYW5nZSBvZiBvbmUgZnVsbCB6b29tIGxldmVsLiBTbWFsbGVyIHZhbHVlcyB3aWxsIG1ha2Ugd2hlZWwtem9vbWluZ1xuXHQvLyBmYXN0ZXIgKGFuZCB2aWNlIHZlcnNhKS5cblx0d2hlZWxQeFBlclpvb21MZXZlbDogNjBcbn0pO1xuXG5MLk1hcC5TY3JvbGxXaGVlbFpvb20gPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gTC5Eb21FdmVudC5nZXRXaGVlbERlbHRhKGUpO1xuXG5cdFx0dmFyIGRlYm91bmNlID0gdGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7XG5cblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcblx0XHR0aGlzLl9sYXN0TW91c2VQb3MgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnQgPSBNYXRoLm1heChkZWJvdW5jZSAtICgrbmV3IERhdGUoKSAtIHRoaXMuX3N0YXJ0VGltZSksIDApO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblx0XHR0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3BlcmZvcm1ab29tLCB0aGlzKSwgbGVmdCk7XG5cblx0XHRMLkRvbUV2ZW50LnN0b3AoZSk7XG5cdH0sXG5cblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCksXG5cdFx0ICAgIHNuYXAgPSB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCB8fCAwO1xuXG5cdFx0bWFwLl9zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cblx0XHQvLyBtYXAgdGhlIGRlbHRhIHdpdGggYSBzaWdtb2lkIGZ1bmN0aW9uIHRvIC00Li40IHJhbmdlIGxlYW5pbmcgb24gLTEuLjFcblx0XHR2YXIgZDIgPSB0aGlzLl9kZWx0YSAvICh0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsICogNCksXG5cdFx0ICAgIGQzID0gNCAqIE1hdGgubG9nKDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkMikpKSkgLyBNYXRoLkxOMixcblx0XHQgICAgZDQgPSBzbmFwID8gTWF0aC5jZWlsKGQzIC8gc25hcCkgKiBzbmFwIDogZDMsXG5cdFx0ICAgIGRlbHRhID0gbWFwLl9saW1pdFpvb20oem9vbSArICh0aGlzLl9kZWx0YSA+IDAgPyBkNCA6IC1kNCkpIC0gem9vbTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuXHRcdGlmIChtYXAub3B0aW9ucy5zY3JvbGxXaGVlbFpvb20gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tICsgZGVsdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXAuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsIHpvb20gKyBkZWx0YSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBzY3JvbGxXaGVlbFpvb206IEhhbmRsZXJcbi8vIFNjcm9sbCB3aGVlbCB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBMLk1hcC5TY3JvbGxXaGVlbFpvb20pO1xuXG4vKlxuICogQGNsYXNzIFBvc0FuaW1hdGlvblxuICogQGFrYSBMLlBvc0FuaW1hdGlvblxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcGFubmluZyBhbmltYXRpb25zLCB1dGlsaXppbmcgQ1NTMyBUcmFuc2l0aW9ucyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBhIHRpbWVyIGZhbGxiYWNrIGZvciBJRTYtOS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBmeCA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xuICogZngucnVuKGVsLCBbMzAwLCA1MDBdLCAwLjUpO1xuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yIEwuUG9zQW5pbWF0aW9uKClcbiAqIENyZWF0ZXMgYSBgUG9zQW5pbWF0aW9uYCBvYmplY3QuXG4gKlxuICovXG5cbkwuUG9zQW5pbWF0aW9uID0gTC5FdmVudGVkLmV4dGVuZCh7XG5cblx0Ly8gQG1ldGhvZCBydW4oZWw6IEhUTUxFbGVtZW50LCBuZXdQb3M6IFBvaW50LCBkdXJhdGlvbj86IE51bWJlciwgZWFzZUxpbmVhcml0eT86IE51bWJlcilcblx0Ly8gUnVuIGFuIGFuaW1hdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQgdG8gYSBuZXcgcG9zaXRpb24sIG9wdGlvbmFsbHkgc2V0dGluZ1xuXHQvLyBkdXJhdGlvbiBpbiBzZWNvbmRzIChgMC4yNWAgYnkgZGVmYXVsdCkgYW5kIGVhc2luZyBsaW5lYXJpdHkgZmFjdG9yICgzcmRcblx0Ly8gYXJndW1lbnQgb2YgdGhlIFtjdWJpYyBiZXppZXIgY3VydmVdKGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xuXHRcdHRoaXMuX29mZnNldCA9IG5ld1Bvcy5zdWJ0cmFjdCh0aGlzLl9zdGFydFBvcyk7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cblx0XHQvLyBAZXZlbnQgc3RhcnQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0c1xuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcblxuXHRcdHRoaXMuX2FuaW1hdGUoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHN0b3AoKVxuXHQvLyBTdG9wcyB0aGUgYW5pbWF0aW9uIChpZiBjdXJyZW50bHkgcnVubmluZykuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9zdGVwKHRydWUpO1xuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBhbmltYXRpb24gbG9vcFxuXHRcdHRoaXMuX2FuaW1JZCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2FuaW1hdGUsIHRoaXMpO1xuXHRcdHRoaXMuX3N0ZXAoKTtcblx0fSxcblxuXHRfc3RlcDogZnVuY3Rpb24gKHJvdW5kKSB7XG5cdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdCAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uICogMTAwMDtcblxuXHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoZWxhcHNlZCAvIGR1cmF0aW9uKSwgcm91bmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ydW5GcmFtZSgxKTtcblx0XHRcdHRoaXMuX2NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzLCByb3VuZCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQodGhpcy5fb2Zmc2V0Lm11bHRpcGx5QnkocHJvZ3Jlc3MpKTtcblx0XHRpZiAocm91bmQpIHtcblx0XHRcdHBvcy5fcm91bmQoKTtcblx0XHR9XG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbUlkKTtcblxuXHRcdHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHQvLyBAZXZlbnQgZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxuXHRcdHRoaXMuZmlyZSgnZW5kJyk7XG5cdH0sXG5cblx0X2Vhc2VPdXQ6IGZ1bmN0aW9uICh0KSB7XG5cdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgdGhpcy5fZWFzZU91dFBvd2VyKTtcblx0fVxufSk7XG5cbi8qXG4gKiBFeHRlbmRzIEwuTWFwIHRvIGhhbmRsZSBwYW5uaW5nIGFuaW1hdGlvbnMuXG4gKi9cblxuTC5NYXAuaW5jbHVkZSh7XG5cblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xuXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB0aGlzLl9saW1pdFpvb20oem9vbSk7XG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoTC5sYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR0aGlzLl9zdG9wKCk7XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcblxuXHRcdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xuXHRcdFx0XHRvcHRpb25zLnBhbiA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXG5cdFx0XHR2YXIgbW92ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFpvb20gJiYgdGhpcy5fdHJ5QW5pbWF0ZWRab29tKGNlbnRlciwgem9vbSwgb3B0aW9ucy56b29tKSA6XG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xuXG5cdFx0XHRpZiAobW92ZWQpIHtcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHBhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XG5cdFx0b2Zmc2V0ID0gTC5wb2ludChvZmZzZXQpLnJvdW5kKCk7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuXHRcdH1cblx0XHQvLyBJZiB3ZSBwYW4gdG9vIGZhciwgQ2hyb21lIGdldHMgaXNzdWVzIHdpdGggdGlsZXNcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHtcblx0XHRcdHRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpLCB0aGlzLmdldFpvb20oKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcblx0XHRcdHRoaXMuX3BhbkFuaW0gPSBuZXcgTC5Qb3NBbmltYXRpb24oKTtcblxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcblx0XHRcdFx0J2VuZCc6IHRoaXMuX29uUGFuVHJhbnNpdGlvbkVuZFxuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0ZSBwYW4gdW5sZXNzIGFuaW1hdGU6IGZhbHNlIHNwZWNpZmllZFxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpLnJvdW5kKCk7XG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZmlyZSgnbW92ZScpO1xuXHR9LFxuXG5cdF9vblBhblRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtcGFuLWFuaW0nKTtcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcblx0fSxcblxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xuXHRcdHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoY2VudGVyKS5fZmxvb3IoKTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xuXHRcdGlmICgob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGUpICE9PSB0cnVlICYmICF0aGlzLmdldFNpemUoKS5jb250YWlucyhvZmZzZXQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG4vKlxuICogRXh0ZW5kcyBMLk1hcCB0byBoYW5kbGUgem9vbSBhbmltYXRpb25zLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBBbmltYXRpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcblx0Ly8gaW4gYWxsIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zIGV4Y2VwdCBBbmRyb2lkLlxuXHR6b29tQW5pbWF0aW9uOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24gem9vbUFuaW1hdGlvblRocmVzaG9sZDogTnVtYmVyID0gNFxuXHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXG5cdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDRcbn0pO1xuXG52YXIgem9vbUFuaW1hdGVkID0gTC5Eb21VdGlsLlRSQU5TSVRJT04gJiYgTC5Ccm93c2VyLmFueTNkICYmICFMLkJyb3dzZXIubW9iaWxlT3BlcmE7XG5cbmlmICh6b29tQW5pbWF0ZWQpIHtcblxuXHRMLk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb247XG5cblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcblx0XHQvLyBoYXBwZW5zIGFmdGVyIHN0YXJ0aW5nIHpvb20gYW5pbWF0aW9uIChwcm9wYWdhdGluZyB0byB0aGUgbWFwIHBhbmUpLCB3ZSBrbm93IHRoYXQgaXQgZW5kZWQgZ2xvYmFsbHlcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XG5cblx0XHRcdHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpO1xuXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX3Byb3h5LCBMLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XG5cdFx0fVxuXHR9KTtcbn1cblxuTC5NYXAuaW5jbHVkZSghem9vbUFuaW1hdGVkID8ge30gOiB7XG5cblx0X2NyZWF0ZUFuaW1Qcm94eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHByb3h5ID0gdGhpcy5fcHJveHkgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcblx0XHR0aGlzLl9wYW5lcy5tYXBQYW5lLmFwcGVuZENoaWxkKHByb3h5KTtcblxuXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciBwcm9wID0gTC5Eb21VdGlsLlRSQU5TRk9STSxcblx0XHRcdCAgICB0cmFuc2Zvcm0gPSBwcm94eS5zdHlsZVtwcm9wXTtcblxuXHRcdFx0TC5Eb21VdGlsLnNldFRyYW5zZm9ybShwcm94eSwgdGhpcy5wcm9qZWN0KGUuY2VudGVyLCBlLnpvb20pLCB0aGlzLmdldFpvb21TY2FsZShlLnpvb20sIDEpKTtcblxuXHRcdFx0Ly8gd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHRyYW5zZm9ybSBpcyB0aGUgc2FtZSBhbmQgc28gdHJhbnNpdGlvbmVuZCBldmVudCBpcyBub3QgZmlyZWRcblx0XHRcdGlmICh0cmFuc2Zvcm0gPT09IHByb3h5LnN0eWxlW3Byb3BdICYmIHRoaXMuX2FuaW1hdGluZ1pvb20pIHtcblx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5vbignbG9hZCBtb3ZlZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxuXHRcdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcblx0XHRcdEwuRG9tVXRpbC5zZXRUcmFuc2Zvcm0ocHJveHksIHRoaXMucHJvamVjdChjLCB6KSwgdGhpcy5nZXRab29tU2NhbGUoeiwgMSkpO1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9jYXRjaFRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xuXHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xuXHRcdH1cblx0fSxcblxuXHRfbm90aGluZ1RvQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcblx0fSxcblxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XG5cblx0XHRpZiAodGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2Vcblx0XHRpZiAoIXRoaXMuX3pvb21BbmltYXRlZCB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlIHx8IHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKSB8fFxuXHRcdCAgICAgICAgTWF0aC5hYnMoem9vbSAtIHRoaXMuX3pvb20pID4gdGhpcy5vcHRpb25zLnpvb21BbmltYXRpb25UaHJlc2hvbGQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyBvZmZzZXQgaXMgdGhlIHBpeGVsIGNvb3JkcyBvZiB0aGUgem9vbSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY2VudGVyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoem9vbSksXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcblxuXHRcdC8vIGRvbid0IGFuaW1hdGUgaWYgdGhlIHpvb20gb3JpZ2luIGlzbid0IHdpdGhpbiBvbmUgc2NyZWVuIGZyb20gdGhlIGN1cnJlbnQgY2VudGVyLCB1bmxlc3MgZm9yY2VkXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXNcblx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlKVxuXHRcdFx0ICAgIC5fYW5pbWF0ZVpvb20oY2VudGVyLCB6b29tLCB0cnVlKTtcblx0XHR9LCB0aGlzKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9hbmltYXRlWm9vbTogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgc3RhcnRBbmltLCBub1VwZGF0ZSkge1xuXHRcdGlmIChzdGFydEFuaW0pIHtcblx0XHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSB0cnVlO1xuXG5cdFx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cblx0XHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xuXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XG5cdFx0fVxuXG5cdFx0Ly8gQGV2ZW50IHpvb21hbmltOiBab29tQW5pbUV2ZW50XG5cdFx0Ly8gRmlyZWQgb24gZXZlcnkgZnJhbWUgb2YgYSB6b29tIGFuaW1hdGlvblxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdHpvb206IHpvb20sXG5cdFx0XHRub1VwZGF0ZTogbm9VcGRhdGVcblx0XHR9KTtcblxuXHRcdC8vIFdvcmsgYXJvdW5kIHdlYmtpdCBub3QgZmlyaW5nICd0cmFuc2l0aW9uZW5kJywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzM2ODksIDI2OTNcblx0XHRzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcblx0fSxcblxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcblxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcblxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tKTtcblxuXHRcdC8vIFRoaXMgYW5pbSBmcmFtZSBzaG91bGQgcHJldmVudCBhbiBvYnNjdXJlIGlPUyB3ZWJraXQgdGlsZSBsb2FkaW5nIHJhY2UgY29uZGl0aW9uLlxuXHRcdEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21vdmVFbmQodHJ1ZSk7XG5cdFx0fSwgdGhpcyk7XG5cdH1cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxuTC5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCAoZ2VvZ3JhcGhpY2FsIGNlbnRlciBhbmQgem9vbSkgcGVyZm9ybWluZyBhIHNtb290aFxuXHQvLyBwYW4tem9vbSBhbmltYXRpb24uXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhTC5Ccm93c2VyLmFueTNkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3RvcCgpO1xuXG5cdFx0dmFyIGZyb20gPSB0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSksXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcblx0XHQgICAgc3RhcnRab29tID0gdGhpcy5fem9vbTtcblxuXHRcdHRhcmdldENlbnRlciA9IEwubGF0TG5nKHRhcmdldENlbnRlcik7XG5cdFx0dGFyZ2V0Wm9vbSA9IHRhcmdldFpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHRhcmdldFpvb207XG5cblx0XHR2YXIgdzAgPSBNYXRoLm1heChzaXplLngsIHNpemUueSksXG5cdFx0ICAgIHcxID0gdzAgKiB0aGlzLmdldFpvb21TY2FsZShzdGFydFpvb20sIHRhcmdldFpvb20pLFxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxuXHRcdCAgICByaG8gPSAxLjQyLFxuXHRcdCAgICByaG8yID0gcmhvICogcmhvO1xuXG5cdFx0ZnVuY3Rpb24gcihpKSB7XG5cdFx0XHR2YXIgczEgPSBpID8gLTEgOiAxLFxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXG5cdFx0XHQgICAgdDEgPSB3MSAqIHcxIC0gdzAgKiB3MCArIHMxICogcmhvMiAqIHJobzIgKiB1MSAqIHUxLFxuXHRcdFx0ICAgIGIxID0gMiAqIHMyICogcmhvMiAqIHUxLFxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxuXHRcdFx0ICAgIHNxID0gTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiO1xuXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxuXHRcdFx0ICAgIC8vIHRodXMgdHJpZ2dlcmluZyBhbiBpbmZpbml0ZSBsb29wIGluIGZseVRvXG5cdFx0XHQgICAgdmFyIGxvZyA9IHNxIDwgMC4wMDAwMDAwMDEgPyAtMTggOiBNYXRoLmxvZyhzcSk7XG5cblx0XHRcdHJldHVybiBsb2c7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2luaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpIC8gMjsgfVxuXHRcdGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XG5cblx0XHR2YXIgcjAgPSByKDApO1xuXG5cdFx0ZnVuY3Rpb24gdyhzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH1cblx0XHRmdW5jdGlvbiB1KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApICogdGFuaChyMCArIHJobyAqIHMpIC0gc2luaChyMCkpIC8gcmhvMjsgfVxuXG5cdFx0ZnVuY3Rpb24gZWFzZU91dCh0KSB7IHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIDEuNSk7IH1cblxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXG5cdFx0ICAgIFMgPSAocigxKSAtIHIwKSAvIHJobyxcblx0XHQgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gMTAwMCAqIG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwICogUyAqIDAuODtcblxuXHRcdGZ1bmN0aW9uIGZyYW1lKCkge1xuXHRcdFx0dmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uLFxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcblxuXHRcdFx0aWYgKHQgPD0gMSkge1xuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnJhbWUsIHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMuX21vdmUoXG5cdFx0XHRcdFx0dGhpcy51bnByb2plY3QoZnJvbS5hZGQodG8uc3VidHJhY3QoZnJvbSkubXVsdGlwbHlCeSh1KHMpIC8gdTEpKSwgc3RhcnRab29tKSxcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXG5cdFx0XHRcdFx0e2ZseVRvOiB0cnVlfSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXNcblx0XHRcdFx0XHQuX21vdmUodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tKVxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9tb3ZlU3RhcnQodHJ1ZSk7XG5cblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZmx5VG9Cb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIHdpdGggYSBzbW9vdGggYW5pbWF0aW9uIGxpa2UgW2BmbHlUb2BdKCNtYXAtZmx5dG8pLFxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXG5cdGZseVRvQm91bmRzOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20oYm91bmRzLCBvcHRpb25zKTtcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XG5cdH1cbn0pO1xuXG4vKlxyXG4gKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqL1xyXG5cclxuTC5leHRlbmQoTC5Eb21FdmVudCwge1xyXG5cclxuXHRfdG91Y2hzdGFydDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JyxcclxuXHRfdG91Y2hlbmQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnIDogTC5Ccm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcnVwJyA6ICd0b3VjaGVuZCcsXHJcblxyXG5cdC8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcblx0YWRkRG91YmxlVGFwTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XHJcblx0XHR2YXIgbGFzdCwgdG91Y2gsXHJcblx0XHQgICAgZG91YmxlVGFwID0gZmFsc2UsXHJcblx0XHQgICAgZGVsYXkgPSAyNTA7XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcclxuXHRcdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0Y291bnQgPSBMLkRvbUV2ZW50Ll9wb2ludGVyc0NvdW50O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvdW50ID0gZS50b3VjaGVzLmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGNvdW50ID4gMSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRcdHZhciBub3cgPSBEYXRlLm5vdygpLFxyXG5cdFx0XHQgICAgZGVsdGEgPSBub3cgLSAobGFzdCB8fCBub3cpO1xyXG5cclxuXHRcdFx0dG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xyXG5cdFx0XHRkb3VibGVUYXAgPSAoZGVsdGEgPiAwICYmIGRlbHRhIDw9IGRlbGF5KTtcclxuXHRcdFx0bGFzdCA9IG5vdztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xyXG5cdFx0XHRpZiAoZG91YmxlVGFwICYmICF0b3VjaC5jYW5jZWxCdWJibGUpIHtcclxuXHRcdFx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0XHRcdC8vIHdvcmsgYXJvdW5kIC50eXBlIGJlaW5nIHJlYWRvbmx5IHdpdGggTVNQb2ludGVyKiBldmVudHNcclxuXHRcdFx0XHRcdHZhciBuZXdUb3VjaCA9IHt9LFxyXG5cdFx0XHRcdFx0ICAgIHByb3AsIGk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yIChpIGluIHRvdWNoKSB7XHJcblx0XHRcdFx0XHRcdHByb3AgPSB0b3VjaFtpXTtcclxuXHRcdFx0XHRcdFx0bmV3VG91Y2hbaV0gPSBwcm9wICYmIHByb3AuYmluZCA/IHByb3AuYmluZCh0b3VjaCkgOiBwcm9wO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dG91Y2ggPSBuZXdUb3VjaDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dG91Y2gudHlwZSA9ICdkYmxjbGljayc7XHJcblx0XHRcdFx0aGFuZGxlcih0b3VjaCk7XHJcblx0XHRcdFx0bGFzdCA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXHJcblx0XHQgICAgdG91Y2hzdGFydCA9IHRoaXMuX3RvdWNoc3RhcnQsXHJcblx0XHQgICAgdG91Y2hlbmQgPSB0aGlzLl90b3VjaGVuZDtcclxuXHJcblx0XHRvYmpbcHJlICsgdG91Y2hzdGFydCArIGlkXSA9IG9uVG91Y2hTdGFydDtcclxuXHRcdG9ialtwcmUgKyB0b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcblx0XHRvYmpbcHJlICsgJ2RibGNsaWNrJyArIGlkXSA9IGhhbmRsZXI7XHJcblxyXG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XHJcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0b3VjaGVuZCwgb25Ub3VjaEVuZCwgZmFsc2UpO1xyXG5cclxuXHRcdC8vIE9uIHNvbWUgcGxhdGZvcm1zIChub3RhYmx5LCBjaHJvbWUgb24gd2luMTAgKyB0b3VjaHNjcmVlbiArIG1vdXNlKSxcclxuXHRcdC8vIHRoZSBicm93c2VyIGRvZXNuJ3QgZmlyZSB0b3VjaGVuZC9wb2ludGVydXAgZXZlbnRzIGJ1dCBkb2VzIGZpcmVcclxuXHRcdC8vIG5hdGl2ZSBkYmxjbGlja3MuIFNlZSAjNDEyNy5cclxuXHRcdGlmICghTC5Ccm93c2VyLmVkZ2UpIHtcclxuXHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZURvdWJsZVRhcExpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCBpZCkge1xyXG5cdFx0dmFyIHByZSA9ICdfbGVhZmxldF8nLFxyXG5cdFx0ICAgIHRvdWNoc3RhcnQgPSBvYmpbcHJlICsgdGhpcy5fdG91Y2hzdGFydCArIGlkXSxcclxuXHRcdCAgICB0b3VjaGVuZCA9IG9ialtwcmUgKyB0aGlzLl90b3VjaGVuZCArIGlkXSxcclxuXHRcdCAgICBkYmxjbGljayA9IG9ialtwcmUgKyAnZGJsY2xpY2snICsgaWRdO1xyXG5cclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX3RvdWNoc3RhcnQsIHRvdWNoc3RhcnQsIGZhbHNlKTtcclxuXHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX3RvdWNoZW5kLCB0b3VjaGVuZCwgZmFsc2UpO1xyXG5cdFx0aWYgKCFMLkJyb3dzZXIuZWRnZSkge1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBkYmxjbGljaywgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxuTC5leHRlbmQoTC5Eb21FdmVudCwge1xuXG5cdFBPSU5URVJfRE9XTjogICBMLkJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckRvd24nICAgOiAncG9pbnRlcmRvd24nLFxuXHRQT0lOVEVSX01PVkU6ICAgTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJyxcblx0UE9JTlRFUl9VUDogICAgIEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnICAgICA6ICdwb2ludGVydXAnLFxuXHRQT0lOVEVSX0NBTkNFTDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnLFxuXHRUQUdfV0hJVEVfTElTVDogWydJTlBVVCcsICdTRUxFQ1QnLCAnT1BUSU9OJ10sXG5cblx0X3BvaW50ZXJzOiB7fSxcblx0X3BvaW50ZXJzQ291bnQ6IDAsXG5cblx0Ly8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuXHQvLyByZWYgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8gaHR0cHM6Ly93d3cudzMub3JnL0J1Z3MvUHVibGljL3Nob3dfYnVnLmNnaT9pZD0yMjg5MFxuXG5cdGFkZFBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcblxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJTdGFydChvYmosIGhhbmRsZXIsIGlkKTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcblx0XHRcdHRoaXMuX2FkZFBvaW50ZXJNb3ZlKG9iaiwgaGFuZGxlciwgaWQpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG5cdFx0XHR0aGlzLl9hZGRQb2ludGVyRW5kKG9iaiwgaGFuZGxlciwgaWQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaWQpIHtcblx0XHR2YXIgaGFuZGxlciA9IG9ialsnX2xlYWZsZXRfJyArIHR5cGUgKyBpZF07XG5cblx0XHRpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfRE9XTiwgaGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndG91Y2htb3ZlJykge1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIGhhbmRsZXIsIGZhbHNlKTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZFBvaW50ZXJTdGFydDogZnVuY3Rpb24gKG9iaiwgaGFuZGxlciwgaWQpIHtcblx0XHR2YXIgb25Eb3duID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyAmJiBlLnBvaW50ZXJUeXBlICE9PSBlLk1TUE9JTlRFUl9UWVBFX01PVVNFKSB7XG5cdFx0XHRcdC8vIEluIElFMTEsIHNvbWUgdG91Y2ggZXZlbnRzIG5lZWRzIHRvIGZpcmUgZm9yIGZvcm0gY29udHJvbHMsIG9yXG5cdFx0XHRcdC8vIHRoZSBjb250cm9scyB3aWxsIHN0b3Agd29ya2luZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBvZiB0YWcgbmFtZXMgdGhhdFxuXHRcdFx0XHQvLyBuZWVkIHRoZXNlIGV2ZW50cy4gRm9yIG90aGVyIHRhcmdldCB0YWdzLCB3ZSBwcmV2ZW50IGRlZmF1bHQgb24gdGhlIGV2ZW50LlxuXHRcdFx0XHRpZiAodGhpcy5UQUdfV0hJVEVfTElTVC5pbmRleE9mKGUudGFyZ2V0LnRhZ05hbWUpIDwgMCkge1xuXHRcdFx0XHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRvYmpbJ19sZWFmbGV0X3RvdWNoc3RhcnQnICsgaWRdID0gb25Eb3duO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBvbkRvd24sIGZhbHNlKTtcblxuXHRcdC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGF0IHBvaW50ZXJzIGFuZCBob3cgbWFueSBhcmUgYWN0aXZlIHRvIHByb3ZpZGUgZS50b3VjaGVzIGVtdWxhdGlvblxuXHRcdGlmICghdGhpcy5fcG9pbnRlckRvY0xpc3RlbmVyKSB7XG5cdFx0XHR2YXIgcG9pbnRlclVwID0gTC5iaW5kKHRoaXMuX2dsb2JhbFBvaW50ZXJVcCwgdGhpcyk7XG5cblx0XHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudEVsZW1lbnQgYXMgYW55IGRyYWdzIHRoYXQgZW5kIGJ5IG1vdmluZyB0aGUgdG91Y2ggb2ZmIHRoZSBzY3JlZW4gZ2V0IGZpcmVkIHRoZXJlXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfRE9XTiwgTC5iaW5kKHRoaXMuX2dsb2JhbFBvaW50ZXJEb3duLCB0aGlzKSwgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfTU9WRSwgTC5iaW5kKHRoaXMuX2dsb2JhbFBvaW50ZXJNb3ZlLCB0aGlzKSwgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIHBvaW50ZXJVcCwgdHJ1ZSk7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBwb2ludGVyVXAsIHRydWUpO1xuXG5cdFx0XHR0aGlzLl9wb2ludGVyRG9jTGlzdGVuZXIgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRfZ2xvYmFsUG9pbnRlckRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fcG9pbnRlcnNbZS5wb2ludGVySWRdID0gZTtcblx0XHR0aGlzLl9wb2ludGVyc0NvdW50Kys7XG5cdH0sXG5cblx0X2dsb2JhbFBvaW50ZXJNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9wb2ludGVyc1tlLnBvaW50ZXJJZF0pIHtcblx0XHRcdHRoaXMuX3BvaW50ZXJzW2UucG9pbnRlcklkXSA9IGU7XG5cdFx0fVxuXHR9LFxuXG5cdF9nbG9iYWxQb2ludGVyVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcblx0XHR0aGlzLl9wb2ludGVyc0NvdW50LS07XG5cdH0sXG5cblx0X2hhbmRsZVBvaW50ZXI6IGZ1bmN0aW9uIChlLCBoYW5kbGVyKSB7XG5cdFx0ZS50b3VjaGVzID0gW107XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9wb2ludGVycykge1xuXHRcdFx0ZS50b3VjaGVzLnB1c2godGhpcy5fcG9pbnRlcnNbaV0pO1xuXHRcdH1cblx0XHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdFx0aGFuZGxlcihlKTtcblx0fSxcblxuXHRfYWRkUG9pbnRlck1vdmU6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XG5cdFx0dmFyIG9uTW92ZSA9IEwuYmluZChmdW5jdGlvbiAoZSkge1xuXHRcdFx0Ly8gZG9uJ3QgZmlyZSB0b3VjaCBtb3ZlcyB3aGVuIG1vdXNlIGlzbid0IGRvd25cblx0XHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSAmJiBlLmJ1dHRvbnMgPT09IDApIHsgcmV0dXJuOyB9XG5cblx0XHRcdHRoaXMuX2hhbmRsZVBvaW50ZXIoZSwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHRvYmpbJ19sZWFmbGV0X3RvdWNobW92ZScgKyBpZF0gPSBvbk1vdmU7XG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX01PVkUsIG9uTW92ZSwgZmFsc2UpO1xuXHR9LFxuXG5cdF9hZGRQb2ludGVyRW5kOiBmdW5jdGlvbiAob2JqLCBoYW5kbGVyLCBpZCkge1xuXHRcdHZhciBvblVwID0gTC5iaW5kKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVQb2ludGVyKGUsIGhhbmRsZXIpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0b2JqWydfbGVhZmxldF90b3VjaGVuZCcgKyBpZF0gPSBvblVwO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9VUCwgb25VcCwgZmFsc2UpO1xuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9DQU5DRUwsIG9uVXAsIGZhbHNlKTtcblx0fVxufSk7XG5cbi8qXG4gKiBMLkhhbmRsZXIuVG91Y2hab29tIGlzIHVzZWQgYnkgTC5NYXAgdG8gYWRkIHBpbmNoIHpvb20gb24gc3VwcG9ydGVkIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG5cdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG5cdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdC8vIGJyb3dzZXJzIGV4Y2VwdCBmb3Igb2xkIEFuZHJvaWRzLlxuXHR0b3VjaFpvb206IEwuQnJvd3Nlci50b3VjaCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcblxuXHQvLyBAb3B0aW9uIGJvdW5jZUF0Wm9vbUxpbWl0czogQm9vbGVhbiA9IHRydWVcblx0Ly8gU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBtYXAgdG8gem9vbSBiZXlvbmQgbWluL21heCB6b29tXG5cdC8vIGFuZCB0aGVuIGJvdW5jZSBiYWNrIHdoZW4gcGluY2gtem9vbWluZy5cblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXG59KTtcblxuTC5NYXAuVG91Y2hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC10b3VjaC16b29tJyk7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcblx0fSxcblxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCBtYXAuX2FuaW1hdGluZ1pvb20gfHwgdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pO1xuXG5cdFx0dGhpcy5fY2VudGVyUG9pbnQgPSBtYXAuZ2V0U2l6ZSgpLl9kaXZpZGVCeSgyKTtcblx0XHR0aGlzLl9zdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KTtcblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tICE9PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fcGluY2hTdGFydExhdExuZyA9IG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdGFydERpc3QgPSBwMS5kaXN0YW5jZVRvKHAyKTtcblx0XHR0aGlzLl9zdGFydFpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcblx0XHR0aGlzLl96b29taW5nID0gdHJ1ZTtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgdGhpcylcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzIHx8IGUudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgIXRoaXMuX3pvb21pbmcpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBwMSA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMF0pLFxuXHRcdCAgICBwMiA9IG1hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlLnRvdWNoZXNbMV0pLFxuXHRcdCAgICBzY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xuXG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUpO1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0dmFyIG1vdmVGbiA9IEwuYmluZChtYXAuX21vdmUsIG1hcCwgdGhpcy5fY2VudGVyLCB0aGlzLl96b29tLCB7cGluY2g6IHRydWUsIHJvdW5kOiBmYWxzZX0pO1xuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUobW92ZUZuLCB0aGlzLCB0cnVlKTtcblxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xuXG5cdFx0TC5Eb21FdmVudFxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpXG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBMLk1hcC5Ub3VjaFpvb20pO1xuXG4vKlxuICogTC5NYXAuVGFwIGlzIHVzZWQgdG8gZW5hYmxlIG1vYmlsZSBoYWNrcyBsaWtlIHF1aWNrIHRhcHMgYW5kIGxvbmcgaG9sZC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRhcDogQm9vbGVhbiA9IHRydWVcblx0Ly8gRW5hYmxlcyBtb2JpbGUgaGFja3MgZm9yIHN1cHBvcnRpbmcgaW5zdGFudCB0YXBzIChmaXhpbmcgMjAwbXMgY2xpY2tcblx0Ly8gZGVsYXkgb24gaU9TL0FuZHJvaWQpIGFuZCB0b3VjaCBob2xkcyAoZmlyZWQgYXMgYGNvbnRleHRtZW51YCBldmVudHMpLlxuXHR0YXA6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiB0YXBUb2xlcmFuY2U6IE51bWJlciA9IDE1XG5cdC8vIFRoZSBtYXggbnVtYmVyIG9mIHBpeGVscyBhIHVzZXIgY2FuIHNoaWZ0IGhpcyBmaW5nZXIgZHVyaW5nIHRvdWNoXG5cdC8vIGZvciBpdCB0byBiZSBjb25zaWRlcmVkIGEgdmFsaWQgdGFwLlxuXHR0YXBUb2xlcmFuY2U6IDE1XG59KTtcblxuTC5NYXAuVGFwID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS50b3VjaGVzKSB7IHJldHVybjsgfVxuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblxuXHRcdHRoaXMuX2ZpcmVDbGljayA9IHRydWU7XG5cblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMuX2ZpcmVDbGljayA9IGZhbHNlO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF0sXG5cdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9uZXdQb3MgPSBuZXcgTC5Qb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdC8vIGlmIHRvdWNoaW5nIGEgbGluaywgaGlnaGxpZ2h0IGl0XG5cdFx0aWYgKGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhlbCwgJ2xlYWZsZXQtYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0Ly8gc2ltdWxhdGUgbG9uZyBob2xkIGJ1dCBzZXR0aW5nIGEgdGltZW91dFxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX2lzVGFwVmFsaWQoKSkge1xuXHRcdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb25VcCgpO1xuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjb250ZXh0bWVudScsIGZpcnN0KTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSwgMTAwMCk7XG5cblx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZWRvd24nLCBmaXJzdCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblxuXHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHR0b3VjaG1vdmU6IHRoaXMuX29uTW92ZSxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLl9vblVwXG5cdFx0fSwgdGhpcyk7XG5cblx0XHRpZiAodGhpcy5fZmlyZUNsaWNrICYmIGUgJiYgZS5jaGFuZ2VkVG91Y2hlcykge1xuXG5cdFx0XHR2YXIgZmlyc3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLFxuXHRcdFx0ICAgIGVsID0gZmlyc3QudGFyZ2V0O1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuXHRcdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdtb3VzZXVwJywgZmlyc3QpO1xuXG5cdFx0XHQvLyBzaW11bGF0ZSBjbGljayBpZiB0aGUgdG91Y2ggZGlkbid0IG1vdmUgdG9vIG11Y2hcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcblx0XHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY2xpY2snLCBmaXJzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKSA8PSB0aGlzLl9tYXAub3B0aW9ucy50YXBUb2xlcmFuY2U7XG5cdH0sXG5cblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXNbMF07XG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnbW91c2Vtb3ZlJywgZmlyc3QpO1xuXHR9LFxuXG5cdF9zaW11bGF0ZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuXHRcdHZhciBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXG5cdFx0c2ltdWxhdGVkRXZlbnQuX3NpbXVsYXRlZCA9IHRydWU7XG5cdFx0ZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrID0gdHJ1ZTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KFxuXHRcdCAgICAgICAgdHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLFxuXHRcdCAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksXG5cdFx0ICAgICAgICBlLmNsaWVudFgsIGUuY2xpZW50WSxcblx0XHQgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSB0YXA6IEhhbmRsZXJcbi8vIE1vYmlsZSB0b3VjaCBoYWNrcyAocXVpY2sgdGFwIGFuZCB0b3VjaCBob2xkKSBoYW5kbGVyLlxuaWYgKEwuQnJvd3Nlci50b3VjaCAmJiAhTC5Ccm93c2VyLnBvaW50ZXIpIHtcblx0TC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwJywgTC5NYXAuVGFwKTtcbn1cblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBib3hab29tOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgc3BlY2lmaWVkIGJ5XG5cdC8vIGRyYWdnaW5nIHRoZSBtb3VzZSB3aGlsZSBwcmVzc2luZyB0aGUgc2hpZnQga2V5LlxuXHRib3hab29tOiB0cnVlXG59KTtcblxuTC5NYXAuQm94Wm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX3BhbmUgPSBtYXAuX3BhbmVzLm92ZXJsYXlQYW5lO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X3Jlc2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHRoaXMuX3Jlc2V0U3RhdGUoKTtcblxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XG5cblx0XHR0aGlzLl9zdGFydFBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0TC5Eb21FdmVudC5vbihkb2N1bWVudCwge1xuXHRcdFx0Y29udGV4dG1lbnU6IEwuRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblxuXHRcdFx0dGhpcy5fbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2JveCwgYm91bmRzLm1pbik7XG5cblx0XHR0aGlzLl9ib3guc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4Jztcblx0XHR0aGlzLl9ib3guc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4Jztcblx0fSxcblxuXHRfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlKHRoaXMuX2JveCk7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdEwuRG9tVXRpbC5lbmFibGVJbWFnZURyYWcoKTtcblxuXHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogTC5Eb21FdmVudC5zdG9wLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLl9vbk1vdXNlTW92ZSxcblx0XHRcdG1vdXNldXA6IHRoaXMuX29uTW91c2VVcCxcblx0XHRcdGtleWRvd246IHRoaXMuX29uS2V5RG93blxuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmluaXNoKCk7XG5cblx0XHRpZiAoIXRoaXMuX21vdmVkKSB7IHJldHVybjsgfVxuXHRcdC8vIFBvc3Rwb25lIHRvIG5leHQgSlMgdGljayBzbyBpbnRlcm5hbCBjbGljayBldmVudCBoYW5kbGluZ1xuXHRcdC8vIHN0aWxsIHNlZSBpdCBhcyBcIm1vdmVkXCIuXG5cdFx0c2V0VGltZW91dChMLmJpbmQodGhpcy5fcmVzZXRTdGF0ZSwgdGhpcyksIDApO1xuXG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGJveFpvb206IEhhbmRsZXJcbi8vIEJveCAoc2hpZnQtZHJhZyB3aXRoIG1vdXNlKSB6b29tIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdib3hab29tJywgTC5NYXAuQm94Wm9vbSk7XG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGtleWJvYXJkOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBNYWtlcyB0aGUgbWFwIGZvY3VzYWJsZSBhbmQgYWxsb3dzIHVzZXJzIHRvIG5hdmlnYXRlIHRoZSBtYXAgd2l0aCBrZXlib2FyZFxuXHQvLyBhcnJvd3MgYW5kIGArYC9gLWAga2V5cy5cblx0a2V5Ym9hcmQ6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBrZXlib2FyZFBhbkRlbHRhOiBOdW1iZXIgPSA4MFxuXHQvLyBBbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiB3aGVuIHByZXNzaW5nIGFuIGFycm93IGtleS5cblx0a2V5Ym9hcmRQYW5EZWx0YTogODBcbn0pO1xuXG5MLk1hcC5LZXlib2FyZCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG5cdGtleUNvZGVzOiB7XG5cdFx0bGVmdDogICAgWzM3XSxcblx0XHRyaWdodDogICBbMzldLFxuXHRcdGRvd246ICAgIFs0MF0sXG5cdFx0dXA6ICAgICAgWzM4XSxcblx0XHR6b29tSW46ICBbMTg3LCAxMDcsIDYxLCAxNzFdLFxuXHRcdHpvb21PdXQ6IFsxODksIDEwOSwgNTQsIDE3M11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXG5cdFx0dGhpcy5fc2V0UGFuRGVsdGEobWFwLm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSk7XG5cdFx0dGhpcy5fc2V0Wm9vbURlbHRhKG1hcC5vcHRpb25zLnpvb21EZWx0YSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XG5cblx0XHQvLyBtYWtlIHRoZSBjb250YWluZXIgZm9jdXNhYmxlIGJ5IHRhYmJpbmdcblx0XHRpZiAoY29udGFpbmVyLnRhYkluZGV4IDw9IDApIHtcblx0XHRcdGNvbnRhaW5lci50YWJJbmRleCA9ICcwJztcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub24oe1xuXHRcdFx0Zm9jdXM6IHRoaXMuX2FkZEhvb2tzLFxuXHRcdFx0Ymx1cjogdGhpcy5fcmVtb3ZlSG9va3Ncblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbW92ZUhvb2tzKCk7XG5cblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRvbUV2ZW50Lm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XG5cdH0sXG5cblx0X3JlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGtleSA9IGUua2V5Q29kZSxcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvZmZzZXQ7XG5cblx0XHRpZiAoa2V5IGluIHRoaXMuX3BhbktleXMpIHtcblxuXHRcdFx0aWYgKG1hcC5fcGFuQW5pbSAmJiBtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XG5cblx0XHRcdG9mZnNldCA9IHRoaXMuX3BhbktleXNba2V5XTtcblx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdG9mZnNldCA9IEwucG9pbnQob2Zmc2V0KS5tdWx0aXBseUJ5KDMpO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblxuXHRcdFx0aWYgKG1hcC5vcHRpb25zLm1heEJvdW5kcykge1xuXHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xuXHRcdFx0bWFwLnNldFpvb20obWFwLmdldFpvb20oKSArIChlLnNoaWZ0S2V5ID8gMyA6IDEpICogdGhpcy5fem9vbUtleXNba2V5XSk7XG5cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gMjcpIHtcblx0XHRcdG1hcC5jbG9zZVBvcHVwKCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGtleWJvYXJkOiBIYW5kbGVyXG4vLyBLZXlib2FyZCBuYXZpZ2F0aW9uIGhhbmRsZXIuXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEwuTWFwLktleWJvYXJkKTtcblxuLypcbiAqIEwuSGFuZGxlci5NYXJrZXJEcmFnIGlzIHVzZWQgaW50ZXJuYWxseSBieSBMLk1hcmtlciB0byBtYWtlIHRoZSBtYXJrZXJzIGRyYWdnYWJsZS5cbiAqL1xuXG5cbi8qIEBuYW1lc3BhY2UgTWFya2VyXG4gKiBAc2VjdGlvbiBJbnRlcmFjdGlvbiBoYW5kbGVyc1xuICpcbiAqIEludGVyYWN0aW9uIGhhbmRsZXJzIGFyZSBwcm9wZXJ0aWVzIG9mIGEgbWFya2VyIGluc3RhbmNlIHRoYXQgYWxsb3cgeW91IHRvIGNvbnRyb2wgaW50ZXJhY3Rpb24gYmVoYXZpb3IgaW4gcnVudGltZSwgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIGNlcnRhaW4gZmVhdHVyZXMgc3VjaCBhcyBkcmFnZ2luZyAoc2VlIGBIYW5kbGVyYCBtZXRob2RzKS4gRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogbWFya2VyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAqIGBgYFxuICpcbiAqIEBwcm9wZXJ0eSBkcmFnZ2luZzogSGFuZGxlclxuICogTWFya2VyIGRyYWdnaW5nIGhhbmRsZXIgKGJ5IGJvdGggbW91c2UgYW5kIHRvdWNoKS5cbiAqL1xuXG5MLkhhbmRsZXIuTWFya2VyRHJhZyA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGljb24gPSB0aGlzLl9tYXJrZXIuX2ljb247XG5cblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLm9mZih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZGlzYWJsZSgpO1xuXG5cdFx0aWYgKHRoaXMuX21hcmtlci5faWNvbikge1xuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xuXHRcdH1cblx0fSxcblxuXHRtb3ZlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmNsb3NlUG9wdXAoKVxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0Jylcblx0XHQgICAgLmZpcmUoJ2RyYWdzdGFydCcpO1xuXHR9LFxuXG5cdF9vbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgc2hhZG93ID0gbWFya2VyLl9zaGFkb3csXG5cdFx0ICAgIGljb25Qb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24obWFya2VyLl9pY29uKSxcblx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuXG5cdFx0Ly8gdXBkYXRlIHNoYWRvdyBwb3NpdGlvblxuXHRcdGlmIChzaGFkb3cpIHtcblx0XHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFya2VyIHN0b3BzIG1vdmluZyAoYmVjYXVzZSBvZiBkcmFnZ2luZykuXG5cdFx0ZGVsZXRlIHRoaXMuX29sZExhdExuZztcblx0XHR0aGlzLl9tYXJrZXJcblx0XHQgICAgLmZpcmUoJ21vdmVlbmQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xuXHR9XG59KTtcblxuLypcclxuICogQGNsYXNzIENvbnRyb2xcclxuICogQGFrYSBMLkNvbnRyb2xcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvLyBAb3B0aW9uIHBvc2l0aW9uOiBTdHJpbmcgPSAndG9wcmlnaHQnXHJcblx0XHQvLyBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgKG9uZSBvZiB0aGUgbWFwIGNvcm5lcnMpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAndG9wbGVmdCdgLFxyXG5cdFx0Ly8gYCd0b3ByaWdodCdgLCBgJ2JvdHRvbWxlZnQnYCBvciBgJ2JvdHRvbXJpZ2h0J2BcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKiBAc2VjdGlvblxyXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIEwuQ29udHJvbCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRQb3NpdGlvbjogc3RyaW5nXHJcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuXHJcblx0ICovXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb247XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcblx0XHRpZiAobWFwKSB7XHJcblx0XHRcdG1hcC5hZGRDb250cm9sKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q29udGFpbmVyOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIEhUTUxFbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2wuXHJcblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkVG8obWFwOiBNYXApOiB0aGlzXHJcblx0Ly8gQWRkcyB0aGUgY29udHJvbCB0byB0aGUgZ2l2ZW4gbWFwLlxyXG5cdGFkZFRvOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLnJlbW92ZSgpO1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0aGlzLm9uQWRkKG1hcCksXHJcblx0XHQgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sJyk7XHJcblxyXG5cdFx0aWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29ybmVyLmluc2VydEJlZm9yZShjb250YWluZXIsIGNvcm5lci5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgY29udHJvbCBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xyXG4gKiBAdW5pbmhlcml0YWJsZVxyXG4gKlxyXG4gKiBFdmVyeSBjb250cm9sIHNob3VsZCBleHRlbmQgZnJvbSBgTC5Db250cm9sYCBhbmQgKHJlLSlpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2RzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uQWRkKG1hcDogTWFwKTogSFRNTEVsZW1lbnRcclxuICogU2hvdWxkIHJldHVybiB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgY29udHJvbCBhbmQgYWRkIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2Bjb250cm9sLmFkZFRvKG1hcClgXSgjY29udHJvbC1hZGRUbykuXHJcbiAqXHJcbiAqIEBtZXRob2Qgb25SZW1vdmUobWFwOiBNYXApXHJcbiAqIE9wdGlvbmFsIG1ldGhvZC4gU2hvdWxkIGNvbnRhaW4gYWxsIGNsZWFuIHVwIGNvZGUgdGhhdCByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgcHJldmlvdXNseSBhZGRlZCBpbiBbYG9uQWRkYF0oI2NvbnRyb2wtb25hZGQpLiBDYWxsZWQgb24gW2Bjb250cm9sLnJlbW92ZSgpYF0oI2NvbnRyb2wtcmVtb3ZlKS5cclxuICovXHJcblxyXG4vKiBAbmFtZXNwYWNlIE1hcFxyXG4gKiBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXHJcbiAqL1xyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHQvLyBAbWV0aG9kIGFkZENvbnRyb2woY29udHJvbDogQ29udHJvbCk6IHRoaXNcclxuXHQvLyBBZGRzIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXBcclxuXHRhZGRDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5hZGRUbyh0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwXHJcblx0cmVtb3ZlQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wucmVtb3ZlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdENvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fY29udHJvbENvcm5lcnMgPSB7fSxcclxuXHRcdCAgICBsID0gJ2xlYWZsZXQtJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID1cclxuXHRcdCAgICAgICAgICAgIEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAnbGVmdCcpO1xyXG5cdFx0Y3JlYXRlQ29ybmVyKCd0b3AnLCAncmlnaHQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcignYm90dG9tJywgJ3JpZ2h0Jyk7XHJcblx0fSxcclxuXHJcblx0X2NsZWFyQ29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHR9XHJcbn0pO1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sLlpvb20gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5ab29tIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ3RvcGxlZnQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGV4dDogU3RyaW5nID0gJysnXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnKycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UaXRsZTogU3RyaW5nID0gJ1pvb20gaW4nXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBpbicgYnV0dG9uLlxyXG5cdFx0em9vbUluVGl0bGU6ICdab29tIGluJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb21PdXRUZXh0OiBTdHJpbmcgPSAnLSdcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJy0nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU91dFRpdGxlOiBTdHJpbmcgPSAnWm9vbSBvdXQnXHJcblx0XHQvLyBUaGUgdGl0bGUgc2V0IG9uIHRoZSAnem9vbSBvdXQnIGJ1dHRvbi5cclxuXHRcdHpvb21PdXRUaXRsZTogJ1pvb20gb3V0J1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgem9vbU5hbWUgPSAnbGVhZmxldC1jb250cm9sLXpvb20nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gTC5Eb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaW5uZXJIVE1MID0gaHRtbDtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSB0aXRsZTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHQgICAgLm9uKGxpbmssICdtb3VzZWRvd24gZGJsY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBmbiwgdGhpcylcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCB0aGlzKTtcclxuXHJcblx0XHRyZXR1cm4gbGluaztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY2xhc3NOYW1lID0gJ2xlYWZsZXQtZGlzYWJsZWQnO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fZGlzYWJsZWQgfHwgbWFwLl96b29tID09PSBtYXAuZ2V0TWluWm9vbSgpKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tT3V0QnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IEwuQ29udHJvbC5ab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbkwuY29udHJvbC56b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5ab29tKG9wdGlvbnMpO1xyXG59O1xyXG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBha2EgTC5Db250cm9sLkF0dHJpYnV0aW9uXHJcbiAqIEBpbmhlcml0cyBDb250cm9sXHJcbiAqXHJcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250cm9sIGFsbG93cyB5b3UgdG8gZGlzcGxheSBhdHRyaWJ1dGlvbiBkYXRhIGluIGEgc21hbGwgdGV4dCBib3ggb24gYSBtYXAuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgYXR0cmlidXRpb25Db250cm9sYCBvcHRpb25dKCNtYXAtYXR0cmlidXRpb25jb250cm9sKSB0byBgZmFsc2VgLCBhbmQgaXQgZmV0Y2hlcyBhdHRyaWJ1dGlvbiB0ZXh0cyBmcm9tIGxheWVycyB3aXRoIHRoZSBbYGdldEF0dHJpYnV0aW9uYCBtZXRob2RdKCNsYXllci1nZXRhdHRyaWJ1dGlvbikgYXV0b21hdGljYWxseS4gRXh0ZW5kcyBDb250cm9sLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEwuQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uJyk7XHJcblx0XHRpZiAoTC5Eb21FdmVudCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVE9ETyB1Z2x5LCByZWZhY3RvclxyXG5cdFx0Zm9yICh2YXIgaSBpbiBtYXAuX2xheWVycykge1xyXG5cdFx0XHRpZiAobWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0aW9uKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFByZWZpeChwcmVmaXg6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB0ZXh0IGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnVmVjdG9yIGRhdGEgJmNvcHk7IE1hcGJveCdgKS5cclxuXHRhZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0rKztcclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUF0dHJpYnV0aW9uKHRleHQ6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGF0dHJpYnV0aW9uIHRleHQuXHJcblx0cmVtb3ZlQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fYXR0cmlidXRpb25zW3RleHRdKSB7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XS0tO1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fYXR0cmlidXRpb25zKSB7XHJcblx0XHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbaV0pIHtcclxuXHRcdFx0XHRhdHRyaWJzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcHJlZml4QW5kQXR0cmlicyA9IFtdO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJlZml4KSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaCh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHRcdH1cclxuXHRcdGlmIChhdHRyaWJzLmxlbmd0aCkge1xyXG5cdFx0XHRwcmVmaXhBbmRBdHRyaWJzLnB1c2goYXR0cmlicy5qb2luKCcsICcpKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gcHJlZml4QW5kQXR0cmlicy5qb2luKCcgfCAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0YXR0cmlidXRpb25Db250cm9sOiB0cnVlXHJcbn0pO1xyXG5cclxuTC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRpb25Db250cm9sKSB7XHJcblx0XHRuZXcgTC5Db250cm9sLkF0dHJpYnV0aW9uKCkuYWRkVG8odGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wuYXR0cmlidXRpb24ob3B0aW9uczogQ29udHJvbC5BdHRyaWJ1dGlvbiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGFuIGF0dHJpYnV0aW9uIGNvbnRyb2wuXHJcbkwuY29udHJvbC5hdHRyaWJ1dGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wuQXR0cmlidXRpb24ob3B0aW9ucyk7XHJcbn07XHJcblxuLypcbiAqIEBjbGFzcyBDb250cm9sLlNjYWxlXG4gKiBAYWthIEwuQ29udHJvbC5TY2FsZVxuICogQGluaGVyaXRzIENvbnRyb2xcbiAqXG4gKiBBIHNpbXBsZSBzY2FsZSBjb250cm9sIHRoYXQgc2hvd3MgdGhlIHNjYWxlIG9mIHRoZSBjdXJyZW50IGNlbnRlciBvZiBzY3JlZW4gaW4gbWV0cmljIChtL2ttKSBhbmQgaW1wZXJpYWwgKG1pL2Z0KSBzeXN0ZW1zLiBFeHRlbmRzIGBDb250cm9sYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiBMLmNvbnRyb2wuc2NhbGUoKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuTC5Db250cm9sLlNjYWxlID0gTC5Db250cm9sLmV4dGVuZCh7XG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgQ29udHJvbC5TY2FsZSBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhXaWR0aDogTnVtYmVyID0gMTAwXG5cdFx0Ly8gTWF4aW11bSB3aWR0aCBvZiB0aGUgY29udHJvbCBpbiBwaXhlbHMuIFRoZSB3aWR0aCBpcyBzZXQgZHluYW1pY2FsbHkgdG8gc2hvdyByb3VuZCB2YWx1ZXMgKGUuZy4gMTAwLCAyMDAsIDUwMCkuXG5cdFx0bWF4V2lkdGg6IDEwMCxcblxuXHRcdC8vIEBvcHRpb24gbWV0cmljOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgbWV0cmljIHNjYWxlIGxpbmUgKG0va20pLlxuXHRcdG1ldHJpYzogdHJ1ZSxcblxuXHRcdC8vIEBvcHRpb24gaW1wZXJpYWw6IEJvb2xlYW4gPSBUcnVlXG5cdFx0Ly8gV2hldGhlciB0byBzaG93IHRoZSBpbXBlcmlhbCBzY2FsZSBsaW5lIChtaS9mdCkuXG5cdFx0aW1wZXJpYWw6IHRydWVcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSBmYWxzZVxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgaXMgdXBkYXRlZCBvbiBbYG1vdmVlbmRgXSgjbWFwLW1vdmVlbmQpLCBvdGhlcndpc2UgaXQncyBhbHdheXMgdXAtdG8tZGF0ZSAodXBkYXRlZCBvbiBbYG1vdmVgXSgjbWFwLW1vdmUpKS5cblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLXNjYWxlJyxcblx0XHQgICAgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUgKyAnLWxpbmUnLCBjb250YWluZXIpO1xuXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdFx0bWFwLndoZW5SZWFkeSh0aGlzLl91cGRhdGUsIHRoaXMpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlID8gJ21vdmVlbmQnIDogJ21vdmUnLCB0aGlzLl91cGRhdGUsIHRoaXMpO1xuXHR9LFxuXG5cdF9hZGRTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuXHRcdGlmIChvcHRpb25zLm1ldHJpYykge1xuXHRcdFx0dGhpcy5fbVNjYWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgeSA9IG1hcC5nZXRTaXplKCkueSAvIDI7XG5cblx0XHR2YXIgbWF4TWV0ZXJzID0gbWFwLmRpc3RhbmNlKFxuXHRcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCwgeV0pLFxuXHRcdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5MLmNvbnRyb2wuc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5TY2FsZShvcHRpb25zKTtcbn07XG5cbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLkxheWVyc1xyXG4gKiBAYWthIEwuQ29udHJvbC5MYXllcnNcclxuICogQGluaGVyaXRzIENvbnRyb2xcclxuICpcclxuICogVGhlIGxheWVycyBjb250cm9sIGdpdmVzIHVzZXJzIHRoZSBhYmlsaXR5IHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBiYXNlIGxheWVycyBhbmQgc3dpdGNoIG92ZXJsYXlzIG9uL29mZiAoY2hlY2sgb3V0IHRoZSBbZGV0YWlsZWQgZXhhbXBsZV0oaHR0cDovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wuaHRtbCkpLiBFeHRlbmRzIGBDb250cm9sYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGJhc2VMYXllcnMgPSB7XHJcbiAqIFx0XCJNYXBib3hcIjogbWFwYm94LFxyXG4gKiBcdFwiT3BlblN0cmVldE1hcFwiOiBvc21cclxuICogfTtcclxuICpcclxuICogdmFyIG92ZXJsYXlzID0ge1xyXG4gKiBcdFwiTWFya2VyXCI6IG1hcmtlcixcclxuICogXHRcIlJvYWRzXCI6IHJvYWRzTGF5ZXJcclxuICogfTtcclxuICpcclxuICogTC5jb250cm9sLmxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cykuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBgYmFzZUxheWVyc2AgYW5kIGBvdmVybGF5c2AgcGFyYW1ldGVycyBhcmUgb2JqZWN0IGxpdGVyYWxzIHdpdGggbGF5ZXIgbmFtZXMgYXMga2V5cyBhbmQgYExheWVyYCBvYmplY3RzIGFzIHZhbHVlczpcclxuICpcclxuICogYGBganNcclxuICoge1xyXG4gKiAgICAgXCI8c29tZU5hbWUxPlwiOiBsYXllcjEsXHJcbiAqICAgICBcIjxzb21lTmFtZTI+XCI6IGxheWVyMlxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXIgbmFtZXMgY2FuIGNvbnRhaW4gSFRNTCwgd2hpY2ggYWxsb3dzIHlvdSB0byBhZGQgYWRkaXRpb25hbCBzdHlsaW5nIHRvIHRoZSBpdGVtczpcclxuICpcclxuICogYGBganNcclxuICoge1wiPGltZyBzcmM9J215LWxheWVyLWljb24nIC8+IDxzcGFuIGNsYXNzPSdteS1sYXllci1pdGVtJz5NeSBMYXllcjwvc3Bhbj5cIjogbXlMYXllcn1cclxuICogYGBgXHJcbiAqL1xyXG5cclxuXHJcbkwuQ29udHJvbC5MYXllcnMgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyIG9yIHRvdWNoLlxyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvWkluZGV4OiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGFzc2lnbiB6SW5kZXhlcyBpbiBpbmNyZWFzaW5nIG9yZGVyIHRvIGFsbCBvZiBpdHMgbGF5ZXJzIHNvIHRoYXQgdGhlIG9yZGVyIGlzIHByZXNlcnZlZCB3aGVuIHN3aXRjaGluZyB0aGVtIG9uL29mZi5cclxuXHRcdGF1dG9aSW5kZXg6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBoaWRlU2luZ2xlQmFzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBiYXNlIGxheWVycyBpbiB0aGUgY29udHJvbCB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZXJlIGlzIG9ubHkgb25lLlxyXG5cdFx0aGlkZVNpbmdsZUJhc2U6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kJywgdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycywgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZEJhc2VMYXllcihsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGEgYmFzZSBsYXllciAocmFkaW8gYnV0dG9uIGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRPdmVybGF5KGxheWVyOiBMYXllciwgbmFtZTogU3RyaW5nKTogdGhpc1xyXG5cdC8vIEFkZHMgYW4gb3ZlcmxheSAoY2hlY2tib3ggZW50cnkpIHdpdGggdGhlIGdpdmVuIG5hbWUgdG8gdGhlIGNvbnRyb2wuXHJcblx0YWRkT3ZlcmxheTogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBjb250cm9sLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGxheWVyLm9mZignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihMLnN0YW1wKGxheWVyKSk7XHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zcGxpY2UodGhpcy5fbGF5ZXJzLmluZGV4T2Yob2JqKSwgMSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKHRoaXMuX21hcCkgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBleHBhbmQoKTogdGhpc1xyXG5cdC8vIEV4cGFuZCB0aGUgY29udHJvbCBjb250YWluZXIgaWYgY29sbGFwc2VkLlxyXG5cdGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHRoaXMuX2Zvcm0uc3R5bGUuaGVpZ2h0ID0gbnVsbDtcclxuXHRcdHZhciBhY2NlcHRhYmxlSGVpZ2h0ID0gdGhpcy5fbWFwLmdldFNpemUoKS55IC0gKHRoaXMuX2NvbnRhaW5lci5vZmZzZXRUb3AgKyA1MCk7XHJcblx0XHRpZiAoYWNjZXB0YWJsZUhlaWdodCA8IHRoaXMuX2Zvcm0uY2xpZW50SGVpZ2h0KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fZm9ybS5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9mb3JtLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29sbGFwc2UoKTogdGhpc1xyXG5cdC8vIENvbGxhcHNlIHRoZSBjb250cm9sIGNvbnRhaW5lciBpZiBleHBhbmRlZC5cclxuXHRjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0Ly8gbWFrZXMgdGhpcyB3b3JrIG9uIElFIHRvdWNoIGRldmljZXMgYnkgc3RvcHBpbmcgaXQgZnJvbSBmaXJpbmcgYSBtb3VzZW91dCBldmVudCB3aGVuIHRoZSB0b3VjaCBpcyByZWxlYXNlZFxyXG5cdFx0Y29udGFpbmVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsIHRydWUpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuZGlzYWJsZVNjcm9sbFByb3BhZ2F0aW9uKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZvcm0gPSB0aGlzLl9mb3JtID0gTC5Eb21VdGlsLmNyZWF0ZSgnZm9ybScsIGNsYXNzTmFtZSArICctbGlzdCcpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdGlmICghTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKGNvbnRhaW5lciwge1xyXG5cdFx0XHRcdFx0bW91c2VlbnRlcjogdGhpcy5leHBhbmQsXHJcblx0XHRcdFx0XHRtb3VzZWxlYXZlOiB0aGlzLmNvbGxhcHNlXHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRMLkRvbUV2ZW50Lm9uKGxpbmssICdmb2N1cycsIHRoaXMuZXhwYW5kLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gd29yayBhcm91bmQgZm9yIEZpcmVmb3ggQW5kcm9pZCBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDMzXHJcblx0XHRcdEwuRG9tRXZlbnQub24oZm9ybSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyksIDApO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLmNvbGxhcHNlLCB0aGlzKTtcclxuXHRcdFx0Ly8gVE9ETyBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmV4cGFuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Jhc2VMYXllcnNMaXN0ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1iYXNlJywgZm9ybSk7XHJcblx0XHR0aGlzLl9zZXBhcmF0b3IgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIGZvcm0pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1vdmVybGF5cycsIGZvcm0pO1xyXG5cclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9sYXllcnNbaV0gJiYgTC5zdGFtcCh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9sYXllcnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSwgb3ZlcmxheSkge1xyXG5cdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdEwuRG9tVXRpbC5lbXB0eSh0aGlzLl9iYXNlTGF5ZXJzTGlzdCk7XHJcblx0XHRMLkRvbVV0aWwuZW1wdHkodGhpcy5fb3ZlcmxheXNMaXN0KTtcclxuXHJcblx0XHR2YXIgYmFzZUxheWVyc1ByZXNlbnQsIG92ZXJsYXlzUHJlc2VudCwgaSwgb2JqLCBiYXNlTGF5ZXJzQ291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNDb3VudCArPSAhb2JqLm92ZXJsYXkgPyAxIDogMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIaWRlIGJhc2UgbGF5ZXJzIHNlY3Rpb24gaWYgdGhlcmUncyBvbmx5IG9uZSBsYXllci5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaGlkZVNpbmdsZUJhc2UpIHtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCAmJiBiYXNlTGF5ZXJzQ291bnQgPiAxO1xyXG5cdFx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdC5zdHlsZS5kaXNwbGF5ID0gYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheSA9IG92ZXJsYXlzUHJlc2VudCAmJiBiYXNlTGF5ZXJzUHJlc2VudCA/ICcnIDogJ25vbmUnO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQ2hhbmdlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvYmogPSB0aGlzLl9nZXRMYXllcihMLnN0YW1wKGUudGFyZ2V0KSk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIExheWVyIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGJhc2VsYXllcmNoYW5nZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBiYXNlIGxheWVyIGlzIGNoYW5nZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheWFkZDogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgc2VsZWN0ZWQgdGhyb3VnaCB0aGUgW2xheWVyIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXIgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBuYW1lc3BhY2UgQ29udHJvbC5MYXllcnNcclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdvdmVybGF5YWRkJyA6ICdvdmVybGF5cmVtb3ZlJykgOlxyXG5cdFx0XHQoZS50eXBlID09PSAnYWRkJyA/ICdiYXNlbGF5ZXJjaGFuZ2UnIDogbnVsbCk7XHJcblxyXG5cdFx0aWYgKHR5cGUpIHtcclxuXHRcdFx0dGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnMnLCBjaGVja2VkKTtcclxuXHRcdH1cclxuXHJcblx0XHRpbnB1dC5sYXllcklkID0gTC5zdGFtcChvYmoubGF5ZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuXHRcdGxhYmVsLmFwcGVuZENoaWxkKGhvbGRlcik7XHJcblx0XHRob2xkZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKG5hbWUpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXIgPSBvYmoub3ZlcmxheSA/IHRoaXMuX292ZXJsYXlzTGlzdCA6IHRoaXMuX2Jhc2VMYXllcnNMaXN0O1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcclxuXHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gbGFiZWw7XHJcblx0fSxcclxuXHJcblx0X29uSW5wdXRDbGljazogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2Zvcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JyksXHJcblx0XHQgICAgaW5wdXQsIGxheWVyLCBoYXNMYXllcjtcclxuXHRcdHZhciBhZGRlZExheWVycyA9IFtdLFxyXG5cdFx0ICAgIHJlbW92ZWRMYXllcnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRoYXNMYXllciA9IHRoaXMuX21hcC5oYXNMYXllcihsYXllcik7XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCAmJiAhaGFzTGF5ZXIpIHtcclxuXHRcdFx0XHRhZGRlZExheWVycy5wdXNoKGxheWVyKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQgJiYgaGFzTGF5ZXIpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocmVtb3ZlZExheWVyc1tpXSk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fcmVmb2N1c09uTWFwKCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrRGlzYWJsZWRMYXllcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbnB1dHMgPSB0aGlzLl9mb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGxheWVyLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBpbnB1dHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aW5wdXQgPSBpbnB1dHNbaV07XHJcblx0XHRcdGxheWVyID0gdGhpcy5fZ2V0TGF5ZXIoaW5wdXQubGF5ZXJJZCkubGF5ZXI7XHJcblx0XHRcdGlucHV0LmRpc2FibGVkID0gKGxheWVyLm9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPCBsYXllci5vcHRpb25zLm1pblpvb20pIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgKGxheWVyLm9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gPiBsYXllci5vcHRpb25zLm1heFpvb20pO1xyXG5cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKCk7XHJcblx0fSxcclxuXHJcblx0X2NvbGxhcHNlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCByZW1vdmUgbWUgaW4gMS4xLlxyXG5cdFx0cmV0dXJuIHRoaXMuY29sbGFwc2UoKTtcclxuXHR9XHJcblxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmNvbnRyb2wubGF5ZXJzKGJhc2VsYXllcnM/OiBPYmplY3QsIG92ZXJsYXlzPzogT2JqZWN0LCBvcHRpb25zPzogQ29udHJvbC5MYXllcnMgb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sIHdpdGggdGhlIGdpdmVuIGxheWVycy4gQmFzZSBsYXllcnMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIHJhZGlvIGJ1dHRvbnMsIHdoaWxlIG92ZXJsYXlzIHdpbGwgYmUgc3dpdGNoZWQgd2l0aCBjaGVja2JveGVzLiBOb3RlIHRoYXQgYWxsIGJhc2UgbGF5ZXJzIHNob3VsZCBiZSBwYXNzZWQgaW4gdGhlIGJhc2UgbGF5ZXJzIG9iamVjdCwgYnV0IG9ubHkgb25lIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFwIGR1cmluZyBtYXAgaW5zdGFudGlhdGlvbi5cclxuTC5jb250cm9sLmxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLkxheWVycyhiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucyk7XHJcbn07XHJcblxuLypcclxuICogUHJvdmlkZXMgTC5NYXAgd2l0aCBjb252ZW5pZW50IHNob3J0Y3V0cyBmb3IgdXNpbmcgYnJvd3NlciBnZW9sb2NhdGlvbiBmZWF0dXJlcy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG5cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0Ly8gQHNlY3Rpb24gR2VvbG9jYXRpb24gbWV0aG9kc1xyXG5cdF9kZWZhdWx0TG9jYXRlT3B0aW9uczoge1xyXG5cdFx0dGltZW91dDogMTAwMDAsXHJcblx0XHR3YXRjaDogZmFsc2VcclxuXHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHQvLyBtYXhab29tOiA8TnVtYmVyPlxyXG5cdFx0Ly8gbWF4aW11bUFnZTogMFxyXG5cdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbG9jYXRlKG9wdGlvbnM/OiBMb2NhdGUgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBUcmllcyB0byBsb2NhdGUgdGhlIHVzZXIgdXNpbmcgdGhlIEdlb2xvY2F0aW9uIEFQSSwgZmlyaW5nIGEgW2Bsb2NhdGlvbmZvdW5kYF0oI21hcC1sb2NhdGlvbmZvdW5kKVxyXG5cdC8vIGV2ZW50IHdpdGggbG9jYXRpb24gZGF0YSBvbiBzdWNjZXNzIG9yIGEgW2Bsb2NhdGlvbmVycm9yYF0oI21hcC1sb2NhdGlvbmVycm9yKSBldmVudCBvbiBmYWlsdXJlLFxyXG5cdC8vIGFuZCBvcHRpb25hbGx5IHNldHMgdGhlIG1hcCB2aWV3IHRvIHRoZSB1c2VyJ3MgbG9jYXRpb24gd2l0aCByZXNwZWN0IHRvXHJcblx0Ly8gZGV0ZWN0aW9uIGFjY3VyYWN5IChvciB0byB0aGUgd29ybGQgdmlldyBpZiBnZW9sb2NhdGlvbiBmYWlsZWQpLlxyXG5cdC8vIE5vdGUgdGhhdCwgaWYgeW91ciBwYWdlIGRvZXNuJ3QgdXNlIEhUVFBTLCB0aGlzIG1ldGhvZCB3aWxsIGZhaWwgaW5cclxuXHQvLyBtb2Rlcm4gYnJvd3NlcnMgKFtDaHJvbWUgNTAgYW5kIG5ld2VyXShodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZGV2L0hvbWUvY2hyb21pdW0tc2VjdXJpdHkvZGVwcmVjYXRpbmctcG93ZXJmdWwtZmVhdHVyZXMtb24taW5zZWN1cmUtb3JpZ2lucykpXHJcblx0Ly8gU2VlIGBMb2NhdGUgb3B0aW9uc2AgZm9yIG1vcmUgZGV0YWlscy5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnMgPSBMLmV4dGVuZCh7fSwgdGhpcy5fZGVmYXVsdExvY2F0ZU9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSkge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0ICAgIG9uRXJyb3IgPSBMLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvciwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMud2F0Y2gpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRpb25XYXRjaElkID1cclxuXHRcdFx0ICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN0b3BMb2NhdGUoKTogdGhpc1xyXG5cdC8vIFN0b3BzIHdhdGNoaW5nIGxvY2F0aW9uIHByZXZpb3VzbHkgaW5pdGlhdGVkIGJ5IGBtYXAubG9jYXRlKHt3YXRjaDogdHJ1ZX0pYFxyXG5cdC8vIGFuZCBhYm9ydHMgcmVzZXR0aW5nIHRoZSBtYXAgdmlldyBpZiBtYXAubG9jYXRlIHdhcyBjYWxsZWQgd2l0aFxyXG5cdC8vIGB7c2V0VmlldzogdHJ1ZX1gLlxyXG5cdHN0b3BMb2NhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24gJiYgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2gpIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9sb2NhdGVPcHRpb25zKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdFx0dmFyIGMgPSBlcnJvci5jb2RlLFxyXG5cdFx0ICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMSA/ICdwZXJtaXNzaW9uIGRlbmllZCcgOlxyXG5cdFx0ICAgICAgICAgICAgKGMgPT09IDIgPyAncG9zaXRpb24gdW5hdmFpbGFibGUnIDogJ3RpbWVvdXQnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMuc2V0VmlldyAmJiAhdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuZml0V29ybGQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBMb2NhdGlvbiBldmVudHNcclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmVycm9yOiBFcnJvckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKSBmYWlsZWQuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZXJyb3InLCB7XHJcblx0XHRcdGNvZGU6IGMsXHJcblx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBlcnJvcjogJyArIG1lc3NhZ2UgKyAnLidcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9oYW5kbGVHZW9sb2NhdGlvblJlc3BvbnNlOiBmdW5jdGlvbiAocG9zKSB7XHJcblx0XHR2YXIgbGF0ID0gcG9zLmNvb3Jkcy5sYXRpdHVkZSxcclxuXHRcdCAgICBsbmcgPSBwb3MuY29vcmRzLmxvbmdpdHVkZSxcclxuXHRcdCAgICBsYXRsbmcgPSBuZXcgTC5MYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5KSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucztcclxuXHJcblx0XHRpZiAob3B0aW9ucy5zZXRWaWV3KSB7XHJcblx0XHRcdHZhciB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcyk7XHJcblx0XHRcdHRoaXMuc2V0VmlldyhsYXRsbmcsIG9wdGlvbnMubWF4Wm9vbSA/IE1hdGgubWluKHpvb20sIG9wdGlvbnMubWF4Wm9vbSkgOiB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBldmVudCBsb2NhdGlvbmZvdW5kOiBMb2NhdGlvbkV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGdlb2xvY2F0aW9uICh1c2luZyB0aGUgW2Bsb2NhdGVgXSgjbWFwLWxvY2F0ZSkgbWV0aG9kKVxyXG5cdFx0Ly8gd2VudCBzdWNjZXNzZnVsbHkuXHJcblx0XHR0aGlzLmZpcmUoJ2xvY2F0aW9uZm91bmQnLCBkYXRhKTtcclxuXHR9XHJcbn0pO1xyXG4iLCIoZnVuY3Rpb24od2luZG93LCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZiAoIXdpbmRvdykgcmV0dXJuOyAvLyBTZXJ2ZXIgc2lkZVxuXG52YXJcbiAgICBfYmFyb24gPSB3aW5kb3cuYmFyb24sIC8vIFN0b3JlZCBiYXJvbiB2YWx1ZSBmb3Igbm9Db25mbGljdCB1c2FnZVxuICAgICQgPSB3aW5kb3cualF1ZXJ5LCAvLyBUcnlpbmcgdG8gdXNlIGpRdWVyeVxuICAgIG9yaWdpbiA9IHtcbiAgICAgICAgdjogeyAvLyBWZXJ0aWNhbFxuICAgICAgICAgICAgeDogJ1knLCBwb3M6ICd0b3AnLCBjcm9zc1BvczogJ2xlZnQnLCBzaXplOiAnaGVpZ2h0JywgY3Jvc3NTaXplOiAnd2lkdGgnLFxuICAgICAgICAgICAgY2xpZW50OiAnY2xpZW50SGVpZ2h0JywgY3Jvc3NDbGllbnQ6ICdjbGllbnRXaWR0aCcsIG9mZnNldDogJ29mZnNldEhlaWdodCcsIGNyb3NzT2Zmc2V0OiAnb2Zmc2V0V2lkdGgnLCBvZmZzZXRQb3M6ICdvZmZzZXRUb3AnLFxuICAgICAgICAgICAgc2Nyb2xsOiAnc2Nyb2xsVG9wJywgc2Nyb2xsU2l6ZTogJ3Njcm9sbEhlaWdodCdcbiAgICAgICAgfSxcbiAgICAgICAgaDogeyAvLyBIb3Jpem9udGFsXG4gICAgICAgICAgICB4OiAnWCcsIHBvczogJ2xlZnQnLCBjcm9zc1BvczogJ3RvcCcsIHNpemU6ICd3aWR0aCcsIGNyb3NzU2l6ZTogJ2hlaWdodCcsXG4gICAgICAgICAgICBjbGllbnQ6ICdjbGllbnRXaWR0aCcsIGNyb3NzQ2xpZW50OiAnY2xpZW50SGVpZ2h0Jywgb2Zmc2V0OiAnb2Zmc2V0V2lkdGgnLCBjcm9zc09mZnNldDogJ29mZnNldEhlaWdodCcsIG9mZnNldFBvczogJ29mZnNldExlZnQnLFxuICAgICAgICAgICAgc2Nyb2xsOiAnc2Nyb2xsTGVmdCcsIHNjcm9sbFNpemU6ICdzY3JvbGxXaWR0aCdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvcikge1xuICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IHdpbmRvdykgb2JqID0gW29ial07XG5cbiAgICAgICAgd2hpbGUgKG9ialtpXSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbCh0aGlzLCBvYmpbaV0sIGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJhcm9uID0gZnVuY3Rpb24ocGFyYW1zKSB7IC8vIHRoaXMgLSB3aW5kb3cgb3IgalF1ZXJ5IGluc3RhbmNlXG4gICAgICAgIHZhciBqUXVlcnlNb2RlID0gZmFsc2UsLy8odGhpcyAmJiB0aGlzWzBdICYmIHRoaXNbMF0ubm9kZVR5cGUpLFxuICAgICAgICAgICAgcm9vdHMsXG4gICAgICAgICAgICAkO1xuXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgJCA9IHBhcmFtcy4kIHx8IHdpbmRvdy5qUXVlcnk7XG5cbiAgICAgICAgaWYgKGpRdWVyeU1vZGUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5yb290ID0gcm9vdHMgPSB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdHMgPSAkKHBhcmFtcy5yb290IHx8IHBhcmFtcy5zY3JvbGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IGJhcm9uLmZuLmNvbnN0cnVjdG9yKHJvb3RzLCBwYXJhbXMsICQpO1xuICAgIH07XG5cbiAgICBiYXJvbi5mbiA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHJvb3RzLCBpbnB1dCwgJCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHZhbGlkYXRlKGlucHV0KTtcblxuICAgICAgICAgICAgcGFyYW1zLiQgPSAkO1xuICAgICAgICAgICAgZWFjaC5jYWxsKHRoaXMsIHJvb3RzLCBmdW5jdGlvbihyb290LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFyYW1zID0gY2xvbmUocGFyYW1zKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMucm9vdCAmJiBwYXJhbXMuc2Nyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSBwYXJhbXMuJChwYXJhbXMuc2Nyb2xsZXIsIHJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsUGFyYW1zLnNjcm9sbGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSByb290O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQYXJhbXMuc2Nyb2xsZXIgPSByb290O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxvY2FsUGFyYW1zLnJvb3QgPSByb290O1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBpbml0KGxvY2FsUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyYW1zO1xuXG4gICAgICAgICAgICBlYWNoKHRoaXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLmRpc3Bvc2UocGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXS51cGRhdGUuYXBwbHkodGhpc1tpXSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmFyb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zLnJvb3QgPSBbXTtcbiAgICAgICAgICAgIHBhcmFtcy5zY3JvbGxlciA9IHRoaXMucGFyYW1zLnNjcm9sbGVyO1xuXG4gICAgICAgICAgICBlYWNoLmNhbGwodGhpcywgdGhpcywgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5yb290LnB1c2goZWxlbS5yb290KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zLmRpcmVjdGlvbiA9ICh0aGlzLnBhcmFtcy5kaXJlY3Rpb24gPT0gJ3YnKSA/ICdoJyA6ICd2JztcbiAgICAgICAgICAgIHBhcmFtcy5fY2hhaW4gPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gYmFyb24ocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYW5hZ2VFdmVudHMoaXRlbSwgZXZlbnRNYW5hZ2VyLCBtb2RlKSB7XG4gICAgICAgIGl0ZW0uX2V2ZW50SGFuZGxlcnMgPSBpdGVtLl9ldmVudEhhbmRsZXJzIHx8IFsgLy8gQ3JlYXRpbmcgbmV3IGZ1bmN0aW9ucyBmb3Igb25lIGJhcm9uIGl0ZW0gb25seSBvbmUgdGltZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIG9uU2Nyb2xsOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0uc2Nyb2xsZXIsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2Nyb2xsKGUpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnc2Nyb2xsJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIC8vIG9uTW91c2VEb3duOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0uYmFyLFxuXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyAvLyBUZXh0IHNlbGVjdGlvbiBkaXNhYmxpbmcgaW4gT3BlcmEuLi4gYW5kIGFsbCBvdGhlciBicm93c2Vycz9cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZWxlY3Rpb24oKTsgLy8gRGlzYWJsZSB0ZXh0IHNlbGVjdGlvbiBpbiBpZThcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kcmFnLm5vdyA9IDE7IC8vIFNhdmUgcHJpdmF0ZSBieXRlXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0IG1vdXNlZG93bidcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbk1vdXNlVXA6XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZG9jdW1lbnQsXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZWxlY3Rpb24oMSk7IC8vIEVuYWJsZSB0ZXh0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRyYWcubm93ID0gMDtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNldXAgYmx1ciB0b3VjaGVuZCdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbkNvb3JkaW5hdGVSZXNldDpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBpdGVtLmJhcixcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYnV0dG9uICE9IDIpIHsgLy8gTm90IFJNXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9wb3MwKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0IG1vdXNlZG93bidcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvbk1vdXNlTW92ZTpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudCxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZHJhZy5ub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZHJhZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vtb3ZlIHRvdWNobW92ZSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBvblJlc2l6ZTpcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB3aW5kb3csXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jlc2l6ZSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBzaXplQ2hhbmdlOlxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGl0ZW0ucm9vdCxcblxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB0eXBlOiAnc2l6ZUNoYW5nZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICBlYWNoKGl0ZW0uX2V2ZW50SGFuZGxlcnMsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlcihldmVudC5lbGVtZW50LCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgKGl0ZW0uc2Nyb2xsZXIpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0uc2Nyb2xsZXIsICdzY3JvbGwnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uU2Nyb2xsLCBtb2RlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoaXRlbS5iYXIpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0uYmFyLCAndG91Y2hzdGFydCBtb3VzZWRvd24nLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uTW91c2VEb3duLCBtb2RlKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBldmVudChkb2N1bWVudCwgJ21vdXNldXAgYmx1ciB0b3VjaGVuZCcsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25Nb3VzZVVwLCBtb2RlKTtcbiAgICAgICAgLy8gZXZlbnQoZG9jdW1lbnQsICd0b3VjaHN0YXJ0IG1vdXNlZG93bicsIGl0ZW0uX2V2ZW50SGFuZGxlcnMub25Db29yZGluYXRlUmVzZXQsIG1vZGUpO1xuICAgICAgICAvLyBldmVudChkb2N1bWVudCwgJ21vdXNlbW92ZSB0b3VjaG1vdmUnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uTW91c2VNb3ZlLCBtb2RlKTtcbiAgICAgICAgLy8gZXZlbnQod2luZG93LCAncmVzaXplJywgaXRlbS5fZXZlbnRIYW5kbGVycy5vblJlc2l6ZSwgbW9kZSk7XG4gICAgICAgIC8vIGlmIChpdGVtLnJvb3QpIHtcbiAgICAgICAgLy8gICAgIGV2ZW50KGl0ZW0ucm9vdCwgJ3NpemVDaGFuZ2UnLCBpdGVtLl9ldmVudEhhbmRsZXJzLm9uUmVzaXplLCBtb2RlKTsgLy8gQ3VzdG9uIGV2ZW50IGZvciBhbHRlcm5hdGUgYmFyb24gdXBkYXRlIG1lY2hhbmlzbVxuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFuYWdlQXR0cihub2RlLCBkaXJlY3Rpb24sIG1vZGUpIHtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gJ2RhdGEtYmFyb24tJyArIGRpcmVjdGlvbjtcblxuICAgICAgICBpZiAobW9kZSA9PSAnb24nKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgJ2luaXRlZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gJ29mZicpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KHBhcmFtcykge1xuICAgICAgICBpZiAobWFuYWdlQXR0cihwYXJhbXMucm9vdCwgcGFyYW1zLmRpcmVjdGlvbikpIHJldHVybjtcblxuICAgICAgICB2YXIgb3V0ID0gbmV3IGl0ZW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yKHBhcmFtcyk7IC8vIF9fcHJvdG9fXyBvZiByZXR1cm5pbmcgb2JqZWN0IGlzIGJhcm9uLnByb3RvdHlwZVxuXG4gICAgICAgIG1hbmFnZUV2ZW50cyhvdXQsIHBhcmFtcy5ldmVudCwgJ29uJyk7XG5cbiAgICAgICAgbWFuYWdlQXR0cihvdXQucm9vdCwgcGFyYW1zLmRpcmVjdGlvbiwgJ29uJyk7XG5cbiAgICAgICAgb3V0LnVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHt9O1xuXG4gICAgICAgIGlucHV0ID0gaW5wdXQgfHwge307XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGNsb25lKGlucHV0KTtcblxuICAgICAgICBvdXRwdXQuZGlyZWN0aW9uID0gb3V0cHV0LmRpcmVjdGlvbiB8fCAndic7XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gaW5wdXQuZXZlbnQgfHwgZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIG1vZGUpIHtcbiAgICAgICAgICAgIG91dHB1dC4kKGVsZW0pW21vZGUgfHwgJ29uJ10oZXZlbnQsIGZ1bmMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG91dHB1dC5ldmVudCA9IGZ1bmN0aW9uKGVsZW1zLCBlLCBmdW5jLCBtb2RlKSB7XG4gICAgICAgICAgICBlYWNoKGVsZW1zLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQoZWxlbSwgZSwgZnVuYywgbW9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lKSB7XG4gICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBpZiAodGhpcy5ldmVudHMgJiYgdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV1baV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXRlbSA9IHt9O1xuXG4gICAgaXRlbS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciAkLFxuICAgICAgICAgICAgICAgIGJhclBvcyxcbiAgICAgICAgICAgICAgICBzY3JvbGxlclBvczAsXG4gICAgICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICAgICAgcmVzaXplUGF1c2VUaW1lcixcbiAgICAgICAgICAgICAgICBzY3JvbGxQYXVzZVRpbWVyLFxuICAgICAgICAgICAgICAgIHBhdXNlLFxuICAgICAgICAgICAgICAgIHNjcm9sbExhc3RGaXJlLFxuICAgICAgICAgICAgICAgIHJlc2l6ZUxhc3RGaXJlO1xuXG4gICAgICAgICAgICByZXNpemVMYXN0RmlyZSA9IHNjcm9sbExhc3RGaXJlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgICQgPSB0aGlzLiQgPSBwYXJhbXMuJDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBwYXJhbXMuZXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXROb2RlKHNlbCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHNlbCwgY29udGV4dClbMF07IC8vIENhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBwYXJhbXMucm9vdDsgLy8gQWx3YXlzIGh0bWwgbm9kZSwgbm90IGp1c3Qgc2VsZWN0b3JcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIgPSBnZXROb2RlKHBhcmFtcy5zY3JvbGxlcik7IC8vIChwYXJhbXMuc2Nyb2xsZXIpID8gZ2V0Tm9kZShwYXJhbXMuc2Nyb2xsZXIsIHRoaXMucm9vdCkgOiB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB0aGlzLmJhciA9IGdldE5vZGUocGFyYW1zLmJhciwgdGhpcy5yb290KTtcbiAgICAgICAgICAgIHRyYWNrID0gdGhpcy50cmFjayA9IGdldE5vZGUocGFyYW1zLnRyYWNrLCB0aGlzLnJvb3QpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYWNrICYmIHRoaXMuYmFyKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSB0aGlzLmJhci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGlwcGVyID0gdGhpcy5zY3JvbGxlci5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHBhcmFtcy5kaXJlY3Rpb247XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IG9yaWdpblt0aGlzLmRpcmVjdGlvbl07XG4gICAgICAgICAgICB0aGlzLmJhck9uQ2xzID0gcGFyYW1zLmJhck9uQ2xzO1xuICAgICAgICAgICAgdGhpcy5iYXJUb3BMaW1pdCA9IDA7XG4gICAgICAgICAgICBwYXVzZSA9IHBhcmFtcy5wYXVzZSAqIDEwMDAgfHwgMDtcblxuICAgICAgICAgICAgLy8gVXBkYXRpbmcgaGVpZ2h0IG9yIHdpZHRoIG9mIGJhclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0QmFyU2l6ZShzaXplKSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgdmFyIGJhck1pblNpemUgPSB0aGlzLmJhck1pblNpemUgfHwgMjA7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSA8IGJhck1pblNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IGJhck1pblNpemU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5iYXIpLmNzcyh0aGlzLm9yaWdpbi5zaXplLCBwYXJzZUludChzaXplLCAxMCkgKyAncHgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHRvcCBvciBsZWZ0IGJhciBwb3NpdGlvblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9zQmFyKHBvcykge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhcikge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuYmFyKS5jc3ModGhpcy5vcmlnaW4ucG9zLCArcG9zICsgJ3B4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGcmVlIHBhdGggZm9yIGJhclxuICAgICAgICAgICAgZnVuY3Rpb24gaygpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2tbdGhpcy5vcmlnaW4uY2xpZW50XSAtIHRoaXMuYmFyVG9wTGltaXQgLSB0aGlzLmJhclt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWxhdGl2ZSBjb250ZW50IHRvcCBwb3NpdGlvbiB0byBiYXIgdG9wIHBvc2l0aW9uXG4gICAgICAgICAgICBmdW5jdGlvbiByZWxUb1BvcyhyKSB7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgKiBrLmNhbGwodGhpcykgKyB0aGlzLmJhclRvcExpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCYXIgcG9zaXRpb24gdG8gcmVsYXRpdmUgY29udGVudCBwb3NpdGlvblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9zVG9SZWwodCkge1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAodCAtIHRoaXMuYmFyVG9wTGltaXQpIC8gay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDdXJzb3IgcG9zaXRpb24gaW4gbWFpbiBkaXJlY3Rpb24gaW4gcHggLy8gTm93IHdpdGggaU9zIHN1cHBvcnRcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlWydjbGllbnQnICsgdGhpcy5vcmlnaW4ueF0gfHwgKCgoZS5vcmlnaW5hbEV2ZW50IHx8IGUpLnRvdWNoZXMgfHwge30pWzBdIHx8IHt9KVsncGFnZScgKyB0aGlzLm9yaWdpbi54XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRleHQgc2VsZWN0aW9uIHBvcyBwcmV2ZW50aW5nXG4gICAgICAgICAgICBmdW5jdGlvbiBkb250UG9zU2VsZWN0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5wb3MgPSBmdW5jdGlvbih4KSB7IC8vIEFic29sdXRlIHNjcm9sbGVyIHBvc2l0aW9uIGluIHB4XG4gICAgICAgICAgICAgICAgdmFyIGllID0gJ3BhZ2UnICsgdGhpcy5vcmlnaW4ueCArICdPZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICBrZXkgPSAodGhpcy5zY3JvbGxlcltpZV0pID8gaWUgOiB0aGlzLm9yaWdpbi5zY3JvbGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKSB0aGlzLnNjcm9sbGVyW2tleV0gPSB4O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsZXJba2V5XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucnBvcyA9IGZ1bmN0aW9uKHIpIHsgLy8gUmVsYXRpdmUgc2Nyb2xsZXIgcG9zaXRpb24gKDAuLjEpXG4gICAgICAgICAgICAgICAgdmFyIGZyZWUgPSB0aGlzLnNjcm9sbGVyW3RoaXMub3JpZ2luLnNjcm9sbFNpemVdIC0gdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdLFxuICAgICAgICAgICAgICAgICAgICB4O1xuXG4gICAgICAgICAgICAgICAgaWYgKHIpIHggPSB0aGlzLnBvcyhyICogZnJlZSk7XG4gICAgICAgICAgICAgICAgZWxzZSB4ID0gdGhpcy5wb3MoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB4IC8gKGZyZWUgfHwgMSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTd2l0Y2ggb24gdGhlIGJhciBieSBhZGRpbmcgdXNlci1kZWZpbmVkIENTUyBjbGFzc25hbWUgdG8gc2Nyb2xsZXJcbiAgICAgICAgICAgIHRoaXMuYmFyT24gPSBmdW5jdGlvbihkaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFyT25DbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2UgfHwgdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5jbGllbnRdID49IHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uc2Nyb2xsU2l6ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5yb290KS5yZW1vdmVDbGFzcyh0aGlzLmJhck9uQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcy5yb290KS5hZGRDbGFzcyh0aGlzLmJhck9uQ2xzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX3BvczAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJQb3MwID0gdGhpcy5jdXJzb3IoZSkgLSBiYXJQb3M7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmRyYWcgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5zY3JvbGxdID0gcG9zVG9SZWwuY2FsbCh0aGlzLCB0aGlzLmN1cnNvcihlKSAtIHNjcm9sbGVyUG9zMCkgKiAodGhpcy5zY3JvbGxlclt0aGlzLm9yaWdpbi5zY3JvbGxTaXplXSAtIHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uY2xpZW50XSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBUZXh0IHNlbGVjdGlvbiBwcmV2ZW50aW5nIG9uIGRyYWdcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudChkb2N1bWVudCwgJ3NlbGVjdHBvcyBzZWxlY3RzdGFydCcsIGRvbnRQb3NTZWxlY3QsIGVuYWJsZSA/ICdvZmYnIDogJ29uJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBvblJlc2l6ZSAmIERPTSBtb2RpZmllZCBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gcmVzaXplTGFzdEZpcmUgPCBwYXVzZSkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplUGF1c2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGF1c2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNyb3NzT2Zmc2V0XSAtIHNlbGYuc2Nyb2xsZXJbc2VsZi5vcmlnaW4uY3Jvc3NDbGllbnRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZnJlZXplICYmICFzZWxmLmNsaXBwZXIuc3R5bGVbc2VsZi5vcmlnaW4uY3Jvc3NTaXplXSkgeyAvLyBTb3VsZCBmaXJlIG9ubHkgb25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgJChzZWxmLmNsaXBwZXIpLmNzcyhzZWxmLm9yaWdpbi5jcm9zc1NpemUsIHNlbGYuY2xpcHBlcltzZWxmLm9yaWdpbi5jcm9zc0NsaWVudF0gLSBkZWx0YSArICdweCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5zY3JvbGxlcikuY3NzKHNlbGYub3JpZ2luLmNyb3NzU2l6ZSwgc2VsZi5jbGlwcGVyW3NlbGYub3JpZ2luLmNyb3NzQ2xpZW50XSArIGRlbHRhICsgJ3B4Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbChhcmd1bWVudHMsICdyZXNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZUxhc3RGaXJlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZVBhdXNlVGltZXIgPSBzZXRUaW1lb3V0KHVwZCwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG9uU2Nyb2xsIGhhbmRsZXJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEJhclNpemUsIG5ld0JhclNpemUsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzY3JvbGxMYXN0RmlyZSA8IHBhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxQYXVzZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBwYXVzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QmFyU2l6ZSA9ICh0cmFja1tzZWxmLm9yaWdpbi5jbGllbnRdIC0gc2VsZi5iYXJUb3BMaW1pdCkgKiBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLmNsaWVudF0gLyBzZWxmLnNjcm9sbGVyW3NlbGYub3JpZ2luLnNjcm9sbFNpemVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbmluZyBiYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRCYXJTaXplICE9IG5ld0JhclNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRCYXJTaXplLmNhbGwoc2VsZiwgbmV3QmFyU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQmFyU2l6ZSA9IG5ld0JhclNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJhclBvcyA9IHJlbFRvUG9zLmNhbGwoc2VsZiwgc2VsZi5ycG9zKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NCYXIuY2FsbChzZWxmLCBiYXJQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbCggYXJndW1lbnRzLCAnc2Nyb2xsJyApO1xuICAgICAgICAgICAgICAgICAgICBmaXJlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGFzdEZpcmUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsUGF1c2VUaW1lciA9IHNldFRpbWVvdXQodXBkLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAgICAgZmlyZS5jYWxsKHRoaXMsICd1cGQnLCBwYXJhbXMpOyAvLyDQntCx0L3QvtCy0LvRj9C10Lwg0L/QsNGA0LDQvNC10YLRgNGLINCy0YHQtdGFINC/0LvQsNCz0LjQvdC+0LJcblxuICAgICAgICAgICAgdGhpcy5yZXNpemUoMSk7XG4gICAgICAgICAgICB0aGlzLmJhck9uKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIG1hbmFnZUV2ZW50cyh0aGlzLCB0aGlzLmV2ZW50LCAnb2ZmJyk7XG4gICAgICAgICAgICBtYW5hZ2VBdHRyKHRoaXMucm9vdCwgcGFyYW1zLmRpcmVjdGlvbiwgJ29mZicpO1xuICAgICAgICAgICAgJCh0aGlzLnNjcm9sbGVyKS5jc3ModGhpcy5vcmlnaW4uY3Jvc3NTaXplLCAnJyk7XG4gICAgICAgICAgICB0aGlzLmJhck9uKHRydWUpO1xuICAgICAgICAgICAgZmlyZS5jYWxsKHRoaXMsICdkaXNwb3NlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZnVuYywgYXJnKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBldmVudE5hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbmFtZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzW2ldID09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgYXJnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1tuYW1lc1tpXV0gPSB0aGlzLmV2ZW50c1tuYW1lc1tpXV0gfHwgW107XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbbmFtZXNbaV1dLnB1c2goZnVuY3Rpb24odXNlckFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHVzZXJBcmcgfHwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGJhcm9uLmZuLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGJhcm9uLmZuO1xuICAgIGl0ZW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGl0ZW0ucHJvdG90eXBlO1xuXG4gICAgLy8gVXNlIHdoZW4geW91IG5lZWQgXCJiYXJvblwiIGdsb2JhbCB2YXIgZm9yIGFub3RoZXIgcHVycG9zZXNcbiAgICBiYXJvbi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5iYXJvbiA9IF9iYXJvbjsgLy8gUmVzdG9yaW5nIG9yaWdpbmFsIHZhbHVlIG9mIFwiYmFyb25cIiBnbG9iYWwgdmFyXG4gICAgICAgIHJldHVybiBiYXJvbjtcbiAgICB9O1xuXG4gICAgYmFyb24udmVyc2lvbiA9ICcwLjYuNic7XG5cbiAgICBpZiAoJCAmJiAkLmZuKSB7IC8vIEFkZGluZyBiYXJvbiB0byBqUXVlcnkgYXMgcGx1Z2luXG4gICAgICAgICQuZm4uYmFyb24gPSBiYXJvbjtcbiAgICB9XG4gICAgd2luZG93LmJhcm9uID0gYmFyb247IC8vIFVzZSBub0NvbmZsaWN0IG1ldGhvZCBpZiB5b3UgbmVlZCB3aW5kb3cuYmFyb24gdmFyIGZvciBhbm90aGVyIHB1cnBvc2VzXG5cbiAgICB2YXIgZml4ID0gZnVuY3Rpb24odXNlclBhcmFtcykge1xuICAgICAgICB2YXIgZWxlbWVudHMsIHZpZXdQb3J0U2l6ZSxcbiAgICAgICAgICAgIHBhcmFtcyA9IHsgLy8gRGVmYXVsdCBwYXJhbXNcbiAgICAgICAgICAgICAgICBvdXRzaWRlOiAnJyxcbiAgICAgICAgICAgICAgICBiZWZvcmU6ICcnLFxuICAgICAgICAgICAgICAgIGFmdGVyOiAnJyxcbiAgICAgICAgICAgICAgICBwYXN0OiAnJyxcbiAgICAgICAgICAgICAgICBmdXR1cmU6ICcnLFxuICAgICAgICAgICAgICAgIHJhZGl1czogMCxcbiAgICAgICAgICAgICAgICBtaW5WaWV3OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9wRml4SGVpZ2h0cyA9IFtdLCAvLyBpbmxpbmUgc3R5bGUgZm9yIGVsZW1lbnRcbiAgICAgICAgICAgIHRvcFJlYWxIZWlnaHRzID0gW10sIC8vIHJlYWwgb2Zmc2V0IHBvc2l0aW9uIHdoZW4gbm90IGZpeGVkXG4gICAgICAgICAgICBoZWFkZXJUb3BzID0gW10sXG4gICAgICAgICAgICBzY3JvbGxlciA9IHRoaXMuc2Nyb2xsZXIsXG4gICAgICAgICAgICBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgJCA9IHRoaXMuJCxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpeEVsZW1lbnQoaSwgcG9zKSB7XG4gICAgICAgICAgICBpZiAodmlld1BvcnRTaXplIDwgKHBhcmFtcy5taW5WaWV3IHx8IDApKSB7IC8vIE5vIGhlYWRlcnMgZml4aW5nIHdoZW4gbm8gZW5vdWdodCBzcGFjZSBmb3Igdmlld3BvcnRcbiAgICAgICAgICAgICAgICBwb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBvcyArPSAncHgnO1xuICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuY3NzKHRoaXMub3JpZ2luLnBvcywgcG9zKS5hZGRDbGFzcyhwYXJhbXMub3V0c2lkZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuY3NzKHRoaXMub3JpZ2luLnBvcywgJycpLnJlbW92ZUNsYXNzKHBhcmFtcy5vdXRzaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGJ1YmJsZVdoZWVsKGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdXaGVlbEV2ZW50Jyk7IC8vIGkgLSBmb3IgZXh0cmEgYnl0ZVxuICAgICAgICAgICAgICAgIC8vIGV2dC5pbml0V2ViS2l0V2hlZWxFdmVudChkZWx0YVgsIGRlbHRhWSwgd2luZG93LCBzY3JlZW5YLCBzY3JlZW5ZLCBjbGllbnRYLCBjbGllbnRZLCBjdHJsS2V5LCBhbHRLZXksIHNoaWZ0S2V5LCBtZXRhS2V5KTtcbiAgICAgICAgICAgICAgICBpLmluaXRXZWJLaXRXaGVlbEV2ZW50KGUub3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCwgZS5vcmlnaW5hbEV2ZW50LndoZWVsRGVsdGFZKTtcbiAgICAgICAgICAgICAgICBzY3JvbGxlci5kaXNwYXRjaEV2ZW50KGkpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0KF9wYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBwb3M7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSBfcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnRzID0gdGhpcy4kKHBhcmFtcy5lbGVtZW50cywgdGhpcy5zY3JvbGxlcik7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHZpZXdQb3J0U2l6ZSA9IHRoaXMuc2Nyb2xsZXJbdGhpcy5vcmlnaW4uY2xpZW50XTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBlbGVtZW50cy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFyaWFibGUgaGVhZGVyIGhlaWdodHNcbiAgICAgICAgICAgICAgICAgICAgcG9zID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvc1t0aGlzLm9yaWdpbi5zaXplXSA9IGVsZW1lbnRzW2ldW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1tpXS5wYXJlbnROb2RlICE9PSB0aGlzLnNjcm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0ucGFyZW50Tm9kZSkuY3NzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvc1t0aGlzLm9yaWdpbi5jcm9zc1NpemVdID0gZWxlbWVudHNbaV0ucGFyZW50Tm9kZVt0aGlzLm9yaWdpbi5jcm9zc0NsaWVudF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuY3NzKHBvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmV0d2VlbiBmaXhlZCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIHZpZXdQb3J0U2l6ZSAtPSBlbGVtZW50c1tpXVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlclRvcHNbaV0gPSBlbGVtZW50c1tpXS5wYXJlbnROb2RlW3RoaXMub3JpZ2luLm9mZnNldFBvc107IC8vIE5vIHBhZGRpbmdzIGZvciBwYXJlbnROb2RlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VtbWFyeSBlbGVtZW50cyBoZWlnaHQgYWJvdmUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICB0b3BGaXhIZWlnaHRzW2ldID0gKHRvcEZpeEhlaWdodHNbaSAtIDFdIHx8IDApOyAvLyBOb3QgemVybyBiZWNhdXNlIG9mIG5lZ2F0aXZlIG1hcmdpbnNcbiAgICAgICAgICAgICAgICAgICAgdG9wUmVhbEhlaWdodHNbaV0gPSAodG9wUmVhbEhlaWdodHNbaSAtIDFdIHx8IE1hdGgubWluKGhlYWRlclRvcHNbaV0sIDApKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BGaXhIZWlnaHRzW2ldICs9IGVsZW1lbnRzW2kgLSAxXVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wUmVhbEhlaWdodHNbaV0gKz0gZWxlbWVudHNbaSAtIDFdW3RoaXMub3JpZ2luLm9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoICEoaSA9PSAwICYmIGhlYWRlclRvcHNbaV0gPT0gMCkvKiAmJiBmb3JjZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudChlbGVtZW50c1tpXSwgJ21vdXNld2hlZWwnLCBidWJibGVXaGVlbCwgJ29mZicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudChlbGVtZW50c1tpXSwgJ21vdXNld2hlZWwnLCBidWJibGVXaGVlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxpbWl0ZXIgJiYgZWxlbWVudHNbMF0pIHsgLy8gQm90dG9tIGVkZ2Ugb2YgZmlyc3QgaGVhZGVyIGFzIHRvcCBsaW1pdCBmb3IgdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2sgJiYgdGhpcy50cmFjayAhPSB0aGlzLnNjcm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc1t0aGlzLm9yaWdpbi5wb3NdID0gZWxlbWVudHNbMF0ucGFyZW50Tm9kZVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kKHRoaXMudHJhY2spLmNzcyhwb3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXJUb3BMaW1pdCA9IGVsZW1lbnRzWzBdLnBhcmVudE5vZGVbdGhpcy5vcmlnaW4ub2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmJhclRvcExpbWl0ID0gZWxlbWVudHNbMF0ucGFyZW50Tm9kZVt0aGlzLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGltaXRlciA9PT0gZmFsc2UpIHsgLy8gdW5kZWZpbmVkIChpbiBzZWNvbmQgZml4IGluc3RhbmNlKSBzaG91bGQgaGF2ZSBubyBpbmZsdWVuY2Ugb24gYmFyIGxpbWl0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFyVG9wTGltaXQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRzLFxuXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAkKHRoaXMpWzBdLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBwYXJlbnQub2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmRpbmcgbnVtIC0+IGVsZW1lbnRzW251bV0gPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZWxlbWVudHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2ldID09PSB0aGlzKSBudW0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRvcCAtIHRvcEZpeEhlaWdodHNbbnVtXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnNjcm9sbCkgeyAvLyBVc2VyIGRlZmluZWQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zY3JvbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxOiBzZWxmLnNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MjogcG9zXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHR5cGU6ICdjbGljaydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVycy5wdXNoKGV2ZW50KTsgLy8gRm9yIGF1dG8tZGlzcG9zZVxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlcihldmVudC5lbGVtZW50LCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCAnb2ZmJyk7XG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyKGV2ZW50LmVsZW1lbnQsIGV2ZW50LnR5cGUsIGV2ZW50LmhhbmRsZXIsICdvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbignaW5pdCcsIGluaXQsIHVzZXJQYXJhbXMpO1xuXG4gICAgICAgIHRoaXMub24oJ2luaXQgc2Nyb2xsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZml4U3RhdGUsIGhUb3AsXG4gICAgICAgICAgICAgICAgZml4RmxhZyA9IFtdOyAvLyAxIC0gcGFzdCwgMiAtIGZ1dHVyZSwgMyAtIGN1cnJlbnQgKG5vdCBmaXhlZClcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZTtcblxuICAgICAgICAgICAgICAgIC8vIGZpeEZsYWcgdXBkYXRlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZWxlbWVudHMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpeFN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlclRvcHNbaV0gLSB0aGlzLnBvcygpIDwgdG9wUmVhbEhlaWdodHNbaV0gKyBwYXJhbXMucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIZWFkZXIgdHJ5aW5nIHRvIGdvIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBoVG9wID0gdG9wRml4SGVpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJUb3BzW2ldIC0gdGhpcy5wb3MoKSA+IHRvcFJlYWxIZWlnaHRzW2ldICsgdmlld1BvcnRTaXplIC0gcGFyYW1zLnJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVhZGVyIHRyeWluZyB0byBnbyBkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhTdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBoVG9wID0gdG9wRml4SGVpZ2h0c1tpXSArIHZpZXdQb3J0U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlYWRlciBpbiB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgZml4U3RhdGUgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaFRvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZml4U3RhdGUgIT0gZml4RmxhZ1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZml4RWxlbWVudC5jYWxsKHRoaXMsIGksIGhUb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZml4RmxhZ1tpXSA9IGZpeFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZGluZyBwb3NpdGlvbmluZyBjbGFzc2VzIChvbiBsYXN0IHRvcCBhbmQgZmlyc3QgYm90dG9tIGhlYWRlcilcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlKSB7IC8vIEF0IGxlYXRzIG9uZSBjaGFuZ2UgaW4gZWxlbWVudHMgZmxhZyBzdHJ1Y3R1cmUgb2NjdXJlZFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IGVsZW1lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeEZsYWdbaV0gPT0gMSAmJiBwYXJhbXMucGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJChlbGVtZW50c1tpXSkuYWRkQ2xhc3MocGFyYW1zLnBhc3QpLnJlbW92ZUNsYXNzKHBhcmFtcy5mdXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4RmxhZ1tpXSA9PSAyICYmIHBhcmFtcy5mdXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLmFkZENsYXNzKHBhcmFtcy5mdXR1cmUpLnJlbW92ZUNsYXNzKHBhcmFtcy5wYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeEZsYWdbaV0gPT0gMyAmJiAocGFyYW1zLmZ1dHVyZSB8fCBwYXJhbXMucGFzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLnJlbW92ZUNsYXNzKHBhcmFtcy5wYXN0KS5yZW1vdmVDbGFzcyhwYXJhbXMuZnV0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeEZsYWdbaV0gIT0gZml4RmxhZ1tpICsgMV0gJiYgZml4RmxhZ1tpXSA9PSAxICYmIHBhcmFtcy5iZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLmFkZENsYXNzKHBhcmFtcy5iZWZvcmUpLnJlbW92ZUNsYXNzKHBhcmFtcy5hZnRlcik7IC8vIExhc3QgdG9wIGZpeGVkIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaXhGbGFnW2ldICE9IGZpeEZsYWdbaSAtIDFdICYmIGZpeEZsYWdbaV0gPT0gMiAmJiBwYXJhbXMuYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQoZWxlbWVudHNbaV0pLmFkZENsYXNzKHBhcmFtcy5hZnRlcikucmVtb3ZlQ2xhc3MocGFyYW1zLmJlZm9yZSk7IC8vIEZpcnN0IGJvdHRvbSBmaXhlZCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kKGVsZW1lbnRzW2ldKS5yZW1vdmVDbGFzcyhwYXJhbXMuYmVmb3JlKS5yZW1vdmVDbGFzcyhwYXJhbXMuYWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uKCdyZXNpemUgdXBkJywgZnVuY3Rpb24odXBkUGFyYW1zKSB7XG4gICAgICAgICAgICBpbml0LmNhbGwodGhpcywgdXBkUGFyYW1zICYmIHVwZFBhcmFtcy5maXgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYmFyb24uZm4uZml4ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgZml4LmNhbGwodGhpc1tpXSwgcGFyYW1zKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgY29udHJvbHMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGZvcndhcmQsIGJhY2t3YXJkLCB0cmFjaywgc2NyZWVuLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7IC8vIEFBQUFBQSEhISEhMTFcblxuICAgICAgICBzY3JlZW4gPSBwYXJhbXMuc2NyZWVuIHx8IDAuOTtcblxuICAgICAgICBpZiAocGFyYW1zLmZvcndhcmQpIHtcbiAgICAgICAgICAgIGZvcndhcmQgPSB0aGlzLiQocGFyYW1zLmZvcndhcmQsIHRoaXMuY2xpcHBlcik7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnQoZm9yd2FyZCwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzZWxmLnBvcygpIC0gcGFyYW1zLmRlbHRhIHx8IDMwO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wb3MoeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuYmFja3dhcmQpIHtcbiAgICAgICAgICAgIGJhY2t3YXJkID0gdGhpcy4kKHBhcmFtcy5iYWNrd2FyZCwgdGhpcy5jbGlwcGVyKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudChiYWNrd2FyZCwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBzZWxmLnBvcygpICsgcGFyYW1zLmRlbHRhIHx8IDMwO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5wb3MoeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMudHJhY2spIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudHJhY2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0cmFjayA9IHRoaXMudHJhY2s7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNrID0gdGhpcy4kKHBhcmFtcy50cmFjaywgdGhpcy5jbGlwcGVyKVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCh0cmFjaywgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBlWydvZmZzZXQnICsgc2VsZi5vcmlnaW4ueF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4QmFyID0gc2VsZi5iYXJbc2VsZi5vcmlnaW4ub2Zmc2V0UG9zXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgeEJhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHggPiB4QmFyICsgc2VsZi5iYXJbc2VsZi5vcmlnaW4ub2Zmc2V0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHNlbGYucG9zKCkgKyBzaWduICogc2NyZWVuICogc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5jbGllbnRdO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBvcyh5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIGJhcm9uLmZuLmNvbnRyb2xzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgY29udHJvbHMuY2FsbCh0aGlzW2ldLCBwYXJhbXMpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHZhciBwdWxsID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBibG9jayA9IHRoaXMuJChwYXJhbXMuYmxvY2spLFxuICAgICAgICAgICAgc2l6ZSA9IHBhcmFtcy5zaXplIHx8IHRoaXMub3JpZ2luLnNpemUsXG4gICAgICAgICAgICBsaW1pdCA9IHBhcmFtcy5saW1pdCB8fCA4MCxcbiAgICAgICAgICAgIG9uRXhwYW5kID0gcGFyYW1zLm9uRXhwYW5kLFxuICAgICAgICAgICAgZWxlbWVudHMgPSBwYXJhbXMuZWxlbWVudHMgfHwgW10sXG4gICAgICAgICAgICBpblByb2dyZXNzID0gcGFyYW1zLmluUHJvZ3Jlc3MgfHwgJycsXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIF9pbnNpc3RlbmNlID0gMCxcbiAgICAgICAgICAgIF96ZXJvWENvdW50ID0gMCxcbiAgICAgICAgICAgIF9pbnRlcnZhbCxcbiAgICAgICAgICAgIF90aW1lcixcbiAgICAgICAgICAgIF94ID0gMCxcbiAgICAgICAgICAgIF9vbkV4cGFuZENhbGxlZCxcbiAgICAgICAgICAgIF93YWl0aW5nID0gcGFyYW1zLndhaXRpbmcgfHwgNTAwLFxuICAgICAgICAgICAgX29uO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5zY3JvbGxdICsgc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5vZmZzZXRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2Nyb2xsZXIgY29udGVudCBoZWlnaHRcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGVudFNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5zY3JvbGxTaXplXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNjcm9sbGVyIGhlaWdodFxuICAgICAgICBmdW5jdGlvbiBnZXRTY3JvbGxlclNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zY3JvbGxlcltzZWxmLm9yaWdpbi5jbGllbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RlcCh4LCBmb3JjZSkge1xuICAgICAgICAgICAgdmFyIGsgPSB4ICogMC4wMDA1O1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihmb3JjZSAtIGsgKiAoeCArIDU1MCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlKG9uKSB7XG4gICAgICAgICAgICBfb24gPSBvbjtcblxuICAgICAgICAgICAgaWYgKG9uKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7IC8vIEZpcnN0IHRpbWUgd2l0aCBubyBkZWxheVxuICAgICAgICAgICAgICAgIF9pbnRlcnZhbCA9IHNldEludGVydmFsKHVwZGF0ZSwgMjAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHt9LFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGdldFNpemUoKSxcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBnZXRDb250ZW50U2l6ZSgpLFxuICAgICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICAgIG9wNCxcbiAgICAgICAgICAgICAgICBzY3JvbGxJblByb2dyZXNzID0gX2luc2lzdGVuY2UgPT0gMTtcblxuICAgICAgICAgICAgb3A0ID0gMDsgLy8g0JLQvtC30LLRgNCw0YnQsNGO0YnQsNGPINGB0LjQu9CwXG4gICAgICAgICAgICBpZiAoX2luc2lzdGVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3A0ID0gNDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIChfaW5zaXN0ZW5jZSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZHggPSBzdGVwKF94LCBvcDQpO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQgPj0gc2Nyb2xsSGVpZ2h0IC0gX3ggJiYgX2luc2lzdGVuY2UgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ggKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfeCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF94IDwgMCkgX3ggPSAwO1xuXG4gICAgICAgICAgICAgICAgcG9zW3NpemVdID0gX3ggKyAncHgnO1xuICAgICAgICAgICAgICAgIGlmIChnZXRTY3JvbGxlclNpemUoKSA8PSBnZXRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJChibG9jaykuY3NzKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGVsZW1lbnRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kKGVsZW1lbnRzW2ldLnNlbGYpLmNzcyhlbGVtZW50c1tpXS5wcm9wZXJ0eSwgTWF0aC5taW4oX3ggLyBsaW1pdCAqIDEwMCwgMTAwKSArICclJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5Qcm9ncmVzcyAmJiBfeCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiQoc2VsZi5yb290KS5hZGRDbGFzcyhpblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3ggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLm9uQ29sbGFwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5vbkNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfaW5zaXN0ZW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX2luc2lzdGVuY2UgPSAtMTtcbiAgICAgICAgICAgICAgICB9LCBfd2FpdGluZyk7XG4gICAgICAgICAgICAvL31cblxuICAgICAgICAgICAgaWYgKG9uRXhwYW5kICYmIF94ID4gbGltaXQgJiYgIV9vbkV4cGFuZENhbGxlZCkge1xuICAgICAgICAgICAgICAgIG9uRXhwYW5kKCk7XG4gICAgICAgICAgICAgICAgX29uRXhwYW5kQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF94ID09IDApIHtcbiAgICAgICAgICAgICAgICBfemVyb1hDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfemVyb1hDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfemVyb1hDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIF9vbkV4cGFuZENhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJChzZWxmLnJvb3QpLnJlbW92ZUNsYXNzKGluUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub24oJ2luaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRvZ2dsZSh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudCh0aGlzLnNjcm9sbGVyLCAnbW91c2V3aGVlbCBET01Nb3VzZVNjcm9sbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBkb3duID0gZS53aGVlbERlbHRhIDwgMCB8fCAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC53aGVlbERlbHRhIDwgMCkgfHwgZS5kZXRhaWwgPiAwO1xuXG4gICAgICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgICAgIF9pbnNpc3RlbmNlID0gMTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RpbWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9vbiAmJiBnZXRTaXplKCkgPj0gZ2V0Q29udGVudFNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIHRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBiYXJvbi5mbi5wdWxsID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgcHVsbC5jYWxsKHRoaXNbaV0sIHBhcmFtcyk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSkod2luZG93KTtcbiJdfQ==


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_MarkerDrawer__ = __webpack_require__(9);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_0__src_MarkerDrawer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_Atlas__ = __webpack_require__(7);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_1__src_Atlas__["a"]; });




/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GrowingPacker = __webpack_require__(3);

module.exports = function(items, options) {
	options = options || {};
	var packer = new GrowingPacker();
	var inPlace = options.inPlace || false;

	// Clone the items.
	var newItems = items.map(function(item) { return inPlace ? item : { width: item.width, height: item.height, item: item }; });

	newItems = newItems.sort(function(a, b) {
		// TODO: check that each actually HAS a width and a height.
		// Sort based on the size (area) of each block.
		return (b.width * b.height) - (a.width * a.height);
	});

	packer.fit(newItems);

	var w = newItems.reduce(function(curr, item) { return Math.max(curr, item.x + item.width); }, 0);
	var h = newItems.reduce(function(curr, item) { return Math.max(curr, item.y + item.height); }, 0);

	var ret = {
		width: w,
		height: h
	};

	if (!inPlace) {
		ret.items = newItems;
	}

	return ret;
};


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/******************************************************************************

This is a binary tree based bin packing algorithm that is more complex than
the simple Packer (packer.js). Instead of starting off with a fixed width and
height, it starts with the width and height of the first block passed and then
grows as necessary to accomodate each subsequent block. As it grows it attempts
to maintain a roughly square ratio by making 'smart' choices about whether to
grow right or down.

When growing, the algorithm can only grow to the right OR down. Therefore, if
the new block is BOTH wider and taller than the current target then it will be
rejected. This makes it very important to initialize with a sensible starting
width and height. If you are providing sorted input (largest first) then this
will not be an issue.

A potential way to solve this limitation would be to allow growth in BOTH
directions at once, but this requires maintaining a more complex tree
with 3 children (down, right and center) and that complexity can be avoided
by simply chosing a sensible starting block.

Best results occur when the input blocks are sorted by height, or even better
when sorted by max(width,height).

Inputs:
------

	blocks: array of any objects that have .w and .h attributes

Outputs:
-------

	marks each block that fits with a .fit attribute pointing to a
	node with .x and .y coordinates

Example:
-------

	var blocks = [
		{ w: 100, h: 100 },
		{ w: 100, h: 100 },
		{ w:  80, h:  80 },
		{ w:  80, h:  80 },
		etc
		etc
	];

	var packer = new GrowingPacker();
	packer.fit(blocks);

	for(var n = 0 ; n < blocks.length ; n++) {
		var block = blocks[n];
		if (block.fit) {
			Draw(block.fit.x, block.fit.y, block.w, block.h);
		}
	}


******************************************************************************/

var GrowingPacker = function() { };

GrowingPacker.prototype = {

	fit: function(blocks) {
		var n, node, block, len = blocks.length, fit;
		var width  = len > 0 ? blocks[0].width : 0;
		var height = len > 0 ? blocks[0].height : 0;
		this.root = { x: 0, y: 0, width: width, height: height };
		for (n = 0; n < len ; n++) {
			block = blocks[n];
			if (node = this.findNode(this.root, block.width, block.height)) {
				fit = this.splitNode(node, block.width, block.height);
				block.x = fit.x;
				block.y = fit.y;
			}
			else {
				fit = this.growNode(block.width, block.height);
				block.x = fit.x;
				block.y = fit.y;
			}
		}
	},

	findNode: function(root, width, height) {
		if (root.used)
			return this.findNode(root.right, width, height) || this.findNode(root.down, width, height);
		else if ((width <= root.width) && (height <= root.height))
			return root;
		else
			return null;
	},

	splitNode: function(node, width, height) {
		node.used = true;
		node.down  = { x: node.x,         y: node.y + height, width: node.width,         height: node.height - height };
		node.right = { x: node.x + width, y: node.y,          width: node.width - width, height: height               };
		return node;
	},

	growNode: function(width, height) {
		var canGrowDown  = (width  <= this.root.width);
		var canGrowRight = (height <= this.root.height);

		var shouldGrowRight = canGrowRight && (this.root.height >= (this.root.width  + width )); // attempt to keep square-ish by growing right when height is much greater than width
		var shouldGrowDown  = canGrowDown  && (this.root.width  >= (this.root.height + height)); // attempt to keep square-ish by growing down  when width  is much greater than height

		if (shouldGrowRight)
			return this.growRight(width, height);
		else if (shouldGrowDown)
			return this.growDown(width, height);
		else if (canGrowRight)
			return this.growRight(width, height);
		else if (canGrowDown)
			return this.growDown(width, height);
		else
			return null; // need to ensure sensible root starting size to avoid this happening
	},

	growRight: function(width, height) {
		this.root = {
			used: true,
			x: 0,
			y: 0,
			width: this.root.width + width,
			height: this.root.height,
			down: this.root,
			right: { x: this.root.width, y: 0, width: width, height: this.root.height }
		};
		var node;
		if (node = this.findNode(this.root, width, height))
			return this.splitNode(node, width, height);
		else
			return null;
	},

	growDown: function(width, height) {
		this.root = {
			used: true,
			x: 0,
			y: 0,
			width: this.root.width,
			height: this.root.height + height,
			down:  { x: 0, y: this.root.height, width: this.root.width, height: height },
			right: this.root
		};
		var node;
		if (node = this.findNode(this.root, width, height))
			return this.splitNode(node, width, height);
		else
			return null;
	}

};

module.exports = GrowingPacker;



/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = partialSort;

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

function partialSort(arr, k, left, right, compare) {
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            partialSort(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;

var quickselect = __webpack_require__(4);

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_2gis_maps__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_2gis_maps___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_2gis_maps__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src__ = __webpack_require__(1);


var map = window['map'] = __WEBPACK_IMPORTED_MODULE_0_2gis_maps__["map"]('map', {
    center: [54.980156831455, 82.897440725094],
    zoom: 15,
    geoclicker: true,
});
var random = (function () {
    var seed = 15;
    return function () {
        seed = seed * 16807 % 2147483647;
        return (seed - 1) / 2147483646;
    };
})();
map.on('click', function () {
    // tslint:disable-next-line
    console.log('map click');
});
map.poi.getMetaLayer().on('click', function () {
    // tslint:disable-next-line
    console.log('poi click');
});
var centerLngLat = [82.897440725094, 54.980156831455];
var markersData = [];
for (var i = 0; i < 5000; i++) {
    markersData.push({
        position: [
            centerLngLat[0] + (random() - 0.5) * 0.25,
            centerLngLat[1] + (random() - 0.5) * 0.1,
        ],
    });
}
markersData.push({
    position: centerLngLat,
});
var pin = new Image();
var pixelRatio = window.devicePixelRatio < 2 ? 1 : 2;
pin.src = 'demo/markers/' + pixelRatio + '/pin_regular.png';
var hoveredPin = new Image();
hoveredPin.src = 'demo/markers/' + pixelRatio + '/pin_regular_hover.png';
var atlas = new __WEBPACK_IMPORTED_MODULE_1__src__["a" /* Atlas */]([{
        image: pin,
        anchor: [0.5, 1],
        pixelDensity: pixelRatio,
    }, {
        image: hoveredPin,
        anchor: [0.5, 1],
        pixelDensity: pixelRatio,
    }]);
var markerDrawer = new __WEBPACK_IMPORTED_MODULE_1__src__["b" /* MarkerDrawer */](atlas, {
    bufferFactor: 0.5,
});
markerDrawer.setMarkers(markersData);
markerDrawer.on('click', function (ev) {
    // tslint:disable-next-line
    console.log('click', ev);
    ev.markers.forEach(function (index) {
        markersData[index].iconIndex = 1;
    });
    markerDrawer.update();
});
markerDrawer.addTo(map);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bin_pack__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bin_pack___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bin_pack__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Atlas; });

/**
 * The Atlas creates one image from a set of icons.
 * After creating holds information about positions of each icon in the image.
 */
var Atlas = (function () {
    function Atlas(icons) {
        var _this = this;
        this.sprites = [];
        this._promise = Promise.all(icons.map(function (icon) { return _this._imageLoad(icon.image); }))
            .then(function () { return _this._createSprite(icons); });
    }
    /**
     * Returns a promise that will be resolve after all images loading done
     */
    Atlas.prototype.whenReady = function () {
        return this._promise;
    };
    Atlas.prototype._imageLoad = function (image) {
        if (image.complete) {
            return Promise.resolve();
        }
        return new Promise(function (resolve) {
            image.addEventListener('load', resolve);
        });
    };
    Atlas.prototype._createSprite = function (icons) {
        var margin = 2;
        var arr = icons.map(function (icon) {
            var imageSize = [icon.image.width, icon.image.height];
            var size = icon.size || imageSize;
            return {
                // Data for bin-pack
                width: size[0] + margin * 2,
                height: size[1] + margin * 2,
                // Data that we need after bin-pack
                image: icon.image,
                anchor: icon.anchor || [0.5, 0.5],
                size: size,
                imageSize: imageSize,
                pixelDensity: icon.pixelDensity || 1,
            };
        });
        var packed = __WEBPACK_IMPORTED_MODULE_0_bin_pack__(arr, { inPlace: true });
        this.size = [packed.width, packed.height];
        // Sum margins that get texture coordinates without margins
        this.sprites = arr.map(function (icon) { return ({
            position: [icon.x + margin, icon.y + margin],
            size: icon.size,
            anchor: icon.anchor,
            pixelDensity: icon.pixelDensity,
        }); });
        var canvas = this.image = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        if (!ctx) {
            return;
        }
        canvas.width = packed.width;
        canvas.height = packed.height;
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        arr.forEach(function (icon) {
            ctx.drawImage(icon.image, 0, 0, icon.imageSize[0], icon.imageSize[1], icon.x + margin, icon.y + margin, icon.size[0], icon.size[1]);
        });
    };
    return Atlas;
}());



/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rbush__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rbush___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rbush__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(10);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CanvasRenderer; });


var CanvasRenderer = (function () {
    function CanvasRenderer(atlas, debugDrawing, bufferFactor) {
        var _this = this;
        this.update = function () {
            if (!_this._map) {
                return;
            }
            if (_this._isRendering || _this._isZooming) {
                _this._needUpdate = true;
                return;
            }
            _this._zoom = _this._map.getZoom();
            var center = _this._map.getCenter();
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* lngLatToZoomPoint */])(_this._origin, [center.lng, center.lat], _this._zoom);
            _this._origin[0] -= _this._mapSize[0] / 2;
            _this._origin[1] -= _this._mapSize[1] / 2;
            var pixelOffset = _this._map.containerPointToLayerPoint([
                -_this._bufferOffset[0],
                -_this._bufferOffset[1],
            ]).round();
            L.DomUtil.setPosition(_this._hiddenFrame.canvas, pixelOffset);
            _this._render();
        };
        this._onResize = function () {
            if (!_this._map) {
                return;
            }
            var mapSize = _this._map.getSize();
            _this._pixelRatio = window.devicePixelRatio;
            _this._bufferOffset = [
                Math.round(mapSize.x * _this._bufferFactor),
                Math.round(mapSize.y * _this._bufferFactor),
            ];
            var size = _this._size = [
                mapSize.x + _this._bufferOffset[0] * 2,
                mapSize.y + _this._bufferOffset[1] * 2,
            ];
            _this._mapSize = [
                mapSize.x,
                mapSize.y,
            ];
            _this._currentFrame.canvas.width = size[0] * _this._pixelRatio;
            _this._currentFrame.canvas.height = size[1] * _this._pixelRatio;
            _this._currentFrame.canvas.style.width = size[0] + 'px';
            _this._currentFrame.canvas.style.height = size[1] + 'px';
            _this._hiddenFrame.canvas.width = size[0] * _this._pixelRatio;
            _this._hiddenFrame.canvas.height = size[1] * _this._pixelRatio;
            _this._hiddenFrame.canvas.style.width = size[0] + 'px';
            _this._hiddenFrame.canvas.style.height = size[1] + 'px';
        };
        this._onZoomStart = function () {
            _this.clear();
            _this._isZooming = true;
        };
        this._onMoveEnd = function () {
            _this._isZooming = false;
            _this.update();
        };
        this._renderLoop = function () {
            var from = _this._lastRenderedMarker;
            var to = Math.min(from + _this._markersPerFrame, _this._markers.length);
            if (from === to) {
                _this._renderFinish();
                return;
            }
            var startTime = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["b" /* now */])();
            _this._renderPart(from, to);
            _this._lastRenderedMarker = to;
            var timeDelta = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["b" /* now */])() - startTime;
            var timePerMarker = timeDelta / (to - from);
            if (timePerMarker !== 0) {
                _this._markersPerFrame = Math.max(Math.floor((_this._markersPerFrame + _this._timePerFrame / timePerMarker) / 2), 100);
            }
            if (to !== _this._markers.length) {
                _this._requestAnimationFrameId = requestAnimationFrame(_this._renderLoop);
            }
            else {
                _this._renderFinish();
            }
        };
        this._atlas = atlas;
        this._markers = [];
        this._markersData = [];
        this._isZooming = false;
        this._debugDrawing = debugDrawing;
        this._bufferFactor = bufferFactor;
        this._markersPerFrame = 5000;
        this._timePerFrame = 10;
        this._origin = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["c" /* vec2create */])();
        this._vec = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["c" /* vec2create */])();
        this._lastRenderedMarker = 0;
        this._needUpdate = false;
        this.container = document.createElement('div');
        this._currentFrame = this._createFrame();
        this._hiddenFrame = this._createFrame();
    }
    CanvasRenderer.prototype.setMarkers = function (markers) {
        this._needUpdate = false;
        if (this._isRendering) {
            cancelAnimationFrame(this._requestAnimationFrameId);
            this._isRendering = false;
        }
        // Set ordered indices
        if (markers.length > this._markersData.length) {
            var markersData = [];
            for (var i = 0; i < markers.length; i++) {
                markersData[i] = {
                    index: i,
                };
            }
            this._markersData = markersData;
        }
        this._markers = markers;
        this.update();
    };
    CanvasRenderer.prototype.onAddToMap = function (map) {
        this._map = map;
        map.on({
            viewreset: this.update,
            moveend: this._onMoveEnd,
            zoomstart: this._onZoomStart,
            resize: this._onResize,
        });
        this._onResize();
    };
    CanvasRenderer.prototype.onRemoveFromMap = function () {
        if (!this._map) {
            return;
        }
        this._map.off({
            viewreset: this.update,
            moveend: this._onMoveEnd,
            zoomstart: this._onZoomStart,
            resize: this._onResize,
        });
        this._map = undefined;
        this._markersData = [];
        this._markers = [];
    };
    CanvasRenderer.prototype.clear = function () {
        if (!this._map) {
            return;
        }
        this._currentFrame.ctx.clearRect(0, 0, this._size[0] * this._pixelRatio, this._size[1] * this._pixelRatio);
        this._currentFrame.tree.clear();
        this._needUpdate = false;
        if (this._isRendering) {
            cancelAnimationFrame(this._requestAnimationFrameId);
            this._isRendering = false;
        }
    };
    CanvasRenderer.prototype.search = function (point) {
        var x = (point[0] + this._bufferOffset[0]) * this._pixelRatio;
        var y = (point[1] + this._bufferOffset[1]) * this._pixelRatio;
        var res = this._currentFrame.tree.search({
            minX: x,
            minY: y,
            maxX: x,
            maxY: y,
        });
        return res.map(function (d) { return d.index; });
    };
    CanvasRenderer.prototype.setDebugDrawing = function (value) {
        this._debugDrawing = value;
    };
    CanvasRenderer.prototype._render = function () {
        if (!this._map) {
            return;
        }
        this._hiddenFrame.tree.clear();
        this._hiddenFrame.ctx.clearRect(0, 0, this._size[0] * this._pixelRatio, this._size[1] * this._pixelRatio);
        this._isRendering = true;
        this._lastRenderedMarker = 0;
        this._renderLoop();
    };
    CanvasRenderer.prototype._renderFinish = function () {
        this._isRendering = false;
        this._switchFrames();
        if (this._needUpdate) {
            this._needUpdate = false;
            this.update();
        }
    };
    CanvasRenderer.prototype._renderPart = function (from, to) {
        var markers = this._markers;
        var markersData = this._markersData;
        var atlas = this._atlas;
        var debugDrawing = this._debugDrawing;
        var pixelRatio = this._pixelRatio;
        var size = this._size;
        var ctx = this._hiddenFrame.ctx;
        var offset = this._vec;
        var zoom = this._zoom;
        var origin = this._origin;
        var bufferOffset = this._bufferOffset;
        if (!atlas.image) {
            return;
        }
        this._lastRenderedMarker = to;
        var visibleMarkers = [];
        for (var i = from; i < to; i++) {
            var marker = markers[i];
            var data = markersData[i];
            var sprite = atlas.sprites[marker.iconIndex || 0];
            if (!sprite) {
                continue;
            }
            var spriteScale = pixelRatio / sprite.pixelDensity;
            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* lngLatToZoomPoint */])(offset, marker.position, zoom);
            // Do not change the sequence of rounding, it corresponds to the rounding in Leaflet
            offset[0] = Math.round(offset[0]);
            offset[1] = Math.round(offset[1]);
            offset[0] = Math.round(offset[0] - origin[0]) + bufferOffset[0];
            offset[1] = Math.round(offset[1] - origin[1]) + bufferOffset[1];
            offset[0] = Math.round(offset[0] * pixelRatio - sprite.size[0] * spriteScale * sprite.anchor[0]);
            offset[1] = Math.round(offset[1] * pixelRatio - sprite.size[1] * spriteScale * sprite.anchor[1]);
            if (offset[0] < 0 || offset[0] + sprite.size[0] * spriteScale > size[0] * pixelRatio ||
                offset[1] < 0 || offset[1] + sprite.size[1] * spriteScale > size[1] * pixelRatio) {
                continue;
            }
            // Prepare for rbush
            data.minX = offset[0];
            data.minY = offset[1];
            data.maxX = offset[0] + sprite.size[0] * spriteScale;
            data.maxY = offset[1] + sprite.size[1] * spriteScale;
            visibleMarkers.push(data);
            ctx.drawImage(atlas.image, sprite.position[0], sprite.position[1], sprite.size[0], sprite.size[1], offset[0], offset[1], sprite.size[0] * spriteScale, sprite.size[1] * spriteScale);
            if (debugDrawing) {
                this._debugDraw(marker, offset, sprite.size);
            }
        }
        this._hiddenFrame.tree.load(visibleMarkers);
    };
    CanvasRenderer.prototype._debugDraw = function (marker, offset, size) {
        var ctx = this._hiddenFrame.ctx;
        var colors = [
            '#000000',
            '#ff0000',
            '#00ff00',
            '#0000ff',
        ];
        var drawingOffsets = marker.drawingOffsets;
        if (!drawingOffsets) {
            return;
        }
        for (var j = 0; j < drawingOffsets.length; j++) {
            var drawingOffset = drawingOffsets[j];
            ctx.beginPath();
            ctx.strokeStyle = colors[j];
            ctx.rect(offset[0] - drawingOffset, offset[1] - drawingOffset, size[0] + drawingOffset * 2, size[1] + drawingOffset * 2);
            ctx.stroke();
        }
    };
    CanvasRenderer.prototype._createFrame = function () {
        var canvas = document.createElement('canvas');
        canvas.style.display = 'none';
        // In 2gis-maps a "position: absolute" style affects to the canvas
        // Remove when 2gis-maps update leaflet to 1.0.3
        canvas.style.position = 'initial';
        // We do not consider the case when 2d context is not exist
        var ctx = canvas.getContext('2d');
        var tree = __WEBPACK_IMPORTED_MODULE_0_rbush__();
        this.container.appendChild(canvas);
        return {
            canvas: canvas,
            ctx: ctx,
            tree: tree,
        };
    };
    CanvasRenderer.prototype._switchFrames = function () {
        if (!this._map) {
            return;
        }
        this._currentFrame.canvas.style.display = 'none';
        this._hiddenFrame.canvas.style.display = 'block';
        var t = this._currentFrame;
        this._currentFrame = this._hiddenFrame;
        this._hiddenFrame = t;
    };
    return CanvasRenderer;
}());



/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CanvasRenderer__ = __webpack_require__(8);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MarkerDrawer; });
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * This class helps to draw fast a huge amount of markers
 */
var MarkerDrawer = (function (_super) {
    __extends(MarkerDrawer, _super);
    function MarkerDrawer(atlas, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this._onClick = function (ev) {
            var point = _this._getMousePosition(ev);
            var markers = _this._renderer.search(point);
            if (markers.length) {
                ev.stopPropagation();
                _this.fire('click', { markers: markers });
            }
        };
        _this._atlas = atlas;
        _this._markers = [];
        _this._renderer = new __WEBPACK_IMPORTED_MODULE_0__CanvasRenderer__["a" /* CanvasRenderer */](_this._atlas, options.debugDrawing || false, options.bufferFactor !== undefined ? options.bufferFactor : 0.5);
        return _this;
    }
    MarkerDrawer.prototype.setMarkers = function (markers) {
        this._markers = markers;
        this._renderer.setMarkers(markers);
    };
    MarkerDrawer.prototype.update = function () {
        this._renderer.update();
    };
    MarkerDrawer.prototype.addTo = function (map) {
        map.addLayer(this);
        return this;
    };
    MarkerDrawer.prototype.onAdd = function () {
        var _this = this;
        if (!this._map) {
            return this;
        }
        this._pane = this._map.getPane('overlayPane');
        this._renderer.onAddToMap(this._map);
        this._renderer.container.addEventListener('click', this._onClick);
        this._pane.appendChild(this._renderer.container);
        this._atlas.whenReady()
            .then(function () {
            _this._renderer.update();
        });
        return this;
    };
    MarkerDrawer.prototype.remove = function () {
        if (this._map) {
            this._map.removeLayer(this);
        }
        return this;
    };
    MarkerDrawer.prototype.onRemove = function () {
        this._pane.removeChild(this._renderer.container);
        this._renderer.onRemoveFromMap();
        this._renderer.container.removeEventListener('click', this._onClick);
        return this;
    };
    MarkerDrawer.prototype.setDebugDrawing = function (value) {
        this._renderer.setDebugDrawing(value);
    };
    MarkerDrawer.prototype._getMousePosition = function (ev) {
        var map = this._map;
        var container = map.getContainer();
        var rect = container.getBoundingClientRect();
        return [
            ev.clientX - rect.left - container.clientLeft,
            ev.clientY - rect.top - container.clientTop,
        ];
    };
    return MarkerDrawer;
}(L.Layer));



/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = vec2create;
/* harmony export (immutable) */ __webpack_exports__["a"] = lngLatToZoomPoint;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return now; });
var R = 6378137;
var MAX_LATITUDE = 85.0511287798;
function vec2create() {
    return new Float64Array(2);
}
function lngLatToZoomPoint(out, lngLat, zoom) {
    latLngToMapPoint(out, lngLat);
    mapPointToScreenPoint(out, out, zoom);
}
function mapPointToScreenPoint(out, point, zoom) {
    var scale = 256 * Math.pow(2, zoom);
    var k = 0.5 / (Math.PI * R);
    out[0] = scale * (k * point[0] + 0.5);
    out[1] = scale * (-k * point[1] + 0.5);
}
function latLngToMapPoint(out, lngLat) {
    var d = Math.PI / 180;
    var lat = Math.max(Math.min(MAX_LATITUDE, lngLat[1]), -MAX_LATITUDE);
    var sin = Math.sin(lat * d);
    out[0] = R * lngLat[0] * d;
    out[1] = R * Math.log((1 + sin) / (1 - sin)) / 2;
}
var now = window.performance ? performance.now.bind(performance) : Date.now.bind(Date);


/***/ })
/******/ ]);
//# sourceMappingURL=demo.js.map